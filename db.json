{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/clexy/source/LICENSE","path":"LICENSE","modified":1,"renderable":1},{"_id":"themes/clexy/source/manifest.webmanifest","path":"manifest.webmanifest","modified":1,"renderable":1},{"_id":"themes/clexy/source/images/apple-touch-icon-120x120.png","path":"images/apple-touch-icon-120x120.png","modified":1,"renderable":1},{"_id":"themes/clexy/source/images/apple-touch-icon-114x114.png","path":"images/apple-touch-icon-114x114.png","modified":1,"renderable":1},{"_id":"themes/clexy/source/images/apple-touch-icon-152x152.png","path":"images/apple-touch-icon-152x152.png","modified":1,"renderable":1},{"_id":"themes/clexy/source/images/apple-touch-icon-144x144.png","path":"images/apple-touch-icon-144x144.png","modified":1,"renderable":1},{"_id":"themes/clexy/source/images/apple-touch-icon-60x60.png","path":"images/apple-touch-icon-60x60.png","modified":1,"renderable":1},{"_id":"themes/clexy/source/images/apple-touch-icon-57x57.png","path":"images/apple-touch-icon-57x57.png","modified":1,"renderable":1},{"_id":"themes/clexy/source/images/apple-touch-icon-72x72.png","path":"images/apple-touch-icon-72x72.png","modified":1,"renderable":1},{"_id":"themes/clexy/source/images/apple-touch-icon-76x76.png","path":"images/apple-touch-icon-76x76.png","modified":1,"renderable":1},{"_id":"themes/clexy/source/images/favicon-128.png","path":"images/favicon-128.png","modified":1,"renderable":1},{"_id":"themes/clexy/source/images/favicon-16x16.png","path":"images/favicon-16x16.png","modified":1,"renderable":1},{"_id":"themes/clexy/source/images/favicon-196x196.png","path":"images/favicon-196x196.png","modified":1,"renderable":1},{"_id":"themes/clexy/source/images/favicon-32x32.png","path":"images/favicon-32x32.png","modified":1,"renderable":1},{"_id":"themes/clexy/source/images/favicon.ico","path":"images/favicon.ico","modified":1,"renderable":1},{"_id":"themes/clexy/source/images/favicon-96x96.png","path":"images/favicon-96x96.png","modified":1,"renderable":1},{"_id":"themes/clexy/source/images/logo.png","path":"images/logo.png","modified":1,"renderable":1},{"_id":"themes/clexy/source/images/main.png","path":"images/main.png","modified":1,"renderable":1},{"_id":"themes/clexy/source/images/mstile-144x144.png","path":"images/mstile-144x144.png","modified":1,"renderable":1},{"_id":"themes/clexy/source/images/mstile-150x150.png","path":"images/mstile-150x150.png","modified":1,"renderable":1},{"_id":"themes/clexy/source/images/mstile-310x150.png","path":"images/mstile-310x150.png","modified":1,"renderable":1},{"_id":"themes/clexy/source/images/mstile-70x70.png","path":"images/mstile-70x70.png","modified":1,"renderable":1},{"_id":"themes/clexy/source/scripts/index.js","path":"scripts/index.js","modified":1,"renderable":1},{"_id":"themes/clexy/source/styles/fontawesome.min.css","path":"styles/fontawesome.min.css","modified":1,"renderable":1},{"_id":"themes/clexy/source/styles/normalize.css","path":"styles/normalize.css","modified":1,"renderable":1},{"_id":"themes/clexy/source/styles/screen.styl","path":"styles/screen.styl","modified":1,"renderable":1},{"_id":"themes/clexy/source/images/mstile-310x310.png","path":"images/mstile-310x310.png","modified":1,"renderable":1},{"_id":"themes/clexy/source/fonts/fira/400.woff2","path":"fonts/fira/400.woff2","modified":1,"renderable":1},{"_id":"themes/clexy/source/fonts/fira/500.woff2","path":"fonts/fira/500.woff2","modified":1,"renderable":1},{"_id":"themes/clexy/source/fonts/opensans/300.woff","path":"fonts/opensans/300.woff","modified":1,"renderable":1},{"_id":"themes/clexy/source/fonts/opensans/300.woff2","path":"fonts/opensans/300.woff2","modified":1,"renderable":1},{"_id":"themes/clexy/source/fonts/opensans/300i.woff2","path":"fonts/opensans/300i.woff2","modified":1,"renderable":1},{"_id":"themes/clexy/source/fonts/opensans/400.woff","path":"fonts/opensans/400.woff","modified":1,"renderable":1},{"_id":"themes/clexy/source/fonts/opensans/400.woff2","path":"fonts/opensans/400.woff2","modified":1,"renderable":1},{"_id":"themes/clexy/source/fonts/opensans/400i.woff2","path":"fonts/opensans/400i.woff2","modified":1,"renderable":1},{"_id":"themes/clexy/source/fonts/opensans/600.woff2","path":"fonts/opensans/600.woff2","modified":1,"renderable":1},{"_id":"themes/clexy/source/fonts/opensans/600i.woff2","path":"fonts/opensans/600i.woff2","modified":1,"renderable":1},{"_id":"themes/clexy/source/fonts/opensans/700.woff","path":"fonts/opensans/700.woff","modified":1,"renderable":1},{"_id":"themes/clexy/source/fonts/opensans/700.woff2","path":"fonts/opensans/700.woff2","modified":1,"renderable":1},{"_id":"themes/clexy/source/fonts/opensans/700i.woff2","path":"fonts/opensans/700i.woff2","modified":1,"renderable":1},{"_id":"themes/clexy/source/fonts/opensans/800.woff2","path":"fonts/opensans/800.woff2","modified":1,"renderable":1},{"_id":"themes/clexy/source/fonts/opensans/800i.woff2","path":"fonts/opensans/800i.woff2","modified":1,"renderable":1},{"_id":"themes/clexy/source/fonts/code/CodeFont.otf","path":"fonts/code/CodeFont.otf","modified":1,"renderable":1},{"_id":"themes/clexy/source/fonts/code/CodeFont.woff","path":"fonts/code/CodeFont.woff","modified":1,"renderable":1},{"_id":"themes/clexy/source/fonts/fontawesome/fontawesome-webfont.woff","path":"fonts/fontawesome/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/clexy/source/fonts/fira/400.woff","path":"fonts/fira/400.woff","modified":1,"renderable":1},{"_id":"themes/clexy/source/fonts/fira/500.woff","path":"fonts/fira/500.woff","modified":1,"renderable":1},{"_id":"themes/clexy/source/fonts/fira/700.woff","path":"fonts/fira/700.woff","modified":1,"renderable":1},{"_id":"themes/clexy/source/fonts/fira/700.woff2","path":"fonts/fira/700.woff2","modified":1,"renderable":1},{"_id":"themes/clexy/source/fonts/opensans/300i.woff","path":"fonts/opensans/300i.woff","modified":1,"renderable":1},{"_id":"themes/clexy/source/fonts/opensans/400i.woff","path":"fonts/opensans/400i.woff","modified":1,"renderable":1},{"_id":"themes/clexy/source/fonts/opensans/600.woff","path":"fonts/opensans/600.woff","modified":1,"renderable":1},{"_id":"themes/clexy/source/fonts/opensans/600i.woff","path":"fonts/opensans/600i.woff","modified":1,"renderable":1},{"_id":"themes/clexy/source/fonts/opensans/700i.woff","path":"fonts/opensans/700i.woff","modified":1,"renderable":1},{"_id":"themes/clexy/source/fonts/opensans/800.woff","path":"fonts/opensans/800.woff","modified":1,"renderable":1},{"_id":"themes/clexy/source/fonts/opensans/800i.woff","path":"fonts/opensans/800i.woff","modified":1,"renderable":1},{"_id":"themes/clexy/source/fonts/code/CodeFont.ttf","path":"fonts/code/CodeFont.ttf","modified":1,"renderable":1},{"_id":"themes/clexy/source/fonts/fontawesome/fontawesome-webfont.woff2","path":"fonts/fontawesome/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/clexy/source/fonts/code/CodeFont.svg","path":"fonts/code/CodeFont.svg","modified":1,"renderable":1},{"_id":"themes/clexy/source/fonts/fontawesome/fontawesome-webfont.eot","path":"fonts/fontawesome/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/clexy/source/fonts/fontawesome/fontawesome-webfont.ttf","path":"fonts/fontawesome/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/clexy/source/fonts/fontawesome/fontawesome-webfont.svg","path":"fonts/fontawesome/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/clexy/source/images/avatar.jpeg","path":"images/avatar.jpeg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/clexy/_config.yml","hash":"70a644899fbbee6e8711ccb6c53719e6d18f40d0","modified":1551437670669},{"_id":"source/.DS_Store","hash":"b48c4f7d61a5928be717d4bd654481ff1eab36ee","modified":1550886720930},{"_id":"themes/clexy/layout/_footer.jade","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1548993346613},{"_id":"themes/clexy/source/LICENSE","hash":"37fd25acef1b10a40eb8861e091a0eec9a993147","modified":1551181729099},{"_id":"themes/clexy/source/manifest.webmanifest","hash":"84eb1c4277746f2f3b1b08f5e5394210c28a1d85","modified":1551495687390},{"_id":"themes/clexy/layout/_comments.jade","hash":"4ac668fa7883ecb1ae8230d5f023e6936f17403a","modified":1548993346612},{"_id":"themes/clexy/layout/_content.jade","hash":"790c15307bc3d74b8ec6a87e16f30a0b5c2eae91","modified":1551430533496},{"_id":"themes/clexy/layout/_head.jade","hash":"bbccab5b579c0caf7a7083b43e272d104e7315b0","modified":1551494610718},{"_id":"themes/clexy/layout/_header.jade","hash":"c4581819c1f4b568bfec950990270fa09b7270b9","modified":1549005016126},{"_id":"themes/clexy/layout/_mixins.jade","hash":"fef1a26fef90db4c5f41e6c56cdbf284e6786b8a","modified":1548993346616},{"_id":"themes/clexy/layout/_scripts.jade","hash":"d68dfdcfba97f54f748f75457d7ca54faf8188c8","modified":1551439032436},{"_id":"themes/clexy/layout/layout.jade","hash":"68d0421b31dc01b2095209019b5a821d3507c656","modified":1551053339687},{"_id":"themes/clexy/layout/index.jade","hash":"17f6ec2ed0ab4e0fc6cf2007265e4ade41bc6714","modified":1548993346617},{"_id":"source/tags/index.md","hash":"d4ddfb9ddf3f518be753476ac02d650ead195cb7","modified":1549008747933},{"_id":"source/articles/index.md","hash":"041c36a25f37e9ed9f4b0d7b4cb16c5842e36b3b","modified":1548999265261},{"_id":"source/author/index.md","hash":"238de7fea22d5667a119cd7d2d46a54bcd1e4c18","modified":1548999355693},{"_id":"source/_posts/.DS_Store","hash":"c87bd1b30b8069621a859283e72600ef08cc0e20","modified":1551175987628},{"_id":"source/_posts/2017-开篇.md","hash":"ead284d08b1f2cf0c9d0fb5c3d537ca1a6f7654f","modified":1549949639018},{"_id":"source/_posts/Android-以-Post-方式发送-Http-请求.md","hash":"418c62590eec19fa91395a4048b8cb48cf675840","modified":1549205930940},{"_id":"source/_posts/BigPipe-原理实现与使用场景分析.md","hash":"a25291c1cc252ad0f6786cff818dd43c3f72f418","modified":1549953392101},{"_id":"source/_posts/C-小记录.md","hash":"d6288d61e28a5e4cee587826127cc4f4c118bbad","modified":1550572209809},{"_id":"source/_posts/CSS-常用布局解决方案.md","hash":"c2ff6ce6818315c414fea42e1b61b78946f1cc55","modified":1549942697201},{"_id":"source/_posts/CentOS-7-2-之-MySQL-到-MariaDB-的迁移.md","hash":"ddf448f6557b033c4bcc24d4d4d0ab802f995f8e","modified":1549949733800},{"_id":"source/_posts/Common-Lisp-全记录（一）.md","hash":"8c9c9f7185ac4ab05093e60c061c9748434c2257","modified":1550569251122},{"_id":"source/_posts/Docker-最佳实践（一）.md","hash":"bb955c6ceea2eb55d17efcdfb704375fbb3ecdc5","modified":1550636098565},{"_id":"source/_posts/Docker-最佳实践（三）.md","hash":"84d06986233f31678b8837ff41ad22fbe4e6b851","modified":1550642316842},{"_id":"source/_posts/Docker-最佳实践（二）.md","hash":"d128b6ace70670e8a6d7273ecb7c214fca0562ce","modified":1550642060051},{"_id":"source/_posts/ECMAScript6-新特性-迭代器和-for-of-循环.md","hash":"ed7513aa900750614acc25b34283d5951ca89949","modified":1549355755339},{"_id":"source/_posts/ES-8-新特性一览.md","hash":"961830a0f5e1428aa8f43238d7c3b64a08c5fc93","modified":1550569797287},{"_id":"source/_posts/ES-6-ES-2015-常用知识点归纳.md","hash":"b9338af7e7b70abfb36d4e2540386e3fc7e6f64e","modified":1549942772337},{"_id":"source/_posts/Flush-Reload-Attack-与-Meltdown.md","hash":"07f959d81aaa7ce5bf492cca66422002938a0901","modified":1550643557161},{"_id":"source/_posts/GeekBank-C-线下班学习心得（一）.md","hash":"20e22e74c2b1d2423ebecd65e13711c37b5d2e8b","modified":1549283308860},{"_id":"source/_posts/GeekBank-C-线下班学习心得（三）.md","hash":"1291d4746709721e1b6400c4054ea3d1c1a39f34","modified":1549298186717},{"_id":"source/_posts/GeekBank-C-线下班学习心得（二）.md","hash":"dfa12fae076a4df144c4fcd4c771f7149371f2a3","modified":1549298166121},{"_id":"source/_posts/Git-你需要具备的基础知识.md","hash":"448bfd90a6640a1b4d3d2d8bd7fb310f8d79ba59","modified":1549274310726},{"_id":"source/_posts/Git-最佳实践.md","hash":"2ded443cb05b8f4ccae8213d376f61e29e18911a","modified":1550643762813},{"_id":"source/_posts/HTML5-随记录.md","hash":"d8198a87bf10181a7f38f97b1e90ab892612f3af","modified":1549727048232},{"_id":"source/_posts/HTTP-基础整理.md","hash":"bc9a68af5d18d7caabbf7c1d823203cd749a8722","modified":1549951135744},{"_id":"source/_posts/IT-行业的入门与精通.md","hash":"04b08745a621f9d763bd4816f015f7d303c3bc5d","modified":1549207297364},{"_id":"source/_posts/Java-基础语法特性记录.md","hash":"f8615b30c4c5992911eafe2585c5ae76a2685411","modified":1549360926721},{"_id":"source/_posts/JavaScript-核心特性揭秘（一）.md","hash":"6a3fb7570bc82141659c5b2a469fadd38dae3c2f","modified":1549363246570},{"_id":"source/_posts/JavaScript-核心特性揭秘（三）.md","hash":"5f3ee71d338c080c40a4cd4c636a16e18b26b265","modified":1549364683135},{"_id":"source/_posts/JavaScript-核心特性揭秘（二）.md","hash":"8f71c537876bfeabd49d06a0ace4199583ebed9f","modified":1549363196723},{"_id":"source/_posts/JavaScript-浏览器自动化.md","hash":"5959e6965b8601932104fb861db0bddfecb7cc15","modified":1551173623210},{"_id":"source/_posts/LAMP-架构之升级-PHP-版本.md","hash":"53386ad95518cceaa74510d4687a657404b220b4","modified":1549359206178},{"_id":"source/_posts/LeetCode-每日一题-1-Two-Sum.md","hash":"939b484825da327ad404e0535cfc29b0e0d27c8d","modified":1549766979935},{"_id":"source/_posts/LeetCode-每日一题-100-Same-Tree.md","hash":"1d0e1bf07c6fbe342a95d3ed4adeb7618caaf5b6","modified":1549767002270},{"_id":"source/_posts/LeetCode-每日一题-104-Maximum-Depth-of-Binary-Tree.md","hash":"5d73b5667685a94c180897c29f248352171c4c06","modified":1549767006969},{"_id":"source/_posts/LeetCode-每日一题-121-Best-Time-to-Buy-and-Sell-Stock.md","hash":"01f2fb2be1f7beafa4768d96c19eff89f5f3a169","modified":1549767010087},{"_id":"source/_posts/LeetCode-每日一题-136-Single-Number.md","hash":"f9b3973c9508568a39504ebcdb9e98d2371fbdd8","modified":1549767014276},{"_id":"source/_posts/LeetCode-每日一题-168-Excel-Sheet-Column-Title.md","hash":"cff2f54ca6b1bbe50943b406fd712daa99efea90","modified":1549767018169},{"_id":"source/_posts/LeetCode-每日一题-169-Majority-Element.md","hash":"5be4adbc31a557b61fedce4d2adc09568f8af205","modified":1549767020763},{"_id":"source/_posts/LeetCode-每日一题-189-Rotate-Array.md","hash":"0dbf0d71bc95e0910dd16c775fdfb48d80cfa86e","modified":1549767023571},{"_id":"source/_posts/LeetCode-每日一题-203-Remove-Linked-List-Elements.md","hash":"f5045ec3d668c7cfabaa4f68af1258766e63db54","modified":1549767027327},{"_id":"source/_posts/LeetCode-每日一题-217-Contains-Duplicate.md","hash":"767912364d7c286c38338c3422331663d6983094","modified":1549767030396},{"_id":"source/_posts/LeetCode-每日一题-219-Contains-Duplicate-II.md","hash":"4dc49ca371183e729706c3690ea23898bfdcd26a","modified":1549767033888},{"_id":"source/_posts/LeetCode-每日一题-258-Add-Digits.md","hash":"4643b761da761afd520c88b3a959a39607e53e59","modified":1549767036668},{"_id":"source/_posts/LeetCode-每日一题-27-Remove-Element.md","hash":"23ec319e3d751587ea1c728c9df6bfb0d6f272f8","modified":1549766992789},{"_id":"source/_posts/LeetCode-每日一题-283-Move-Zeroes.md","hash":"75664b38fe833552a43605af5a64f230d951e281","modified":1549767039048},{"_id":"source/_posts/LeetCode-每日一题-342-Power-of-Four.md","hash":"517c959f94c2186b651d66e5b57c73ac9e1ddf74","modified":1549767042179},{"_id":"source/_posts/LeetCode-每日一题-344-Reverse-String.md","hash":"ed2dea0b5ea42f096c2954282bb2cdf195abb04f","modified":1549767045487},{"_id":"source/_posts/LeetCode-每日一题-58-Length-of-Last-Word.md","hash":"6c113ca5ff8fc7f4f1acc5e16f0313bc858628bf","modified":1549766995613},{"_id":"source/_posts/LeetCode-每日一题-6-ZigZag-Conversion.md","hash":"805ab34487e93fa215ff076018b133f3b0478896","modified":1549766984941},{"_id":"source/_posts/LeetCode-每日一题-7-Reverse-Integer.md","hash":"9d462d16bed1e2549fd38aec7e142afac2a5591d","modified":1549766987267},{"_id":"source/_posts/LeetCode-每日一题-70-Climbing-Stairs.md","hash":"425d85c125a58d6581e18e1add38912928803513","modified":1549766998563},{"_id":"source/_posts/LeetCode-每日一题-9-Palindrome-Number.md","hash":"6f15ac6e4a0cb44d1b3b2d7166b89a842cfd021b","modified":1549766990010},{"_id":"source/_posts/Linux-后台运行任务.md","hash":"7cca46e5e2d517d9beffa33c30ee8d28dc3ef4a9","modified":1549553066757},{"_id":"source/_posts/Mac-配置-Commom-Lisp-开发环境.md","hash":"181fbdfe245ad8a94d466257f7f15b1079238ff0","modified":1550569094115},{"_id":"source/_posts/Prism-js-在-AJAX-下的应用问题.md","hash":"364695817669d4a1e9658dc4f650f50656aaa2ea","modified":1549273049590},{"_id":"source/_posts/Promise-A-调用详谈.md","hash":"131ae40438627bd013f81b1281c41b952cd31212","modified":1549950206350},{"_id":"source/_posts/Promise-浅谈.md","hash":"53fa80499bbffddfd0e079a64dc9b259a37d9401","modified":1549943175597},{"_id":"source/_posts/PureRenderMixin-immutable-js-提高-VDOM-渲染效率.md","hash":"2e9c84fd8dccf32083b19a7e0d61ab6381982a41","modified":1550455946232},{"_id":"source/_posts/Python-小记.md","hash":"9a41b679756f3e84da866e528e1d06ba89a886eb","modified":1550570401814},{"_id":"source/_posts/Python-高级用法.md","hash":"bd5d772a4790af2e19b73184fbdcc9ab493344e4","modified":1550571307232},{"_id":"source/_posts/RSS-概述.md","hash":"6b522926c662e61d0dce4a8a6c92c64845a75fa5","modified":1549255406074},{"_id":"source/_posts/Redis-源码之内存管理-zmalloc-zfree.md","hash":"0fad5f5b2ed5c21141a5cc2d4ed9eca8e62b5be0","modified":1550571915739},{"_id":"source/_posts/STC-与-PTC.md","hash":"0f66f7585b9ecf537fb35376c3d5d8dcfd27591e","modified":1550454106323},{"_id":"source/_posts/SVG-技术之-路径.md","hash":"464cfe708229a14f1b145580ee26f74d038f6ddc","modified":1549299198947},{"_id":"source/_posts/The-Twelve-Factor-App.md","hash":"02e58dedec5db584fc83a553ec0c12468a2d8133","modified":1550642946269},{"_id":"source/_posts/UCS-2-编码的妙用.md","hash":"a4f2dae9d6dbc7c3d98676114edf8fc6e921243f","modified":1549358058898},{"_id":"source/_posts/URL-编码的那些事儿.md","hash":"aef8e151b47c7b1505036606ece8f649f9a9489e","modified":1549952564106},{"_id":"source/_posts/V8-内存优化之-Ignition-解释器.md","hash":"0250d5cb0038f86397a00b9a2e11466a19983687","modified":1550572873512},{"_id":"source/_posts/Web-新时代与挑战.md","hash":"bfcf47ac6e56478e8c8e19f09c4766257ce432af","modified":1550645492691},{"_id":"source/_posts/WebAssembly-尝试研究报告-API-之初始化、内存和表的分配.md","hash":"a581a9e53e0c9a20506f159fe0e4e29f35061e4f","modified":1550565301629},{"_id":"source/_posts/WebAssembly-尝试研究报告-DIP-实践.md","hash":"31e24a9f39492b22a2dc45347fc5b799978452dc","modified":1550567234728},{"_id":"source/_posts/WebAssembly-尝试研究报告-本地存储与转移.md","hash":"9dfdeafec4b9181cdbbe2c81912ef9f3e3a2e5d8","modified":1550565588142},{"_id":"source/_posts/WebAssembly-尝试研究报告-错误处理.md","hash":"2ec44277fbc512d9876c66c2f827190f255709bd","modified":1550561668810},{"_id":"source/_posts/WebAssembly-尝试研究报告（一）.md","hash":"314465e0cfc34355fa1a8620c7887490d2a0f50c","modified":1550547386890},{"_id":"source/_posts/WebAssembly-尝试研究报告（三）.md","hash":"0d6ce16e9c5eb21dbdd4a73ede1ddb049731e3b8","modified":1550558246142},{"_id":"source/_posts/WebAssembly-尝试研究报告（二）.md","hash":"71c92f0c5e4e9013e931d880a4e741e1e60e2b48","modified":1550557617714},{"_id":"source/_posts/WebAssembly-深入研究报告-二进制编码.md","hash":"bbeac96c3eff6520f33666a9e195f6e82d22ca2c","modified":1550568468034},{"_id":"source/_posts/WebAssembly-深入研究报告-安全性.md","hash":"23b77413755982c15e5a969057c7a52794d716c2","modified":1550568848195},{"_id":"source/_posts/WebAssembly-深入研究报告-碎片知识.md","hash":"ec0ceff2fe3bee6affcbd2655966f27c171fb170","modified":1550571099308},{"_id":"source/_posts/Zoomage-js-正式版-V1-0-0-核心原理介绍.md","hash":"15518643fda9564f9de786252716221aac2f7a16","modified":1549766387846},{"_id":"source/_posts/event-target-与-event-srcElement.md","hash":"8175728bf40471e65f117e112bfa1787bf6f0131","modified":1549264796226},{"_id":"source/_posts/jQuery-源码江湖-初入江湖.md","hash":"ea5bebe79d766d9d5744eac76f5d7d7ed29509b9","modified":1549949076917},{"_id":"source/_posts/“函数柯里化”常见使用场景记录.md","hash":"923ed4ab091f3312c7344b970b6c8be0972ccd67","modified":1550454422547},{"_id":"source/_posts/“增长黑客：创业公司的用户与收入增长秘籍” 读书笔记.md","hash":"e3871ac7d2954865e8acaa17b483f0cb390fa762","modified":1550645563726},{"_id":"source/_posts/“大型网站技术架构”总结：一，概述.md","hash":"f9a522e8efd55002a4f8a57311debbc9eac01275","modified":1550416444972},{"_id":"source/_posts/“大型网站技术架构”总结：三，网站的高可用架构.md","hash":"b8737778b284a7d1d8abc3f55caecb52d362d5d3","modified":1550418121630},{"_id":"source/_posts/“大型网站技术架构”总结：二，网站的高性能架构.md","hash":"f1ae5c764a2bd2e58b778727ed3200302a87b96a","modified":1550416960990},{"_id":"source/_posts/“重新定义团队：谷歌如何工作”-读书笔记.md","hash":"1220b16c77b4408cd70cdb7bfce2f1c53bae6625","modified":1550645550490},{"_id":"source/_posts/“阿米巴经营”-读书笔记.md","hash":"27939cab957aea7ff97b2472726c3b69c9fdbfa0","modified":1550645565869},{"_id":"source/_posts/“零售的哲学”-读书笔记.md","hash":"d233cbcf3b5ee72499b0ea77b2341a7b61090573","modified":1550645561058},{"_id":"source/_posts/一种新的共享计算力模式.md","hash":"f65a85c84c5989784569def1be34223d42e7a74c","modified":1550573080273},{"_id":"source/_posts/一道面试题的思考.md","hash":"6adba12aaa89bb9e6e0f15de1f3cf8297fe6d5f0","modified":1549952213766},{"_id":"source/_posts/不得不防范的-iframe-非法嵌入.md","hash":"c14f4f4eb91fe5da93a88d269b0070c2d4b928df","modified":1549299084341},{"_id":"source/_posts/为-Swing-控件-JList-动态添加元素.md","hash":"de6079303da770a7146a7693fe5bb81138139a61","modified":1549266796095},{"_id":"source/_posts/五分钟算法-二分法查找（Binary-Search）.md","hash":"9f92ef716c465712390a5747cf9d9d9f51664ab8","modified":1549511400581},{"_id":"source/_posts/今日商业评论—瑞幸咖啡VS星巴克，如何互补？.md","hash":"c3d5975dae208bb18c952bc7470ea01edd8f7f17","modified":1551371368204},{"_id":"source/_posts/使用-Noteflight-来快速作曲和-MusicXML-导出.md","hash":"c97525a39f0a55be6ce3d11d4379d8df8c665cd3","modified":1550624353701},{"_id":"source/_posts/利用-ab-命令进行简单压测.md","hash":"6fef7ff5d6657e72b019f2b388e7c7317715e1d7","modified":1549264878352},{"_id":"source/_posts/前端-DCE-策略之-—-Tree-Shaking.md","hash":"f16774a558225cf67b6dd4ab352b4d711fe35141","modified":1550454743232},{"_id":"source/_posts/前端关键技术点杂烩.md","hash":"531bd3e865ac2861ca54502694ebf77bcce59773","modified":1549781815703},{"_id":"source/_posts/前端常见技术点-CSS-DOM-布局.md","hash":"133e37393a34534bcf35bb685ea141134955342e","modified":1549785163050},{"_id":"source/_posts/前端常见技术点-HTML.md","hash":"da52e392563468a590ccad8403f12a6764309055","modified":1549869917203},{"_id":"source/_posts/前端常见技术点-JavaScript.md","hash":"5f069198ffe74543a050f64b234863ea1c97d48e","modified":1549867663988},{"_id":"source/_posts/前端那些事儿-Console-对象.md","hash":"8e1b8d50236c09c2fca31430c5185098384f605d","modified":1549356828653},{"_id":"source/_posts/前端那些事儿-JavaScript-函数之-IIFE.md","hash":"56b2740af365f8d5ecafa39799379189f114d072","modified":1549353392572},{"_id":"source/_posts/前端那些事儿-URL-对象.md","hash":"56553d77742c9aa12f7ee63ac5aefb84e8f40ea0","modified":1549499436306},{"_id":"source/_posts/前端那些事儿-三字节-BOM-头.md","hash":"f8a50c56dd5fe0fef83626daae03fd3e7a4ade8a","modified":1549354972553},{"_id":"source/_posts/前端那些事儿-表单域的-MIME-编码.md","hash":"bffb957a1bcebd39cfdd920660e6a07df9ea2803","modified":1549352633371},{"_id":"source/_posts/前端项目规划与团队管理.md","hash":"8651a149dfe764dba30437f698b374b771067acc","modified":1549870357927},{"_id":"source/_posts/博客正式使用“知识共享-CC”国际协议.md","hash":"8ceb29daa5109647bcd6aef3193323d61b532cf4","modified":1549257384986},{"_id":"source/_posts/图像扫描及-OCR-技术开发-SDK-Asprise.md","hash":"310915c0b112da7390b04aeed3819799a1bae8f2","modified":1549273582372},{"_id":"source/_posts/基于-AWS-探索-Shadowsocks.md","hash":"ce1ce297f1df597445835e89e0c6d77d33b98fd5","modified":1549765718339},{"_id":"source/_posts/基于-NumPy-和-TensorFlow-的简单-KNN-实现.md","hash":"64219b848e19066375723264be436d7ffa7cec3a","modified":1550456326276},{"_id":"source/_posts/基于-PHP-实现的优化盐值加密算法.md","hash":"6bca9b7d032e80bd98b948274eaf38d7ae84117f","modified":1549266219759},{"_id":"source/_posts/大数据基础架构概述.md","hash":"5096743d6a452c16e927f0c3e8b07bd9a19f6c6c","modified":1550572460888},{"_id":"source/_posts/常用-Shell-知识点和技巧.md","hash":"64432b05457abec8a27488b98fc8b8cc19735498","modified":1550455174955},{"_id":"source/_posts/我的新书《深入浅出-WebAssembly》出版啦-｡･ω･｡-ﾉ.md","hash":"851aa7e2203b385ba732a84a98571248f5b5fbbe","modified":1550645467664},{"_id":"source/_posts/技术是成功的“绊脚石”.md","hash":"9c94f79425710c651c455eb2628ab0afd2fa0d1c","modified":1549357262009},{"_id":"source/_posts/数据结构-线性顺序表.md","hash":"980e1e87d475e78f7f1187d6111fda2ddd19ebfd","modified":1549377330280},{"_id":"source/_posts/机器学习记录-简介.md","hash":"d70bb1404cfc7047ac4bd28f1465be3dada883b1","modified":1549952698691},{"_id":"source/_posts/日本樱花季游攻略.md","hash":"69c6b058f29eb108304907999cc025e6c6c83974","modified":1551169401310},{"_id":"source/_posts/浅谈-CORS：跨域资源共享.md","hash":"be0d8bde54d532a5f00ee626376525d9e354e1db","modified":1549297536021},{"_id":"source/_posts/浅谈-SEO.md","hash":"5665ded9844f5ccae4c4a0f6337aa0dc46afd3e4","modified":1549206144769},{"_id":"source/_posts/淘宝网的-BigRender.md","hash":"6b9bd11c5d1d53b997d91630f2b940f0736026df","modified":1550414956102},{"_id":"source/_posts/深夜吐槽-笔试与企业文化.md","hash":"bd0ef063b439b8c6af7e028c79075a17eba57fc6","modified":1549257049162},{"_id":"source/_posts/简单理解-HTTP-协议.md","hash":"ccb90b2418747e058b6fbfb7fa40640dd8f22cdc","modified":1549205940642},{"_id":"source/_posts/简谈-JavaScript-中的数据类型.md","hash":"237d33d99a55b5a56f8f0e320553107668c323e9","modified":1549206655296},{"_id":"source/_posts/算法基础-常用排序算法（上）.md","hash":"284509f916ebba020ea281040079874a7acc2762","modified":1549767722087},{"_id":"source/_posts/编码与“锟斤拷”的故事.md","hash":"2b1c145964c82404929c28ddff6106ec150ea3e7","modified":1549270053768},{"_id":"source/_posts/设计模式速谈：一、序论.md","hash":"93c4b96ac2ee8f00ecd0f75ae568b9d60b4a7195","modified":1549553938505},{"_id":"source/_posts/设计模式速谈：三、工厂模式.md","hash":"d3aec53a97c9a90a260599f5db0b5e963c279db6","modified":1549724915448},{"_id":"source/_posts/设计模式速谈：二、简单工厂模式.md","hash":"70c3eedcdf448b307dd12211c78608f45c56c633","modified":1549724222261},{"_id":"source/_posts/设计模式速谈：五、建造者模式.md","hash":"ef97483bfec94547ed407d2d52cf07b56d37dd03","modified":1549725253860},{"_id":"source/_posts/设计模式速谈：六、单例模式.md","hash":"bc83526d44f74fbd1bf4757eaf51e2ae76d24d52","modified":1549725636070},{"_id":"source/_posts/设计模式速谈：四、抽象工厂模式.md","hash":"80732ac0385c77df56d2fb8c47d4be5a9b77ed9f","modified":1549725053905},{"_id":"source/works/index.md","hash":"e40e06599d1694a2abf14d58a0641e1c580edaa4","modified":1549072428512},{"_id":"themes/clexy/source/images/apple-touch-icon-120x120.png","hash":"2d2d1995d982b7f2cae143783540b261a5caebf4","modified":1548993346652},{"_id":"themes/clexy/source/images/apple-touch-icon-114x114.png","hash":"c8276ecddc610ff3d19808d5268b27dfbd1e902c","modified":1548993346651},{"_id":"themes/clexy/source/images/apple-touch-icon-152x152.png","hash":"34b78ba88cbe96d159cab6e531fe8c398edc37f8","modified":1548993346653},{"_id":"themes/clexy/source/images/apple-touch-icon-144x144.png","hash":"75c8f71990592ec2ccafabeb8de2ee624d7d432f","modified":1548993346652},{"_id":"themes/clexy/source/images/apple-touch-icon-60x60.png","hash":"5248ff1eb1b7ea65155ae506070ec3d151f1fce8","modified":1548993346654},{"_id":"themes/clexy/source/images/apple-touch-icon-57x57.png","hash":"3aad1f5ab167c2dfa02d476353dbb401f17ab587","modified":1548993346654},{"_id":"themes/clexy/source/images/apple-touch-icon-72x72.png","hash":"8c17f59712942553d6d326a86340ffde18e00541","modified":1548993346655},{"_id":"themes/clexy/source/images/apple-touch-icon-76x76.png","hash":"2ebc1226c5640e2285b48ea50af7d624325a2ed4","modified":1548993346656},{"_id":"themes/clexy/source/images/favicon-128.png","hash":"5b2d400c7db321ce6b233de46fb696ba218bf64d","modified":1548993346658},{"_id":"themes/clexy/source/images/favicon-16x16.png","hash":"5e956d1a4321b2b1b3cc388016f7e754a897ac69","modified":1548993346659},{"_id":"themes/clexy/source/images/favicon-196x196.png","hash":"154b220eec554991d10b3da11a0eeb1267925a14","modified":1548993346660},{"_id":"themes/clexy/source/images/favicon-32x32.png","hash":"4c24eae0da91c62670ee6b0f6fc8a7671fb3f899","modified":1548993346661},{"_id":"themes/clexy/source/images/favicon.ico","hash":"17a847b6be406e5308921368c8badb6c296a5be1","modified":1548993346663},{"_id":"themes/clexy/source/images/favicon-96x96.png","hash":"59dc1149fcc12139e59db2c357d82250be6e40f7","modified":1548993346661},{"_id":"themes/clexy/source/images/logo.png","hash":"59dc1149fcc12139e59db2c357d82250be6e40f7","modified":1548993346663},{"_id":"themes/clexy/source/images/main.png","hash":"a6a103582037a5e0b43335370eb4f9a9ed8def83","modified":1548993346664},{"_id":"themes/clexy/source/images/mstile-144x144.png","hash":"75c8f71990592ec2ccafabeb8de2ee624d7d432f","modified":1548993346665},{"_id":"themes/clexy/source/images/mstile-150x150.png","hash":"0b4ccb912109566fbb60a3444da37d0ad2e228cb","modified":1548993346666},{"_id":"themes/clexy/source/images/mstile-310x150.png","hash":"c553816fb2ab63704ee8846af754d62abbd901ac","modified":1548993346667},{"_id":"themes/clexy/source/images/mstile-70x70.png","hash":"5b2d400c7db321ce6b233de46fb696ba218bf64d","modified":1548993346669},{"_id":"themes/clexy/source/scripts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1551439920886},{"_id":"themes/clexy/source/scripts/index.js","hash":"baea8e415131eadd5deae79ef301c71046f33ba3","modified":1551430530857},{"_id":"themes/clexy/source/styles/fontawesome.min.css","hash":"7961402d7d01e19387fe609a38454b0bc8c6cca4","modified":1550674723190},{"_id":"themes/clexy/source/styles/_mixins.styl","hash":"9a6d2de6090e9d7ab140a8c95d634012b26031dd","modified":1548993346670},{"_id":"themes/clexy/source/styles/normalize.css","hash":"02fe53286d071637534d5aa2c57c76c168c0d521","modified":1548993346671},{"_id":"themes/clexy/source/styles/screen.styl","hash":"71f6fef63d7da7405efa4d480f27e4f13e59ec84","modified":1551494933601},{"_id":"source/_posts/BigPipe-原理实现与使用场景分析/1.png","hash":"7389e88e2cd3aa589af48a2ef1712dd8767f4748","modified":1549953328076},{"_id":"source/_posts/BigPipe-原理实现与使用场景分析/2.png","hash":"f2f9fe5a72474c01a42e9aec329ce2377592dbab","modified":1549953328100},{"_id":"source/_posts/BigPipe-原理实现与使用场景分析/3.jpg","hash":"1d53c7964d06321ffbf5daee96fd1896fd051a76","modified":1549953328114},{"_id":"source/_posts/CSS-常用布局解决方案/1.jpg","hash":"7e355d1a73ea8b656cc8a3c69c7f3f1724b2e25b","modified":1549942583062},{"_id":"source/_posts/CSS-常用布局解决方案/10.jpg","hash":"75c3e01a31848d776c10493628be3696fbe0834a","modified":1549942582896},{"_id":"source/_posts/CSS-常用布局解决方案/11.jpg","hash":"79f5a6b41f2d603e59f6cde7579662d5e833d334","modified":1549942582913},{"_id":"source/_posts/CSS-常用布局解决方案/12.jpg","hash":"75078db2f1d05aaf855411236a72cddaec48b699","modified":1549942582932},{"_id":"source/_posts/CSS-常用布局解决方案/13.jpg","hash":"80b43445428479a7d54cee13fca5011580dc988f","modified":1549942583001},{"_id":"source/_posts/CSS-常用布局解决方案/14.jpg","hash":"3bb7b6c55737c3a97664b95a2926954d025ef18f","modified":1549942583044},{"_id":"source/_posts/CSS-常用布局解决方案/15.jpg","hash":"d718a3a9d1a74f96d0d1e9383a7707a3e2f4ce13","modified":1549942583135},{"_id":"source/_posts/CSS-常用布局解决方案/2.jpg","hash":"5d59f710cd570024cc0200db0efb1cf796daba13","modified":1549942583085},{"_id":"source/_posts/CSS-常用布局解决方案/3.jpg","hash":"3abb353aa00c6e6638437ebfe1cb15dd5422241d","modified":1549942583116},{"_id":"source/_posts/CSS-常用布局解决方案/4.jpg","hash":"a5ff108167bb4b9938cf8341f836bb6f898b237e","modified":1549942582947},{"_id":"source/_posts/CSS-常用布局解决方案/5.jpg","hash":"458de7945f935ecb7e9ae6613aee17535bab36d6","modified":1549942582962},{"_id":"source/_posts/CSS-常用布局解决方案/7.jpg","hash":"b393304d8f029a11262cd2c26060eff7961eae5a","modified":1549942582992},{"_id":"source/_posts/CSS-常用布局解决方案/8.jpg","hash":"71c3a43912ed752018be83b88ec2c7c7d9a6e29d","modified":1549942583025},{"_id":"source/_posts/CSS-常用布局解决方案/9.jpg","hash":"91d8d07d3a8f3c5c7e15f74307feaef681634f83","modified":1549942583098},{"_id":"source/_posts/Docker-最佳实践（一）/3.png","hash":"1d2e06fa2e981b994e75ce7f7d25428942b7d0b5","modified":1550636031148},{"_id":"source/_posts/Docker-最佳实践（二）/1.png","hash":"ae2517c22e772195e040c83ff852f37a10e72f30","modified":1550637001454},{"_id":"source/_posts/Docker-最佳实践（二）/2.png","hash":"a69303bfb4b7bf80721a3cc3e4009c8493668380","modified":1550637001469},{"_id":"source/_posts/Docker-最佳实践（二）/3.png","hash":"604d43634bb18039bce5fd49315a3ef7a3aa09cb","modified":1550637001473},{"_id":"source/_posts/Docker-最佳实践（二）/4.png","hash":"2beecedf96883d6bb4f35cb0a8cd338b699ac2b6","modified":1550637001458},{"_id":"source/_posts/ES-6-ES-2015-常用知识点归纳/1.png","hash":"6ee3f072dbb90940644c141bc1bb8a604b449ae1","modified":1549874929698},{"_id":"source/_posts/JavaScript-浏览器自动化/1.jpg","hash":"08b9a923841da6e8b33d9e3357b761a2a5ed1985","modified":1551173558140},{"_id":"source/_posts/JavaScript-浏览器自动化/2.jpg","hash":"bdac51aeb0bbb42e1cf1a68a4f62aa4dcd55e728","modified":1549263677845},{"_id":"source/_posts/JavaScript-浏览器自动化/3.jpg","hash":"9011f04127ffe3106c819e0ba840967f9a1b6c9d","modified":1549263677862},{"_id":"source/_posts/Redis-源码之内存管理-zmalloc-zfree/1.jpg","hash":"20c2b80c593b025a5645630c21cdf0c30e0d8a97","modified":1550571648926},{"_id":"source/_posts/Redis-源码之内存管理-zmalloc-zfree/2.jpg","hash":"6bda35ec5bd815834c0585de1330c9ae78c1ee82","modified":1550571648930},{"_id":"source/_posts/SVG-技术之-路径/1.png","hash":"a9fa8ee7d61b0b34472377e568d401eddf6abbd3","modified":1549298771055},{"_id":"source/_posts/WebAssembly-尝试研究报告-DIP-实践/3.png","hash":"da60ab0c7b50c7a6abe6f71c87e57dc4ea6d3b35","modified":1550566819795},{"_id":"source/_posts/WebAssembly-尝试研究报告（一）/1.png","hash":"12392ba9a6c68ffb7d0775feee314a18dc100f5c","modified":1550547385367},{"_id":"source/_posts/WebAssembly-深入研究报告-二进制编码/1.png","hash":"cc5c2dc5093cb803144f67199ef0121c0f2b66ff","modified":1550567799861},{"_id":"source/_posts/WebAssembly-深入研究报告-二进制编码/3.png","hash":"1d9c13ee0a14c4db3126af47dfc7c14b7ff18772","modified":1550567799881},{"_id":"source/_posts/WebAssembly-深入研究报告-二进制编码/5.png","hash":"ed398271cad5d17b304870ab046ab117becea133","modified":1550567799890},{"_id":"source/_posts/一种新的共享计算力模式/1.png","hash":"94f4bc8acd647dc16a9de7fe842203ce7c51f5c3","modified":1550573079307},{"_id":"source/_posts/“大型网站技术架构”总结：三，网站的高可用架构/1.jpg","hash":"4787eff7cacad6f26fa6c11613aaaa57a83abe21","modified":1550417131306},{"_id":"source/_posts/一种新的共享计算力模式/3.png","hash":"bd58a669dbea60c188c05126d8453a128e0bf899","modified":1550573079334},{"_id":"source/_posts/五分钟算法-二分法查找（Binary-Search）/1.jpg","hash":"6b3ab0b443b616a5fc84bcb6e1087944fc63b410","modified":1549375199561},{"_id":"source/_posts/利用-ab-命令进行简单压测/1.png","hash":"f6566250e1ed0bb8b2144b2812885056a476b84d","modified":1549264473345},{"_id":"source/_posts/利用-ab-命令进行简单压测/2.png","hash":"65807ff1bc9294e79d842d9cda86fe43d676fd5a","modified":1549264473362},{"_id":"source/_posts/前端-DCE-策略之-—-Tree-Shaking/1.jpg","hash":"72c76bf6068b77816e96351b3c3e49e538df6e78","modified":1550454675710},{"_id":"source/_posts/前端-DCE-策略之-—-Tree-Shaking/2.jpg","hash":"3201250f41c9b37a29b57fdd3ab6bee6fe6210af","modified":1550454675717},{"_id":"source/_posts/前端-DCE-策略之-—-Tree-Shaking/3.jpg","hash":"0fcd6538cd2ed029a7514fcd47b82e3cba419591","modified":1550454675720},{"_id":"source/_posts/前端常见技术点-CSS-DOM-布局/1.jpg","hash":"d3181e844b81e23773c5b4b72766f5eb60fb495e","modified":1549784406233},{"_id":"source/_posts/前端常见技术点-JavaScript/3.jpg","hash":"10347693b99c3e3003d172d7f5c6891e3d5f7784","modified":1549866622594},{"_id":"source/_posts/前端常见技术点-JavaScript/4.jpg","hash":"d0c834ff76efbafe93b68625f9fdfb1bf0619d60","modified":1549866622615},{"_id":"source/_posts/前端常见技术点-JavaScript/5.jpg","hash":"93fec99bb11555f13cf76f38a50a0fff808ca6f0","modified":1549866622608},{"_id":"source/_posts/前端那些事儿-Console-对象/2.png","hash":"b8acec8f2c9a50e34384112afa54426c3ee9fffc","modified":1549356559435},{"_id":"source/_posts/前端那些事儿-Console-对象/3.png","hash":"3ca539e77d8c8a069d6e7ea09350d95aff10b2a8","modified":1549356559451},{"_id":"source/_posts/前端那些事儿-Console-对象/4.png","hash":"7424aec1f81ae912afce4988d20e357c2c8294e7","modified":1549356559379},{"_id":"source/_posts/前端那些事儿-Console-对象/5.png","hash":"e2d3f7a63bc7dea473c1e4eb0f5214de352df1c2","modified":1549356559402},{"_id":"source/_posts/前端那些事儿-表单域的-MIME-编码/1.jpg","hash":"38e3685eb6aeec514969c1d9ed1c9e1490b33009","modified":1549352213978},{"_id":"source/_posts/前端项目规划与团队管理/1.jpg","hash":"994622693651234985df9f06a87388c202082a50","modified":1549870041942},{"_id":"source/_posts/基于-AWS-探索-Shadowsocks/2.png","hash":"338ba9207b2561b0c2080775b6adca2979d75f0a","modified":1549765443459},{"_id":"source/_posts/日本樱花季游攻略/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1550897225050},{"_id":"source/_posts/简单理解-HTTP-协议/1.png","hash":"4131aaa0a674457bfd0ab9c905326d90a11ca588","modified":1549122758060},{"_id":"source/_posts/设计模式速谈：三、工厂模式/1.png","hash":"4167b09c04f94e1852f0a292715ce35a131ecf64","modified":1549724427017},{"_id":"source/_posts/设计模式速谈：二、简单工厂模式/1.png","hash":"555ff4469aff14fea22d211b125652294d69d83d","modified":1549723758245},{"_id":"source/_posts/设计模式速谈：二、简单工厂模式/2.png","hash":"3d9d41b0186d198e870e21b258ea8dd16de64f8d","modified":1549723758266},{"_id":"source/_posts/设计模式速谈：五、建造者模式/1.png","hash":"534b49b1886a3ab758b967f3df691933e4c9b476","modified":1549725106589},{"_id":"source/_posts/设计模式速谈：六、单例模式/1.png","hash":"2259e6ffa1c5a7fe35391c1b78b8a6dc9cf31ae3","modified":1549725477089},{"_id":"source/_posts/设计模式速谈：四、抽象工厂模式/1.png","hash":"30b94a94a077aeaccfa116d6b65d99f5493a4f0d","modified":1549724760553},{"_id":"themes/clexy/source/images/mstile-310x310.png","hash":"3f9d9c684c50721ba9ef51fbd63b52e4f53eb841","modified":1548993346668},{"_id":"source/_posts/CSS-常用布局解决方案/6.jpg","hash":"5516b460bc51487405ad701b96e4b6ecadddaf63","modified":1549942582978},{"_id":"source/_posts/Docker-最佳实践（一）/2.png","hash":"b2082b10ce4285994f5cc204f9c62cd37ae6d088","modified":1550636031143},{"_id":"source/_posts/STC-与-PTC/1.jpg","hash":"dc4f8039551fcd8345e0ec52f7cd1e525fb43c9a","modified":1550453960903},{"_id":"source/_posts/WebAssembly-尝试研究报告-API-之初始化、内存和表的分配/1.png","hash":"48883568869771a9a21a7c09fb462273e1d01e98","modified":1550565258091},{"_id":"source/_posts/WebAssembly-尝试研究报告（一）/2.png","hash":"7efa98b2069ca194210b68e33378592308ebdb7d","modified":1550547385373},{"_id":"source/_posts/WebAssembly-深入研究报告-二进制编码/2.png","hash":"6e6ed7d9dda1df84dfa0694488a1775a656fe62f","modified":1550567799865},{"_id":"source/_posts/WebAssembly-深入研究报告-二进制编码/4.png","hash":"03138b750f55b9dcfc88840d3740dc655d9f9137","modified":1550567799874},{"_id":"source/_posts/WebAssembly-深入研究报告-二进制编码/6.png","hash":"6c1157dd22b81c7efd95ad3e5daac041b123ec6a","modified":1550567799878},{"_id":"source/_posts/一种新的共享计算力模式/2.png","hash":"65a7888d19f2c9385022fcdf8ae7dc82e88daa8c","modified":1550573079322},{"_id":"source/_posts/前端常见技术点-JavaScript/1.jpg","hash":"a8409a4c7bb2fc892682b71bc3701b77487f0649","modified":1549866622561},{"_id":"source/_posts/前端常见技术点-JavaScript/2.jpg","hash":"e88f892fcfa2b35d9e3640483865c17de7322c2f","modified":1549866622579},{"_id":"source/_posts/前端那些事儿-Console-对象/1.png","hash":"8bfca6ae334b4da14c012eb12668bc456a920e13","modified":1549356559418},{"_id":"source/_posts/日本樱花季游攻略/12.jpg","hash":"b98be0936d55074454e741fc6e04d759d9891f38","modified":1550845339800},{"_id":"source/_posts/日本樱花季游攻略/10.jpg","hash":"b41d5d7c0120b6679a1e28c603f63dcf05050263","modified":1550845339795},{"_id":"source/_posts/日本樱花季游攻略/13.jpg","hash":"b04ed06ce69e27d92e7835438bdb6e88b9d6cd2c","modified":1550846265770},{"_id":"source/_posts/日本樱花季游攻略/15.jpg","hash":"0fb0972b2c4a908116468a9fe1c588039615d74b","modified":1550846265779},{"_id":"source/_posts/日本樱花季游攻略/17.jpg","hash":"78440a955918dad980eb7630dd1e0f38b2b586ba","modified":1550846265787},{"_id":"source/_posts/日本樱花季游攻略/25.jpg","hash":"70a35f408b34148e4df722ae86f67f18fc43a9cb","modified":1550887039969},{"_id":"source/_posts/日本樱花季游攻略/4.jpg","hash":"c042533938a137bdf44268ae11975745ac89b9f9","modified":1550844764622},{"_id":"source/_posts/日本樱花季游攻略/7.jpg","hash":"0b4aee26fd16074f08c19fab11228d07750b03b4","modified":1550844764635},{"_id":"source/_posts/编码与“锟斤拷”的故事/1.jpg","hash":"ad364e45ee5606264c6e3ef9d760451bf273be38","modified":1549258665628},{"_id":"themes/clexy/source/fonts/fira/400.woff2","hash":"a8e246df0368fd8eef4806d9a1b36cf914beae15","modified":1548993346621},{"_id":"themes/clexy/source/fonts/fira/500.woff2","hash":"86d5b01469d71971cb0aa0f6f6f7946c045ff628","modified":1548993346623},{"_id":"themes/clexy/source/fonts/opensans/300.woff","hash":"8578430db19589546f1be89d121016713c801d30","modified":1548993346627},{"_id":"themes/clexy/source/fonts/opensans/300.woff2","hash":"ad2af0f0a073835100e66ee93b50def2e57a28df","modified":1548993346628},{"_id":"themes/clexy/source/fonts/opensans/300i.woff2","hash":"d45729f6376fe48d2b8a2c611b651a7f1502ae01","modified":1548993346630},{"_id":"themes/clexy/source/fonts/opensans/400.woff","hash":"7dd17593d3947f4ea10be937634ef8f553443e5a","modified":1548993346634},{"_id":"themes/clexy/source/fonts/opensans/400.woff2","hash":"9b18ae04f11fc74d27f281737b23b45a4bad5937","modified":1548993346635},{"_id":"themes/clexy/source/fonts/opensans/400i.woff2","hash":"24cc685201e9dd17ba9fed66f61fa4626f83211b","modified":1548993346637},{"_id":"themes/clexy/source/fonts/opensans/600.woff2","hash":"931f5105f0e909f90bdea2e246a1a230809a699a","modified":1548993346639},{"_id":"themes/clexy/source/fonts/opensans/600i.woff2","hash":"e51180cddda569a91790c2dc4c352d06831bb07b","modified":1548993346642},{"_id":"themes/clexy/source/fonts/opensans/700.woff","hash":"7956fd048338c3c6253aa58f65442441866d4b4e","modified":1548993346643},{"_id":"themes/clexy/source/fonts/opensans/700.woff2","hash":"074d6e274d90a1b510d6eff3a5f8d26f567c1575","modified":1548993346645},{"_id":"themes/clexy/source/fonts/opensans/700i.woff2","hash":"649af46dba2ec76c793426335e4026ca6c7a6109","modified":1548993346647},{"_id":"themes/clexy/source/fonts/opensans/800.woff2","hash":"ee323b2accd80d6845d5cb1ba426bea25f087abe","modified":1548993346649},{"_id":"themes/clexy/source/fonts/opensans/800i.woff2","hash":"649af46dba2ec76c793426335e4026ca6c7a6109","modified":1548993346650},{"_id":"themes/clexy/source/fonts/code/CodeFont.otf","hash":"5aef87ad807a638501c3b74936aa34afdfeb66de","modified":1495078874000},{"_id":"themes/clexy/source/fonts/code/CodeFont.woff","hash":"5d8c1b55ecdf181e0142ebc97413750e6681f62b","modified":1495078874000},{"_id":"themes/clexy/source/fonts/fontawesome/fontawesome-webfont.woff","hash":"2ee7af028d66bfdc0e78bb8aec3962d9a48a11af","modified":1550674947093},{"_id":"source/_posts/Docker-最佳实践（一）/1.png","hash":"cd213cacdc6aff029f20eb86a56840ea8fb099dc","modified":1550635948608},{"_id":"source/_posts/Docker-最佳实践（三）/1.png","hash":"65d7544378735f30b6435a91675bee11a2beac75","modified":1550642343511},{"_id":"source/_posts/前端常见技术点-CSS-DOM-布局/2.png","hash":"9f556349d7fef3c88df47d690a0ba2f429f48481","modified":1549784406268},{"_id":"source/_posts/前端常见技术点-CSS-DOM-布局/3.jpg","hash":"4e980e3b6e394cd3430cea81516f1d6fb52282f3","modified":1549784406243},{"_id":"source/_posts/基于-AWS-探索-Shadowsocks/3.png","hash":"a3aa9532651ae94474c18fea435ad4ced17c7cbf","modified":1549765443469},{"_id":"source/_posts/日本樱花季游攻略/19.jpg","hash":"11afa258c871bd3b086fde7eaed197b1c177ab17","modified":1550846265765},{"_id":"source/_posts/日本樱花季游攻略/23.jpg","hash":"4efc16aa45b078f48364c032932a77a46ca0a8ed","modified":1550887039963},{"_id":"source/_posts/日本樱花季游攻略/28.jpg","hash":"5a422958f329b61580bfc2e19d08624228d42c32","modified":1550893453452},{"_id":"source/_posts/日本樱花季游攻略/5.jpg","hash":"8b86b39a05d7c35d333780ab1503a73924398589","modified":1550844764627},{"_id":"source/_posts/简单理解-HTTP-协议/0.png","hash":"c792d84c7cfb9ec313a812069cb067e87babb2bc","modified":1549122548672},{"_id":"source/_posts/简单理解-HTTP-协议/2.png","hash":"4e7e22b1461cc91106fd0db61371b06e4c79fc81","modified":1549122663905},{"_id":"themes/clexy/source/fonts/fira/400.woff","hash":"4ee1b0356eac96f44b48a5ecc36584c4c81e33bd","modified":1548993346620},{"_id":"themes/clexy/source/fonts/fira/500.woff","hash":"5d4c15722ac01fb9c74662496967d6ebeda078d7","modified":1548993346622},{"_id":"themes/clexy/source/fonts/fira/700.woff","hash":"4b2ef8d1724a48a42afc5e7ff8ee77a960ed6895","modified":1548993346624},{"_id":"themes/clexy/source/fonts/fira/700.woff2","hash":"798f8fe64d02e466b546e16cf82a6ce914e96db5","modified":1548993346626},{"_id":"themes/clexy/source/fonts/opensans/300i.woff","hash":"dae3f536b867ea3d6cce0ef1406ab9b0813c16ea","modified":1548993346629},{"_id":"themes/clexy/source/fonts/opensans/400i.woff","hash":"9599e5da71b62e5227becb48e5498939e636e923","modified":1548993346636},{"_id":"themes/clexy/source/fonts/opensans/600.woff","hash":"7c9f1210d31388fe5df9e368bd0e73a8f4091b28","modified":1548993346638},{"_id":"themes/clexy/source/fonts/opensans/600i.woff","hash":"9406a2e087eb0d1790c2a7348b940f773ae6dda3","modified":1548993346641},{"_id":"themes/clexy/source/fonts/opensans/700i.woff","hash":"87f22f6a8759ae4bc18d97469091d9b218210b45","modified":1548993346646},{"_id":"themes/clexy/source/fonts/opensans/800.woff","hash":"31075459cd2010120a805d95506a9f8d7005b228","modified":1548993346648},{"_id":"themes/clexy/source/fonts/opensans/800i.woff","hash":"87f22f6a8759ae4bc18d97469091d9b218210b45","modified":1548993346650},{"_id":"themes/clexy/source/fonts/code/CodeFont.ttf","hash":"4d3d8054231ec4e9bfc14a46ad4d60c575fbfeec","modified":1495078874000},{"_id":"themes/clexy/source/fonts/fontawesome/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1550674947017},{"_id":"source/_posts/V8-内存优化之-Ignition-解释器/4.png","hash":"b78a463b9308ed6b6589973905c4fea95995f938","modified":1550572839914},{"_id":"source/_posts/Web-新时代与挑战/1.png","hash":"41ab2aaa04e1802ec5c69bee8d23f4ba724ced1d","modified":1550643243206},{"_id":"source/_posts/前端那些事儿-表单域的-MIME-编码/2.jpg","hash":"273647ee2a5044c871d873f9500c4306cd0e9230","modified":1549352214013},{"_id":"source/_posts/日本樱花季游攻略/11.jpg","hash":"72ab9b6261c70b89d118e1ad32fd46419c2f6042","modified":1550845339798},{"_id":"source/_posts/日本樱花季游攻略/18.jpg","hash":"8d8de16c785f32861b3f926b3e452d911c7a0e3a","modified":1550846265760},{"_id":"source/_posts/日本樱花季游攻略/22.jpg","hash":"559605547640208bafe991a55f0527f53ae41da5","modified":1550887039960},{"_id":"source/_posts/日本樱花季游攻略/26.jpg","hash":"1f65f71e57747a528f01957deb0fc0ce7a84da4f","modified":1550887039948},{"_id":"source/_posts/日本樱花季游攻略/3.jpg","hash":"f405c881472ae6e70354f849e225246651ab90b6","modified":1550844764617},{"_id":"source/_posts/日本樱花季游攻略/8.jpg","hash":"158b62f0d668c3f1cc57b3826c1ac09424f97227","modified":1550845339787},{"_id":"themes/clexy/source/fonts/code/CodeFont.svg","hash":"a26a0d90ef1433b8b22e2aba972facf28b9c6c3d","modified":1495078874000},{"_id":"themes/clexy/source/fonts/fontawesome/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1550674975531},{"_id":"themes/clexy/source/fonts/fontawesome/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1550674994062},{"_id":"source/_posts/Flush-Reload-Attack-与-Meltdown/1.png","hash":"3b8077b988cc7fdf90bad96ca5c961570f953afb","modified":1550643509373},{"_id":"source/_posts/Flush-Reload-Attack-与-Meltdown/2.png","hash":"85dc702cafb4e894e4e7dbd99a7d33e4449014ab","modified":1550643509384},{"_id":"source/_posts/Flush-Reload-Attack-与-Meltdown/3.png","hash":"8517d64c18dcc0afd43f8f7a2e8abe7841064ded","modified":1550643509388},{"_id":"source/_posts/PureRenderMixin-immutable-js-提高-VDOM-渲染效率/1.gif","hash":"93c37a476770bf80f4debd367237f8ef0280643c","modified":1550455842434},{"_id":"source/_posts/使用-Noteflight-来快速作曲和-MusicXML-导出/1.png","hash":"d398e1cc2077aa518932424eea4b1b603c22ef28","modified":1550569999169},{"_id":"source/_posts/使用-Noteflight-来快速作曲和-MusicXML-导出/2.png","hash":"9ded8ab0f352686672836fe49ed4d3829e82b51a","modified":1550569999174},{"_id":"source/_posts/日本樱花季游攻略/2.jpg","hash":"a0515212908c4dc59d26f1d586494b238523ddc5","modified":1550844764611},{"_id":"source/_posts/日本樱花季游攻略/21.jpg","hash":"3362a2fec548d1c398d39faa907af9848720f60c","modified":1550846744368},{"_id":"source/_posts/日本樱花季游攻略/9.gif","hash":"c8a965409ce86fe53fdc01742a0b5e332132de96","modified":1550845339792},{"_id":"source/_posts/V8-内存优化之-Ignition-解释器/3.png","hash":"bcc8f76147083d4045c6fe466762814f49ec4c74","modified":1550572839918},{"_id":"source/_posts/WebAssembly-尝试研究报告-DIP-实践/2.png","hash":"9e677c6d498375e4ee3915bf7e51e712eafeb019","modified":1550566819792},{"_id":"source/_posts/日本樱花季游攻略/1.jpg","hash":"501d8cf600f6d0f9320b8b66e296558ddf54b318","modified":1550159211754},{"_id":"source/_posts/日本樱花季游攻略/6.jpg","hash":"617761e4b81265941d7a8e7edda92967d5044ba2","modified":1550844764631},{"_id":"source/_posts/WebAssembly-尝试研究报告-DIP-实践/1.png","hash":"b512261726b5702ebc0e3fe49d36b8f5b7aecfb9","modified":1550566819787},{"_id":"source/_posts/基于-AWS-探索-Shadowsocks/1.png","hash":"aabf6abb8559e47f37af798ef620a32e71a7a408","modified":1549765443444},{"_id":"source/_posts/V8-内存优化之-Ignition-解释器/2.png","hash":"9482828a1f35f6ddb05b6e6d93dfd917758f61b9","modified":1550572839911},{"_id":"source/_posts/日本樱花季游攻略/16.jpg","hash":"6ab543555dfd21e60d6bbe01c6ac7ef5b3ab3956","modified":1550846265784},{"_id":"themes/clexy/source/fonts/fontawesome/fontawesome-webfont.svg","hash":"dcad0dd62ca23d8cfafa8c06cf54699bfce4fbf5","modified":1550675094728},{"_id":"source/_posts/V8-内存优化之-Ignition-解释器/1.png","hash":"495ea88fe031d0da5128756c6134d539f11a9072","modified":1550572839906},{"_id":"source/_posts/Web-新时代与挑战/2.png","hash":"759f3f0866fd01b7b7db8b17d499509e23d3940a","modified":1550643243213},{"_id":"source/_posts/“大型网站技术架构”总结：一，概述/1.jpg","hash":"79b7c27f2cb1fd042bc44172b168f27202d6cd02","modified":1550416051182},{"_id":"source/_posts/日本樱花季游攻略/24.jpg","hash":"7f7ffeb1a18db1bb9f1fc24dca16d8c53800e9a7","modified":1550887039966},{"_id":"themes/clexy/source/images/avatar.jpeg","hash":"0f703e2b763e5848a5c6ba81a7fe350bce1f590e","modified":1549002718581},{"_id":"source/_posts/日本樱花季游攻略/20.jpg","hash":"4592d94cd4ec8386a7d7b83a1f33e24c59b1ff93","modified":1550887039955},{"_id":"source/_posts/WebAssembly-尝试研究报告（三）/2.png","hash":"6326e4068b61302d340126c24564ba343c5f2396","modified":1550558241116},{"_id":"source/_posts/WebAssembly-尝试研究报告（三）/3.png","hash":"51bb9171c74a1f92d388d67dc97daf65d8651fac","modified":1550558241133},{"_id":"source/_posts/日本樱花季游攻略/27.png","hash":"972a0f1d300569603c48cb84abd8295ee1417bf7","modified":1550892120713},{"_id":"source/_posts/日本樱花季游攻略/31.png","hash":"9910c5cb986bfc1f9905952f4d3dd824ffe927cd","modified":1550897362605},{"_id":"source/_posts/日本樱花季游攻略/30.png","hash":"e51cc8363b8911269c05f9240e8634c99af005ab","modified":1550897224435},{"_id":"source/_posts/日本樱花季游攻略/29.png","hash":"b65bd234d8245cf4682b2971122ed51b183faf79","modified":1550897158537},{"_id":"source/_posts/WebAssembly-尝试研究报告（三）/1.png","hash":"0b564c9f67616bd83f86bfc6b38f65e692c11b3c","modified":1550558241104},{"_id":"public/tags/index.html","hash":"a3d4d6d1ae25687a35269ce5bfc1c26ac0502a19","modified":1551495727901},{"_id":"public/author/index.html","hash":"0438f266bf1e0d30ffa8d18994fe6b568b73631e","modified":1551495727901},{"_id":"public/works/index.html","hash":"679f6903d52d9939d183df647694e54646234ec7","modified":1551495727902},{"_id":"public/2019/02/28/今日商业评论—瑞幸咖啡VS星巴克，如何互补？/index.html","hash":"9a7a44f6180284cd828c960ad36a65a11b7f3b90","modified":1551495727902},{"_id":"public/2019/01/14/“重新定义团队：谷歌如何工作”-读书笔记/index.html","hash":"217bf40a468628930be2f96757a7daec0bac5d06","modified":1551495727902},{"_id":"public/2019/01/08/“阿米巴经营”-读书笔记/index.html","hash":"51fcf26c6769fa46e46ff1ce748fe920005e3988","modified":1551495727902},{"_id":"public/2019/01/07/“零售的哲学”-读书笔记/index.html","hash":"9f53cb18904072e5f668c791c47d6ec58f25f1e7","modified":1551495727902},{"_id":"public/2019/01/05/“增长黑客：创业公司的用户与收入增长秘籍” 读书笔记/index.html","hash":"be5cd56fbd5e6e73392da2b598fdeae92ea966a8","modified":1551495727902},{"_id":"public/2018/11/29/Git-最佳实践/index.html","hash":"29a4080ab011533cdbe52e7654b411d435622ef5","modified":1551495727902},{"_id":"public/2018/11/01/我的新书《深入浅出-WebAssembly》出版啦-｡･ω･｡-ﾉ/index.html","hash":"706c93705a272a658bbcfceee9822459a566dfd9","modified":1551495727902},{"_id":"public/2018/01/08/Flush-Reload-Attack-与-Meltdown/index.html","hash":"0caaab7c505a6f518c777b6c3b6d58867e837fc0","modified":1551495727902},{"_id":"public/2017/12/17/Web-新时代与挑战/index.html","hash":"eae6e0c33f42bb970b3acd975b0a0009c22d0171","modified":1551495727902},{"_id":"public/2017/11/12/The-Twelve-Factor-App/index.html","hash":"4ebcf019e701ecb7cbabebf8893723f8682dfe6b","modified":1551495727902},{"_id":"public/2017/11/07/Docker-最佳实践（二）/index.html","hash":"0b4f48de8c6c1a4cf5471bf2dd9b5a556e1ad35e","modified":1551495727903},{"_id":"public/2017/09/30/一种新的共享计算力模式/index.html","hash":"bd80c30eaed380a1667c402d3ccc2b19856eab8d","modified":1551495727903},{"_id":"public/2017/09/07/V8-内存优化之-Ignition-解释器/index.html","hash":"9061ef07c778d0eba3f6b0198698eefcd03f6037","modified":1551495727903},{"_id":"public/2017/09/04/大数据基础架构概述/index.html","hash":"ae82454fec04db8f07248b631188a3e8b8c2cc8c","modified":1551495727903},{"_id":"public/2017/09/02/C-小记录/index.html","hash":"38ca7ce4f3a7980266f9a01cf2f4aa325a4b9f91","modified":1551495727903},{"_id":"public/2017/07/20/Python-高级用法/index.html","hash":"a553365a1f905af2804bd0e76e7b60c68a5fe0da","modified":1551495727903},{"_id":"public/2017/07/19/WebAssembly-深入研究报告-碎片知识/index.html","hash":"d62b907d8bb7c172b761e7816d89a0c8f9fa25bf","modified":1551495727903},{"_id":"public/2017/07/06/使用-Noteflight-来快速作曲和-MusicXML-导出/index.html","hash":"4e53561deb7783db10e4ffa7015ef0f3c2cb7427","modified":1551495727903},{"_id":"public/2017/06/29/Common-Lisp-全记录（一）/index.html","hash":"0ad129f005c69b0a2a61747ac21fc6f425be0ec4","modified":1551495727903},{"_id":"public/2017/06/29/Mac-配置-Commom-Lisp-开发环境/index.html","hash":"bc57455c08c3eea3dcee88f72538eb25103fddf9","modified":1551495727903},{"_id":"public/2017/06/28/WebAssembly-深入研究报告-安全性/index.html","hash":"5ecc7115f20276870de2442c26a75285e4077e5a","modified":1551495727903},{"_id":"public/2017/06/13/WebAssembly-尝试研究报告-错误处理/index.html","hash":"7eb8a9b6f22e60a84c6f82bafdf3a3ef385c67c2","modified":1551495727903},{"_id":"public/2017/06/11/WebAssembly-尝试研究报告（三）/index.html","hash":"538af427ebdae5b401e95fea225196f8adae194d","modified":1551495727903},{"_id":"public/2017/05/18/PureRenderMixin-immutable-js-提高-VDOM-渲染效率/index.html","hash":"7391afe66f05ea70f540b49dab5cc36a20e27162","modified":1551495727903},{"_id":"public/2017/05/08/前端-DCE-策略之-—-Tree-Shaking/index.html","hash":"7e16c3040a79a2612ea1f67cf882d6a9acf7adff","modified":1551495727903},{"_id":"public/2017/05/08/“函数柯里化”常见使用场景记录/index.html","hash":"b058b041a67ae1e03fb7b50d75c51e290804ad9d","modified":1551495727904},{"_id":"public/2017/05/06/STC-与-PTC/index.html","hash":"3253cb2f44587371d28821edff79b77c41a7a664","modified":1551495727904},{"_id":"public/2017/05/02/“大型网站技术架构”总结：三，网站的高可用架构/index.html","hash":"74f1acf25b65d12b323f99946af6366210876f43","modified":1551495727904},{"_id":"public/2017/04/30/“大型网站技术架构”总结：二，网站的高性能架构/index.html","hash":"327a4a49f2908487fa03630cda36c7dafd693659","modified":1551495727904},{"_id":"public/2017/04/29/“大型网站技术架构”总结：一，概述/index.html","hash":"ee6d63339fe22daa2ac80dd659c794305ea5cf2f","modified":1551495727904},{"_id":"public/2017/04/22/机器学习记录-简介/index.html","hash":"14f0edc1ac10782c46974ec8bb56edb39f0f9d3d","modified":1551495727904},{"_id":"public/2017/03/23/URL-编码的那些事儿/index.html","hash":"95fbdf3c2aa5399118832d4e212727ca45bbe3cc","modified":1551495727904},{"_id":"public/2017/03/21/一道面试题的思考/index.html","hash":"ad53de45d6c2d0a6dcb8498d3e2bf0d6206c0894","modified":1551495727904},{"_id":"public/2017/01/29/CentOS-7-2-之-MySQL-到-MariaDB-的迁移/index.html","hash":"f06d77dc91e8ec44b2dbd09251757e0e1fc9212c","modified":1551495727904},{"_id":"public/2017/01/16/2017-开篇/index.html","hash":"20a408f96c64fdf0107f0f0d8dc0b4c2d522371e","modified":1551495727904},{"_id":"public/2016/12/15/CSS-常用布局解决方案/index.html","hash":"1548c98cf741a7a044da4a768a0e463ca9bf779f","modified":1551495727904},{"_id":"public/2016/12/14/前端项目规划与团队管理/index.html","hash":"e0dcd6ce1ba8b7f7f34a2aafeac535c60e11bcc6","modified":1551495727904},{"_id":"public/2016/09/17/LeetCode-每日一题-104-Maximum-Depth-of-Binary-Tree/index.html","hash":"1f6ea353677b4828846e817e78a1c61e5a8e9500","modified":1551495727904},{"_id":"public/2016/09/17/LeetCode-每日一题-58-Length-of-Last-Word/index.html","hash":"e6a7fe47ed0e66bc865b3910e3938d268b3ac49a","modified":1551495727904},{"_id":"public/2016/09/16/Zoomage-js-正式版-V1-0-0-核心原理介绍/index.html","hash":"27b239ed0b95cd97edbf23c86a4f58f6de330ff4","modified":1551495727905},{"_id":"public/2016/08/16/基于-AWS-探索-Shadowsocks/index.html","hash":"c32f50c94d2cf41c931f46ff6848b20e237ab341","modified":1551495727905},{"_id":"public/2016/07/16/设计模式速谈：一、序论/index.html","hash":"440e1c9468bdbce272c0aeba95e8ab5c435b6f7e","modified":1551495727905},{"_id":"public/2016/07/07/LeetCode-每日一题-100-Same-Tree/index.html","hash":"821ab605d6134b22e758f426bc30e3e0982b9344","modified":1551495727905},{"_id":"public/2016/06/15/LeetCode-每日一题-203-Remove-Linked-List-Elements/index.html","hash":"dea871870749ca1210f461ceca5102603f49a8cb","modified":1551495727905},{"_id":"public/2016/05/24/LeetCode-每日一题-27-Remove-Element/index.html","hash":"5ad83a1cec3f09328d1817dc7141da1f74854117","modified":1551495727905},{"_id":"public/2016/05/12/LeetCode-每日一题-9-Palindrome-Number/index.html","hash":"1354d3189fd2e029d4c739a9be8b0b0d4d3dcc94","modified":1551495727905},{"_id":"public/2016/05/06/LeetCode-每日一题-258-Add-Digits/index.html","hash":"6d4ccf8acfabd5e8d1b227ed44b17697f7d7b90b","modified":1551495727905},{"_id":"public/2016/05/05/LeetCode-每日一题-344-Reverse-String/index.html","hash":"0afcc2133658a2f0da0673f7bacd14be01c4f84b","modified":1551495727905},{"_id":"public/2016/04/25/LeetCode-每日一题-342-Power-of-Four/index.html","hash":"538f6ddacc6d2ee3c8ddf4ac0f45f8924ee21c6f","modified":1551495727905},{"_id":"public/2016/04/20/LeetCode-每日一题-70-Climbing-Stairs/index.html","hash":"ee5340cb1ffe09311fe9ec93c0eed743b15ea825","modified":1551495727905},{"_id":"public/2016/03/20/Java-基础语法特性记录/index.html","hash":"42ee92cb4719e240f7c60c4beb9e46e16315c7d5","modified":1551495727905},{"_id":"public/2016/03/16/LAMP-架构之升级-PHP-版本/index.html","hash":"c876663b32c55b622b363ad5de3f1302a79848ca","modified":1551495727905},{"_id":"public/2016/02/12/技术是成功的“绊脚石”/index.html","hash":"69d3cd3363b0c299c003e90fa1dfe1183e0da8fc","modified":1551495727905},{"_id":"public/2016/02/09/前端那些事儿-Console-对象/index.html","hash":"82baa1d57c95d052f147672bba86d93c630d6fdf","modified":1551495727905},{"_id":"public/2015/11/24/前端那些事儿-表单域的-MIME-编码/index.html","hash":"189495c4a0039a407767d32dd097fc7e3d4980be","modified":1551495727906},{"_id":"public/2015/11/08/SVG-技术之-路径/index.html","hash":"2e849fa9975ba4bec8d01ed5633d3bc2dfdc7ff9","modified":1551495727906},{"_id":"public/2015/08/12/不得不防范的-iframe-非法嵌入/index.html","hash":"ff64af7594b3c7ccf6d55fc3369baffc19caf731","modified":1551495727906},{"_id":"public/2015/08/11/浅谈-CORS：跨域资源共享/index.html","hash":"9ffbe429592c152183a96e691545ab825063b1e0","modified":1551495727906},{"_id":"public/2015/08/01/GeekBank-C-线下班学习心得（三）/index.html","hash":"8ac695ba22a4451f0c57d1356b0accdbb2028234","modified":1551495727906},{"_id":"public/2015/07/21/GeekBank-C-线下班学习心得（一）/index.html","hash":"f0c4b3b2d7db0dd659f7ef651674f1f3a109fc92","modified":1551495727906},{"_id":"public/2015/03/22/图像扫描及-OCR-技术开发-SDK-Asprise/index.html","hash":"421c455270e14d3133c2a17752b7945b656b5902","modified":1551495727906},{"_id":"public/2015/03/22/为-Swing-控件-JList-动态添加元素/index.html","hash":"42168b0f44f1636a61ba0cb40020217e2be96efe","modified":1551495727906},{"_id":"public/2015/03/20/基于-PHP-实现的优化盐值加密算法/index.html","hash":"cb1c2001e567e7896fc5ba019f8da8c4af900181","modified":1551495727906},{"_id":"public/2015/03/12/利用-ab-命令进行简单压测/index.html","hash":"b43b28ec26278d8e3b57f719fdacd446309ebdaf","modified":1551495727906},{"_id":"public/2015/02/18/JavaScript-浏览器自动化/index.html","hash":"fa8b279c98853318f22b0e9ac01b0be37dd737db","modified":1551495727906},{"_id":"public/2015/02/13/event-target-与-event-srcElement/index.html","hash":"f4e7a8f906e81c6d54c164cbd2452634fae59f3c","modified":1551495727906},{"_id":"public/2015/01/26/编码与“锟斤拷”的故事/index.html","hash":"4e5fe1a5d4a787efdcbbae95559dd900d2845f51","modified":1551495727906},{"_id":"public/2015/01/12/Prism-js-在-AJAX-下的应用问题/index.html","hash":"5cc4c157ce5a8a1cbbb7a6f5467b1f18bafe6621","modified":1551495727906},{"_id":"public/2015/01/11/博客正式使用“知识共享-CC”国际协议/index.html","hash":"61f1dcbd3192fa4ba5eb63788fd9b1f8431194fe","modified":1551495727906},{"_id":"public/2015/01/06/深夜吐槽-笔试与企业文化/index.html","hash":"e190092cbb9bc2407fce3c5dd873e36f4a691a3e","modified":1551495727906},{"_id":"public/2015/01/04/RSS-概述/index.html","hash":"9c9224affe0b721e199c2864e0e53bef91a94e04","modified":1551495727906},{"_id":"public/2015/01/02/IT-行业的入门与精通/index.html","hash":"14850e8da7b0fd8c234a12ca0bca71377f637156","modified":1551495727906},{"_id":"public/2014/12/27/简谈-JavaScript-中的数据类型/index.html","hash":"b4e08adfaa5f4d74fd8d835f8e26b5e1dcf9e799","modified":1551495727906},{"_id":"public/2014/12/26/浅谈-SEO/index.html","hash":"51de7a347bab2e4ea0fad2c5c6d8e4f22b73f18f","modified":1551495727906},{"_id":"public/2014/12/25/简单理解-HTTP-协议/index.html","hash":"fb2088d53191947a584d549aa8e08565481f7c5c","modified":1551495727906},{"_id":"public/2014/12/24/Android-以-Post-方式发送-Http-请求/index.html","hash":"247de512b271997703114828e31c6bd01b050495","modified":1551495727907},{"_id":"public/index.html","hash":"62bed998d66d025c65f49cefadf3d0c92ea1c84c","modified":1551495727907},{"_id":"public/page/2/index.html","hash":"62bed998d66d025c65f49cefadf3d0c92ea1c84c","modified":1551495727907},{"_id":"public/page/3/index.html","hash":"62bed998d66d025c65f49cefadf3d0c92ea1c84c","modified":1551495727907},{"_id":"public/page/4/index.html","hash":"62bed998d66d025c65f49cefadf3d0c92ea1c84c","modified":1551495727907},{"_id":"public/page/5/index.html","hash":"62bed998d66d025c65f49cefadf3d0c92ea1c84c","modified":1551495727907},{"_id":"public/page/6/index.html","hash":"62bed998d66d025c65f49cefadf3d0c92ea1c84c","modified":1551495727907},{"_id":"public/page/7/index.html","hash":"62bed998d66d025c65f49cefadf3d0c92ea1c84c","modified":1551495727907},{"_id":"public/page/8/index.html","hash":"62bed998d66d025c65f49cefadf3d0c92ea1c84c","modified":1551495727907},{"_id":"public/page/9/index.html","hash":"62bed998d66d025c65f49cefadf3d0c92ea1c84c","modified":1551495727907},{"_id":"public/page/10/index.html","hash":"62bed998d66d025c65f49cefadf3d0c92ea1c84c","modified":1551495727907},{"_id":"public/page/11/index.html","hash":"62bed998d66d025c65f49cefadf3d0c92ea1c84c","modified":1551495727907},{"_id":"public/page/12/index.html","hash":"62bed998d66d025c65f49cefadf3d0c92ea1c84c","modified":1551495727907},{"_id":"public/page/13/index.html","hash":"62bed998d66d025c65f49cefadf3d0c92ea1c84c","modified":1551495727907},{"_id":"public/page/14/index.html","hash":"62bed998d66d025c65f49cefadf3d0c92ea1c84c","modified":1551495727907},{"_id":"public/tags/日记/index.html","hash":"a5fd9474c18da793d2dc0145b519ae13659de470","modified":1551495727907},{"_id":"public/tags/Android/index.html","hash":"1bb853898312e8822d72b689a578717f470a95e3","modified":1551495727907},{"_id":"public/tags/JavaScript/index.html","hash":"aa111bb6f95b3dcfd93cd84352c99e9d6c339dc3","modified":1551495727908},{"_id":"public/tags/JavaScript/page/2/index.html","hash":"aa111bb6f95b3dcfd93cd84352c99e9d6c339dc3","modified":1551495727908},{"_id":"public/tags/JavaScript/page/3/index.html","hash":"aa111bb6f95b3dcfd93cd84352c99e9d6c339dc3","modified":1551495727908},{"_id":"public/tags/BigPipe/index.html","hash":"8495e74e9d8dd1a749fcc3c8a5725714a9ecdc1e","modified":1551495727908},{"_id":"public/tags/C/index.html","hash":"81e201c7b89922ddcb5bae4a007fdd90fc967d96","modified":1551495727908},{"_id":"public/tags/CSS/index.html","hash":"6f7970942627ff0698b8efb015b703f5908b95b1","modified":1551495727908},{"_id":"public/tags/Linux/index.html","hash":"cb58bfd3845eb6ab9622efcd45a277e56f2d13d6","modified":1551495727908},{"_id":"public/tags/MySQL/index.html","hash":"5c95fffcfbbafa4fb75332eaa4223e6ec97e5b35","modified":1551495727908},{"_id":"public/tags/Lisp/index.html","hash":"9831f31a47e915534f700839b0fe4614f760a6a5","modified":1551495727908},{"_id":"public/tags/Docker/index.html","hash":"dbbf5ec7a99b107ddda089c3603c007f4c5f9d54","modified":1551495727908},{"_id":"public/tags/ECMAScript/index.html","hash":"1f72834eb9299d818814f1446fdb3eb1faaf1583","modified":1551495727908},{"_id":"public/tags/漏洞/index.html","hash":"222db66424f44d63915eca76bedbcfd5a8decd69","modified":1551495727908},{"_id":"public/tags/Git/index.html","hash":"1b9f7804291106d39a89e95b28c2c94e8e61d3c3","modified":1551495727908},{"_id":"public/tags/HTML/index.html","hash":"9bce417c0160db3f5af2d424ba903486af0733cf","modified":1551495727908},{"_id":"public/tags/HTTP/index.html","hash":"2ac1376c9aae6a169ebd3ab9760c4345815055a9","modified":1551495727908},{"_id":"public/tags/互联网思考/index.html","hash":"e629c42283e4173dfad2fa399e7607faa230ebce","modified":1551495727908},{"_id":"public/tags/Java/index.html","hash":"13804c67e4d6a3871a9e90fdec2c09f65733ece3","modified":1551495727908},{"_id":"public/tags/PHP/index.html","hash":"f5523c75d9a3aec9ea9e61de7171ea216842b085","modified":1551495727908},{"_id":"public/tags/算法/index.html","hash":"2f6cba97e9b77589be372abb2725e43624b962d9","modified":1551495727908},{"_id":"public/tags/算法/page/2/index.html","hash":"2f6cba97e9b77589be372abb2725e43624b962d9","modified":1551495727909},{"_id":"public/tags/算法/page/3/index.html","hash":"2f6cba97e9b77589be372abb2725e43624b962d9","modified":1551495727909},{"_id":"public/tags/LeetCode/index.html","hash":"296e823120e6500edf91010e3a4b52e30cf68197","modified":1551495727909},{"_id":"public/tags/LeetCode/page/2/index.html","hash":"296e823120e6500edf91010e3a4b52e30cf68197","modified":1551495727909},{"_id":"public/tags/LeetCode/page/3/index.html","hash":"296e823120e6500edf91010e3a4b52e30cf68197","modified":1551495727909},{"_id":"public/tags/Web/index.html","hash":"ec58eb8093a27067756095fb8247741d1c1fad44","modified":1551495727909},{"_id":"public/tags/React/index.html","hash":"1eced7422055c94481aa790cf393a66b7ebc3a4a","modified":1551495727909},{"_id":"public/tags/Python/index.html","hash":"4365dd83c58c4516122365256e0cecc59905191c","modified":1551495727909},{"_id":"public/tags/python/index.html","hash":"bcafec630ad1bdd0b4b1ff9fa115b08dbf42642c","modified":1551495727909},{"_id":"public/tags/尾递归/index.html","hash":"d9678b0bcb4426c59be0709f15fa1092e99b87ab","modified":1551495727909},{"_id":"public/tags/Redis/index.html","hash":"392fb3263177324dce22b5992f9f9675f8ec4503","modified":1551495727909},{"_id":"public/tags/编码/index.html","hash":"08f9517baeb4dced65c2899fe38c2f7ecaceb25d","modified":1551495727909},{"_id":"public/tags/Twelve-Factor/index.html","hash":"1a5234c6f65c3fcc9b3d7dc4b37f0e7b6d24ae78","modified":1551495727909},{"_id":"public/tags/WebAssembly/index.html","hash":"d7215321bd2e668605fad60c50ffee8db9ade58d","modified":1551495727909},{"_id":"public/tags/Library/index.html","hash":"4c56bce4d4d05285385111ec1428f4a2dfb61f13","modified":1551495727909},{"_id":"public/tags/V8/index.html","hash":"59d07b2c0f25b3d0b691d27c7b0d08be2bc088fb","modified":1551495727909},{"_id":"public/tags/柯里化/index.html","hash":"3962753cced75755dff305ebb5f2442ed4c66d44","modified":1551495727909},{"_id":"public/tags/读书/index.html","hash":"14101727cbb4f1f7982d2689b76eb903daf60dea","modified":1551495727909},{"_id":"public/tags/创业/index.html","hash":"7a1de5ce653e223b3ae5f2a4478860fa6664ef6d","modified":1551495727909},{"_id":"public/tags/后端/index.html","hash":"f217026b2b34830058676269f110cc3790967c97","modified":1551495727910},{"_id":"public/tags/架构/index.html","hash":"bec2f8b7f374d8c7b5b20f0673162af25f32c8ca","modified":1551495727910},{"_id":"public/tags/经营/index.html","hash":"8a4d1c3315c0b021d3c472bb7dfc72251419dc43","modified":1551495727910},{"_id":"public/tags/jQuery/index.html","hash":"792cc146d6428dae88f2dc8988bc1d6097e65360","modified":1551495727910},{"_id":"public/tags/商业评论/index.html","hash":"a672f835f8ea6b51df744cd1cdc66b0247959966","modified":1551495727910},{"_id":"public/tags/钢琴/index.html","hash":"b0cb8a1b304e204e986527e17dd9527b425d1ade","modified":1551495727910},{"_id":"public/tags/Apache/index.html","hash":"4f2342cdf58b6c494b79158bbe7136e5d73e68e0","modified":1551495727910},{"_id":"public/tags/ES6/index.html","hash":"380ac3c080f433c65455a93571837c0792afb3e5","modified":1551495727910},{"_id":"public/tags/DCE/index.html","hash":"27d6a07999f14cfb2508b4892264f4afdc3c76e3","modified":1551495727910},{"_id":"public/tags/DOM/index.html","hash":"64c840dd28ce409adaa9f4633bcc98fd63ac4749","modified":1551495727910},{"_id":"public/tags/团队管理/index.html","hash":"61fbf1528680a13e35f4b88bdf0f6010246e7a96","modified":1551495727910},{"_id":"public/tags/网站事务/index.html","hash":"6a001469756dfb0118e6a4c36bac5c262b6bac93","modified":1551495727910},{"_id":"public/tags/AWS/index.html","hash":"b7a34bd373fff5d20e8482b726d85945f0fd9b3b","modified":1551495727910},{"_id":"public/tags/Shadowsocks/index.html","hash":"0edff61b25f73e69368e838dfd9e02740ff16c02","modified":1551495727910},{"_id":"public/tags/KNN/index.html","hash":"ccbd9a5c1eae2d4ea8ede5331e543d6742845bfa","modified":1551495727910},{"_id":"public/tags/TensorFlow/index.html","hash":"4779b5448262b01e94eab3e0ae641c22e718d467","modified":1551495727910},{"_id":"public/tags/大数据/index.html","hash":"a93ec257c62370f878860c1288b54cdfcfc689d6","modified":1551495727911},{"_id":"public/tags/Shell/index.html","hash":"1f229b3ca9cf189b99d2821aeeb1355139a42b4c","modified":1551495727911},{"_id":"public/tags/出版/index.html","hash":"759d23ba15e9f476cbd50e23933cb169d5d9408e","modified":1551495727911},{"_id":"public/tags/机器学习/index.html","hash":"c066924dd9923a23a107be2557855018b71c4571","modified":1551495727911},{"_id":"public/tags/旅游/index.html","hash":"bde29f8217da77c7e5d5b23c056d12758727c694","modified":1551495727911},{"_id":"public/tags/BigRender/index.html","hash":"93ff2685d3e7d2a931b4e3a89be520b0bd487b59","modified":1551495727911},{"_id":"public/tags/互联网/index.html","hash":"8b0a82a01f89673ca0dee5934acde9ee891692ff","modified":1551495727911},{"_id":"public/tags/设计模式/index.html","hash":"1c0ff1f5fec3e8f1637e45bd3361515cef595f5c","modified":1551495727911},{"_id":"public/articles/index.html","hash":"7c47dd72c19feef763c722d847dc0f967d3e6b59","modified":1551495727911},{"_id":"public/2019/02/14/日本樱花季游攻略/index.html","hash":"aa18d91c1cb2b8c17af7e6978995e389a03d498c","modified":1551495727911},{"_id":"public/2017/11/09/Docker-最佳实践（三）/index.html","hash":"0f93a126950ee8f566d8144b99d8bc4a0d5ea5f7","modified":1551495727911},{"_id":"public/2017/11/04/Docker-最佳实践（一）/index.html","hash":"703423212028f724334d0ed9c1a3fe049d630e56","modified":1551495727911},{"_id":"public/2017/08/22/Redis-源码之内存管理-zmalloc-zfree/index.html","hash":"e9b570bb3b576139c244038e260a459eb69c07f9","modified":1551495727911},{"_id":"public/2017/07/13/Python-小记/index.html","hash":"7b249d4fe3a9a0bd46b756f1b1f0b5c677aa4be4","modified":1551495727912},{"_id":"public/2017/07/06/ES-8-新特性一览/index.html","hash":"38c15bb2787e8d231975262a4a9f7121e8eb5a2a","modified":1551495727912},{"_id":"public/2017/06/20/WebAssembly-深入研究报告-二进制编码/index.html","hash":"48ec0655ecfa19013ae9490ef683a66ce3cc2891","modified":1551495727912},{"_id":"public/2017/06/16/WebAssembly-尝试研究报告-DIP-实践/index.html","hash":"b93456ab8d4bf89503c729189feeb8c3fe452ed3","modified":1551495727912},{"_id":"public/2017/06/16/WebAssembly-尝试研究报告-本地存储与转移/index.html","hash":"30ecd29749469f2c30deb5698418606145930b29","modified":1551495727912},{"_id":"public/2017/06/14/WebAssembly-尝试研究报告-API-之初始化、内存和表的分配/index.html","hash":"4bf816f824752b522661851cdff21bbe6367dc04","modified":1551495727912},{"_id":"public/2017/06/10/WebAssembly-尝试研究报告（二）/index.html","hash":"81e3706645c3a0e200ff190ce02802d48de2937f","modified":1551495727912},{"_id":"public/2017/06/09/WebAssembly-尝试研究报告（一）/index.html","hash":"7d9910fe87f63b175eb53160684024014e65bec5","modified":1551495727912},{"_id":"public/2017/05/26/基于-NumPy-和-TensorFlow-的简单-KNN-实现/index.html","hash":"d3b660806ec3fb2a1f8a3487279ea3a9f22d8fb9","modified":1551495727912},{"_id":"public/2017/05/16/常用-Shell-知识点和技巧/index.html","hash":"5c48f7a52f7c680a7746ee9c5e61892f0644c517","modified":1551495727912},{"_id":"public/2017/04/26/淘宝网的-BigRender/index.html","hash":"1043456997d71517765af66f021fcbd8047ee907","modified":1551495727912},{"_id":"public/2017/04/24/BigPipe-原理实现与使用场景分析/index.html","hash":"4eeec916542679f16168d70783db54713b416faf","modified":1551495727912},{"_id":"public/2017/03/09/HTTP-基础整理/index.html","hash":"df58739d38583e0f96e132a3e8fb5e2c0f310b3c","modified":1551495727912},{"_id":"public/2017/02/28/Promise-A-调用详谈/index.html","hash":"7c399a9858217462279433b5642b3a0dabd5fe1d","modified":1551495727912},{"_id":"public/2016/12/29/jQuery-源码江湖-初入江湖/index.html","hash":"de4b265cb3bdc66d67401a6f38ab5ca899bf7575","modified":1551495727912},{"_id":"public/2016/12/22/Promise-浅谈/index.html","hash":"ce7bebbe55291e96d879038741d7eab33f80a1e5","modified":1551495727913},{"_id":"public/2016/12/18/ES-6-ES-2015-常用知识点归纳/index.html","hash":"e154027adfba1c1320c60e4c757579a36193f25f","modified":1551495727913},{"_id":"public/2016/12/13/前端常见技术点-HTML/index.html","hash":"b8124dd7ded584c62b9421047b45b2c34d7fb571","modified":1551495727913},{"_id":"public/2016/12/13/前端常见技术点-JavaScript/index.html","hash":"66d6e52b6ce9141a8f8cd1d390a5c2ce6155f9fe","modified":1551495727913},{"_id":"public/2016/12/13/前端常见技术点-CSS-DOM-布局/index.html","hash":"90d26993ee4ddce1d0fcb1a394a8831d48f7fb38","modified":1551495727913},{"_id":"public/2016/12/09/前端关键技术点杂烩/index.html","hash":"8ccaf3af4c55e972271e608fdeba0d069eabcff1","modified":1551495727913},{"_id":"public/2016/09/18/算法基础-常用排序算法（上）/index.html","hash":"ec8ca976e17dd73387cdac82bfd38c38f862194e","modified":1551495727913},{"_id":"public/2016/07/27/HTML5-随记录/index.html","hash":"fdc2813b32c6bce3122a81266978109499afaa02","modified":1551495727913},{"_id":"public/2016/07/25/设计模式速谈：六、单例模式/index.html","hash":"d80c4630e34bccd76f8c1ac0fb2f76f588bf1a9d","modified":1551495727913},{"_id":"public/2016/07/23/设计模式速谈：五、建造者模式/index.html","hash":"02cef86aef03a6a68092c975e66771274c8716dc","modified":1551495727913},{"_id":"public/2016/07/21/设计模式速谈：四、抽象工厂模式/index.html","hash":"274eb9b5d80df67ffcc21dd997f6067af6167c1d","modified":1551495727913},{"_id":"public/2016/07/19/设计模式速谈：三、工厂模式/index.html","hash":"bd1de2c538a769241464c98febededa1a3bd781a","modified":1551495727913},{"_id":"public/2016/07/17/设计模式速谈：二、简单工厂模式/index.html","hash":"df17eeb7ff2a3691e03a939bfa68dab66957d1f3","modified":1551495727913},{"_id":"public/2016/07/14/Linux-后台运行任务/index.html","hash":"bfe87eb58e633d0ecf4c468167ec66dbbd62e841","modified":1551495727913},{"_id":"public/2016/06/16/LeetCode-每日一题-136-Single-Number/index.html","hash":"3e3f07695479ceebd076f92bbd53ae61700ba898","modified":1551495727913},{"_id":"public/2016/05/12/前端那些事儿-URL-对象/index.html","hash":"d8f06c0feaf4f60ada9c99dd18469e4f7f3b17bc","modified":1551495727913},{"_id":"public/2016/05/10/LeetCode-每日一题-7-Reverse-Integer/index.html","hash":"d4dfcba24936d87e9680e67df6a8c9095b71276c","modified":1551495727913},{"_id":"public/2016/05/08/LeetCode-每日一题-6-ZigZag-Conversion/index.html","hash":"06254d627c297be98448210ce79fc3940f2c9d04","modified":1551495727913},{"_id":"public/2016/04/21/LeetCode-每日一题-168-Excel-Sheet-Column-Title/index.html","hash":"c465e62341cde4494f7428e38c91214f4abaedc6","modified":1551495727914},{"_id":"public/2016/04/19/LeetCode-每日一题-189-Rotate-Array/index.html","hash":"2386ab2a36ab9fdd54a7782d78be554379cb2ddb","modified":1551495727914},{"_id":"public/2016/04/17/LeetCode-每日一题-121-Best-Time-to-Buy-and-Sell-Stock/index.html","hash":"b126ad527793ff03b9bf28b75383062ba313c76e","modified":1551495727914},{"_id":"public/2016/04/16/LeetCode-每日一题-169-Majority-Element/index.html","hash":"9f5cc6f120654f3c8e3feddb63769a9779d83877","modified":1551495727914},{"_id":"public/2016/04/14/LeetCode-每日一题-219-Contains-Duplicate-II/index.html","hash":"479419aaf44aebda9e034001e2d85b74e19e82cc","modified":1551495727914},{"_id":"public/2016/04/13/LeetCode-每日一题-217-Contains-Duplicate/index.html","hash":"d9c1f52ab842bc6e9772874e2859401cad4276b6","modified":1551495727914},{"_id":"public/2016/04/12/LeetCode-每日一题-283-Move-Zeroes/index.html","hash":"6145db04c41a2744b7b411c147f47662347ebecd","modified":1551495727914},{"_id":"public/2016/04/11/LeetCode-每日一题-1-Two-Sum/index.html","hash":"6bb51108cdf1e9ead55601702cb1c1c7e428d023","modified":1551495727914},{"_id":"public/2016/04/09/五分钟算法-二分法查找（Binary-Search）/index.html","hash":"e09ae0559ed409c91e959224fcec90e028fd7415","modified":1551495727914},{"_id":"public/2016/04/03/JavaScript-核心特性揭秘（三）/index.html","hash":"4781cdd73f6636c142074844c81f771b8babbb94","modified":1551495727914},{"_id":"public/2016/03/29/JavaScript-核心特性揭秘（二）/index.html","hash":"d67ed87e03ebf0f403fdf2b5de558b36a10ced78","modified":1551495727914},{"_id":"public/2016/03/26/JavaScript-核心特性揭秘（一）/index.html","hash":"dc7360c38ab7b5846019db0fc021c86b23654dd4","modified":1551495727914},{"_id":"public/2016/02/19/UCS-2-编码的妙用/index.html","hash":"912be6897ef91ee45ddcc100ead45588bdd23545","modified":1551495727914},{"_id":"public/2016/01/08/ECMAScript6-新特性-迭代器和-for-of-循环/index.html","hash":"76e342a9cc6a35c0a16b2645b04e72e13b7c8b4c","modified":1551495727914},{"_id":"public/2016/01/06/前端那些事儿-三字节-BOM-头/index.html","hash":"331e7f99100324d1418badbaf76f04fc6ed39a07","modified":1551495727914},{"_id":"public/2015/11/30/前端那些事儿-JavaScript-函数之-IIFE/index.html","hash":"cefc560a89c1d7a1d742bd8a6392724abfd8e4a1","modified":1551495727914},{"_id":"public/2015/07/25/GeekBank-C-线下班学习心得（二）/index.html","hash":"ce54275cbaeb08a8502baa2208406464b3c7ab1f","modified":1551495727914},{"_id":"public/2015/03/24/Git-你需要具备的基础知识/index.html","hash":"5afe848f1209f2713c0986e9f01a4041d2a51d95","modified":1551495727914},{"_id":"public/2014/12/23/数据结构-线性顺序表/index.html","hash":"af38b3580b999c23ec01526ac32db6cefd839800","modified":1551495727915},{"_id":"public/archives/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727915},{"_id":"public/archives/page/2/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727915},{"_id":"public/archives/page/3/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727915},{"_id":"public/archives/page/4/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727915},{"_id":"public/archives/page/5/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727915},{"_id":"public/archives/page/6/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727915},{"_id":"public/archives/page/7/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727915},{"_id":"public/archives/page/8/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727915},{"_id":"public/archives/page/9/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727915},{"_id":"public/archives/page/10/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727915},{"_id":"public/archives/page/11/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727915},{"_id":"public/archives/page/12/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727915},{"_id":"public/archives/page/13/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727915},{"_id":"public/archives/page/14/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727915},{"_id":"public/archives/2014/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727916},{"_id":"public/archives/2014/12/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727916},{"_id":"public/archives/2015/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727916},{"_id":"public/archives/2015/page/2/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727916},{"_id":"public/archives/2015/page/3/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727916},{"_id":"public/archives/2015/01/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727916},{"_id":"public/archives/2015/02/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727916},{"_id":"public/archives/2015/03/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727916},{"_id":"public/archives/2015/07/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727916},{"_id":"public/archives/2015/08/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727916},{"_id":"public/archives/2015/11/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727916},{"_id":"public/archives/2016/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727916},{"_id":"public/archives/2016/page/2/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727916},{"_id":"public/archives/2016/page/3/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727916},{"_id":"public/archives/2016/page/4/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727916},{"_id":"public/archives/2016/page/5/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727916},{"_id":"public/archives/2016/page/6/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727917},{"_id":"public/archives/2016/01/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727917},{"_id":"public/archives/2016/02/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727917},{"_id":"public/archives/2016/03/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727917},{"_id":"public/archives/2016/04/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727917},{"_id":"public/archives/2016/04/page/2/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727917},{"_id":"public/archives/2016/05/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727917},{"_id":"public/archives/2016/06/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727917},{"_id":"public/archives/2016/07/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727917},{"_id":"public/archives/2016/08/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727917},{"_id":"public/archives/2016/09/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727917},{"_id":"public/archives/2016/12/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727917},{"_id":"public/archives/2017/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727917},{"_id":"public/archives/2017/page/2/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727917},{"_id":"public/archives/2017/page/3/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727917},{"_id":"public/archives/2017/page/4/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727918},{"_id":"public/archives/2017/page/5/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727918},{"_id":"public/archives/2017/01/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727918},{"_id":"public/archives/2017/02/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727918},{"_id":"public/archives/2017/03/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727918},{"_id":"public/archives/2017/04/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727918},{"_id":"public/archives/2017/05/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727918},{"_id":"public/archives/2017/06/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727918},{"_id":"public/archives/2017/06/page/2/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727918},{"_id":"public/archives/2017/07/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727918},{"_id":"public/archives/2017/08/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727918},{"_id":"public/archives/2017/09/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727918},{"_id":"public/archives/2017/11/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727918},{"_id":"public/archives/2017/12/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727918},{"_id":"public/archives/2018/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727919},{"_id":"public/archives/2018/01/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727919},{"_id":"public/archives/2018/11/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727919},{"_id":"public/archives/2019/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727919},{"_id":"public/archives/2019/01/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727919},{"_id":"public/archives/2019/02/index.html","hash":"d947120d61d32ebf9d1c5237bdcc1b074e7f7662","modified":1551495727919},{"_id":"public/manifest.webmanifest","hash":"84eb1c4277746f2f3b1b08f5e5394210c28a1d85","modified":1551495727938},{"_id":"public/images/apple-touch-icon-120x120.png","hash":"2d2d1995d982b7f2cae143783540b261a5caebf4","modified":1551495727938},{"_id":"public/images/apple-touch-icon-144x144.png","hash":"75c8f71990592ec2ccafabeb8de2ee624d7d432f","modified":1551495727938},{"_id":"public/images/apple-touch-icon-60x60.png","hash":"5248ff1eb1b7ea65155ae506070ec3d151f1fce8","modified":1551495727938},{"_id":"public/LICENSE","hash":"37fd25acef1b10a40eb8861e091a0eec9a993147","modified":1551495727938},{"_id":"public/images/apple-touch-icon-114x114.png","hash":"c8276ecddc610ff3d19808d5268b27dfbd1e902c","modified":1551495727938},{"_id":"public/images/apple-touch-icon-57x57.png","hash":"3aad1f5ab167c2dfa02d476353dbb401f17ab587","modified":1551495727938},{"_id":"public/images/apple-touch-icon-152x152.png","hash":"34b78ba88cbe96d159cab6e531fe8c398edc37f8","modified":1551495727938},{"_id":"public/images/apple-touch-icon-72x72.png","hash":"8c17f59712942553d6d326a86340ffde18e00541","modified":1551495727938},{"_id":"public/images/apple-touch-icon-76x76.png","hash":"2ebc1226c5640e2285b48ea50af7d624325a2ed4","modified":1551495727939},{"_id":"public/images/favicon-128.png","hash":"5b2d400c7db321ce6b233de46fb696ba218bf64d","modified":1551495727939},{"_id":"public/images/favicon-16x16.png","hash":"5e956d1a4321b2b1b3cc388016f7e754a897ac69","modified":1551495727939},{"_id":"public/images/favicon-196x196.png","hash":"154b220eec554991d10b3da11a0eeb1267925a14","modified":1551495727939},{"_id":"public/images/favicon.ico","hash":"17a847b6be406e5308921368c8badb6c296a5be1","modified":1551495727939},{"_id":"public/images/favicon-32x32.png","hash":"4c24eae0da91c62670ee6b0f6fc8a7671fb3f899","modified":1551495727939},{"_id":"public/images/favicon-96x96.png","hash":"59dc1149fcc12139e59db2c357d82250be6e40f7","modified":1551495727939},{"_id":"public/images/logo.png","hash":"59dc1149fcc12139e59db2c357d82250be6e40f7","modified":1551495727939},{"_id":"public/images/mstile-144x144.png","hash":"75c8f71990592ec2ccafabeb8de2ee624d7d432f","modified":1551495727939},{"_id":"public/images/main.png","hash":"a6a103582037a5e0b43335370eb4f9a9ed8def83","modified":1551495727939},{"_id":"public/images/mstile-150x150.png","hash":"0b4ccb912109566fbb60a3444da37d0ad2e228cb","modified":1551495727939},{"_id":"public/images/mstile-310x150.png","hash":"c553816fb2ab63704ee8846af754d62abbd901ac","modified":1551495727939},{"_id":"public/images/mstile-70x70.png","hash":"5b2d400c7db321ce6b233de46fb696ba218bf64d","modified":1551495727939},{"_id":"public/fonts/fira/400.woff2","hash":"a8e246df0368fd8eef4806d9a1b36cf914beae15","modified":1551495727939},{"_id":"public/fonts/fira/500.woff2","hash":"86d5b01469d71971cb0aa0f6f6f7946c045ff628","modified":1551495727939},{"_id":"public/fonts/opensans/300.woff","hash":"8578430db19589546f1be89d121016713c801d30","modified":1551495727939},{"_id":"public/fonts/opensans/300.woff2","hash":"ad2af0f0a073835100e66ee93b50def2e57a28df","modified":1551495727939},{"_id":"public/fonts/opensans/300i.woff2","hash":"d45729f6376fe48d2b8a2c611b651a7f1502ae01","modified":1551495727939},{"_id":"public/fonts/opensans/400.woff","hash":"7dd17593d3947f4ea10be937634ef8f553443e5a","modified":1551495727939},{"_id":"public/fonts/opensans/400.woff2","hash":"9b18ae04f11fc74d27f281737b23b45a4bad5937","modified":1551495727939},{"_id":"public/fonts/opensans/400i.woff2","hash":"24cc685201e9dd17ba9fed66f61fa4626f83211b","modified":1551495727940},{"_id":"public/fonts/opensans/600.woff2","hash":"931f5105f0e909f90bdea2e246a1a230809a699a","modified":1551495727940},{"_id":"public/fonts/opensans/600i.woff2","hash":"e51180cddda569a91790c2dc4c352d06831bb07b","modified":1551495727940},{"_id":"public/fonts/opensans/700.woff","hash":"7956fd048338c3c6253aa58f65442441866d4b4e","modified":1551495727940},{"_id":"public/fonts/opensans/700.woff2","hash":"074d6e274d90a1b510d6eff3a5f8d26f567c1575","modified":1551495727940},{"_id":"public/fonts/opensans/700i.woff2","hash":"649af46dba2ec76c793426335e4026ca6c7a6109","modified":1551495727940},{"_id":"public/fonts/opensans/800.woff2","hash":"ee323b2accd80d6845d5cb1ba426bea25f087abe","modified":1551495727940},{"_id":"public/fonts/opensans/800i.woff2","hash":"649af46dba2ec76c793426335e4026ca6c7a6109","modified":1551495727940},{"_id":"public/fonts/code/CodeFont.woff","hash":"5d8c1b55ecdf181e0142ebc97413750e6681f62b","modified":1551495727940},{"_id":"public/fonts/code/CodeFont.otf","hash":"5aef87ad807a638501c3b74936aa34afdfeb66de","modified":1551495727940},{"_id":"public/fonts/fontawesome/fontawesome-webfont.woff","hash":"2ee7af028d66bfdc0e78bb8aec3962d9a48a11af","modified":1551495727940},{"_id":"public/2015/11/08/SVG-技术之-路径/1.png","hash":"a9fa8ee7d61b0b34472377e568d401eddf6abbd3","modified":1551495727940},{"_id":"public/2016/12/18/ES-6-ES-2015-常用知识点归纳/1.png","hash":"6ee3f072dbb90940644c141bc1bb8a604b449ae1","modified":1551495727940},{"_id":"public/2016/04/09/五分钟算法-二分法查找（Binary-Search）/1.jpg","hash":"6b3ab0b443b616a5fc84bcb6e1087944fc63b410","modified":1551495727940},{"_id":"public/2017/05/02/“大型网站技术架构”总结：三，网站的高可用架构/1.jpg","hash":"4787eff7cacad6f26fa6c11613aaaa57a83abe21","modified":1551495727941},{"_id":"public/2016/12/14/前端项目规划与团队管理/1.jpg","hash":"994622693651234985df9f06a87388c202082a50","modified":1551495727941},{"_id":"public/2016/07/19/设计模式速谈：三、工厂模式/1.png","hash":"4167b09c04f94e1852f0a292715ce35a131ecf64","modified":1551495727941},{"_id":"public/2017/08/22/Redis-源码之内存管理-zmalloc-zfree/2.jpg","hash":"6bda35ec5bd815834c0585de1330c9ae78c1ee82","modified":1551495727941},{"_id":"public/2017/08/22/Redis-源码之内存管理-zmalloc-zfree/1.jpg","hash":"20c2b80c593b025a5645630c21cdf0c30e0d8a97","modified":1551495727941},{"_id":"public/2017/06/09/WebAssembly-尝试研究报告（一）/1.png","hash":"12392ba9a6c68ffb7d0775feee314a18dc100f5c","modified":1551495727941},{"_id":"public/2015/03/12/利用-ab-命令进行简单压测/1.png","hash":"f6566250e1ed0bb8b2144b2812885056a476b84d","modified":1551495727941},{"_id":"public/2015/11/24/前端那些事儿-表单域的-MIME-编码/1.jpg","hash":"38e3685eb6aeec514969c1d9ed1c9e1490b33009","modified":1551495727941},{"_id":"public/2015/03/12/利用-ab-命令进行简单压测/2.png","hash":"65807ff1bc9294e79d842d9cda86fe43d676fd5a","modified":1551495727941},{"_id":"public/2016/07/17/设计模式速谈：二、简单工厂模式/1.png","hash":"555ff4469aff14fea22d211b125652294d69d83d","modified":1551495727941},{"_id":"public/2017/04/24/BigPipe-原理实现与使用场景分析/1.png","hash":"7389e88e2cd3aa589af48a2ef1712dd8767f4748","modified":1551495727941},{"_id":"public/2017/04/24/BigPipe-原理实现与使用场景分析/2.png","hash":"f2f9fe5a72474c01a42e9aec329ce2377592dbab","modified":1551495727941},{"_id":"public/2016/07/17/设计模式速谈：二、简单工厂模式/2.png","hash":"3d9d41b0186d198e870e21b258ea8dd16de64f8d","modified":1551495727941},{"_id":"public/2017/04/24/BigPipe-原理实现与使用场景分析/3.jpg","hash":"1d53c7964d06321ffbf5daee96fd1896fd051a76","modified":1551495727941},{"_id":"public/2015/02/18/JavaScript-浏览器自动化/1.jpg","hash":"08b9a923841da6e8b33d9e3357b761a2a5ed1985","modified":1551495727941},{"_id":"public/2017/11/04/Docker-最佳实践（一）/3.png","hash":"1d2e06fa2e981b994e75ce7f7d25428942b7d0b5","modified":1551495727941},{"_id":"public/2015/02/18/JavaScript-浏览器自动化/3.jpg","hash":"9011f04127ffe3106c819e0ba840967f9a1b6c9d","modified":1551495727941},{"_id":"public/2015/02/18/JavaScript-浏览器自动化/2.jpg","hash":"bdac51aeb0bbb42e1cf1a68a4f62aa4dcd55e728","modified":1551495727942},{"_id":"public/2017/06/16/WebAssembly-尝试研究报告-DIP-实践/3.png","hash":"da60ab0c7b50c7a6abe6f71c87e57dc4ea6d3b35","modified":1551495727942},{"_id":"public/2017/09/30/一种新的共享计算力模式/1.png","hash":"94f4bc8acd647dc16a9de7fe842203ce7c51f5c3","modified":1551495727942},{"_id":"public/2017/09/30/一种新的共享计算力模式/3.png","hash":"bd58a669dbea60c188c05126d8453a128e0bf899","modified":1551495727942},{"_id":"public/2017/05/08/前端-DCE-策略之-—-Tree-Shaking/1.jpg","hash":"72c76bf6068b77816e96351b3c3e49e538df6e78","modified":1551495727942},{"_id":"public/2017/05/08/前端-DCE-策略之-—-Tree-Shaking/2.jpg","hash":"3201250f41c9b37a29b57fdd3ab6bee6fe6210af","modified":1551495727942},{"_id":"public/2017/05/08/前端-DCE-策略之-—-Tree-Shaking/3.jpg","hash":"0fcd6538cd2ed029a7514fcd47b82e3cba419591","modified":1551495727942},{"_id":"public/2016/12/13/前端常见技术点-CSS-DOM-布局/1.jpg","hash":"d3181e844b81e23773c5b4b72766f5eb60fb495e","modified":1551495727942},{"_id":"public/2016/08/16/基于-AWS-探索-Shadowsocks/2.png","hash":"338ba9207b2561b0c2080775b6adca2979d75f0a","modified":1551495727942},{"_id":"public/2014/12/25/简单理解-HTTP-协议/1.png","hash":"4131aaa0a674457bfd0ab9c905326d90a11ca588","modified":1551495727942},{"_id":"public/2017/11/07/Docker-最佳实践（二）/1.png","hash":"ae2517c22e772195e040c83ff852f37a10e72f30","modified":1551495727942},{"_id":"public/2017/11/07/Docker-最佳实践（二）/2.png","hash":"a69303bfb4b7bf80721a3cc3e4009c8493668380","modified":1551495727942},{"_id":"public/2017/11/07/Docker-最佳实践（二）/3.png","hash":"604d43634bb18039bce5fd49315a3ef7a3aa09cb","modified":1551495727942},{"_id":"public/2017/11/07/Docker-最佳实践（二）/4.png","hash":"2beecedf96883d6bb4f35cb0a8cd338b699ac2b6","modified":1551495727942},{"_id":"public/2016/02/09/前端那些事儿-Console-对象/2.png","hash":"b8acec8f2c9a50e34384112afa54426c3ee9fffc","modified":1551495727942},{"_id":"public/2016/02/09/前端那些事儿-Console-对象/3.png","hash":"3ca539e77d8c8a069d6e7ea09350d95aff10b2a8","modified":1551495727942},{"_id":"public/2016/02/09/前端那些事儿-Console-对象/4.png","hash":"7424aec1f81ae912afce4988d20e357c2c8294e7","modified":1551495727942},{"_id":"public/2016/02/09/前端那些事儿-Console-对象/5.png","hash":"e2d3f7a63bc7dea473c1e4eb0f5214de352df1c2","modified":1551495727942},{"_id":"public/2016/12/13/前端常见技术点-JavaScript/3.jpg","hash":"10347693b99c3e3003d172d7f5c6891e3d5f7784","modified":1551495727942},{"_id":"public/2016/12/13/前端常见技术点-JavaScript/4.jpg","hash":"d0c834ff76efbafe93b68625f9fdfb1bf0619d60","modified":1551495727942},{"_id":"public/2017/06/20/WebAssembly-深入研究报告-二进制编码/1.png","hash":"cc5c2dc5093cb803144f67199ef0121c0f2b66ff","modified":1551495727942},{"_id":"public/2016/12/13/前端常见技术点-JavaScript/5.jpg","hash":"93fec99bb11555f13cf76f38a50a0fff808ca6f0","modified":1551495727943},{"_id":"public/2017/06/20/WebAssembly-深入研究报告-二进制编码/5.png","hash":"ed398271cad5d17b304870ab046ab117becea133","modified":1551495727943},{"_id":"public/2017/06/20/WebAssembly-深入研究报告-二进制编码/3.png","hash":"1d9c13ee0a14c4db3126af47dfc7c14b7ff18772","modified":1551495727943},{"_id":"public/2016/12/15/CSS-常用布局解决方案/1.jpg","hash":"7e355d1a73ea8b656cc8a3c69c7f3f1724b2e25b","modified":1551495727943},{"_id":"public/2016/12/15/CSS-常用布局解决方案/10.jpg","hash":"75c3e01a31848d776c10493628be3696fbe0834a","modified":1551495727943},{"_id":"public/2016/12/15/CSS-常用布局解决方案/13.jpg","hash":"80b43445428479a7d54cee13fca5011580dc988f","modified":1551495727943},{"_id":"public/2016/12/15/CSS-常用布局解决方案/12.jpg","hash":"75078db2f1d05aaf855411236a72cddaec48b699","modified":1551495727943},{"_id":"public/2016/12/15/CSS-常用布局解决方案/11.jpg","hash":"79f5a6b41f2d603e59f6cde7579662d5e833d334","modified":1551495727943},{"_id":"public/2016/12/15/CSS-常用布局解决方案/14.jpg","hash":"3bb7b6c55737c3a97664b95a2926954d025ef18f","modified":1551495727943},{"_id":"public/2016/12/15/CSS-常用布局解决方案/3.jpg","hash":"3abb353aa00c6e6638437ebfe1cb15dd5422241d","modified":1551495727943},{"_id":"public/2016/12/15/CSS-常用布局解决方案/15.jpg","hash":"d718a3a9d1a74f96d0d1e9383a7707a3e2f4ce13","modified":1551495727943},{"_id":"public/2016/12/15/CSS-常用布局解决方案/2.jpg","hash":"5d59f710cd570024cc0200db0efb1cf796daba13","modified":1551495727943},{"_id":"public/2016/12/15/CSS-常用布局解决方案/4.jpg","hash":"a5ff108167bb4b9938cf8341f836bb6f898b237e","modified":1551495727943},{"_id":"public/2016/12/15/CSS-常用布局解决方案/7.jpg","hash":"b393304d8f029a11262cd2c26060eff7961eae5a","modified":1551495727943},{"_id":"public/2016/12/15/CSS-常用布局解决方案/5.jpg","hash":"458de7945f935ecb7e9ae6613aee17535bab36d6","modified":1551495727943},{"_id":"public/2016/12/15/CSS-常用布局解决方案/8.jpg","hash":"71c3a43912ed752018be83b88ec2c7c7d9a6e29d","modified":1551495727943},{"_id":"public/2016/12/15/CSS-常用布局解决方案/9.jpg","hash":"91d8d07d3a8f3c5c7e15f74307feaef681634f83","modified":1551495727944},{"_id":"public/2016/07/23/设计模式速谈：五、建造者模式/1.png","hash":"534b49b1886a3ab758b967f3df691933e4c9b476","modified":1551495727944},{"_id":"public/2016/07/25/设计模式速谈：六、单例模式/1.png","hash":"2259e6ffa1c5a7fe35391c1b78b8a6dc9cf31ae3","modified":1551495727944},{"_id":"public/css/prism-okaidia.css","hash":"e6ba835f5a5b5506158830c5df7e8ff875ed12e4","modified":1551495727944},{"_id":"public/2016/07/21/设计模式速谈：四、抽象工厂模式/1.png","hash":"30b94a94a077aeaccfa116d6b65d99f5493a4f0d","modified":1551495727944},{"_id":"public/css/prism-line-numbers.css","hash":"e0db113a99e4a09d2161a539b1652d96e4a22fac","modified":1551495727944},{"_id":"public/images/mstile-310x310.png","hash":"3f9d9c684c50721ba9ef51fbd63b52e4f53eb841","modified":1551495728398},{"_id":"public/fonts/fira/400.woff","hash":"4ee1b0356eac96f44b48a5ecc36584c4c81e33bd","modified":1551495728598},{"_id":"public/fonts/fira/700.woff","hash":"4b2ef8d1724a48a42afc5e7ff8ee77a960ed6895","modified":1551495728598},{"_id":"public/fonts/fira/500.woff","hash":"5d4c15722ac01fb9c74662496967d6ebeda078d7","modified":1551495728600},{"_id":"public/fonts/opensans/300i.woff","hash":"dae3f536b867ea3d6cce0ef1406ab9b0813c16ea","modified":1551495728600},{"_id":"public/fonts/fira/700.woff2","hash":"798f8fe64d02e466b546e16cf82a6ce914e96db5","modified":1551495728600},{"_id":"public/fonts/opensans/400i.woff","hash":"9599e5da71b62e5227becb48e5498939e636e923","modified":1551495728600},{"_id":"public/fonts/opensans/600.woff","hash":"7c9f1210d31388fe5df9e368bd0e73a8f4091b28","modified":1551495728600},{"_id":"public/fonts/opensans/600i.woff","hash":"9406a2e087eb0d1790c2a7348b940f773ae6dda3","modified":1551495728600},{"_id":"public/fonts/opensans/700i.woff","hash":"87f22f6a8759ae4bc18d97469091d9b218210b45","modified":1551495728600},{"_id":"public/fonts/opensans/800.woff","hash":"31075459cd2010120a805d95506a9f8d7005b228","modified":1551495728600},{"_id":"public/fonts/opensans/800i.woff","hash":"87f22f6a8759ae4bc18d97469091d9b218210b45","modified":1551495728600},{"_id":"public/fonts/fontawesome/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1551495728601},{"_id":"public/fonts/code/CodeFont.ttf","hash":"4d3d8054231ec4e9bfc14a46ad4d60c575fbfeec","modified":1551495728601},{"_id":"public/2017/06/14/WebAssembly-尝试研究报告-API-之初始化、内存和表的分配/1.png","hash":"48883568869771a9a21a7c09fb462273e1d01e98","modified":1551495728601},{"_id":"public/2017/05/06/STC-与-PTC/1.jpg","hash":"dc4f8039551fcd8345e0ec52f7cd1e525fb43c9a","modified":1551495728601},{"_id":"public/2015/01/26/编码与“锟斤拷”的故事/1.jpg","hash":"ad364e45ee5606264c6e3ef9d760451bf273be38","modified":1551495728601},{"_id":"public/2017/06/09/WebAssembly-尝试研究报告（一）/2.png","hash":"7efa98b2069ca194210b68e33378592308ebdb7d","modified":1551495728601},{"_id":"public/2017/11/04/Docker-最佳实践（一）/2.png","hash":"b2082b10ce4285994f5cc204f9c62cd37ae6d088","modified":1551495728601},{"_id":"public/2017/09/30/一种新的共享计算力模式/2.png","hash":"65a7888d19f2c9385022fcdf8ae7dc82e88daa8c","modified":1551495728601},{"_id":"public/2016/02/09/前端那些事儿-Console-对象/1.png","hash":"8bfca6ae334b4da14c012eb12668bc456a920e13","modified":1551495728601},{"_id":"public/2016/12/13/前端常见技术点-JavaScript/1.jpg","hash":"a8409a4c7bb2fc892682b71bc3701b77487f0649","modified":1551495728601},{"_id":"public/2016/12/13/前端常见技术点-JavaScript/2.jpg","hash":"e88f892fcfa2b35d9e3640483865c17de7322c2f","modified":1551495728602},{"_id":"public/2017/06/20/WebAssembly-深入研究报告-二进制编码/2.png","hash":"6e6ed7d9dda1df84dfa0694488a1775a656fe62f","modified":1551495728602},{"_id":"public/2017/06/20/WebAssembly-深入研究报告-二进制编码/4.png","hash":"03138b750f55b9dcfc88840d3740dc655d9f9137","modified":1551495728602},{"_id":"public/2017/06/20/WebAssembly-深入研究报告-二进制编码/6.png","hash":"6c1157dd22b81c7efd95ad3e5daac041b123ec6a","modified":1551495728602},{"_id":"public/2016/12/15/CSS-常用布局解决方案/6.jpg","hash":"5516b460bc51487405ad701b96e4b6ecadddaf63","modified":1551495728602},{"_id":"public/2019/02/14/日本樱花季游攻略/10.jpg","hash":"b41d5d7c0120b6679a1e28c603f63dcf05050263","modified":1551495728602},{"_id":"public/2019/02/14/日本樱花季游攻略/13.jpg","hash":"b04ed06ce69e27d92e7835438bdb6e88b9d6cd2c","modified":1551495728602},{"_id":"public/2019/02/14/日本樱花季游攻略/12.jpg","hash":"b98be0936d55074454e741fc6e04d759d9891f38","modified":1551495728603},{"_id":"public/2019/02/14/日本樱花季游攻略/15.jpg","hash":"0fb0972b2c4a908116468a9fe1c588039615d74b","modified":1551495728603},{"_id":"public/2019/02/14/日本樱花季游攻略/17.jpg","hash":"78440a955918dad980eb7630dd1e0f38b2b586ba","modified":1551495728603},{"_id":"public/2019/02/14/日本樱花季游攻略/25.jpg","hash":"70a35f408b34148e4df722ae86f67f18fc43a9cb","modified":1551495728603},{"_id":"public/2019/02/14/日本樱花季游攻略/4.jpg","hash":"c042533938a137bdf44268ae11975745ac89b9f9","modified":1551495728603},{"_id":"public/2019/02/14/日本樱花季游攻略/7.jpg","hash":"0b4aee26fd16074f08c19fab11228d07750b03b4","modified":1551495728603},{"_id":"public/scripts/index.js","hash":"5cb8dc5761f6086493d508ebda0d2683381efd90","modified":1551495728617},{"_id":"public/styles/normalize.css","hash":"dba50edb5c2b2093889e80d9027e02cf33b35f33","modified":1551495728617},{"_id":"public/styles/fontawesome.min.css","hash":"1701c2a00799775f2ae58cf8fc3f6cdbb8a42b5a","modified":1551495728617},{"_id":"public/styles/screen.css","hash":"5eff8da06bf1d70494774c5a1d53f09131092196","modified":1551495728617},{"_id":"public/fonts/code/CodeFont.svg","hash":"a26a0d90ef1433b8b22e2aba972facf28b9c6c3d","modified":1551495728617},{"_id":"public/fonts/fontawesome/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1551495728617},{"_id":"public/2017/11/09/Docker-最佳实践（三）/1.png","hash":"65d7544378735f30b6435a91675bee11a2beac75","modified":1551495728618},{"_id":"public/fonts/fontawesome/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1551495728618},{"_id":"public/2017/11/04/Docker-最佳实践（一）/1.png","hash":"cd213cacdc6aff029f20eb86a56840ea8fb099dc","modified":1551495728618},{"_id":"public/2016/12/13/前端常见技术点-CSS-DOM-布局/2.png","hash":"9f556349d7fef3c88df47d690a0ba2f429f48481","modified":1551495728618},{"_id":"public/2016/12/13/前端常见技术点-CSS-DOM-布局/3.jpg","hash":"4e980e3b6e394cd3430cea81516f1d6fb52282f3","modified":1551495728618},{"_id":"public/2016/08/16/基于-AWS-探索-Shadowsocks/3.png","hash":"a3aa9532651ae94474c18fea435ad4ced17c7cbf","modified":1551495728618},{"_id":"public/2014/12/25/简单理解-HTTP-协议/0.png","hash":"c792d84c7cfb9ec313a812069cb067e87babb2bc","modified":1551495728618},{"_id":"public/2014/12/25/简单理解-HTTP-协议/2.png","hash":"4e7e22b1461cc91106fd0db61371b06e4c79fc81","modified":1551495728618},{"_id":"public/2019/02/14/日本樱花季游攻略/23.jpg","hash":"4efc16aa45b078f48364c032932a77a46ca0a8ed","modified":1551495728618},{"_id":"public/2019/02/14/日本樱花季游攻略/19.jpg","hash":"11afa258c871bd3b086fde7eaed197b1c177ab17","modified":1551495728618},{"_id":"public/2019/02/14/日本樱花季游攻略/28.jpg","hash":"5a422958f329b61580bfc2e19d08624228d42c32","modified":1551495728619},{"_id":"public/2019/02/14/日本樱花季游攻略/5.jpg","hash":"8b86b39a05d7c35d333780ab1503a73924398589","modified":1551495728619},{"_id":"public/2017/09/07/V8-内存优化之-Ignition-解释器/4.png","hash":"b78a463b9308ed6b6589973905c4fea95995f938","modified":1551495728640},{"_id":"public/2017/12/17/Web-新时代与挑战/1.png","hash":"41ab2aaa04e1802ec5c69bee8d23f4ba724ced1d","modified":1551495728640},{"_id":"public/2015/11/24/前端那些事儿-表单域的-MIME-编码/2.jpg","hash":"273647ee2a5044c871d873f9500c4306cd0e9230","modified":1551495728640},{"_id":"public/2019/02/14/日本樱花季游攻略/11.jpg","hash":"72ab9b6261c70b89d118e1ad32fd46419c2f6042","modified":1551495728640},{"_id":"public/2019/02/14/日本樱花季游攻略/18.jpg","hash":"8d8de16c785f32861b3f926b3e452d911c7a0e3a","modified":1551495728641},{"_id":"public/2019/02/14/日本樱花季游攻略/22.jpg","hash":"559605547640208bafe991a55f0527f53ae41da5","modified":1551495728641},{"_id":"public/2019/02/14/日本樱花季游攻略/26.jpg","hash":"1f65f71e57747a528f01957deb0fc0ce7a84da4f","modified":1551495728641},{"_id":"public/2019/02/14/日本樱花季游攻略/8.jpg","hash":"158b62f0d668c3f1cc57b3826c1ac09424f97227","modified":1551495728641},{"_id":"public/2019/02/14/日本樱花季游攻略/3.jpg","hash":"f405c881472ae6e70354f849e225246651ab90b6","modified":1551495728642},{"_id":"public/2018/01/08/Flush-Reload-Attack-与-Meltdown/3.png","hash":"8517d64c18dcc0afd43f8f7a2e8abe7841064ded","modified":1551495728655},{"_id":"public/2018/01/08/Flush-Reload-Attack-与-Meltdown/2.png","hash":"85dc702cafb4e894e4e7dbd99a7d33e4449014ab","modified":1551495728655},{"_id":"public/2018/01/08/Flush-Reload-Attack-与-Meltdown/1.png","hash":"3b8077b988cc7fdf90bad96ca5c961570f953afb","modified":1551495728655},{"_id":"public/2017/05/18/PureRenderMixin-immutable-js-提高-VDOM-渲染效率/1.gif","hash":"93c37a476770bf80f4debd367237f8ef0280643c","modified":1551495728655},{"_id":"public/2019/02/14/日本樱花季游攻略/2.jpg","hash":"a0515212908c4dc59d26f1d586494b238523ddc5","modified":1551495728655},{"_id":"public/2017/07/06/使用-Noteflight-来快速作曲和-MusicXML-导出/1.png","hash":"d398e1cc2077aa518932424eea4b1b603c22ef28","modified":1551495728656},{"_id":"public/2019/02/14/日本樱花季游攻略/21.jpg","hash":"3362a2fec548d1c398d39faa907af9848720f60c","modified":1551495728656},{"_id":"public/2019/02/14/日本樱花季游攻略/9.gif","hash":"c8a965409ce86fe53fdc01742a0b5e332132de96","modified":1551495728656},{"_id":"public/2017/07/06/使用-Noteflight-来快速作曲和-MusicXML-导出/2.png","hash":"9ded8ab0f352686672836fe49ed4d3829e82b51a","modified":1551495728657},{"_id":"public/2017/06/16/WebAssembly-尝试研究报告-DIP-实践/2.png","hash":"9e677c6d498375e4ee3915bf7e51e712eafeb019","modified":1551495728661},{"_id":"public/2017/09/07/V8-内存优化之-Ignition-解释器/3.png","hash":"bcc8f76147083d4045c6fe466762814f49ec4c74","modified":1551495728662},{"_id":"public/2019/02/14/日本樱花季游攻略/1.jpg","hash":"501d8cf600f6d0f9320b8b66e296558ddf54b318","modified":1551495728662},{"_id":"public/2019/02/14/日本樱花季游攻略/6.jpg","hash":"617761e4b81265941d7a8e7edda92967d5044ba2","modified":1551495728662},{"_id":"public/fonts/fontawesome/fontawesome-webfont.svg","hash":"dcad0dd62ca23d8cfafa8c06cf54699bfce4fbf5","modified":1551495728676},{"_id":"public/2017/06/16/WebAssembly-尝试研究报告-DIP-实践/1.png","hash":"b512261726b5702ebc0e3fe49d36b8f5b7aecfb9","modified":1551495728676},{"_id":"public/2016/08/16/基于-AWS-探索-Shadowsocks/1.png","hash":"aabf6abb8559e47f37af798ef620a32e71a7a408","modified":1551495728677},{"_id":"public/2017/09/07/V8-内存优化之-Ignition-解释器/2.png","hash":"9482828a1f35f6ddb05b6e6d93dfd917758f61b9","modified":1551495728721},{"_id":"public/2019/02/14/日本樱花季游攻略/16.jpg","hash":"6ab543555dfd21e60d6bbe01c6ac7ef5b3ab3956","modified":1551495728721},{"_id":"public/2017/12/17/Web-新时代与挑战/2.png","hash":"759f3f0866fd01b7b7db8b17d499509e23d3940a","modified":1551495728733},{"_id":"public/2017/04/29/“大型网站技术架构”总结：一，概述/1.jpg","hash":"79b7c27f2cb1fd042bc44172b168f27202d6cd02","modified":1551495728733},{"_id":"public/2017/09/07/V8-内存优化之-Ignition-解释器/1.png","hash":"495ea88fe031d0da5128756c6134d539f11a9072","modified":1551495728733},{"_id":"public/2019/02/14/日本樱花季游攻略/24.jpg","hash":"7f7ffeb1a18db1bb9f1fc24dca16d8c53800e9a7","modified":1551495728733},{"_id":"public/2019/02/14/日本樱花季游攻略/20.jpg","hash":"4592d94cd4ec8386a7d7b83a1f33e24c59b1ff93","modified":1551495728753},{"_id":"public/images/avatar.jpeg","hash":"0f703e2b763e5848a5c6ba81a7fe350bce1f590e","modified":1551495728755},{"_id":"public/2017/06/11/WebAssembly-尝试研究报告（三）/3.png","hash":"51bb9171c74a1f92d388d67dc97daf65d8651fac","modified":1551495728772},{"_id":"public/2017/06/11/WebAssembly-尝试研究报告（三）/2.png","hash":"6326e4068b61302d340126c24564ba343c5f2396","modified":1551495728774},{"_id":"public/2019/02/14/日本樱花季游攻略/27.png","hash":"972a0f1d300569603c48cb84abd8295ee1417bf7","modified":1551495728839},{"_id":"public/2019/02/14/日本樱花季游攻略/31.png","hash":"9910c5cb986bfc1f9905952f4d3dd824ffe927cd","modified":1551495728841},{"_id":"public/2019/02/14/日本樱花季游攻略/30.png","hash":"e51cc8363b8911269c05f9240e8634c99af005ab","modified":1551495728843},{"_id":"public/2019/02/14/日本樱花季游攻略/29.png","hash":"b65bd234d8245cf4682b2971122ed51b183faf79","modified":1551495728844},{"_id":"public/2017/06/11/WebAssembly-尝试研究报告（三）/1.png","hash":"0b564c9f67616bd83f86bfc6b38f65e692c11b3c","modified":1551495728846}],"Category":[],"Data":[],"Page":[{"title":"tags","date":"2019-02-01T08:07:01.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2019-02-01 16:07:01\ntype: tags\n---\n","updated":"2019-02-01T08:12:27.933Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjsqwht700000knp22i0j2nsm","content":"","site":{"data":{}},"id":"d57ac45256849d9b13e2422d91580fb9","excerpt":"","more":""},{"title":"articles","date":"2019-02-01T05:34:25.000Z","_content":"","source":"articles/index.md","raw":"---\ntitle: articles\ndate: 2019-02-01 13:34:25\n---\n","updated":"2019-02-01T05:34:25.261Z","path":"articles/index.html","comments":1,"layout":"page","_id":"cjsqwht740002knp26e05ik9h","content":"","site":{"data":{}},"id":"dba5d91846ce1a5e63734dfcbcb481cb","excerpt":"","more":""},{"title":"author","date":"2019-02-01T05:35:55.000Z","_content":"","source":"author/index.md","raw":"---\ntitle: author\ndate: 2019-02-01 13:35:55\n---\n","updated":"2019-02-01T05:35:55.693Z","path":"author/index.html","comments":1,"layout":"page","_id":"cjsqwht780005knp29ec5hvgv","content":"","site":{"data":{}},"id":"02bd92faa38aaa6cc0ea75e59937a1ef","excerpt":"","more":""},{"title":"works","date":"2019-02-02T01:53:48.000Z","_content":"","source":"works/index.md","raw":"---\ntitle: works\ndate: 2019-02-02 09:53:48\n---\n","updated":"2019-02-02T01:53:48.512Z","path":"works/index.html","comments":1,"layout":"page","_id":"cjsqwhth400c6knp217i2dzy0","content":"","site":{"data":{}},"id":"038703c7230ae012e3c783ace1d09d64","excerpt":"","more":""}],"Post":[{"title":"2017 开篇","intro":"一转眼，本命年到了。不知不觉从记忆中的十七八岁长到了现在的二十四岁，一切仿佛只发生在一瞬间。自从学校毕业到步入社会，时间的每一秒都过得很快，仿佛自己在数着月份过日子。这个博客从建立之初写的第一行代码开始，到现在发布了将近100篇博文，时间已经过去整整两年了。","comments":1,"date":"2017-01-16T06:17:58.000Z","_content":"\n一转眼，本命年到了。不知不觉从记忆中的十七八岁长到了现在的二十四岁，一切仿佛只发生在一瞬间。自从学校毕业到步入社会，时间的每一秒都过得很快，仿佛自己在数着月份过日子。这个博客从建立之初写的第一行代码开始，到现在发布了将近100篇博文，时间已经过去整整两年了。\n\n当然已经发布的这100篇博文肯定不会篇篇都是精品，甚至可能没有精品。但收获的是分享知识的喜悦，是写作水平的逐渐提高。过去两年网站的流量很少，几乎没有人光顾，接下来的一年会提高产出质量，并且增加网站外链和好友链接的数量。总结的来看，从2015年7月毕业，到现在2017年新的一年。在技术成长这条路上有很多值得我去深思的事情，大体分为以下两点：\n\n**1. 知识维度：**在过去的两年里，由于职位原因，在工作上一直都是 Web 前端和后端一起干，所以对 B/S 架构的交互有了更深刻的理解。但前端后端哪个拿出来深入钻研一下都有很大体量的知识。所以从2017年开始，每一个半年的时间里我会只着重深入去研究两个方面的知识点，比如今年上半年的“**算法**”和“**前端框架源码**”。研究源码对于自身水平的提高有着很大的帮助，不论是一个语法点还是一个整体系统的架构，都能学到很多的知识。但为什么要研究算法呢？可能大多数人都认为在实际的工作项目中很少或者几乎用不到自己去写特定算法的逻辑程序，如果需要用也是直接“拿来主义”，Github 上能搜出一堆别人已经写好的库，直接下载即可使用。我不希望工程师们只会学习“表面上的知识”，比如这个框架是怎么用的，那个框架是怎么用的，最后学了一大堆框架的用法，但如果深入进去问你框架某个组件是用什么数据结构来优化执行的，你可能会很懵逼。框架的诞生只会意味着学习和使用的过程越来越简单、易用性越来越强，会的框架多并不代表你学习能力强或者基础知识很扎实。如果你想要为自己的职业负责，我希望你能用一年的时间来学习下算法和数据结构，把算法与实际问题结合起来你会发现其实还是很有意思的。\n\n**2. 细心：**这个方面算是个人处事方面的一个缺点，也是急需在2017年加以改进的。细心不只是体现在学习态度上，同样也体现在团队管理与处理问题的决策方法上。所谓的细心其实就是让自己能够静下心来去接受去学习，抛开浮躁的想法。具体的做法因人而异。对我来说，可能先坚持的完整的看完一本书并记录一本工整的笔记是改掉不细心这个问题的第一步。\n\n","source":"_posts/2017-开篇.md","raw":"---\ntitle: 2017 开篇\nintro: 一转眼，本命年到了。不知不觉从记忆中的十七八岁长到了现在的二十四岁，一切仿佛只发生在一瞬间。自从学校毕业到步入社会，时间的每一秒都过得很快，仿佛自己在数着月份过日子。这个博客从建立之初写的第一行代码开始，到现在发布了将近100篇博文，时间已经过去整整两年了。\ncomments: true\ndate: 2017-01-16 14:17:58\ntags:\n- 日记\n---\n\n一转眼，本命年到了。不知不觉从记忆中的十七八岁长到了现在的二十四岁，一切仿佛只发生在一瞬间。自从学校毕业到步入社会，时间的每一秒都过得很快，仿佛自己在数着月份过日子。这个博客从建立之初写的第一行代码开始，到现在发布了将近100篇博文，时间已经过去整整两年了。\n\n当然已经发布的这100篇博文肯定不会篇篇都是精品，甚至可能没有精品。但收获的是分享知识的喜悦，是写作水平的逐渐提高。过去两年网站的流量很少，几乎没有人光顾，接下来的一年会提高产出质量，并且增加网站外链和好友链接的数量。总结的来看，从2015年7月毕业，到现在2017年新的一年。在技术成长这条路上有很多值得我去深思的事情，大体分为以下两点：\n\n**1. 知识维度：**在过去的两年里，由于职位原因，在工作上一直都是 Web 前端和后端一起干，所以对 B/S 架构的交互有了更深刻的理解。但前端后端哪个拿出来深入钻研一下都有很大体量的知识。所以从2017年开始，每一个半年的时间里我会只着重深入去研究两个方面的知识点，比如今年上半年的“**算法**”和“**前端框架源码**”。研究源码对于自身水平的提高有着很大的帮助，不论是一个语法点还是一个整体系统的架构，都能学到很多的知识。但为什么要研究算法呢？可能大多数人都认为在实际的工作项目中很少或者几乎用不到自己去写特定算法的逻辑程序，如果需要用也是直接“拿来主义”，Github 上能搜出一堆别人已经写好的库，直接下载即可使用。我不希望工程师们只会学习“表面上的知识”，比如这个框架是怎么用的，那个框架是怎么用的，最后学了一大堆框架的用法，但如果深入进去问你框架某个组件是用什么数据结构来优化执行的，你可能会很懵逼。框架的诞生只会意味着学习和使用的过程越来越简单、易用性越来越强，会的框架多并不代表你学习能力强或者基础知识很扎实。如果你想要为自己的职业负责，我希望你能用一年的时间来学习下算法和数据结构，把算法与实际问题结合起来你会发现其实还是很有意思的。\n\n**2. 细心：**这个方面算是个人处事方面的一个缺点，也是急需在2017年加以改进的。细心不只是体现在学习态度上，同样也体现在团队管理与处理问题的决策方法上。所谓的细心其实就是让自己能够静下心来去接受去学习，抛开浮躁的想法。具体的做法因人而异。对我来说，可能先坚持的完整的看完一本书并记录一本工整的笔记是改掉不细心这个问题的第一步。\n\n","slug":"2017-开篇","published":1,"updated":"2019-02-12T05:33:59.018Z","layout":"post","photos":[],"link":"","_id":"cjsqwht710001knp2a28wu9d8","content":"<p>一转眼，本命年到了。不知不觉从记忆中的十七八岁长到了现在的二十四岁，一切仿佛只发生在一瞬间。自从学校毕业到步入社会，时间的每一秒都过得很快，仿佛自己在数着月份过日子。这个博客从建立之初写的第一行代码开始，到现在发布了将近100篇博文，时间已经过去整整两年了。</p>\n<p>当然已经发布的这100篇博文肯定不会篇篇都是精品，甚至可能没有精品。但收获的是分享知识的喜悦，是写作水平的逐渐提高。过去两年网站的流量很少，几乎没有人光顾，接下来的一年会提高产出质量，并且增加网站外链和好友链接的数量。总结的来看，从2015年7月毕业，到现在2017年新的一年。在技术成长这条路上有很多值得我去深思的事情，大体分为以下两点：</p>\n<p><strong>1. 知识维度：</strong>在过去的两年里，由于职位原因，在工作上一直都是 Web 前端和后端一起干，所以对 B/S 架构的交互有了更深刻的理解。但前端后端哪个拿出来深入钻研一下都有很大体量的知识。所以从2017年开始，每一个半年的时间里我会只着重深入去研究两个方面的知识点，比如今年上半年的“<strong>算法</strong>”和“<strong>前端框架源码</strong>”。研究源码对于自身水平的提高有着很大的帮助，不论是一个语法点还是一个整体系统的架构，都能学到很多的知识。但为什么要研究算法呢？可能大多数人都认为在实际的工作项目中很少或者几乎用不到自己去写特定算法的逻辑程序，如果需要用也是直接“拿来主义”，Github 上能搜出一堆别人已经写好的库，直接下载即可使用。我不希望工程师们只会学习“表面上的知识”，比如这个框架是怎么用的，那个框架是怎么用的，最后学了一大堆框架的用法，但如果深入进去问你框架某个组件是用什么数据结构来优化执行的，你可能会很懵逼。框架的诞生只会意味着学习和使用的过程越来越简单、易用性越来越强，会的框架多并不代表你学习能力强或者基础知识很扎实。如果你想要为自己的职业负责，我希望你能用一年的时间来学习下算法和数据结构，把算法与实际问题结合起来你会发现其实还是很有意思的。</p>\n<p><strong>2. 细心：</strong>这个方面算是个人处事方面的一个缺点，也是急需在2017年加以改进的。细心不只是体现在学习态度上，同样也体现在团队管理与处理问题的决策方法上。所谓的细心其实就是让自己能够静下心来去接受去学习，抛开浮躁的想法。具体的做法因人而异。对我来说，可能先坚持的完整的看完一本书并记录一本工整的笔记是改掉不细心这个问题的第一步。</p>\n","site":{"data":{}},"id":"a6abd26ef992bbde091f032b96186d8d","excerpt":"","more":"<p>一转眼，本命年到了。不知不觉从记忆中的十七八岁长到了现在的二十四岁，一切仿佛只发生在一瞬间。自从学校毕业到步入社会，时间的每一秒都过得很快，仿佛自己在数着月份过日子。这个博客从建立之初写的第一行代码开始，到现在发布了将近100篇博文，时间已经过去整整两年了。</p>\n<p>当然已经发布的这100篇博文肯定不会篇篇都是精品，甚至可能没有精品。但收获的是分享知识的喜悦，是写作水平的逐渐提高。过去两年网站的流量很少，几乎没有人光顾，接下来的一年会提高产出质量，并且增加网站外链和好友链接的数量。总结的来看，从2015年7月毕业，到现在2017年新的一年。在技术成长这条路上有很多值得我去深思的事情，大体分为以下两点：</p>\n<p><strong>1. 知识维度：</strong>在过去的两年里，由于职位原因，在工作上一直都是 Web 前端和后端一起干，所以对 B/S 架构的交互有了更深刻的理解。但前端后端哪个拿出来深入钻研一下都有很大体量的知识。所以从2017年开始，每一个半年的时间里我会只着重深入去研究两个方面的知识点，比如今年上半年的“<strong>算法</strong>”和“<strong>前端框架源码</strong>”。研究源码对于自身水平的提高有着很大的帮助，不论是一个语法点还是一个整体系统的架构，都能学到很多的知识。但为什么要研究算法呢？可能大多数人都认为在实际的工作项目中很少或者几乎用不到自己去写特定算法的逻辑程序，如果需要用也是直接“拿来主义”，Github 上能搜出一堆别人已经写好的库，直接下载即可使用。我不希望工程师们只会学习“表面上的知识”，比如这个框架是怎么用的，那个框架是怎么用的，最后学了一大堆框架的用法，但如果深入进去问你框架某个组件是用什么数据结构来优化执行的，你可能会很懵逼。框架的诞生只会意味着学习和使用的过程越来越简单、易用性越来越强，会的框架多并不代表你学习能力强或者基础知识很扎实。如果你想要为自己的职业负责，我希望你能用一年的时间来学习下算法和数据结构，把算法与实际问题结合起来你会发现其实还是很有意思的。</p>\n<p><strong>2. 细心：</strong>这个方面算是个人处事方面的一个缺点，也是急需在2017年加以改进的。细心不只是体现在学习态度上，同样也体现在团队管理与处理问题的决策方法上。所谓的细心其实就是让自己能够静下心来去接受去学习，抛开浮躁的想法。具体的做法因人而异。对我来说，可能先坚持的完整的看完一本书并记录一本工整的笔记是改掉不细心这个问题的第一步。</p>\n"},{"title":"Android 以 Post 方式发送 HTTP 请求","intro":"网络通信日益发展的今天，出现了多种用于网络通信的标准，虽然 HTTP 协议的发送没有 TCP/IP 那样可靠，并且 HTTP 协议也无法保持状态，每一次数据发送都无法获知此次发送与前一次发送之间的关系。但是在 C/S 模式中还是有他自己的优势的。无连接，无状态，但是却很灵活。那么，移动端如果想要与服务器进行交互，就可以选择 HTTP 协议。","comments":1,"date":"2014-12-24T15:23:06.000Z","_content":"\n网络通信日益发展的今天，出现了多种用于网络通信的标准，虽然 HTTP 协议的发送没有 TCP/IP 那样可靠，并且 HTTP 协议也无法保持状态，每一次数据发送都无法获知此次发送与前一次发送之间的关系。但是在 C/S 模式中还是有他自己的优势的。无连接，无状态，但是却很灵活。那么，移动端如果想要与服务器进行交互，就可以选择 HTTP 协议。\n\n在安卓开发中，想要以 Post 方式发送 HTTP 请求非常简单，首先生成一个 `HttpPost` 对象，构造函数中传入发送 HTTP 请求的服务器地址。\n\n```java\n// point to a server-side endpoint;\nString url = \\\"http://www.xxx.com/server.php\\\";  \nHttpPost httpRequest = new HttpPost(url);  \n```\n\n接下来通过一个 `ArrayList` 向 `HttpPost` 对象传入参数，这些参数可以在服务器端通过 POST 数组的方式取出来。\n\n```java\nList<NameValuePair> params = new ArrayList<NameValuePair>();  \nparams.add(new BasicNameValuePair(\\\"param0\\\", \\\"content0\\\"));  \nparams.add(new BasicNameValuePair(\\\"param1\\\", \\\"content1\\\"));  \nparams.add(new BasicNameValuePair(\\\"param1\\\", \\\"content2\\\"));  \n```\n\n然后在“try...catch”块中生成 httpEntity 实体，并设置数据的编码方式，然后将实体赋给 `HttpPost` 对象。这样就构造好了一个完整的 HTTP 请求实体。\n\n```java\nHttpEntity httpEntity = new UrlEncodedFormEntity(params, \\\"utf-8\\\");  \nhttpRequest.setEntity(httpEntity);  \n```\n\n接下来生成一个 HTTP 客户端，通过客户端的 `execute` 方法即可发送一个 HTTP 实体请求。\n\n```java\nHttpClient httpClient = new DefaultHttpClient();  \nHttpResponse httpResponse = httpClient.execute(httpRequest);  \n```\n\n`HttpResponse` 对象是请求之后的响应对象，它描述着发送的状态等一系列响应信息，我们可以在发送成功后作出响应。\n\n```java\nif (httpResponse.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {  \n    String result = EntityUtils.toString(httpResponse.getEntity());  \n    tv.setText(result);  \n    Log.i(TAG, \\\"result = \\\" + result);  \n} else {  \n    tv.setText(\\\"request error!\\\");  \n} \n```","source":"_posts/Android-以-Post-方式发送-Http-请求.md","raw":"---\ntitle: Android 以 Post 方式发送 HTTP 请求\nintro: 网络通信日益发展的今天，出现了多种用于网络通信的标准，虽然 HTTP 协议的发送没有 TCP/IP 那样可靠，并且 HTTP 协议也无法保持状态，每一次数据发送都无法获知此次发送与前一次发送之间的关系。但是在 C/S 模式中还是有他自己的优势的。无连接，无状态，但是却很灵活。那么，移动端如果想要与服务器进行交互，就可以选择 HTTP 协议。\ncomments: true\ndate: 2014-12-24 23:23:06\ntags:\n- Android\n---\n\n网络通信日益发展的今天，出现了多种用于网络通信的标准，虽然 HTTP 协议的发送没有 TCP/IP 那样可靠，并且 HTTP 协议也无法保持状态，每一次数据发送都无法获知此次发送与前一次发送之间的关系。但是在 C/S 模式中还是有他自己的优势的。无连接，无状态，但是却很灵活。那么，移动端如果想要与服务器进行交互，就可以选择 HTTP 协议。\n\n在安卓开发中，想要以 Post 方式发送 HTTP 请求非常简单，首先生成一个 `HttpPost` 对象，构造函数中传入发送 HTTP 请求的服务器地址。\n\n```java\n// point to a server-side endpoint;\nString url = \\\"http://www.xxx.com/server.php\\\";  \nHttpPost httpRequest = new HttpPost(url);  \n```\n\n接下来通过一个 `ArrayList` 向 `HttpPost` 对象传入参数，这些参数可以在服务器端通过 POST 数组的方式取出来。\n\n```java\nList<NameValuePair> params = new ArrayList<NameValuePair>();  \nparams.add(new BasicNameValuePair(\\\"param0\\\", \\\"content0\\\"));  \nparams.add(new BasicNameValuePair(\\\"param1\\\", \\\"content1\\\"));  \nparams.add(new BasicNameValuePair(\\\"param1\\\", \\\"content2\\\"));  \n```\n\n然后在“try...catch”块中生成 httpEntity 实体，并设置数据的编码方式，然后将实体赋给 `HttpPost` 对象。这样就构造好了一个完整的 HTTP 请求实体。\n\n```java\nHttpEntity httpEntity = new UrlEncodedFormEntity(params, \\\"utf-8\\\");  \nhttpRequest.setEntity(httpEntity);  \n```\n\n接下来生成一个 HTTP 客户端，通过客户端的 `execute` 方法即可发送一个 HTTP 实体请求。\n\n```java\nHttpClient httpClient = new DefaultHttpClient();  \nHttpResponse httpResponse = httpClient.execute(httpRequest);  \n```\n\n`HttpResponse` 对象是请求之后的响应对象，它描述着发送的状态等一系列响应信息，我们可以在发送成功后作出响应。\n\n```java\nif (httpResponse.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {  \n    String result = EntityUtils.toString(httpResponse.getEntity());  \n    tv.setText(result);  \n    Log.i(TAG, \\\"result = \\\" + result);  \n} else {  \n    tv.setText(\\\"request error!\\\");  \n} \n```","slug":"Android-以-Post-方式发送-Http-请求","published":1,"updated":"2019-02-03T14:58:50.940Z","layout":"post","photos":[],"link":"","_id":"cjsqwht750003knp2eone6n5q","content":"<p>网络通信日益发展的今天，出现了多种用于网络通信的标准，虽然 HTTP 协议的发送没有 TCP/IP 那样可靠，并且 HTTP 协议也无法保持状态，每一次数据发送都无法获知此次发送与前一次发送之间的关系。但是在 C/S 模式中还是有他自己的优势的。无连接，无状态，但是却很灵活。那么，移动端如果想要与服务器进行交互，就可以选择 HTTP 协议。</p>\n<p>在安卓开发中，想要以 Post 方式发送 HTTP 请求非常简单，首先生成一个 <code>HttpPost</code> 对象，构造函数中传入发送 HTTP 请求的服务器地址。</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// point to a server-side endpoint;</span>\nString url <span class=\"token operator\">=</span> \\\"http<span class=\"token operator\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span>www<span class=\"token punctuation\">.</span>xxx<span class=\"token punctuation\">.</span>com<span class=\"token operator\">/</span>server<span class=\"token punctuation\">.</span>php\\\"<span class=\"token punctuation\">;</span>  \nHttpPost httpRequest <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HttpPost</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>接下来通过一个 <code>ArrayList</code> 向 <code>HttpPost</code> 对象传入参数，这些参数可以在服务器端通过 POST 数组的方式取出来。</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\">List<span class=\"token operator\">&lt;</span>NameValuePair<span class=\"token operator\">></span> params <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token operator\">&lt;</span>NameValuePair<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \nparams<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">BasicNameValuePair</span><span class=\"token punctuation\">(</span>\\\"param0\\\"<span class=\"token punctuation\">,</span> \\\"content0\\\"<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \nparams<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">BasicNameValuePair</span><span class=\"token punctuation\">(</span>\\\"param1\\\"<span class=\"token punctuation\">,</span> \\\"content1\\\"<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \nparams<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">BasicNameValuePair</span><span class=\"token punctuation\">(</span>\\\"param1\\\"<span class=\"token punctuation\">,</span> \\\"content2\\\"<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>然后在“try…catch”块中生成 httpEntity 实体，并设置数据的编码方式，然后将实体赋给 <code>HttpPost</code> 对象。这样就构造好了一个完整的 HTTP 请求实体。</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\">HttpEntity httpEntity <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">UrlEncodedFormEntity</span><span class=\"token punctuation\">(</span>params<span class=\"token punctuation\">,</span> \\\"utf<span class=\"token operator\">-</span><span class=\"token number\">8</span>\\\"<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \nhttpRequest<span class=\"token punctuation\">.</span><span class=\"token function\">setEntity</span><span class=\"token punctuation\">(</span>httpEntity<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>接下来生成一个 HTTP 客户端，通过客户端的 <code>execute</code> 方法即可发送一个 HTTP 实体请求。</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\">HttpClient httpClient <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">DefaultHttpClient</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \nHttpResponse httpResponse <span class=\"token operator\">=</span> httpClient<span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span>httpRequest<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p><code>HttpResponse</code> 对象是请求之后的响应对象，它描述着发送的状态等一系列响应信息，我们可以在发送成功后作出响应。</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>httpResponse<span class=\"token punctuation\">.</span><span class=\"token function\">getStatusLine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getStatusCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> HttpStatus<span class=\"token punctuation\">.</span>SC_OK<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n    String result <span class=\"token operator\">=</span> EntityUtils<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span>httpResponse<span class=\"token punctuation\">.</span><span class=\"token function\">getEntity</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n    tv<span class=\"token punctuation\">.</span><span class=\"token function\">setText</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n    Log<span class=\"token punctuation\">.</span><span class=\"token function\">i</span><span class=\"token punctuation\">(</span>TAG<span class=\"token punctuation\">,</span> \\\"result <span class=\"token operator\">=</span> \\\" <span class=\"token operator\">+</span> result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>  \n    tv<span class=\"token punctuation\">.</span><span class=\"token function\">setText</span><span class=\"token punctuation\">(</span>\\\"request error<span class=\"token operator\">!</span>\\\"<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n<span class=\"token punctuation\">}</span> \n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"id":"ecd0fa48e8b1ae3f335691d6932e0563","excerpt":"","more":"<p>网络通信日益发展的今天，出现了多种用于网络通信的标准，虽然 HTTP 协议的发送没有 TCP/IP 那样可靠，并且 HTTP 协议也无法保持状态，每一次数据发送都无法获知此次发送与前一次发送之间的关系。但是在 C/S 模式中还是有他自己的优势的。无连接，无状态，但是却很灵活。那么，移动端如果想要与服务器进行交互，就可以选择 HTTP 协议。</p>\n<p>在安卓开发中，想要以 Post 方式发送 HTTP 请求非常简单，首先生成一个 <code>HttpPost</code> 对象，构造函数中传入发送 HTTP 请求的服务器地址。</p>\n<pre><code class=\"java\">// point to a server-side endpoint;\nString url = \\&quot;http://www.xxx.com/server.php\\&quot;;  \nHttpPost httpRequest = new HttpPost(url);  \n</code></pre>\n<p>接下来通过一个 <code>ArrayList</code> 向 <code>HttpPost</code> 对象传入参数，这些参数可以在服务器端通过 POST 数组的方式取出来。</p>\n<pre><code class=\"java\">List&lt;NameValuePair&gt; params = new ArrayList&lt;NameValuePair&gt;();  \nparams.add(new BasicNameValuePair(\\&quot;param0\\&quot;, \\&quot;content0\\&quot;));  \nparams.add(new BasicNameValuePair(\\&quot;param1\\&quot;, \\&quot;content1\\&quot;));  \nparams.add(new BasicNameValuePair(\\&quot;param1\\&quot;, \\&quot;content2\\&quot;));  \n</code></pre>\n<p>然后在“try…catch”块中生成 httpEntity 实体，并设置数据的编码方式，然后将实体赋给 <code>HttpPost</code> 对象。这样就构造好了一个完整的 HTTP 请求实体。</p>\n<pre><code class=\"java\">HttpEntity httpEntity = new UrlEncodedFormEntity(params, \\&quot;utf-8\\&quot;);  \nhttpRequest.setEntity(httpEntity);  \n</code></pre>\n<p>接下来生成一个 HTTP 客户端，通过客户端的 <code>execute</code> 方法即可发送一个 HTTP 实体请求。</p>\n<pre><code class=\"java\">HttpClient httpClient = new DefaultHttpClient();  \nHttpResponse httpResponse = httpClient.execute(httpRequest);  \n</code></pre>\n<p><code>HttpResponse</code> 对象是请求之后的响应对象，它描述着发送的状态等一系列响应信息，我们可以在发送成功后作出响应。</p>\n<pre><code class=\"java\">if (httpResponse.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {  \n    String result = EntityUtils.toString(httpResponse.getEntity());  \n    tv.setText(result);  \n    Log.i(TAG, \\&quot;result = \\&quot; + result);  \n} else {  \n    tv.setText(\\&quot;request error!\\&quot;);  \n} \n</code></pre>\n"},{"title":"BigPipe 原理实现与使用场景分析","intro":"在昨天的 FCC 上海线下技术分享会上，“糖爸”介绍了来自 Facebook 的 BigPipe 技术，以前只知道原理但并没有动手实践过，今天遂写一篇文章详细记录一下。核心内容：BigPipe 主要利用了 HTTP1.1 的分块传输编码机制，可以有效的降低大页面的请求数量，使前端后端并行处理，提高首屏加载速度。","comments":1,"date":"2017-04-24T01:17:25.000Z","_content":"\n在昨天的 FCC 上海线下技术分享会上，“糖爸”介绍了来自 Facebook 的 BigPipe 技术，以前只知道原理但并没有动手实践过，今天遂写一篇文章详细记录一下。核心内容：BigPipe 主要利用了 HTTP1.1 的分块传输编码机制，可以有效的降低大页面的请求数量，使前端后端并行处理，提高首屏加载速度。\n\n实验环境基于 Node 7.5，这里直接使用 Express 框架来实现分块传输编码，Express 的响应对象的方法 `res.render(view [, locals] [, callback])`，如果为其提供一个方法作为第二个或第三个参数，则所有的响应会自动以 `Transfer-Encoding: chunked` 的方式进行传输，因此当所有响应内容输出后，需要手动结束该次请求。\n\nBigPipe 的优势在于可以让服务器与浏览器并行处理，在浏览器渲染其他 Pagelet 服务器也同时在获取其他 Pagelet 所需要的信息，并且 BigPipe 使用了阻塞的  HTTP 请求，从某种程度上来讲也大大降低了网站页面的请求数量，从两方面大大提高了浏览器和服务器的并行效率。\n\n传统的前后端的沟通过程见下图：\n\n![](1.png)\n\nBigPipe 的前后端并行处理过程见下图：\n\n![](2.png)\n\n可以看见，相比较于传统的前后端串行的处理方式，基于 Chunk 的并行处理方式可以更加高效的同时利用浏览器与服务器的处理资源，同时将页面按照特定的“分块”进行 Pagelet 处理，也能有效的减少传统页面的请求数量。\n\n测试环境基于 Express 快速搭建，这里只列出主要的代码。BigPipe 的处理要前后端配合，后端解析到数据后发送给前端，在前端以页面内嵌 JS 的方式进行调用，因此前后端要统一并抽象出一层规范，用于前后端的通信交流。这里我们以如下 JSON 数格式作为通信的规范。每一个从后端发送过来的 Pagelet Bundle 数据都以如下格式统一封装。其中 part 字段代表该 Pagelet 数据的渲染区块，payload 则是需要渲染的数据，具体的数据渲染方式要根据业务或者技术选型的框架来觉得。\n\n\n```json\n{\n    \"part\": \"#main\",\n    \"payload\": {}\n}\n```\n\n由于 Node 本身的异步特性，使得在 Node 下实现 BigPipe 变得十分简单。服务器端用于模拟阻塞分块传输的示例代码如下。\n\n\n```javascript\nres.render(\"index\", function(err, str) {\n// 先写入页面 DOM 和样式；\n  res.write(str);\n  // 模拟数据获取返回；\n  var json = (part, info) => {\n    return JSON.stringify({\n      part: part,\n      data: {\n        innerText: info\n      }\n    });\n  }\n\n  new Promise(function(resolve, reject) {\n    setTimeout(function() {\n      // 输出分块的 Chunk 数据；\n      res.write(`<script>Pagelet.render('${json(\"#pagelet1\", \"Hello!\")}');</script>`);\n      return resolve();\n    }, 2000)\n  }).then(function(data) {\n    return new Promise(function (resolve, reject) {\n      setTimeout(function() {\n        // 输出分块的 Chunk 数据；\n        res.write(`<script>Pagelet.render('${json(\"#pagelet2\", \"Hi!\")}');</script>`);\n        return resolve();\n      }, 8000)\n    });\n  }).then(function(data) {\n    // 全部发送完毕后结束请求；\n    res.end();\n  });\n});\n```\n\n客户端浏览器用于处理 Pagelet Bundle 数据的 JS 逻辑如下：\n\n\n```javascript\nclass Pagelet {\n  static render(json) {\n    let renderData = JSON.parse(json);\n    // Mock 业务逻辑；\n    document.querySelector(renderData.part).innerText = renderData.data.innerText;\n  }\n}\n```\n\n对应的 HTML 代码如下：\n\n\n```html\n<div id=\"pagelet1\"></div>\n<div id=\"pagelet2\"></div>\n```\n\n\n最后通过浏览器可以看到，该 HTTP 请求的 Response 头部返回的传输类型为分块传输编码：\n\n![](3.jpg)\n\n这样前端浏览器便可以在服务器返回数据时立即进行数据的填充，同时后端并行的继续处理数据并返回给前端，整个前后端的业务处理效率大大提升。但要注意的是前端在处理的过程中不能使用  DOMContentLoaded 来监听 DOM 的加载，因为 `DOMContentLoaded` 一定是在页面加载完成之后（HTTP 请求结束之后）才触发的。所以在填充数据时一定要使用另外的手段确保此时对应的 DOM 已经被渲染完毕。\n\n那么 BigPipe 适合什么样的场景呢？BigPipe 比较适用于页面**具有明显的分块内容，且各个分块内容在后端的获取相对独立，且服务端的运算时间大于300~500ms**。但具体的应用还是要根据业务以及进度来划分。\n","source":"_posts/BigPipe-原理实现与使用场景分析.md","raw":"---\ntitle: BigPipe 原理实现与使用场景分析\nintro: 在昨天的 FCC 上海线下技术分享会上，“糖爸”介绍了来自 Facebook 的 BigPipe 技术，以前只知道原理但并没有动手实践过，今天遂写一篇文章详细记录一下。核心内容：BigPipe 主要利用了 HTTP1.1 的分块传输编码机制，可以有效的降低大页面的请求数量，使前端后端并行处理，提高首屏加载速度。\ncomments: true\ndate: 2017-04-24 09:17:25\ntags:\n- JavaScript\n- BigPipe\n---\n\n在昨天的 FCC 上海线下技术分享会上，“糖爸”介绍了来自 Facebook 的 BigPipe 技术，以前只知道原理但并没有动手实践过，今天遂写一篇文章详细记录一下。核心内容：BigPipe 主要利用了 HTTP1.1 的分块传输编码机制，可以有效的降低大页面的请求数量，使前端后端并行处理，提高首屏加载速度。\n\n实验环境基于 Node 7.5，这里直接使用 Express 框架来实现分块传输编码，Express 的响应对象的方法 `res.render(view [, locals] [, callback])`，如果为其提供一个方法作为第二个或第三个参数，则所有的响应会自动以 `Transfer-Encoding: chunked` 的方式进行传输，因此当所有响应内容输出后，需要手动结束该次请求。\n\nBigPipe 的优势在于可以让服务器与浏览器并行处理，在浏览器渲染其他 Pagelet 服务器也同时在获取其他 Pagelet 所需要的信息，并且 BigPipe 使用了阻塞的  HTTP 请求，从某种程度上来讲也大大降低了网站页面的请求数量，从两方面大大提高了浏览器和服务器的并行效率。\n\n传统的前后端的沟通过程见下图：\n\n![](1.png)\n\nBigPipe 的前后端并行处理过程见下图：\n\n![](2.png)\n\n可以看见，相比较于传统的前后端串行的处理方式，基于 Chunk 的并行处理方式可以更加高效的同时利用浏览器与服务器的处理资源，同时将页面按照特定的“分块”进行 Pagelet 处理，也能有效的减少传统页面的请求数量。\n\n测试环境基于 Express 快速搭建，这里只列出主要的代码。BigPipe 的处理要前后端配合，后端解析到数据后发送给前端，在前端以页面内嵌 JS 的方式进行调用，因此前后端要统一并抽象出一层规范，用于前后端的通信交流。这里我们以如下 JSON 数格式作为通信的规范。每一个从后端发送过来的 Pagelet Bundle 数据都以如下格式统一封装。其中 part 字段代表该 Pagelet 数据的渲染区块，payload 则是需要渲染的数据，具体的数据渲染方式要根据业务或者技术选型的框架来觉得。\n\n\n```json\n{\n    \"part\": \"#main\",\n    \"payload\": {}\n}\n```\n\n由于 Node 本身的异步特性，使得在 Node 下实现 BigPipe 变得十分简单。服务器端用于模拟阻塞分块传输的示例代码如下。\n\n\n```javascript\nres.render(\"index\", function(err, str) {\n// 先写入页面 DOM 和样式；\n  res.write(str);\n  // 模拟数据获取返回；\n  var json = (part, info) => {\n    return JSON.stringify({\n      part: part,\n      data: {\n        innerText: info\n      }\n    });\n  }\n\n  new Promise(function(resolve, reject) {\n    setTimeout(function() {\n      // 输出分块的 Chunk 数据；\n      res.write(`<script>Pagelet.render('${json(\"#pagelet1\", \"Hello!\")}');</script>`);\n      return resolve();\n    }, 2000)\n  }).then(function(data) {\n    return new Promise(function (resolve, reject) {\n      setTimeout(function() {\n        // 输出分块的 Chunk 数据；\n        res.write(`<script>Pagelet.render('${json(\"#pagelet2\", \"Hi!\")}');</script>`);\n        return resolve();\n      }, 8000)\n    });\n  }).then(function(data) {\n    // 全部发送完毕后结束请求；\n    res.end();\n  });\n});\n```\n\n客户端浏览器用于处理 Pagelet Bundle 数据的 JS 逻辑如下：\n\n\n```javascript\nclass Pagelet {\n  static render(json) {\n    let renderData = JSON.parse(json);\n    // Mock 业务逻辑；\n    document.querySelector(renderData.part).innerText = renderData.data.innerText;\n  }\n}\n```\n\n对应的 HTML 代码如下：\n\n\n```html\n<div id=\"pagelet1\"></div>\n<div id=\"pagelet2\"></div>\n```\n\n\n最后通过浏览器可以看到，该 HTTP 请求的 Response 头部返回的传输类型为分块传输编码：\n\n![](3.jpg)\n\n这样前端浏览器便可以在服务器返回数据时立即进行数据的填充，同时后端并行的继续处理数据并返回给前端，整个前后端的业务处理效率大大提升。但要注意的是前端在处理的过程中不能使用  DOMContentLoaded 来监听 DOM 的加载，因为 `DOMContentLoaded` 一定是在页面加载完成之后（HTTP 请求结束之后）才触发的。所以在填充数据时一定要使用另外的手段确保此时对应的 DOM 已经被渲染完毕。\n\n那么 BigPipe 适合什么样的场景呢？BigPipe 比较适用于页面**具有明显的分块内容，且各个分块内容在后端的获取相对独立，且服务端的运算时间大于300~500ms**。但具体的应用还是要根据业务以及进度来划分。\n","slug":"BigPipe-原理实现与使用场景分析","published":1,"updated":"2019-02-12T06:36:32.101Z","layout":"post","photos":[],"link":"","_id":"cjsqwht780006knp25wkvl88e","content":"<p>在昨天的 FCC 上海线下技术分享会上，“糖爸”介绍了来自 Facebook 的 BigPipe 技术，以前只知道原理但并没有动手实践过，今天遂写一篇文章详细记录一下。核心内容：BigPipe 主要利用了 HTTP1.1 的分块传输编码机制，可以有效的降低大页面的请求数量，使前端后端并行处理，提高首屏加载速度。</p>\n<p>实验环境基于 Node 7.5，这里直接使用 Express 框架来实现分块传输编码，Express 的响应对象的方法 <code>res.render(view [, locals] [, callback])</code>，如果为其提供一个方法作为第二个或第三个参数，则所有的响应会自动以 <code>Transfer-Encoding: chunked</code> 的方式进行传输，因此当所有响应内容输出后，需要手动结束该次请求。</p>\n<p>BigPipe 的优势在于可以让服务器与浏览器并行处理，在浏览器渲染其他 Pagelet 服务器也同时在获取其他 Pagelet 所需要的信息，并且 BigPipe 使用了阻塞的  HTTP 请求，从某种程度上来讲也大大降低了网站页面的请求数量，从两方面大大提高了浏览器和服务器的并行效率。</p>\n<p>传统的前后端的沟通过程见下图：</p>\n<p><img src=\"1.png\" alt></p>\n<p>BigPipe 的前后端并行处理过程见下图：</p>\n<p><img src=\"2.png\" alt></p>\n<p>可以看见，相比较于传统的前后端串行的处理方式，基于 Chunk 的并行处理方式可以更加高效的同时利用浏览器与服务器的处理资源，同时将页面按照特定的“分块”进行 Pagelet 处理，也能有效的减少传统页面的请求数量。</p>\n<p>测试环境基于 Express 快速搭建，这里只列出主要的代码。BigPipe 的处理要前后端配合，后端解析到数据后发送给前端，在前端以页面内嵌 JS 的方式进行调用，因此前后端要统一并抽象出一层规范，用于前后端的通信交流。这里我们以如下 JSON 数格式作为通信的规范。每一个从后端发送过来的 Pagelet Bundle 数据都以如下格式统一封装。其中 part 字段代表该 Pagelet 数据的渲染区块，payload 则是需要渲染的数据，具体的数据渲染方式要根据业务或者技术选型的框架来觉得。</p>\n<pre class=\"line-numbers language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"part\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"#main\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"payload\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>由于 Node 本身的异步特性，使得在 Node 下实现 BigPipe 变得十分简单。服务器端用于模拟阻塞分块传输的示例代码如下。</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\">res<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"index\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">,</span> str<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token comment\" spellcheck=\"true\">// 先写入页面 DOM 和样式；</span>\n  res<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 模拟数据获取返回；</span>\n  <span class=\"token keyword\">var</span> json <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>part<span class=\"token punctuation\">,</span> info<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> JSON<span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n      part<span class=\"token punctuation\">:</span> part<span class=\"token punctuation\">,</span>\n      data<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n        innerText<span class=\"token punctuation\">:</span> info\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 输出分块的 Chunk 数据；</span>\n      res<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`&lt;script>Pagelet.render('</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"#pagelet1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Hello!\"</span><span class=\"token punctuation\">)</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">');&lt;/script>`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">return</span> <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2000</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 输出分块的 Chunk 数据；</span>\n        res<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`&lt;script>Pagelet.render('</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"#pagelet2\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Hi!\"</span><span class=\"token punctuation\">)</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">');&lt;/script>`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8000</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 全部发送完毕后结束请求；</span>\n    res<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>客户端浏览器用于处理 Pagelet Bundle 数据的 JS 逻辑如下：</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Pagelet</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">static</span> <span class=\"token function\">render</span><span class=\"token punctuation\">(</span>json<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> renderData <span class=\"token operator\">=</span> JSON<span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span>json<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Mock 业务逻辑；</span>\n    document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span>renderData<span class=\"token punctuation\">.</span>part<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>innerText <span class=\"token operator\">=</span> renderData<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>innerText<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>对应的 HTML 代码如下：</p>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>pagelet1<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>pagelet2<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>最后通过浏览器可以看到，该 HTTP 请求的 Response 头部返回的传输类型为分块传输编码：</p>\n<p><img src=\"3.jpg\" alt></p>\n<p>这样前端浏览器便可以在服务器返回数据时立即进行数据的填充，同时后端并行的继续处理数据并返回给前端，整个前后端的业务处理效率大大提升。但要注意的是前端在处理的过程中不能使用  DOMContentLoaded 来监听 DOM 的加载，因为 <code>DOMContentLoaded</code> 一定是在页面加载完成之后（HTTP 请求结束之后）才触发的。所以在填充数据时一定要使用另外的手段确保此时对应的 DOM 已经被渲染完毕。</p>\n<p>那么 BigPipe 适合什么样的场景呢？BigPipe 比较适用于页面<strong>具有明显的分块内容，且各个分块内容在后端的获取相对独立，且服务端的运算时间大于300~500ms</strong>。但具体的应用还是要根据业务以及进度来划分。</p>\n","site":{"data":{}},"id":"b13abe54a227e415151d222aa253bdb6","excerpt":"","more":"<p>在昨天的 FCC 上海线下技术分享会上，“糖爸”介绍了来自 Facebook 的 BigPipe 技术，以前只知道原理但并没有动手实践过，今天遂写一篇文章详细记录一下。核心内容：BigPipe 主要利用了 HTTP1.1 的分块传输编码机制，可以有效的降低大页面的请求数量，使前端后端并行处理，提高首屏加载速度。</p>\n<p>实验环境基于 Node 7.5，这里直接使用 Express 框架来实现分块传输编码，Express 的响应对象的方法 <code>res.render(view [, locals] [, callback])</code>，如果为其提供一个方法作为第二个或第三个参数，则所有的响应会自动以 <code>Transfer-Encoding: chunked</code> 的方式进行传输，因此当所有响应内容输出后，需要手动结束该次请求。</p>\n<p>BigPipe 的优势在于可以让服务器与浏览器并行处理，在浏览器渲染其他 Pagelet 服务器也同时在获取其他 Pagelet 所需要的信息，并且 BigPipe 使用了阻塞的  HTTP 请求，从某种程度上来讲也大大降低了网站页面的请求数量，从两方面大大提高了浏览器和服务器的并行效率。</p>\n<p>传统的前后端的沟通过程见下图：</p>\n<p><img src=\"1.png\" alt></p>\n<p>BigPipe 的前后端并行处理过程见下图：</p>\n<p><img src=\"2.png\" alt></p>\n<p>可以看见，相比较于传统的前后端串行的处理方式，基于 Chunk 的并行处理方式可以更加高效的同时利用浏览器与服务器的处理资源，同时将页面按照特定的“分块”进行 Pagelet 处理，也能有效的减少传统页面的请求数量。</p>\n<p>测试环境基于 Express 快速搭建，这里只列出主要的代码。BigPipe 的处理要前后端配合，后端解析到数据后发送给前端，在前端以页面内嵌 JS 的方式进行调用，因此前后端要统一并抽象出一层规范，用于前后端的通信交流。这里我们以如下 JSON 数格式作为通信的规范。每一个从后端发送过来的 Pagelet Bundle 数据都以如下格式统一封装。其中 part 字段代表该 Pagelet 数据的渲染区块，payload 则是需要渲染的数据，具体的数据渲染方式要根据业务或者技术选型的框架来觉得。</p>\n<pre><code class=\"json\">{\n    &quot;part&quot;: &quot;#main&quot;,\n    &quot;payload&quot;: {}\n}\n</code></pre>\n<p>由于 Node 本身的异步特性，使得在 Node 下实现 BigPipe 变得十分简单。服务器端用于模拟阻塞分块传输的示例代码如下。</p>\n<pre><code class=\"javascript\">res.render(&quot;index&quot;, function(err, str) {\n// 先写入页面 DOM 和样式；\n  res.write(str);\n  // 模拟数据获取返回；\n  var json = (part, info) =&gt; {\n    return JSON.stringify({\n      part: part,\n      data: {\n        innerText: info\n      }\n    });\n  }\n\n  new Promise(function(resolve, reject) {\n    setTimeout(function() {\n      // 输出分块的 Chunk 数据；\n      res.write(`&lt;script&gt;Pagelet.render(&#39;${json(&quot;#pagelet1&quot;, &quot;Hello!&quot;)}&#39;);&lt;/script&gt;`);\n      return resolve();\n    }, 2000)\n  }).then(function(data) {\n    return new Promise(function (resolve, reject) {\n      setTimeout(function() {\n        // 输出分块的 Chunk 数据；\n        res.write(`&lt;script&gt;Pagelet.render(&#39;${json(&quot;#pagelet2&quot;, &quot;Hi!&quot;)}&#39;);&lt;/script&gt;`);\n        return resolve();\n      }, 8000)\n    });\n  }).then(function(data) {\n    // 全部发送完毕后结束请求；\n    res.end();\n  });\n});\n</code></pre>\n<p>客户端浏览器用于处理 Pagelet Bundle 数据的 JS 逻辑如下：</p>\n<pre><code class=\"javascript\">class Pagelet {\n  static render(json) {\n    let renderData = JSON.parse(json);\n    // Mock 业务逻辑；\n    document.querySelector(renderData.part).innerText = renderData.data.innerText;\n  }\n}\n</code></pre>\n<p>对应的 HTML 代码如下：</p>\n<pre><code class=\"html\">&lt;div id=&quot;pagelet1&quot;&gt;&lt;/div&gt;\n&lt;div id=&quot;pagelet2&quot;&gt;&lt;/div&gt;\n</code></pre>\n<p>最后通过浏览器可以看到，该 HTTP 请求的 Response 头部返回的传输类型为分块传输编码：</p>\n<p><img src=\"3.jpg\" alt></p>\n<p>这样前端浏览器便可以在服务器返回数据时立即进行数据的填充，同时后端并行的继续处理数据并返回给前端，整个前后端的业务处理效率大大提升。但要注意的是前端在处理的过程中不能使用  DOMContentLoaded 来监听 DOM 的加载，因为 <code>DOMContentLoaded</code> 一定是在页面加载完成之后（HTTP 请求结束之后）才触发的。所以在填充数据时一定要使用另外的手段确保此时对应的 DOM 已经被渲染完毕。</p>\n<p>那么 BigPipe 适合什么样的场景呢？BigPipe 比较适用于页面<strong>具有明显的分块内容，且各个分块内容在后端的获取相对独立，且服务端的运算时间大于300~500ms</strong>。但具体的应用还是要根据业务以及进度来划分。</p>\n"},{"title":"C++ 小记录","intro":"已经不写 C++ 好多年，主要是由于自己 C++ 写的太烂而且对于在业务和日常开发的应用场景又过于狭窄，所以慢慢的很少去写了。不过由于最近几个月一直在开发 Eufa 相关的功能，C++ 又被我从垃圾堆里“捡”了回来，这里会记录一些遇到的 C++ 相关的知识点。","comments":1,"date":"2017-09-02T15:06:57.000Z","_content":"\n已经不写 C++ 好多年，主要是由于自己 C++ 写的太烂而且对于在业务和日常开发的应用场景又过于狭窄，所以慢慢的很少去写了。不过由于最近几个月一直在开发 Eufa 相关的功能，C++ 又被我从垃圾堆里“捡”了回来，这里会记录一些遇到的 C++ 相关的知识点。\n\n1. ANSI C(C99) 变量名的有效长度为 63 位；\n2. 类似 “__LONG_LONG_MAX__” (climits) 等由一个或两个下划线加大写字母组成等变量名一般用于留给编译器使用，作为保留的全局标示符号；\n3. 新的赋值语句：\n\n```c\nint x(10);\nint x = {10};\nint x{10};\n```\n\n4. 切换 cout 的数字显示格式： `cout << hex;` \\ `cout 2202LL << 2202UL << endl;`；\n5. 数字常量存储规则：1、十进制：int／long／long long；2、八／十六进制：int／unsigned (int) long／long long／unsigned long long；\n6. char 在默认情况下既不是有符号的也不是没有符号的，因此默写情况需要详细指定其类型；\n7. 宽字符集，占用2个字节：\n\n```c\nwchar_t bob = L'P';\nwcout << L\"tall\" << endl;\n\nchar16_t ch1 = u'q';\nchar32_t ch2 = U'U0000222B';\n```\n\n8. float 类型一般只有6-7位精度，double 一般有15位左右的精度；\n9. “cout” 定点输出：\n\n```c\ncout.setf(ios_base::fixed, ios_base::floatfield);\n```\n\n10. `auto` 关键字，自动类型推倒：\n\n```c\nstd::vector<double> scores;\nauto pv = scores.begin();\n```\n\n11. 数组初始化：\n\n```c\ndouble earnings[2] {1.2e4, 1.6e4};\nunsigned int counts[10] = {};\n```\n","source":"_posts/C-小记录.md","raw":"---\ntitle: C++ 小记录\nintro: 已经不写 C++ 好多年，主要是由于自己 C++ 写的太烂而且对于在业务和日常开发的应用场景又过于狭窄，所以慢慢的很少去写了。不过由于最近几个月一直在开发 Eufa 相关的功能，C++ 又被我从垃圾堆里“捡”了回来，这里会记录一些遇到的 C++ 相关的知识点。\ncomments: true\ndate: 2017-09-02 23:06:57\ntags:\n- C++\n---\n\n已经不写 C++ 好多年，主要是由于自己 C++ 写的太烂而且对于在业务和日常开发的应用场景又过于狭窄，所以慢慢的很少去写了。不过由于最近几个月一直在开发 Eufa 相关的功能，C++ 又被我从垃圾堆里“捡”了回来，这里会记录一些遇到的 C++ 相关的知识点。\n\n1. ANSI C(C99) 变量名的有效长度为 63 位；\n2. 类似 “__LONG_LONG_MAX__” (climits) 等由一个或两个下划线加大写字母组成等变量名一般用于留给编译器使用，作为保留的全局标示符号；\n3. 新的赋值语句：\n\n```c\nint x(10);\nint x = {10};\nint x{10};\n```\n\n4. 切换 cout 的数字显示格式： `cout << hex;` \\ `cout 2202LL << 2202UL << endl;`；\n5. 数字常量存储规则：1、十进制：int／long／long long；2、八／十六进制：int／unsigned (int) long／long long／unsigned long long；\n6. char 在默认情况下既不是有符号的也不是没有符号的，因此默写情况需要详细指定其类型；\n7. 宽字符集，占用2个字节：\n\n```c\nwchar_t bob = L'P';\nwcout << L\"tall\" << endl;\n\nchar16_t ch1 = u'q';\nchar32_t ch2 = U'U0000222B';\n```\n\n8. float 类型一般只有6-7位精度，double 一般有15位左右的精度；\n9. “cout” 定点输出：\n\n```c\ncout.setf(ios_base::fixed, ios_base::floatfield);\n```\n\n10. `auto` 关键字，自动类型推倒：\n\n```c\nstd::vector<double> scores;\nauto pv = scores.begin();\n```\n\n11. 数组初始化：\n\n```c\ndouble earnings[2] {1.2e4, 1.6e4};\nunsigned int counts[10] = {};\n```\n","slug":"C-小记录","published":1,"updated":"2019-02-19T10:30:09.809Z","layout":"post","photos":[],"link":"","_id":"cjsqwht790007knp2dczokgpj","content":"<p>已经不写 C++ 好多年，主要是由于自己 C++ 写的太烂而且对于在业务和日常开发的应用场景又过于狭窄，所以慢慢的很少去写了。不过由于最近几个月一直在开发 Eufa 相关的功能，C++ 又被我从垃圾堆里“捡”了回来，这里会记录一些遇到的 C++ 相关的知识点。</p>\n<ol>\n<li>ANSI C(C99) 变量名的有效长度为 63 位；</li>\n<li>类似 “<strong>LONG_LONG_MAX</strong>” (climits) 等由一个或两个下划线加大写字母组成等变量名一般用于留给编译器使用，作为保留的全局标示符号；</li>\n<li>新的赋值语句：</li>\n</ol>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">x</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> x <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">10</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> x<span class=\"token punctuation\">{</span><span class=\"token number\">10</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<ol start=\"4\">\n<li>切换 cout 的数字显示格式： <code>cout &lt;&lt; hex;</code> \\ <code>cout 2202LL &lt;&lt; 2202UL &lt;&lt; endl;</code>；</li>\n<li>数字常量存储规则：1、十进制：int／long／long long；2、八／十六进制：int／unsigned (int) long／long long／unsigned long long；</li>\n<li>char 在默认情况下既不是有符号的也不是没有符号的，因此默写情况需要详细指定其类型；</li>\n<li>宽字符集，占用2个字节：</li>\n</ol>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\">wchar_t bob <span class=\"token operator\">=</span> L<span class=\"token string\">'P'</span><span class=\"token punctuation\">;</span>\nwcout <span class=\"token operator\">&lt;&lt;</span> L<span class=\"token string\">\"tall\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\nchar16_t ch1 <span class=\"token operator\">=</span> u<span class=\"token string\">'q'</span><span class=\"token punctuation\">;</span>\nchar32_t ch2 <span class=\"token operator\">=</span> U<span class=\"token string\">'U0000222B'</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ol start=\"8\">\n<li>float 类型一般只有6-7位精度，double 一般有15位左右的精度；</li>\n<li>“cout” 定点输出：</li>\n</ol>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\">cout<span class=\"token punctuation\">.</span><span class=\"token function\">setf</span><span class=\"token punctuation\">(</span>ios_base<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>fixed<span class=\"token punctuation\">,</span> ios_base<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>floatfield<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<ol start=\"10\">\n<li><code>auto</code> 关键字，自动类型推倒：</li>\n</ol>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\">std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">double</span><span class=\"token operator\">></span> scores<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">auto</span> pv <span class=\"token operator\">=</span> scores<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<ol start=\"11\">\n<li>数组初始化：</li>\n</ol>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">double</span> earnings<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span><span class=\"token number\">1.2e4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.6e4</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> counts<span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n","site":{"data":{}},"id":"86d298601d18bba2b2ba0d9204c64b42","excerpt":"","more":"<p>已经不写 C++ 好多年，主要是由于自己 C++ 写的太烂而且对于在业务和日常开发的应用场景又过于狭窄，所以慢慢的很少去写了。不过由于最近几个月一直在开发 Eufa 相关的功能，C++ 又被我从垃圾堆里“捡”了回来，这里会记录一些遇到的 C++ 相关的知识点。</p>\n<ol>\n<li>ANSI C(C99) 变量名的有效长度为 63 位；</li>\n<li>类似 “<strong>LONG_LONG_MAX</strong>” (climits) 等由一个或两个下划线加大写字母组成等变量名一般用于留给编译器使用，作为保留的全局标示符号；</li>\n<li>新的赋值语句：</li>\n</ol>\n<pre><code class=\"c\">int x(10);\nint x = {10};\nint x{10};\n</code></pre>\n<ol start=\"4\">\n<li>切换 cout 的数字显示格式： <code>cout &lt;&lt; hex;</code> \\ <code>cout 2202LL &lt;&lt; 2202UL &lt;&lt; endl;</code>；</li>\n<li>数字常量存储规则：1、十进制：int／long／long long；2、八／十六进制：int／unsigned (int) long／long long／unsigned long long；</li>\n<li>char 在默认情况下既不是有符号的也不是没有符号的，因此默写情况需要详细指定其类型；</li>\n<li>宽字符集，占用2个字节：</li>\n</ol>\n<pre><code class=\"c\">wchar_t bob = L&#39;P&#39;;\nwcout &lt;&lt; L&quot;tall&quot; &lt;&lt; endl;\n\nchar16_t ch1 = u&#39;q&#39;;\nchar32_t ch2 = U&#39;U0000222B&#39;;\n</code></pre>\n<ol start=\"8\">\n<li>float 类型一般只有6-7位精度，double 一般有15位左右的精度；</li>\n<li>“cout” 定点输出：</li>\n</ol>\n<pre><code class=\"c\">cout.setf(ios_base::fixed, ios_base::floatfield);\n</code></pre>\n<ol start=\"10\">\n<li><code>auto</code> 关键字，自动类型推倒：</li>\n</ol>\n<pre><code class=\"c\">std::vector&lt;double&gt; scores;\nauto pv = scores.begin();\n</code></pre>\n<ol start=\"11\">\n<li>数组初始化：</li>\n</ol>\n<pre><code class=\"c\">double earnings[2] {1.2e4, 1.6e4};\nunsigned int counts[10] = {};\n</code></pre>\n"},{"title":"CSS 常用布局解决方案","intro":"本文记录下 CSS 常用的布局解决方案，对于需要高兼容性的布局可以使用基于 posistion 属性的布局，table 布局方式也经常用到。还有基于margin 和 float 的传统布局方式、利用 BFC 的布局方式和 CSS3 的弹性布局 flex 的布局方式。具体选用哪一种可以依据实际业务加以变通和修改。","comments":1,"date":"2016-12-14T16:14:47.000Z","_content":"\n本文记录下 CSS 常用的布局解决方案，对于需要高兼容性的布局可以使用基于 `posistion` 属性的布局，`table` 布局方式也经常用到。还有基于`margin` 和 `float` 的传统布局方式、利用 BFC 的布局方式和 CSS3 的弹性布局 `flex` 的布局方式。具体选用哪一种可以依据实际业务加以变通和修改。\n\n### 1. 水平居中布局：\n\n#### “inline-block + text-align”\n\n* **优点：**兼容性好；\n* **缺点：**子容器的内容居中需要额外的 `text-align` 属性；\n\n![](1.jpg)\n\n#### “table + margin”\n\n* **优点：**兼容性好，只用关心子元素的样式属性；\n\n`display:table` 属性使得元素具有同 `inline-block` 一样的特性，容器大小取决于内容大小，并且具有宽高。\n\n![](2.jpg)\n\n#### “absoulte + transform (relative + relative)”\n\n* **缺点：**兼容性问题；\n\n“relative + relative”：父元素设置 `relative` 向右平移 50%， 子元素设置 `relative` 向左平移 -50%。`relative` 均是相对于自身宽度进行移动。\n\n![](3.jpg)\n\n#### “flex + justify-content”\n\n* **优点：**只需要对父容器进行设置；\n* **缺点：**兼容性问题；\n\n![](4.jpg)\n\n### 2. 垂直居中布局：\n\n#### “table-cell + vertical-align”\n\n* **优点：**兼容性好；\n\n`vertical-align` 可以作用于 `inline`、`inline-block`、`table-cell` 元素上。\n\n![](5.jpg)\n\n#### “absolute + transform”\n\n* **缺点：**兼容性问题；\n\n![](6.jpg)\n\n#### “flex + align-items”\n\n* **缺点：**兼容性问题；\n\n![](7.jpg)\n\n### 3. 一列定宽，一列自适应：\n\n#### “float + margin”\n\n* **优点：**兼容性较好；\n\n![](8.jpg)\n\n#### “float + margin + (fix) 解决 IE6 下的3像素问题”\n\n* **优点：**兼容性较好；\n\n防止子元素清除浮动带来的问题，使用 `position:relative;` 来提高元素层级。\n\n![](9.jpg)\n\n#### “float + overflow”\n\n* **缺点：**兼容性问题；\n\n利用 BFC 模式使自适应部分不受 float 的影响。\n\n![](10.jpg)\n\n#### “table”\n\n缺点：代码量较多；\n\n`display: table;` 默认大小为内容大小；`display: table-cell` 不能设置 `margin` 属性；`table-layout: fixed;` 可以加速渲染，布局优先，固定表格布局中，水平布局仅取决于表格宽度、列宽度、表格边框宽度、单元格间距，而与单元格的内容无关。自动表格布局中，列的宽度是由列单元格中没有折行的最宽的内容设定的。\n\n![](11.jpg)\n\n#### “flex”\n\n* **缺点：**性能一般；\n\nflex 一般用于小范围布局，防止出现性能问题。\n\n![](12.jpg)\n\n### 4. 多列等分布局：\n\n#### “float”\n\n* **优点：**耦合性较大；\n\n使用 `box-sizing: border-box;` 让浏览器以 IE 的怪异模式解析“盒模型”，即元素尺寸为 “content”、“padding” 与 “border” 三者之和。\n\n![](13.jpg)\n\n#### “table”\n\n* **优点：**结构跟样式解耦；\n\n![](14.jpg)\n\n#### “flex”\n\n* **缺点：**兼容性问题；\n\n![](15.jpg)\n","source":"_posts/CSS-常用布局解决方案.md","raw":"---\ntitle: CSS 常用布局解决方案\nintro: 本文记录下 CSS 常用的布局解决方案，对于需要高兼容性的布局可以使用基于 posistion 属性的布局，table 布局方式也经常用到。还有基于margin 和 float 的传统布局方式、利用 BFC 的布局方式和 CSS3 的弹性布局 flex 的布局方式。具体选用哪一种可以依据实际业务加以变通和修改。\ncomments: true\ndate: 2016-12-15 00:14:47\ntags:\n- CSS\n---\n\n本文记录下 CSS 常用的布局解决方案，对于需要高兼容性的布局可以使用基于 `posistion` 属性的布局，`table` 布局方式也经常用到。还有基于`margin` 和 `float` 的传统布局方式、利用 BFC 的布局方式和 CSS3 的弹性布局 `flex` 的布局方式。具体选用哪一种可以依据实际业务加以变通和修改。\n\n### 1. 水平居中布局：\n\n#### “inline-block + text-align”\n\n* **优点：**兼容性好；\n* **缺点：**子容器的内容居中需要额外的 `text-align` 属性；\n\n![](1.jpg)\n\n#### “table + margin”\n\n* **优点：**兼容性好，只用关心子元素的样式属性；\n\n`display:table` 属性使得元素具有同 `inline-block` 一样的特性，容器大小取决于内容大小，并且具有宽高。\n\n![](2.jpg)\n\n#### “absoulte + transform (relative + relative)”\n\n* **缺点：**兼容性问题；\n\n“relative + relative”：父元素设置 `relative` 向右平移 50%， 子元素设置 `relative` 向左平移 -50%。`relative` 均是相对于自身宽度进行移动。\n\n![](3.jpg)\n\n#### “flex + justify-content”\n\n* **优点：**只需要对父容器进行设置；\n* **缺点：**兼容性问题；\n\n![](4.jpg)\n\n### 2. 垂直居中布局：\n\n#### “table-cell + vertical-align”\n\n* **优点：**兼容性好；\n\n`vertical-align` 可以作用于 `inline`、`inline-block`、`table-cell` 元素上。\n\n![](5.jpg)\n\n#### “absolute + transform”\n\n* **缺点：**兼容性问题；\n\n![](6.jpg)\n\n#### “flex + align-items”\n\n* **缺点：**兼容性问题；\n\n![](7.jpg)\n\n### 3. 一列定宽，一列自适应：\n\n#### “float + margin”\n\n* **优点：**兼容性较好；\n\n![](8.jpg)\n\n#### “float + margin + (fix) 解决 IE6 下的3像素问题”\n\n* **优点：**兼容性较好；\n\n防止子元素清除浮动带来的问题，使用 `position:relative;` 来提高元素层级。\n\n![](9.jpg)\n\n#### “float + overflow”\n\n* **缺点：**兼容性问题；\n\n利用 BFC 模式使自适应部分不受 float 的影响。\n\n![](10.jpg)\n\n#### “table”\n\n缺点：代码量较多；\n\n`display: table;` 默认大小为内容大小；`display: table-cell` 不能设置 `margin` 属性；`table-layout: fixed;` 可以加速渲染，布局优先，固定表格布局中，水平布局仅取决于表格宽度、列宽度、表格边框宽度、单元格间距，而与单元格的内容无关。自动表格布局中，列的宽度是由列单元格中没有折行的最宽的内容设定的。\n\n![](11.jpg)\n\n#### “flex”\n\n* **缺点：**性能一般；\n\nflex 一般用于小范围布局，防止出现性能问题。\n\n![](12.jpg)\n\n### 4. 多列等分布局：\n\n#### “float”\n\n* **优点：**耦合性较大；\n\n使用 `box-sizing: border-box;` 让浏览器以 IE 的怪异模式解析“盒模型”，即元素尺寸为 “content”、“padding” 与 “border” 三者之和。\n\n![](13.jpg)\n\n#### “table”\n\n* **优点：**结构跟样式解耦；\n\n![](14.jpg)\n\n#### “flex”\n\n* **缺点：**兼容性问题；\n\n![](15.jpg)\n","slug":"CSS-常用布局解决方案","published":1,"updated":"2019-02-12T03:38:17.201Z","layout":"post","photos":[],"link":"","_id":"cjsqwht7a0008knp27plwk7p5","content":"<p>本文记录下 CSS 常用的布局解决方案，对于需要高兼容性的布局可以使用基于 <code>posistion</code> 属性的布局，<code>table</code> 布局方式也经常用到。还有基于<code>margin</code> 和 <code>float</code> 的传统布局方式、利用 BFC 的布局方式和 CSS3 的弹性布局 <code>flex</code> 的布局方式。具体选用哪一种可以依据实际业务加以变通和修改。</p>\n<h3 id=\"1-水平居中布局：\"><a href=\"#1-水平居中布局：\" class=\"headerlink\" title=\"1. 水平居中布局：\"></a>1. 水平居中布局：</h3><h4 id=\"“inline-block-text-align”\"><a href=\"#“inline-block-text-align”\" class=\"headerlink\" title=\"“inline-block + text-align”\"></a>“inline-block + text-align”</h4><ul>\n<li><strong>优点：</strong>兼容性好；</li>\n<li><strong>缺点：</strong>子容器的内容居中需要额外的 <code>text-align</code> 属性；</li>\n</ul>\n<p><img src=\"1.jpg\" alt></p>\n<h4 id=\"“table-margin”\"><a href=\"#“table-margin”\" class=\"headerlink\" title=\"“table + margin”\"></a>“table + margin”</h4><ul>\n<li><strong>优点：</strong>兼容性好，只用关心子元素的样式属性；</li>\n</ul>\n<p><code>display:table</code> 属性使得元素具有同 <code>inline-block</code> 一样的特性，容器大小取决于内容大小，并且具有宽高。</p>\n<p><img src=\"2.jpg\" alt></p>\n<h4 id=\"“absoulte-transform-relative-relative-”\"><a href=\"#“absoulte-transform-relative-relative-”\" class=\"headerlink\" title=\"“absoulte + transform (relative + relative)”\"></a>“absoulte + transform (relative + relative)”</h4><ul>\n<li><strong>缺点：</strong>兼容性问题；</li>\n</ul>\n<p>“relative + relative”：父元素设置 <code>relative</code> 向右平移 50%， 子元素设置 <code>relative</code> 向左平移 -50%。<code>relative</code> 均是相对于自身宽度进行移动。</p>\n<p><img src=\"3.jpg\" alt></p>\n<h4 id=\"“flex-justify-content”\"><a href=\"#“flex-justify-content”\" class=\"headerlink\" title=\"“flex + justify-content”\"></a>“flex + justify-content”</h4><ul>\n<li><strong>优点：</strong>只需要对父容器进行设置；</li>\n<li><strong>缺点：</strong>兼容性问题；</li>\n</ul>\n<p><img src=\"4.jpg\" alt></p>\n<h3 id=\"2-垂直居中布局：\"><a href=\"#2-垂直居中布局：\" class=\"headerlink\" title=\"2. 垂直居中布局：\"></a>2. 垂直居中布局：</h3><h4 id=\"“table-cell-vertical-align”\"><a href=\"#“table-cell-vertical-align”\" class=\"headerlink\" title=\"“table-cell + vertical-align”\"></a>“table-cell + vertical-align”</h4><ul>\n<li><strong>优点：</strong>兼容性好；</li>\n</ul>\n<p><code>vertical-align</code> 可以作用于 <code>inline</code>、<code>inline-block</code>、<code>table-cell</code> 元素上。</p>\n<p><img src=\"5.jpg\" alt></p>\n<h4 id=\"“absolute-transform”\"><a href=\"#“absolute-transform”\" class=\"headerlink\" title=\"“absolute + transform”\"></a>“absolute + transform”</h4><ul>\n<li><strong>缺点：</strong>兼容性问题；</li>\n</ul>\n<p><img src=\"6.jpg\" alt></p>\n<h4 id=\"“flex-align-items”\"><a href=\"#“flex-align-items”\" class=\"headerlink\" title=\"“flex + align-items”\"></a>“flex + align-items”</h4><ul>\n<li><strong>缺点：</strong>兼容性问题；</li>\n</ul>\n<p><img src=\"7.jpg\" alt></p>\n<h3 id=\"3-一列定宽，一列自适应：\"><a href=\"#3-一列定宽，一列自适应：\" class=\"headerlink\" title=\"3. 一列定宽，一列自适应：\"></a>3. 一列定宽，一列自适应：</h3><h4 id=\"“float-margin”\"><a href=\"#“float-margin”\" class=\"headerlink\" title=\"“float + margin”\"></a>“float + margin”</h4><ul>\n<li><strong>优点：</strong>兼容性较好；</li>\n</ul>\n<p><img src=\"8.jpg\" alt></p>\n<h4 id=\"“float-margin-fix-解决-IE6-下的3像素问题”\"><a href=\"#“float-margin-fix-解决-IE6-下的3像素问题”\" class=\"headerlink\" title=\"“float + margin + (fix) 解决 IE6 下的3像素问题”\"></a>“float + margin + (fix) 解决 IE6 下的3像素问题”</h4><ul>\n<li><strong>优点：</strong>兼容性较好；</li>\n</ul>\n<p>防止子元素清除浮动带来的问题，使用 <code>position:relative;</code> 来提高元素层级。</p>\n<p><img src=\"9.jpg\" alt></p>\n<h4 id=\"“float-overflow”\"><a href=\"#“float-overflow”\" class=\"headerlink\" title=\"“float + overflow”\"></a>“float + overflow”</h4><ul>\n<li><strong>缺点：</strong>兼容性问题；</li>\n</ul>\n<p>利用 BFC 模式使自适应部分不受 float 的影响。</p>\n<p><img src=\"10.jpg\" alt></p>\n<h4 id=\"“table”\"><a href=\"#“table”\" class=\"headerlink\" title=\"“table”\"></a>“table”</h4><p>缺点：代码量较多；</p>\n<p><code>display: table;</code> 默认大小为内容大小；<code>display: table-cell</code> 不能设置 <code>margin</code> 属性；<code>table-layout: fixed;</code> 可以加速渲染，布局优先，固定表格布局中，水平布局仅取决于表格宽度、列宽度、表格边框宽度、单元格间距，而与单元格的内容无关。自动表格布局中，列的宽度是由列单元格中没有折行的最宽的内容设定的。</p>\n<p><img src=\"11.jpg\" alt></p>\n<h4 id=\"“flex”\"><a href=\"#“flex”\" class=\"headerlink\" title=\"“flex”\"></a>“flex”</h4><ul>\n<li><strong>缺点：</strong>性能一般；</li>\n</ul>\n<p>flex 一般用于小范围布局，防止出现性能问题。</p>\n<p><img src=\"12.jpg\" alt></p>\n<h3 id=\"4-多列等分布局：\"><a href=\"#4-多列等分布局：\" class=\"headerlink\" title=\"4. 多列等分布局：\"></a>4. 多列等分布局：</h3><h4 id=\"“float”\"><a href=\"#“float”\" class=\"headerlink\" title=\"“float”\"></a>“float”</h4><ul>\n<li><strong>优点：</strong>耦合性较大；</li>\n</ul>\n<p>使用 <code>box-sizing: border-box;</code> 让浏览器以 IE 的怪异模式解析“盒模型”，即元素尺寸为 “content”、“padding” 与 “border” 三者之和。</p>\n<p><img src=\"13.jpg\" alt></p>\n<h4 id=\"“table”-1\"><a href=\"#“table”-1\" class=\"headerlink\" title=\"“table”\"></a>“table”</h4><ul>\n<li><strong>优点：</strong>结构跟样式解耦；</li>\n</ul>\n<p><img src=\"14.jpg\" alt></p>\n<h4 id=\"“flex”-1\"><a href=\"#“flex”-1\" class=\"headerlink\" title=\"“flex”\"></a>“flex”</h4><ul>\n<li><strong>缺点：</strong>兼容性问题；</li>\n</ul>\n<p><img src=\"15.jpg\" alt></p>\n","site":{"data":{}},"id":"499776fd3e0530374a8d08475603b9ba","excerpt":"","more":"<p>本文记录下 CSS 常用的布局解决方案，对于需要高兼容性的布局可以使用基于 <code>posistion</code> 属性的布局，<code>table</code> 布局方式也经常用到。还有基于<code>margin</code> 和 <code>float</code> 的传统布局方式、利用 BFC 的布局方式和 CSS3 的弹性布局 <code>flex</code> 的布局方式。具体选用哪一种可以依据实际业务加以变通和修改。</p>\n<h3 id=\"1-水平居中布局：\"><a href=\"#1-水平居中布局：\" class=\"headerlink\" title=\"1. 水平居中布局：\"></a>1. 水平居中布局：</h3><h4 id=\"“inline-block-text-align”\"><a href=\"#“inline-block-text-align”\" class=\"headerlink\" title=\"“inline-block + text-align”\"></a>“inline-block + text-align”</h4><ul>\n<li><strong>优点：</strong>兼容性好；</li>\n<li><strong>缺点：</strong>子容器的内容居中需要额外的 <code>text-align</code> 属性；</li>\n</ul>\n<p><img src=\"1.jpg\" alt></p>\n<h4 id=\"“table-margin”\"><a href=\"#“table-margin”\" class=\"headerlink\" title=\"“table + margin”\"></a>“table + margin”</h4><ul>\n<li><strong>优点：</strong>兼容性好，只用关心子元素的样式属性；</li>\n</ul>\n<p><code>display:table</code> 属性使得元素具有同 <code>inline-block</code> 一样的特性，容器大小取决于内容大小，并且具有宽高。</p>\n<p><img src=\"2.jpg\" alt></p>\n<h4 id=\"“absoulte-transform-relative-relative-”\"><a href=\"#“absoulte-transform-relative-relative-”\" class=\"headerlink\" title=\"“absoulte + transform (relative + relative)”\"></a>“absoulte + transform (relative + relative)”</h4><ul>\n<li><strong>缺点：</strong>兼容性问题；</li>\n</ul>\n<p>“relative + relative”：父元素设置 <code>relative</code> 向右平移 50%， 子元素设置 <code>relative</code> 向左平移 -50%。<code>relative</code> 均是相对于自身宽度进行移动。</p>\n<p><img src=\"3.jpg\" alt></p>\n<h4 id=\"“flex-justify-content”\"><a href=\"#“flex-justify-content”\" class=\"headerlink\" title=\"“flex + justify-content”\"></a>“flex + justify-content”</h4><ul>\n<li><strong>优点：</strong>只需要对父容器进行设置；</li>\n<li><strong>缺点：</strong>兼容性问题；</li>\n</ul>\n<p><img src=\"4.jpg\" alt></p>\n<h3 id=\"2-垂直居中布局：\"><a href=\"#2-垂直居中布局：\" class=\"headerlink\" title=\"2. 垂直居中布局：\"></a>2. 垂直居中布局：</h3><h4 id=\"“table-cell-vertical-align”\"><a href=\"#“table-cell-vertical-align”\" class=\"headerlink\" title=\"“table-cell + vertical-align”\"></a>“table-cell + vertical-align”</h4><ul>\n<li><strong>优点：</strong>兼容性好；</li>\n</ul>\n<p><code>vertical-align</code> 可以作用于 <code>inline</code>、<code>inline-block</code>、<code>table-cell</code> 元素上。</p>\n<p><img src=\"5.jpg\" alt></p>\n<h4 id=\"“absolute-transform”\"><a href=\"#“absolute-transform”\" class=\"headerlink\" title=\"“absolute + transform”\"></a>“absolute + transform”</h4><ul>\n<li><strong>缺点：</strong>兼容性问题；</li>\n</ul>\n<p><img src=\"6.jpg\" alt></p>\n<h4 id=\"“flex-align-items”\"><a href=\"#“flex-align-items”\" class=\"headerlink\" title=\"“flex + align-items”\"></a>“flex + align-items”</h4><ul>\n<li><strong>缺点：</strong>兼容性问题；</li>\n</ul>\n<p><img src=\"7.jpg\" alt></p>\n<h3 id=\"3-一列定宽，一列自适应：\"><a href=\"#3-一列定宽，一列自适应：\" class=\"headerlink\" title=\"3. 一列定宽，一列自适应：\"></a>3. 一列定宽，一列自适应：</h3><h4 id=\"“float-margin”\"><a href=\"#“float-margin”\" class=\"headerlink\" title=\"“float + margin”\"></a>“float + margin”</h4><ul>\n<li><strong>优点：</strong>兼容性较好；</li>\n</ul>\n<p><img src=\"8.jpg\" alt></p>\n<h4 id=\"“float-margin-fix-解决-IE6-下的3像素问题”\"><a href=\"#“float-margin-fix-解决-IE6-下的3像素问题”\" class=\"headerlink\" title=\"“float + margin + (fix) 解决 IE6 下的3像素问题”\"></a>“float + margin + (fix) 解决 IE6 下的3像素问题”</h4><ul>\n<li><strong>优点：</strong>兼容性较好；</li>\n</ul>\n<p>防止子元素清除浮动带来的问题，使用 <code>position:relative;</code> 来提高元素层级。</p>\n<p><img src=\"9.jpg\" alt></p>\n<h4 id=\"“float-overflow”\"><a href=\"#“float-overflow”\" class=\"headerlink\" title=\"“float + overflow”\"></a>“float + overflow”</h4><ul>\n<li><strong>缺点：</strong>兼容性问题；</li>\n</ul>\n<p>利用 BFC 模式使自适应部分不受 float 的影响。</p>\n<p><img src=\"10.jpg\" alt></p>\n<h4 id=\"“table”\"><a href=\"#“table”\" class=\"headerlink\" title=\"“table”\"></a>“table”</h4><p>缺点：代码量较多；</p>\n<p><code>display: table;</code> 默认大小为内容大小；<code>display: table-cell</code> 不能设置 <code>margin</code> 属性；<code>table-layout: fixed;</code> 可以加速渲染，布局优先，固定表格布局中，水平布局仅取决于表格宽度、列宽度、表格边框宽度、单元格间距，而与单元格的内容无关。自动表格布局中，列的宽度是由列单元格中没有折行的最宽的内容设定的。</p>\n<p><img src=\"11.jpg\" alt></p>\n<h4 id=\"“flex”\"><a href=\"#“flex”\" class=\"headerlink\" title=\"“flex”\"></a>“flex”</h4><ul>\n<li><strong>缺点：</strong>性能一般；</li>\n</ul>\n<p>flex 一般用于小范围布局，防止出现性能问题。</p>\n<p><img src=\"12.jpg\" alt></p>\n<h3 id=\"4-多列等分布局：\"><a href=\"#4-多列等分布局：\" class=\"headerlink\" title=\"4. 多列等分布局：\"></a>4. 多列等分布局：</h3><h4 id=\"“float”\"><a href=\"#“float”\" class=\"headerlink\" title=\"“float”\"></a>“float”</h4><ul>\n<li><strong>优点：</strong>耦合性较大；</li>\n</ul>\n<p>使用 <code>box-sizing: border-box;</code> 让浏览器以 IE 的怪异模式解析“盒模型”，即元素尺寸为 “content”、“padding” 与 “border” 三者之和。</p>\n<p><img src=\"13.jpg\" alt></p>\n<h4 id=\"“table”-1\"><a href=\"#“table”-1\" class=\"headerlink\" title=\"“table”\"></a>“table”</h4><ul>\n<li><strong>优点：</strong>结构跟样式解耦；</li>\n</ul>\n<p><img src=\"14.jpg\" alt></p>\n<h4 id=\"“flex”-1\"><a href=\"#“flex”-1\" class=\"headerlink\" title=\"“flex”\"></a>“flex”</h4><ul>\n<li><strong>缺点：</strong>兼容性问题；</li>\n</ul>\n<p><img src=\"15.jpg\" alt></p>\n"},{"title":"CentOS 7.2 之 MySQL 到 MariaDB 的迁移","intro":"CentOS 自从 7.0 以后，其操作系统默认的数据库系统从之前的 MySQL 变成了 MariaDB。MariaDB 数据库管理系统是 MySQL 的一个分支，主要由开源社区在维护，采用 GPL 授权许可 MariaDB 的目的是完全兼容 MySQL，包括 API 和命令行，使之能轻松成为 MySQL 的代替品。","comments":1,"date":"2017-01-29T14:57:05.000Z","_content":"CentOS 自从 7.0 以后，其操作系统默认的数据库系统从之前的 MySQL 变成了 MariaDB。MariaDB 数据库管理系统是 MySQL 的一个分支，主要由开源社区在维护，采用 GPL 授权许可 MariaDB 其目的是完全兼容 MySQL，包括 API 和命令行，使之能够轻松成为 MySQL 的替代品。\n\nMariaDB 由 MySQL 的创始人 Michael Widenius 主导研发，他早前曾以10亿美元的价格，将自己创建的公司 MySQL AB 卖给了 SUN，此后，随着SUN 被甲骨文收购，MySQL 的所有权也落入 Oracle 的手中。开发这个分支的原因之一是：甲骨文公司在收购 MySQL 后，有将 MySQL 闭源的潜在风险，因此社区采用另起分支的方式来避开这个风险。 在过去一年中，大型互联网用户以及 Linux 发行商（这里比如 CentOS）纷纷抛弃 MySQL，转投到 MariaDB 的阵营。MariaDB 是目前最受关注的 MySQL 数据库衍生版，也被视为开源数据库 MySQL 的替代品。\n\nMariaDB 默认的存储引擎是 Maria，不是 MyISAM。Maria 可以支持事务，但是默认情况下没有打开事务支持，因为事务支持对数据库的性能会有着一定的影响。\n\nMariaDB 的安装与配置流程：\n\n#### 1. 检测当前 CentOS 的系统版本\n\n```bash\nlsb_release -a LSB Version\n```\n\n#### 2. 安装 MariaDB\n\n```bash\nyum install mariadb*\n```\n\n#### 3. 启动 MariaDB\n\n```bash\nsystemctl enable mariadb\nsystemctl start mariadb\n```\n\n#### 4. 配置管理员用户权限\n \n```bash\nmysqladmin -u root password <your@password>\n```\n\n#### 5. 设置远程连接的数据库账户\n\n```bash\nmysql -u root -p <your@password>\n> use mysql;\n> insert into user(Host, User, Password) values ('localhost', 'remote', password(<your@password>));\n> flush privileges;\n> create database dbname;\n> grant all privileges on dbname.* to 'remote'@'%' identified by <your@password>;\n> flush privileges;\n```\n\n接下来便可以通过 SQLyog 等数据库远程连接工具以“remote”用户登陆 MariaDB。我们仍然可以使用 `service` 命令来查看当前数据库的状态或者停止启动数据库，在使用 `service` 执行对应的命令时，该命令会被自动跳转到对应的 `systemctl` 命令进行执行。\n\n```bash\nservice mariadb status\nservice mariadb stop\nservice mariadb start \nservice mariadb restart\n```\n\n对应于实际执行的命令：\n\n```bash\nsystemctl status mariadb.service\nsystemctl stop mariadb.service\nsystemctl start mariadb.service\nsystemctl restart mariadb.service\n```\n\n附：如何更改 Mariadb 数据存放位置？\n\n```bash\n# 停止 Mariadb；\nservice mariadb stop\n# 复制原数据库数据文件到新位置；\ncp -r /var/lib/mysql/* /data/mysql\n# 修改配置文件中的 socket 和 datadir 两个选项的值指向到新的数据存放位置；\nvi /etc/my.cnf\n# 同时增加另外两组设置，socket 同样指向新的数据存放位置；\n[client]\ndefault-character-set=utf8\nsocket=/data/mysql/mysql.sock\n[mysql]\ndefault-character-set=utf8\nsocket=/data/mysql/mysql.sock\n# 设置新位置目录的用户组和权限；\nchown -R mysql:mysql /data/mysql\nchmod -R 777 /data/mysql\n# 重启 Mariadb；\nservice mariadb start\n```","source":"_posts/CentOS-7-2-之-MySQL-到-MariaDB-的迁移.md","raw":"---\ntitle: CentOS 7.2 之 MySQL 到 MariaDB 的迁移\nintro: CentOS 自从 7.0 以后，其操作系统默认的数据库系统从之前的 MySQL 变成了 MariaDB。MariaDB 数据库管理系统是 MySQL 的一个分支，主要由开源社区在维护，采用 GPL 授权许可 MariaDB 的目的是完全兼容 MySQL，包括 API 和命令行，使之能轻松成为 MySQL 的代替品。\ncomments: true\ndate: 2017-01-29 22:57:05\ntags:\n- Linux\n- MySQL\n---\nCentOS 自从 7.0 以后，其操作系统默认的数据库系统从之前的 MySQL 变成了 MariaDB。MariaDB 数据库管理系统是 MySQL 的一个分支，主要由开源社区在维护，采用 GPL 授权许可 MariaDB 其目的是完全兼容 MySQL，包括 API 和命令行，使之能够轻松成为 MySQL 的替代品。\n\nMariaDB 由 MySQL 的创始人 Michael Widenius 主导研发，他早前曾以10亿美元的价格，将自己创建的公司 MySQL AB 卖给了 SUN，此后，随着SUN 被甲骨文收购，MySQL 的所有权也落入 Oracle 的手中。开发这个分支的原因之一是：甲骨文公司在收购 MySQL 后，有将 MySQL 闭源的潜在风险，因此社区采用另起分支的方式来避开这个风险。 在过去一年中，大型互联网用户以及 Linux 发行商（这里比如 CentOS）纷纷抛弃 MySQL，转投到 MariaDB 的阵营。MariaDB 是目前最受关注的 MySQL 数据库衍生版，也被视为开源数据库 MySQL 的替代品。\n\nMariaDB 默认的存储引擎是 Maria，不是 MyISAM。Maria 可以支持事务，但是默认情况下没有打开事务支持，因为事务支持对数据库的性能会有着一定的影响。\n\nMariaDB 的安装与配置流程：\n\n#### 1. 检测当前 CentOS 的系统版本\n\n```bash\nlsb_release -a LSB Version\n```\n\n#### 2. 安装 MariaDB\n\n```bash\nyum install mariadb*\n```\n\n#### 3. 启动 MariaDB\n\n```bash\nsystemctl enable mariadb\nsystemctl start mariadb\n```\n\n#### 4. 配置管理员用户权限\n \n```bash\nmysqladmin -u root password <your@password>\n```\n\n#### 5. 设置远程连接的数据库账户\n\n```bash\nmysql -u root -p <your@password>\n> use mysql;\n> insert into user(Host, User, Password) values ('localhost', 'remote', password(<your@password>));\n> flush privileges;\n> create database dbname;\n> grant all privileges on dbname.* to 'remote'@'%' identified by <your@password>;\n> flush privileges;\n```\n\n接下来便可以通过 SQLyog 等数据库远程连接工具以“remote”用户登陆 MariaDB。我们仍然可以使用 `service` 命令来查看当前数据库的状态或者停止启动数据库，在使用 `service` 执行对应的命令时，该命令会被自动跳转到对应的 `systemctl` 命令进行执行。\n\n```bash\nservice mariadb status\nservice mariadb stop\nservice mariadb start \nservice mariadb restart\n```\n\n对应于实际执行的命令：\n\n```bash\nsystemctl status mariadb.service\nsystemctl stop mariadb.service\nsystemctl start mariadb.service\nsystemctl restart mariadb.service\n```\n\n附：如何更改 Mariadb 数据存放位置？\n\n```bash\n# 停止 Mariadb；\nservice mariadb stop\n# 复制原数据库数据文件到新位置；\ncp -r /var/lib/mysql/* /data/mysql\n# 修改配置文件中的 socket 和 datadir 两个选项的值指向到新的数据存放位置；\nvi /etc/my.cnf\n# 同时增加另外两组设置，socket 同样指向新的数据存放位置；\n[client]\ndefault-character-set=utf8\nsocket=/data/mysql/mysql.sock\n[mysql]\ndefault-character-set=utf8\nsocket=/data/mysql/mysql.sock\n# 设置新位置目录的用户组和权限；\nchown -R mysql:mysql /data/mysql\nchmod -R 777 /data/mysql\n# 重启 Mariadb；\nservice mariadb start\n```","slug":"CentOS-7-2-之-MySQL-到-MariaDB-的迁移","published":1,"updated":"2019-02-12T05:35:33.800Z","layout":"post","photos":[],"link":"","_id":"cjsqwht7c000bknp2ennwi2rk","content":"<p>CentOS 自从 7.0 以后，其操作系统默认的数据库系统从之前的 MySQL 变成了 MariaDB。MariaDB 数据库管理系统是 MySQL 的一个分支，主要由开源社区在维护，采用 GPL 授权许可 MariaDB 其目的是完全兼容 MySQL，包括 API 和命令行，使之能够轻松成为 MySQL 的替代品。</p>\n<p>MariaDB 由 MySQL 的创始人 Michael Widenius 主导研发，他早前曾以10亿美元的价格，将自己创建的公司 MySQL AB 卖给了 SUN，此后，随着SUN 被甲骨文收购，MySQL 的所有权也落入 Oracle 的手中。开发这个分支的原因之一是：甲骨文公司在收购 MySQL 后，有将 MySQL 闭源的潜在风险，因此社区采用另起分支的方式来避开这个风险。 在过去一年中，大型互联网用户以及 Linux 发行商（这里比如 CentOS）纷纷抛弃 MySQL，转投到 MariaDB 的阵营。MariaDB 是目前最受关注的 MySQL 数据库衍生版，也被视为开源数据库 MySQL 的替代品。</p>\n<p>MariaDB 默认的存储引擎是 Maria，不是 MyISAM。Maria 可以支持事务，但是默认情况下没有打开事务支持，因为事务支持对数据库的性能会有着一定的影响。</p>\n<p>MariaDB 的安装与配置流程：</p>\n<h4 id=\"1-检测当前-CentOS-的系统版本\"><a href=\"#1-检测当前-CentOS-的系统版本\" class=\"headerlink\" title=\"1. 检测当前 CentOS 的系统版本\"></a>1. 检测当前 CentOS 的系统版本</h4><pre class=\"line-numbers language-bash\"><code class=\"language-bash\">lsb_release -a LSB Version\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h4 id=\"2-安装-MariaDB\"><a href=\"#2-安装-MariaDB\" class=\"headerlink\" title=\"2. 安装 MariaDB\"></a>2. 安装 MariaDB</h4><pre class=\"line-numbers language-bash\"><code class=\"language-bash\">yum <span class=\"token function\">install</span> mariadb*\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h4 id=\"3-启动-MariaDB\"><a href=\"#3-启动-MariaDB\" class=\"headerlink\" title=\"3. 启动 MariaDB\"></a>3. 启动 MariaDB</h4><pre class=\"line-numbers language-bash\"><code class=\"language-bash\">systemctl <span class=\"token function\">enable</span> mariadb\nsystemctl start mariadb\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h4 id=\"4-配置管理员用户权限\"><a href=\"#4-配置管理员用户权限\" class=\"headerlink\" title=\"4. 配置管理员用户权限\"></a>4. 配置管理员用户权限</h4><pre class=\"line-numbers language-bash\"><code class=\"language-bash\">mysqladmin -u root password <span class=\"token operator\">&lt;</span>your@password<span class=\"token operator\">></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h4 id=\"5-设置远程连接的数据库账户\"><a href=\"#5-设置远程连接的数据库账户\" class=\"headerlink\" title=\"5. 设置远程连接的数据库账户\"></a>5. 设置远程连接的数据库账户</h4><pre class=\"line-numbers language-bash\"><code class=\"language-bash\">mysql -u root -p <span class=\"token operator\">&lt;</span>your@password<span class=\"token operator\">></span>\n<span class=\"token operator\">></span> use mysql<span class=\"token punctuation\">;</span>\n<span class=\"token operator\">></span> insert into user<span class=\"token punctuation\">(</span>Host, User, Password<span class=\"token punctuation\">)</span> values <span class=\"token punctuation\">(</span><span class=\"token string\">'localhost'</span>, <span class=\"token string\">'remote'</span>, password<span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;</span>your@password<span class=\"token operator\">></span><span class=\"token punctuation\">))</span><span class=\"token punctuation\">;</span>\n<span class=\"token operator\">></span> flush privileges<span class=\"token punctuation\">;</span>\n<span class=\"token operator\">></span> create database dbname<span class=\"token punctuation\">;</span>\n<span class=\"token operator\">></span> grant all privileges on dbname.* to <span class=\"token string\">'remote'</span>@<span class=\"token string\">'%'</span> identified by <span class=\"token operator\">&lt;</span>your@password<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token operator\">></span> flush privileges<span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>接下来便可以通过 SQLyog 等数据库远程连接工具以“remote”用户登陆 MariaDB。我们仍然可以使用 <code>service</code> 命令来查看当前数据库的状态或者停止启动数据库，在使用 <code>service</code> 执行对应的命令时，该命令会被自动跳转到对应的 <code>systemctl</code> 命令进行执行。</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token function\">service</span> mariadb status\n<span class=\"token function\">service</span> mariadb stop\n<span class=\"token function\">service</span> mariadb start \n<span class=\"token function\">service</span> mariadb restart\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>对应于实际执行的命令：</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\">systemctl status mariadb.service\nsystemctl stop mariadb.service\nsystemctl start mariadb.service\nsystemctl restart mariadb.service\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>附：如何更改 Mariadb 数据存放位置？</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token comment\" spellcheck=\"true\"># 停止 Mariadb；</span>\n<span class=\"token function\">service</span> mariadb stop\n<span class=\"token comment\" spellcheck=\"true\"># 复制原数据库数据文件到新位置；</span>\n<span class=\"token function\">cp</span> -r /var/lib/mysql/* /data/mysql\n<span class=\"token comment\" spellcheck=\"true\"># 修改配置文件中的 socket 和 datadir 两个选项的值指向到新的数据存放位置；</span>\n<span class=\"token function\">vi</span> /etc/my.cnf\n<span class=\"token comment\" spellcheck=\"true\"># 同时增加另外两组设置，socket 同样指向新的数据存放位置；</span>\n<span class=\"token punctuation\">[</span>client<span class=\"token punctuation\">]</span>\ndefault-character-set<span class=\"token operator\">=</span>utf8\nsocket<span class=\"token operator\">=</span>/data/mysql/mysql.sock\n<span class=\"token punctuation\">[</span>mysql<span class=\"token punctuation\">]</span>\ndefault-character-set<span class=\"token operator\">=</span>utf8\nsocket<span class=\"token operator\">=</span>/data/mysql/mysql.sock\n<span class=\"token comment\" spellcheck=\"true\"># 设置新位置目录的用户组和权限；</span>\n<span class=\"token function\">chown</span> -R mysql:mysql /data/mysql\n<span class=\"token function\">chmod</span> -R 777 /data/mysql\n<span class=\"token comment\" spellcheck=\"true\"># 重启 Mariadb；</span>\n<span class=\"token function\">service</span> mariadb start\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"id":"e6328eb09ab4e0099dfba5abbe1b1ab3","excerpt":"","more":"<p>CentOS 自从 7.0 以后，其操作系统默认的数据库系统从之前的 MySQL 变成了 MariaDB。MariaDB 数据库管理系统是 MySQL 的一个分支，主要由开源社区在维护，采用 GPL 授权许可 MariaDB 其目的是完全兼容 MySQL，包括 API 和命令行，使之能够轻松成为 MySQL 的替代品。</p>\n<p>MariaDB 由 MySQL 的创始人 Michael Widenius 主导研发，他早前曾以10亿美元的价格，将自己创建的公司 MySQL AB 卖给了 SUN，此后，随着SUN 被甲骨文收购，MySQL 的所有权也落入 Oracle 的手中。开发这个分支的原因之一是：甲骨文公司在收购 MySQL 后，有将 MySQL 闭源的潜在风险，因此社区采用另起分支的方式来避开这个风险。 在过去一年中，大型互联网用户以及 Linux 发行商（这里比如 CentOS）纷纷抛弃 MySQL，转投到 MariaDB 的阵营。MariaDB 是目前最受关注的 MySQL 数据库衍生版，也被视为开源数据库 MySQL 的替代品。</p>\n<p>MariaDB 默认的存储引擎是 Maria，不是 MyISAM。Maria 可以支持事务，但是默认情况下没有打开事务支持，因为事务支持对数据库的性能会有着一定的影响。</p>\n<p>MariaDB 的安装与配置流程：</p>\n<h4 id=\"1-检测当前-CentOS-的系统版本\"><a href=\"#1-检测当前-CentOS-的系统版本\" class=\"headerlink\" title=\"1. 检测当前 CentOS 的系统版本\"></a>1. 检测当前 CentOS 的系统版本</h4><pre><code class=\"bash\">lsb_release -a LSB Version\n</code></pre>\n<h4 id=\"2-安装-MariaDB\"><a href=\"#2-安装-MariaDB\" class=\"headerlink\" title=\"2. 安装 MariaDB\"></a>2. 安装 MariaDB</h4><pre><code class=\"bash\">yum install mariadb*\n</code></pre>\n<h4 id=\"3-启动-MariaDB\"><a href=\"#3-启动-MariaDB\" class=\"headerlink\" title=\"3. 启动 MariaDB\"></a>3. 启动 MariaDB</h4><pre><code class=\"bash\">systemctl enable mariadb\nsystemctl start mariadb\n</code></pre>\n<h4 id=\"4-配置管理员用户权限\"><a href=\"#4-配置管理员用户权限\" class=\"headerlink\" title=\"4. 配置管理员用户权限\"></a>4. 配置管理员用户权限</h4><pre><code class=\"bash\">mysqladmin -u root password &lt;your@password&gt;\n</code></pre>\n<h4 id=\"5-设置远程连接的数据库账户\"><a href=\"#5-设置远程连接的数据库账户\" class=\"headerlink\" title=\"5. 设置远程连接的数据库账户\"></a>5. 设置远程连接的数据库账户</h4><pre><code class=\"bash\">mysql -u root -p &lt;your@password&gt;\n&gt; use mysql;\n&gt; insert into user(Host, User, Password) values (&#39;localhost&#39;, &#39;remote&#39;, password(&lt;your@password&gt;));\n&gt; flush privileges;\n&gt; create database dbname;\n&gt; grant all privileges on dbname.* to &#39;remote&#39;@&#39;%&#39; identified by &lt;your@password&gt;;\n&gt; flush privileges;\n</code></pre>\n<p>接下来便可以通过 SQLyog 等数据库远程连接工具以“remote”用户登陆 MariaDB。我们仍然可以使用 <code>service</code> 命令来查看当前数据库的状态或者停止启动数据库，在使用 <code>service</code> 执行对应的命令时，该命令会被自动跳转到对应的 <code>systemctl</code> 命令进行执行。</p>\n<pre><code class=\"bash\">service mariadb status\nservice mariadb stop\nservice mariadb start \nservice mariadb restart\n</code></pre>\n<p>对应于实际执行的命令：</p>\n<pre><code class=\"bash\">systemctl status mariadb.service\nsystemctl stop mariadb.service\nsystemctl start mariadb.service\nsystemctl restart mariadb.service\n</code></pre>\n<p>附：如何更改 Mariadb 数据存放位置？</p>\n<pre><code class=\"bash\"># 停止 Mariadb；\nservice mariadb stop\n# 复制原数据库数据文件到新位置；\ncp -r /var/lib/mysql/* /data/mysql\n# 修改配置文件中的 socket 和 datadir 两个选项的值指向到新的数据存放位置；\nvi /etc/my.cnf\n# 同时增加另外两组设置，socket 同样指向新的数据存放位置；\n[client]\ndefault-character-set=utf8\nsocket=/data/mysql/mysql.sock\n[mysql]\ndefault-character-set=utf8\nsocket=/data/mysql/mysql.sock\n# 设置新位置目录的用户组和权限；\nchown -R mysql:mysql /data/mysql\nchmod -R 777 /data/mysql\n# 重启 Mariadb；\nservice mariadb start\n</code></pre>\n"},{"title":"Common Lisp 全记录（一）","intro":"从今天开始进行为期两周的 Common Lisp 语言学习，在此记录第一部分的学习内容。Lisp 作为一种古老的编程语言，有着其独特的魅力，在灵活的同时又不失性能。","comments":1,"date":"2017-06-29T15:27:55.000Z","_content":"\n从今天开始进行为期两周的 Common Lisp 语言学习，在此记录第一部分的学习内容。Lisp 作为一种古老的编程语言，有着其独特的魅力，在灵活的同时又不失性能。\n\nLisp 中所有的表达式都采用前序表达式的形式来组织语法。\n\n \n```lisp\n(+ 2 3 4 5)                     # 14\n(/ (- 7 1) (- 4 2))             # 3\n\n# quote 算子会原方不动的返回后面的实参内容；\n(quote (+ 3 5))                 # (+ 3 5)\n'(+ 3 5)                        # (+ 3 5)\n\n# 符号，不对自身求值；\n'Artichoke                      # ARTICHOKE\n\n# 列表；\n'(my 3 \"\bSons\")                  # (MY 3 \"Sons\")\n(list 'my (+ 2 1) \"Sons\")       # (MY 3 \"Sons\")\n(list '(+ 2 1) (+ 2 1))         # ((+ 2 1) 3)\n\n# 空列表；\n()                              # NIL\nnil                             # NIL\n\n# 合并列表；\n(cons 'a '(b c d))              # (A B C D)\n(cons 'a (cons 'b '(c d)))      # (A B C D)\n\n# 取出列表第一个元素；\n(car (list 'a 'b 'c))           # A\n# 取出第一个元素之后的所有元素；\n(cdr (list 'a 'b 'c))           # B C\n# 取出第三个元素；\n(third (list 'a 'b 'c))         # C\n\n# 验证实参是否是一个列表；\n(listp 'a)                                  # NIL\n(listp (list 'a 'b))                        # T\n\n# 判断实参是否是一个空表；\n(null nil)                                  # T\n\n# 取反；\n(not nil)                                   # T\n# 逻辑与；\n(and t (listp (list 'a 'b)))                # T\n# 逻辑或；\n(or t (listp (list 'a 'b)))                 # T\n```\n\n进一步的语法。\n\n \n```lisp\n# if 语句，接受三个参数(if-then-else)；\n(if (listp (list 'a 'b)) (+ 1 1) (+ 1 2))   # 2\n(if 27 1 2)                                 # 1\n\n# 函数定义，接受三个参数；\n(defun thirdParam (x) (third x))            # THIRDPARAM\n(defun sum-greater (x y z) (> (+ x y) z))   # SUM-GREATER\n\n# 调用函数；\n(thirdParam '(1 2 3))                       # 3\n(sum-greater 1 4 3)                         # T\n\n# 递归；\n(defun our-member (obj lst) \n (if (null lst)\n     nil\n (if (eql (car lst) obj)\n     t\n     (our-member obj (cdr 1st)))))\n\n# 输出，~A 占位，~% 换行；\n(format t \"~A plus ~A equals ~A. ~%\" 2 3 (+ 2 3))    # 2 plus 3 equals 5\n# 输入；\n(defun asken (string)\n    (format t \"~A\" string)\n    (read))\n\n# 变量；\n```\n","source":"_posts/Common-Lisp-全记录（一）.md","raw":"---\ntitle: Common Lisp 全记录（一）\nintro: 从今天开始进行为期两周的 Common Lisp 语言学习，在此记录第一部分的学习内容。Lisp 作为一种古老的编程语言，有着其独特的魅力，在灵活的同时又不失性能。\ncomments: true\ndate: 2017-06-29 23:27:55\ntags:\n- Lisp\n---\n\n从今天开始进行为期两周的 Common Lisp 语言学习，在此记录第一部分的学习内容。Lisp 作为一种古老的编程语言，有着其独特的魅力，在灵活的同时又不失性能。\n\nLisp 中所有的表达式都采用前序表达式的形式来组织语法。\n\n \n```lisp\n(+ 2 3 4 5)                     # 14\n(/ (- 7 1) (- 4 2))             # 3\n\n# quote 算子会原方不动的返回后面的实参内容；\n(quote (+ 3 5))                 # (+ 3 5)\n'(+ 3 5)                        # (+ 3 5)\n\n# 符号，不对自身求值；\n'Artichoke                      # ARTICHOKE\n\n# 列表；\n'(my 3 \"\bSons\")                  # (MY 3 \"Sons\")\n(list 'my (+ 2 1) \"Sons\")       # (MY 3 \"Sons\")\n(list '(+ 2 1) (+ 2 1))         # ((+ 2 1) 3)\n\n# 空列表；\n()                              # NIL\nnil                             # NIL\n\n# 合并列表；\n(cons 'a '(b c d))              # (A B C D)\n(cons 'a (cons 'b '(c d)))      # (A B C D)\n\n# 取出列表第一个元素；\n(car (list 'a 'b 'c))           # A\n# 取出第一个元素之后的所有元素；\n(cdr (list 'a 'b 'c))           # B C\n# 取出第三个元素；\n(third (list 'a 'b 'c))         # C\n\n# 验证实参是否是一个列表；\n(listp 'a)                                  # NIL\n(listp (list 'a 'b))                        # T\n\n# 判断实参是否是一个空表；\n(null nil)                                  # T\n\n# 取反；\n(not nil)                                   # T\n# 逻辑与；\n(and t (listp (list 'a 'b)))                # T\n# 逻辑或；\n(or t (listp (list 'a 'b)))                 # T\n```\n\n进一步的语法。\n\n \n```lisp\n# if 语句，接受三个参数(if-then-else)；\n(if (listp (list 'a 'b)) (+ 1 1) (+ 1 2))   # 2\n(if 27 1 2)                                 # 1\n\n# 函数定义，接受三个参数；\n(defun thirdParam (x) (third x))            # THIRDPARAM\n(defun sum-greater (x y z) (> (+ x y) z))   # SUM-GREATER\n\n# 调用函数；\n(thirdParam '(1 2 3))                       # 3\n(sum-greater 1 4 3)                         # T\n\n# 递归；\n(defun our-member (obj lst) \n (if (null lst)\n     nil\n (if (eql (car lst) obj)\n     t\n     (our-member obj (cdr 1st)))))\n\n# 输出，~A 占位，~% 换行；\n(format t \"~A plus ~A equals ~A. ~%\" 2 3 (+ 2 3))    # 2 plus 3 equals 5\n# 输入；\n(defun asken (string)\n    (format t \"~A\" string)\n    (read))\n\n# 变量；\n```\n","slug":"Common-Lisp-全记录（一）","published":1,"updated":"2019-02-19T09:40:51.122Z","layout":"post","photos":[],"link":"","_id":"cjsqwht7d000cknp2jp70qdn6","content":"<p>从今天开始进行为期两周的 Common Lisp 语言学习，在此记录第一部分的学习内容。Lisp 作为一种古老的编程语言，有着其独特的魅力，在灵活的同时又不失性能。</p>\n<p>Lisp 中所有的表达式都采用前序表达式的形式来组织语法。</p>\n<pre class=\"line-numbers language-lisp\"><code class=\"language-lisp\">(+ 2 3 4 5)                     # 14\n(/ (- 7 1) (- 4 2))             # 3\n\n# quote 算子会原方不动的返回后面的实参内容；\n(quote (+ 3 5))                 # (+ 3 5)\n'(+ 3 5)                        # (+ 3 5)\n\n# 符号，不对自身求值；\n'Artichoke                      # ARTICHOKE\n\n# 列表；\n'(my 3 \"\bSons\")                  # (MY 3 \"Sons\")\n(list 'my (+ 2 1) \"Sons\")       # (MY 3 \"Sons\")\n(list '(+ 2 1) (+ 2 1))         # ((+ 2 1) 3)\n\n# 空列表；\n()                              # NIL\nnil                             # NIL\n\n# 合并列表；\n(cons 'a '(b c d))              # (A B C D)\n(cons 'a (cons 'b '(c d)))      # (A B C D)\n\n# 取出列表第一个元素；\n(car (list 'a 'b 'c))           # A\n# 取出第一个元素之后的所有元素；\n(cdr (list 'a 'b 'c))           # B C\n# 取出第三个元素；\n(third (list 'a 'b 'c))         # C\n\n# 验证实参是否是一个列表；\n(listp 'a)                                  # NIL\n(listp (list 'a 'b))                        # T\n\n# 判断实参是否是一个空表；\n(null nil)                                  # T\n\n# 取反；\n(not nil)                                   # T\n# 逻辑与；\n(and t (listp (list 'a 'b)))                # T\n# 逻辑或；\n(or t (listp (list 'a 'b)))                 # T\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>进一步的语法。</p>\n<pre class=\"line-numbers language-lisp\"><code class=\"language-lisp\"># if 语句，接受三个参数(if-then-else)；\n(if (listp (list 'a 'b)) (+ 1 1) (+ 1 2))   # 2\n(if 27 1 2)                                 # 1\n\n# 函数定义，接受三个参数；\n(defun thirdParam (x) (third x))            # THIRDPARAM\n(defun sum-greater (x y z) (> (+ x y) z))   # SUM-GREATER\n\n# 调用函数；\n(thirdParam '(1 2 3))                       # 3\n(sum-greater 1 4 3)                         # T\n\n# 递归；\n(defun our-member (obj lst) \n (if (null lst)\n     nil\n (if (eql (car lst) obj)\n     t\n     (our-member obj (cdr 1st)))))\n\n# 输出，~A 占位，~% 换行；\n(format t \"~A plus ~A equals ~A. ~%\" 2 3 (+ 2 3))    # 2 plus 3 equals 5\n# 输入；\n(defun asken (string)\n    (format t \"~A\" string)\n    (read))\n\n# 变量；\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"id":"f2b6b4891513badcb6e8f05a1619af25","excerpt":"","more":"<p>从今天开始进行为期两周的 Common Lisp 语言学习，在此记录第一部分的学习内容。Lisp 作为一种古老的编程语言，有着其独特的魅力，在灵活的同时又不失性能。</p>\n<p>Lisp 中所有的表达式都采用前序表达式的形式来组织语法。</p>\n<pre><code class=\"lisp\">(+ 2 3 4 5)                     # 14\n(/ (- 7 1) (- 4 2))             # 3\n\n# quote 算子会原方不动的返回后面的实参内容；\n(quote (+ 3 5))                 # (+ 3 5)\n&#39;(+ 3 5)                        # (+ 3 5)\n\n# 符号，不对自身求值；\n&#39;Artichoke                      # ARTICHOKE\n\n# 列表；\n&#39;(my 3 &quot;\bSons&quot;)                  # (MY 3 &quot;Sons&quot;)\n(list &#39;my (+ 2 1) &quot;Sons&quot;)       # (MY 3 &quot;Sons&quot;)\n(list &#39;(+ 2 1) (+ 2 1))         # ((+ 2 1) 3)\n\n# 空列表；\n()                              # NIL\nnil                             # NIL\n\n# 合并列表；\n(cons &#39;a &#39;(b c d))              # (A B C D)\n(cons &#39;a (cons &#39;b &#39;(c d)))      # (A B C D)\n\n# 取出列表第一个元素；\n(car (list &#39;a &#39;b &#39;c))           # A\n# 取出第一个元素之后的所有元素；\n(cdr (list &#39;a &#39;b &#39;c))           # B C\n# 取出第三个元素；\n(third (list &#39;a &#39;b &#39;c))         # C\n\n# 验证实参是否是一个列表；\n(listp &#39;a)                                  # NIL\n(listp (list &#39;a &#39;b))                        # T\n\n# 判断实参是否是一个空表；\n(null nil)                                  # T\n\n# 取反；\n(not nil)                                   # T\n# 逻辑与；\n(and t (listp (list &#39;a &#39;b)))                # T\n# 逻辑或；\n(or t (listp (list &#39;a &#39;b)))                 # T\n</code></pre>\n<p>进一步的语法。</p>\n<pre><code class=\"lisp\"># if 语句，接受三个参数(if-then-else)；\n(if (listp (list &#39;a &#39;b)) (+ 1 1) (+ 1 2))   # 2\n(if 27 1 2)                                 # 1\n\n# 函数定义，接受三个参数；\n(defun thirdParam (x) (third x))            # THIRDPARAM\n(defun sum-greater (x y z) (&gt; (+ x y) z))   # SUM-GREATER\n\n# 调用函数；\n(thirdParam &#39;(1 2 3))                       # 3\n(sum-greater 1 4 3)                         # T\n\n# 递归；\n(defun our-member (obj lst) \n (if (null lst)\n     nil\n (if (eql (car lst) obj)\n     t\n     (our-member obj (cdr 1st)))))\n\n# 输出，~A 占位，~% 换行；\n(format t &quot;~A plus ~A equals ~A. ~%&quot; 2 3 (+ 2 3))    # 2 plus 3 equals 5\n# 输入；\n(defun asken (string)\n    (format t &quot;~A&quot; string)\n    (read))\n\n# 变量；\n</code></pre>\n"},{"title":"Docker 最佳实践（一）","intro":"Docker 改变了人们日常从开发到部署的工作流方式。不仅如此，Dokcer 在云计算、大数据处理甚至深度学习基础系统架构等方面都有其用武之地和独到之处。Docker 出现的一个重要应用场景就是可以方便地加强开发环境与部署环境的一致性。","comments":1,"date":"2017-11-04T09:36:20.000Z","_content":"\nDocker 改变了人们日常从开发到部署的工作流方式。不仅如此，Dokcer 在云计算、大数据处理甚至深度学习基础系统架构等方面都有其用武之地和独到之处。Docker 出现的一个重要应用场景就是可以方便地加强开发环境与部署环境的一致性。\n\n#### 1、新的开发部署流程：\n\n1. 开发；\n2. 提交 GIT；\n3. 触发 Hook CI/CD；\n4. 构建 Docker 进行测试；\n5. 推送至私有 Registry；\n6. 运维部署 Dokcer 镜像上线；\n\n#### 2、操作系统级虚拟化：\n\nDocker 是操作系统级虚拟化，不同于“管理程序虚拟化（Hypervisor Virtualization, HV）”，它运行在操作系统内核之上的用户态空间中，可以使多个独立用户空间运行在同一台主机上。\n\n#### 3、CentOS/Ubuntu 安装 Docker：\n\n\n```bash\nuname -a # 查看当前 Linux 内核版本；\nsudo yum update # 升级包及系统内核（3.8以上）；\n\n# 其他方式：\ncd /etc/yum.repos.d \nwget http://www.hop5.in/yum/el6/hop5.repo # 下载内核描述文件；\nyum install kernel-ml-aufs kernel-ml-aufs-devel  # 升级内核；\nvi /etc/grub.conf # 修改 default=0 默认启动内核顺序；\nreboot \n\n# 检查 Device Mapeer；\ngrep device-mapper /proc/devices\nls -al /sys/class/misc | grep device-mapper\n\n# 安装 Docker；\nyum install docker-io\n\n# 检查版本；\ndocker version\n\n# 启动 Docker 服务；\nservice docker start\ndocker -d &\n\n# 查看 Docker 状态（启动后才能查看）；\ndocker info\n```\n\n#### 4、创建 Docker 容器：\n\n\n```bash\ndocker help <command> # 查看对应 Docker 命里的帮助文档；\ndocker run --name jason_container -i -t ubuntu /bin/bash # 创建一个 Docker 容器（名字，支持 STDIN 和交互式 Shell，启动后打开容器内的 Bash Shell）；\ndocker run --name jason_container -i -t -d ubuntu /bin/bash # 创建一个长期运行的“守护式容器”；\n\ndocker ps -a # 查看所有 Docker 容器；\ndocker inspect <name/id> # 查看容器的详细配置信息；\ndocker rm -f <name/id> # 删除对应名称的 Docker 容器；\ndocker start <name/id> # 启动该对应名称的 Docker 容器；\ndocker restart <name/id> # 重新启动该对应名称的 Docker 容器；\ndocker attach <name/id> # 附着到正在运行的 Docker 容器上；\ndocker logs -ft <name/id> # 查看对应 Docker 容器上的日志信息；\ndocker top <name/id> # 查看对应 Docker 容器上的进程信息；\ndocker stats <name/id> <name/id> ... # 查看 Docker 容器的资源状态；\ndocker exec -d <name/id> <command>\ndocker stop <name/id> # 向容器发送 SIGTERM 信号；\ndocker kill <name/id> # 向容器发送 SIGKILL 信号；\n```\n\n#### 5、Docker 镜像：\n\n\n```bash\ndocker images # 列出所有可用的 Docker 镜像（/var/lib/docker）；\ndocker pull <image> # 拉取镜像；\ndocker search <image> # 在 Docker Hub 上查找公共镜像；\ndocker login # 登陆 Docker Hub （/root/.docker/config.json）；\ndocker logout # 登出 Docker Hub；\ndocker commit -m \"<messages>\" -a \"<author>\" <name/id> <repository> # 提交镜像；\n\ndocker tag <name/id> <repository>:<tag> # 为镜像标记 Tag；\n# docker tag nginx repo/static:nginx # 为本地的 nginx 镜像打一个仓库为 repo/static 标记为 nginx 的 Tag；\ndocker push <repository>:<tag> # 提交对应 Tag 的镜像；\n# docker push repo/static # 推送本地所有标记了仓库为 repo/static 的镜像（含多个 Tag）；\n# docker push repo/static:nginx # 推送本地标记了仓库为 repo/static 的同时标签为 nginx 的镜像；\n\ndocker rmi <name/id> # 删除本地的 Docker 镜像；\n```\n\n#### 6、使用 Dockerfile 来创建镜像：\n\n![](1.png)\n\n每条 `docker run` 指令都会创建一个新的镜像层，并进行提交。整个镜像从基础镜像开始向上叠加形成一个镜像栈的结构。整个 Dockerfile 会在构建时传递给 Docker Deamon 守护进程，守护进程会负责整个 Docker 镜像的构建过程。\n\n\n```bash\n# Version: 0.0.1\nFROM ubuntu:14.04\nMAINTAINER YHSPY 'yhorg@hotmail.com'\nENV REFRESHED_AT 2017-11-05\nENV DEBIAN_FRONTEND noninteractive\nRUN apt-get -qq update\nRUN apt-get update && apt-get install -y nginx\nRUN echo 'Hi, I am from your docker container' > /usr/share/nginx/html/index.html\nCMD [\"bin/bash\"] # Docker 运行时执行的参数；\n# ENTRYPOINT [\"/usr/sbin/nginx\", \"-g\", \"deamon off,\"] # 默认的 ENTRYPOINT 是 /bin/sh -c；\n# WORKDIR /opt/webapp # 切换当前工作目录(不能使用～)；\n# USER <user> # 设置用户组；\n# ADD 会自动解压源文件；\n# COPY 只负责复制和粘贴；\n# LABEL\n# ARG\n# STOPSIGNAL\n# ONBUILD\nEXPOSE 80\n```\n\n开始镜像的构建流程。\n\n\n```bash\ndocker build -t <repository> <path> # 依据 Dockerfile 来编译 Docker 镜像；\ndocker history <repository> # 查看 Docker 镜像的构建历史；\n```\n\n通过下图可以看到，在 Docker 守护进程构建镜像的过程中，针对每一次操作（对文件系统的改变）都会进行一次提交，并且生成一个对应的“镜像层”。同样在向 Docker Hub 推送镜像时，也是分别依次推送该镜像对应的每个“镜像层”。\n\n![](2.png)\n\n![](3.png)\n\n```bash\ndocker port <name/id> <port> # 查看某个容器的端口映射（映射只在容器启动时才会生效或分配）；\n```\n","source":"_posts/Docker-最佳实践（一）.md","raw":"---\ntitle: Docker 最佳实践（一）\nintro: Docker 改变了人们日常从开发到部署的工作流方式。不仅如此，Dokcer 在云计算、大数据处理甚至深度学习基础系统架构等方面都有其用武之地和独到之处。Docker 出现的一个重要应用场景就是可以方便地加强开发环境与部署环境的一致性。\ncomments: true\ndate: 2017-11-04 17:36:20\ntags:\n- Docker\n---\n\nDocker 改变了人们日常从开发到部署的工作流方式。不仅如此，Dokcer 在云计算、大数据处理甚至深度学习基础系统架构等方面都有其用武之地和独到之处。Docker 出现的一个重要应用场景就是可以方便地加强开发环境与部署环境的一致性。\n\n#### 1、新的开发部署流程：\n\n1. 开发；\n2. 提交 GIT；\n3. 触发 Hook CI/CD；\n4. 构建 Docker 进行测试；\n5. 推送至私有 Registry；\n6. 运维部署 Dokcer 镜像上线；\n\n#### 2、操作系统级虚拟化：\n\nDocker 是操作系统级虚拟化，不同于“管理程序虚拟化（Hypervisor Virtualization, HV）”，它运行在操作系统内核之上的用户态空间中，可以使多个独立用户空间运行在同一台主机上。\n\n#### 3、CentOS/Ubuntu 安装 Docker：\n\n\n```bash\nuname -a # 查看当前 Linux 内核版本；\nsudo yum update # 升级包及系统内核（3.8以上）；\n\n# 其他方式：\ncd /etc/yum.repos.d \nwget http://www.hop5.in/yum/el6/hop5.repo # 下载内核描述文件；\nyum install kernel-ml-aufs kernel-ml-aufs-devel  # 升级内核；\nvi /etc/grub.conf # 修改 default=0 默认启动内核顺序；\nreboot \n\n# 检查 Device Mapeer；\ngrep device-mapper /proc/devices\nls -al /sys/class/misc | grep device-mapper\n\n# 安装 Docker；\nyum install docker-io\n\n# 检查版本；\ndocker version\n\n# 启动 Docker 服务；\nservice docker start\ndocker -d &\n\n# 查看 Docker 状态（启动后才能查看）；\ndocker info\n```\n\n#### 4、创建 Docker 容器：\n\n\n```bash\ndocker help <command> # 查看对应 Docker 命里的帮助文档；\ndocker run --name jason_container -i -t ubuntu /bin/bash # 创建一个 Docker 容器（名字，支持 STDIN 和交互式 Shell，启动后打开容器内的 Bash Shell）；\ndocker run --name jason_container -i -t -d ubuntu /bin/bash # 创建一个长期运行的“守护式容器”；\n\ndocker ps -a # 查看所有 Docker 容器；\ndocker inspect <name/id> # 查看容器的详细配置信息；\ndocker rm -f <name/id> # 删除对应名称的 Docker 容器；\ndocker start <name/id> # 启动该对应名称的 Docker 容器；\ndocker restart <name/id> # 重新启动该对应名称的 Docker 容器；\ndocker attach <name/id> # 附着到正在运行的 Docker 容器上；\ndocker logs -ft <name/id> # 查看对应 Docker 容器上的日志信息；\ndocker top <name/id> # 查看对应 Docker 容器上的进程信息；\ndocker stats <name/id> <name/id> ... # 查看 Docker 容器的资源状态；\ndocker exec -d <name/id> <command>\ndocker stop <name/id> # 向容器发送 SIGTERM 信号；\ndocker kill <name/id> # 向容器发送 SIGKILL 信号；\n```\n\n#### 5、Docker 镜像：\n\n\n```bash\ndocker images # 列出所有可用的 Docker 镜像（/var/lib/docker）；\ndocker pull <image> # 拉取镜像；\ndocker search <image> # 在 Docker Hub 上查找公共镜像；\ndocker login # 登陆 Docker Hub （/root/.docker/config.json）；\ndocker logout # 登出 Docker Hub；\ndocker commit -m \"<messages>\" -a \"<author>\" <name/id> <repository> # 提交镜像；\n\ndocker tag <name/id> <repository>:<tag> # 为镜像标记 Tag；\n# docker tag nginx repo/static:nginx # 为本地的 nginx 镜像打一个仓库为 repo/static 标记为 nginx 的 Tag；\ndocker push <repository>:<tag> # 提交对应 Tag 的镜像；\n# docker push repo/static # 推送本地所有标记了仓库为 repo/static 的镜像（含多个 Tag）；\n# docker push repo/static:nginx # 推送本地标记了仓库为 repo/static 的同时标签为 nginx 的镜像；\n\ndocker rmi <name/id> # 删除本地的 Docker 镜像；\n```\n\n#### 6、使用 Dockerfile 来创建镜像：\n\n![](1.png)\n\n每条 `docker run` 指令都会创建一个新的镜像层，并进行提交。整个镜像从基础镜像开始向上叠加形成一个镜像栈的结构。整个 Dockerfile 会在构建时传递给 Docker Deamon 守护进程，守护进程会负责整个 Docker 镜像的构建过程。\n\n\n```bash\n# Version: 0.0.1\nFROM ubuntu:14.04\nMAINTAINER YHSPY 'yhorg@hotmail.com'\nENV REFRESHED_AT 2017-11-05\nENV DEBIAN_FRONTEND noninteractive\nRUN apt-get -qq update\nRUN apt-get update && apt-get install -y nginx\nRUN echo 'Hi, I am from your docker container' > /usr/share/nginx/html/index.html\nCMD [\"bin/bash\"] # Docker 运行时执行的参数；\n# ENTRYPOINT [\"/usr/sbin/nginx\", \"-g\", \"deamon off,\"] # 默认的 ENTRYPOINT 是 /bin/sh -c；\n# WORKDIR /opt/webapp # 切换当前工作目录(不能使用～)；\n# USER <user> # 设置用户组；\n# ADD 会自动解压源文件；\n# COPY 只负责复制和粘贴；\n# LABEL\n# ARG\n# STOPSIGNAL\n# ONBUILD\nEXPOSE 80\n```\n\n开始镜像的构建流程。\n\n\n```bash\ndocker build -t <repository> <path> # 依据 Dockerfile 来编译 Docker 镜像；\ndocker history <repository> # 查看 Docker 镜像的构建历史；\n```\n\n通过下图可以看到，在 Docker 守护进程构建镜像的过程中，针对每一次操作（对文件系统的改变）都会进行一次提交，并且生成一个对应的“镜像层”。同样在向 Docker Hub 推送镜像时，也是分别依次推送该镜像对应的每个“镜像层”。\n\n![](2.png)\n\n![](3.png)\n\n```bash\ndocker port <name/id> <port> # 查看某个容器的端口映射（映射只在容器启动时才会生效或分配）；\n```\n","slug":"Docker-最佳实践（一）","published":1,"updated":"2019-02-20T04:14:58.565Z","layout":"post","photos":[],"link":"","_id":"cjsqwht7e000eknp29l3h34mx","content":"<p>Docker 改变了人们日常从开发到部署的工作流方式。不仅如此，Dokcer 在云计算、大数据处理甚至深度学习基础系统架构等方面都有其用武之地和独到之处。Docker 出现的一个重要应用场景就是可以方便地加强开发环境与部署环境的一致性。</p>\n<h4 id=\"1、新的开发部署流程：\"><a href=\"#1、新的开发部署流程：\" class=\"headerlink\" title=\"1、新的开发部署流程：\"></a>1、新的开发部署流程：</h4><ol>\n<li>开发；</li>\n<li>提交 GIT；</li>\n<li>触发 Hook CI/CD；</li>\n<li>构建 Docker 进行测试；</li>\n<li>推送至私有 Registry；</li>\n<li>运维部署 Dokcer 镜像上线；</li>\n</ol>\n<h4 id=\"2、操作系统级虚拟化：\"><a href=\"#2、操作系统级虚拟化：\" class=\"headerlink\" title=\"2、操作系统级虚拟化：\"></a>2、操作系统级虚拟化：</h4><p>Docker 是操作系统级虚拟化，不同于“管理程序虚拟化（Hypervisor Virtualization, HV）”，它运行在操作系统内核之上的用户态空间中，可以使多个独立用户空间运行在同一台主机上。</p>\n<h4 id=\"3、CentOS-Ubuntu-安装-Docker：\"><a href=\"#3、CentOS-Ubuntu-安装-Docker：\" class=\"headerlink\" title=\"3、CentOS/Ubuntu 安装 Docker：\"></a>3、CentOS/Ubuntu 安装 Docker：</h4><pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token function\">uname</span> -a <span class=\"token comment\" spellcheck=\"true\"># 查看当前 Linux 内核版本；</span>\n<span class=\"token function\">sudo</span> yum update <span class=\"token comment\" spellcheck=\"true\"># 升级包及系统内核（3.8以上）；</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 其他方式：</span>\n<span class=\"token function\">cd</span> /etc/yum.repos.d \n<span class=\"token function\">wget</span> http://www.hop5.in/yum/el6/hop5.repo <span class=\"token comment\" spellcheck=\"true\"># 下载内核描述文件；</span>\nyum <span class=\"token function\">install</span> kernel-ml-aufs kernel-ml-aufs-devel  <span class=\"token comment\" spellcheck=\"true\"># 升级内核；</span>\n<span class=\"token function\">vi</span> /etc/grub.conf <span class=\"token comment\" spellcheck=\"true\"># 修改 default=0 默认启动内核顺序；</span>\n<span class=\"token function\">reboot</span> \n\n<span class=\"token comment\" spellcheck=\"true\"># 检查 Device Mapeer；</span>\n<span class=\"token function\">grep</span> device-mapper /proc/devices\n<span class=\"token function\">ls</span> -al /sys/class/misc <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> device-mapper\n\n<span class=\"token comment\" spellcheck=\"true\"># 安装 Docker；</span>\nyum <span class=\"token function\">install</span> docker-io\n\n<span class=\"token comment\" spellcheck=\"true\"># 检查版本；</span>\ndocker version\n\n<span class=\"token comment\" spellcheck=\"true\"># 启动 Docker 服务；</span>\n<span class=\"token function\">service</span> docker start\ndocker -d <span class=\"token operator\">&amp;</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 查看 Docker 状态（启动后才能查看）；</span>\ndocker info\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"4、创建-Docker-容器：\"><a href=\"#4、创建-Docker-容器：\" class=\"headerlink\" title=\"4、创建 Docker 容器：\"></a>4、创建 Docker 容器：</h4><pre class=\"line-numbers language-bash\"><code class=\"language-bash\">docker <span class=\"token function\">help</span> <span class=\"token operator\">&lt;</span>command<span class=\"token operator\">></span> <span class=\"token comment\" spellcheck=\"true\"># 查看对应 Docker 命里的帮助文档；</span>\ndocker run --name jason_container -i -t ubuntu /bin/bash <span class=\"token comment\" spellcheck=\"true\"># 创建一个 Docker 容器（名字，支持 STDIN 和交互式 Shell，启动后打开容器内的 Bash Shell）；</span>\ndocker run --name jason_container -i -t -d ubuntu /bin/bash <span class=\"token comment\" spellcheck=\"true\"># 创建一个长期运行的“守护式容器”；</span>\n\ndocker <span class=\"token function\">ps</span> -a <span class=\"token comment\" spellcheck=\"true\"># 查看所有 Docker 容器；</span>\ndocker inspect <span class=\"token operator\">&lt;</span>name/id<span class=\"token operator\">></span> <span class=\"token comment\" spellcheck=\"true\"># 查看容器的详细配置信息；</span>\ndocker <span class=\"token function\">rm</span> -f <span class=\"token operator\">&lt;</span>name/id<span class=\"token operator\">></span> <span class=\"token comment\" spellcheck=\"true\"># 删除对应名称的 Docker 容器；</span>\ndocker start <span class=\"token operator\">&lt;</span>name/id<span class=\"token operator\">></span> <span class=\"token comment\" spellcheck=\"true\"># 启动该对应名称的 Docker 容器；</span>\ndocker restart <span class=\"token operator\">&lt;</span>name/id<span class=\"token operator\">></span> <span class=\"token comment\" spellcheck=\"true\"># 重新启动该对应名称的 Docker 容器；</span>\ndocker attach <span class=\"token operator\">&lt;</span>name/id<span class=\"token operator\">></span> <span class=\"token comment\" spellcheck=\"true\"># 附着到正在运行的 Docker 容器上；</span>\ndocker logs -ft <span class=\"token operator\">&lt;</span>name/id<span class=\"token operator\">></span> <span class=\"token comment\" spellcheck=\"true\"># 查看对应 Docker 容器上的日志信息；</span>\ndocker <span class=\"token function\">top</span> <span class=\"token operator\">&lt;</span>name/id<span class=\"token operator\">></span> <span class=\"token comment\" spellcheck=\"true\"># 查看对应 Docker 容器上的进程信息；</span>\ndocker stats <span class=\"token operator\">&lt;</span>name/id<span class=\"token operator\">></span> <span class=\"token operator\">&lt;</span>name/id<span class=\"token operator\">></span> <span class=\"token punctuation\">..</span>. <span class=\"token comment\" spellcheck=\"true\"># 查看 Docker 容器的资源状态；</span>\ndocker <span class=\"token function\">exec</span> -d <span class=\"token operator\">&lt;</span>name/id<span class=\"token operator\">></span> <span class=\"token operator\">&lt;</span>command<span class=\"token operator\">></span>\ndocker stop <span class=\"token operator\">&lt;</span>name/id<span class=\"token operator\">></span> <span class=\"token comment\" spellcheck=\"true\"># 向容器发送 SIGTERM 信号；</span>\ndocker <span class=\"token function\">kill</span> <span class=\"token operator\">&lt;</span>name/id<span class=\"token operator\">></span> <span class=\"token comment\" spellcheck=\"true\"># 向容器发送 SIGKILL 信号；</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"5、Docker-镜像：\"><a href=\"#5、Docker-镜像：\" class=\"headerlink\" title=\"5、Docker 镜像：\"></a>5、Docker 镜像：</h4><pre class=\"line-numbers language-bash\"><code class=\"language-bash\">docker images <span class=\"token comment\" spellcheck=\"true\"># 列出所有可用的 Docker 镜像（/var/lib/docker）；</span>\ndocker pull <span class=\"token operator\">&lt;</span>image<span class=\"token operator\">></span> <span class=\"token comment\" spellcheck=\"true\"># 拉取镜像；</span>\ndocker search <span class=\"token operator\">&lt;</span>image<span class=\"token operator\">></span> <span class=\"token comment\" spellcheck=\"true\"># 在 Docker Hub 上查找公共镜像；</span>\ndocker login <span class=\"token comment\" spellcheck=\"true\"># 登陆 Docker Hub （/root/.docker/config.json）；</span>\ndocker <span class=\"token function\">logout</span> <span class=\"token comment\" spellcheck=\"true\"># 登出 Docker Hub；</span>\ndocker commit -m <span class=\"token string\">\"&lt;messages>\"</span> -a <span class=\"token string\">\"&lt;author>\"</span> <span class=\"token operator\">&lt;</span>name/id<span class=\"token operator\">></span> <span class=\"token operator\">&lt;</span>repository<span class=\"token operator\">></span> <span class=\"token comment\" spellcheck=\"true\"># 提交镜像；</span>\n\ndocker tag <span class=\"token operator\">&lt;</span>name/id<span class=\"token operator\">></span> <span class=\"token operator\">&lt;</span>repository<span class=\"token operator\">></span>:<span class=\"token operator\">&lt;</span>tag<span class=\"token operator\">></span> <span class=\"token comment\" spellcheck=\"true\"># 为镜像标记 Tag；</span>\n<span class=\"token comment\" spellcheck=\"true\"># docker tag nginx repo/static:nginx # 为本地的 nginx 镜像打一个仓库为 repo/static 标记为 nginx 的 Tag；</span>\ndocker push <span class=\"token operator\">&lt;</span>repository<span class=\"token operator\">></span>:<span class=\"token operator\">&lt;</span>tag<span class=\"token operator\">></span> <span class=\"token comment\" spellcheck=\"true\"># 提交对应 Tag 的镜像；</span>\n<span class=\"token comment\" spellcheck=\"true\"># docker push repo/static # 推送本地所有标记了仓库为 repo/static 的镜像（含多个 Tag）；</span>\n<span class=\"token comment\" spellcheck=\"true\"># docker push repo/static:nginx # 推送本地标记了仓库为 repo/static 的同时标签为 nginx 的镜像；</span>\n\ndocker rmi <span class=\"token operator\">&lt;</span>name/id<span class=\"token operator\">></span> <span class=\"token comment\" spellcheck=\"true\"># 删除本地的 Docker 镜像；</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"6、使用-Dockerfile-来创建镜像：\"><a href=\"#6、使用-Dockerfile-来创建镜像：\" class=\"headerlink\" title=\"6、使用 Dockerfile 来创建镜像：\"></a>6、使用 Dockerfile 来创建镜像：</h4><p><img src=\"1.png\" alt></p>\n<p>每条 <code>docker run</code> 指令都会创建一个新的镜像层，并进行提交。整个镜像从基础镜像开始向上叠加形成一个镜像栈的结构。整个 Dockerfile 会在构建时传递给 Docker Deamon 守护进程，守护进程会负责整个 Docker 镜像的构建过程。</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token comment\" spellcheck=\"true\"># Version: 0.0.1</span>\nFROM ubuntu:14.04\nMAINTAINER YHSPY <span class=\"token string\">'yhorg@hotmail.com'</span>\nENV REFRESHED_AT 2017-11-05\nENV DEBIAN_FRONTEND noninteractive\nRUN <span class=\"token function\">apt-get</span> -qq update\nRUN <span class=\"token function\">apt-get</span> update <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> -y nginx\nRUN <span class=\"token keyword\">echo</span> <span class=\"token string\">'Hi, I am from your docker container'</span> <span class=\"token operator\">></span> /usr/share/nginx/html/index.html\nCMD <span class=\"token punctuation\">[</span><span class=\"token string\">\"bin/bash\"</span><span class=\"token punctuation\">]</span> <span class=\"token comment\" spellcheck=\"true\"># Docker 运行时执行的参数；</span>\n<span class=\"token comment\" spellcheck=\"true\"># ENTRYPOINT [\"/usr/sbin/nginx\", \"-g\", \"deamon off,\"] # 默认的 ENTRYPOINT 是 /bin/sh -c；</span>\n<span class=\"token comment\" spellcheck=\"true\"># WORKDIR /opt/webapp # 切换当前工作目录(不能使用～)；</span>\n<span class=\"token comment\" spellcheck=\"true\"># USER &lt;user> # 设置用户组；</span>\n<span class=\"token comment\" spellcheck=\"true\"># ADD 会自动解压源文件；</span>\n<span class=\"token comment\" spellcheck=\"true\"># COPY 只负责复制和粘贴；</span>\n<span class=\"token comment\" spellcheck=\"true\"># LABEL</span>\n<span class=\"token comment\" spellcheck=\"true\"># ARG</span>\n<span class=\"token comment\" spellcheck=\"true\"># STOPSIGNAL</span>\n<span class=\"token comment\" spellcheck=\"true\"># ONBUILD</span>\nEXPOSE 80\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>开始镜像的构建流程。</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\">docker build -t <span class=\"token operator\">&lt;</span>repository<span class=\"token operator\">></span> <span class=\"token operator\">&lt;</span>path<span class=\"token operator\">></span> <span class=\"token comment\" spellcheck=\"true\"># 依据 Dockerfile 来编译 Docker 镜像；</span>\ndocker <span class=\"token function\">history</span> <span class=\"token operator\">&lt;</span>repository<span class=\"token operator\">></span> <span class=\"token comment\" spellcheck=\"true\"># 查看 Docker 镜像的构建历史；</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>通过下图可以看到，在 Docker 守护进程构建镜像的过程中，针对每一次操作（对文件系统的改变）都会进行一次提交，并且生成一个对应的“镜像层”。同样在向 Docker Hub 推送镜像时，也是分别依次推送该镜像对应的每个“镜像层”。</p>\n<p><img src=\"2.png\" alt></p>\n<p><img src=\"3.png\" alt></p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\">docker port <span class=\"token operator\">&lt;</span>name/id<span class=\"token operator\">></span> <span class=\"token operator\">&lt;</span>port<span class=\"token operator\">></span> <span class=\"token comment\" spellcheck=\"true\"># 查看某个容器的端口映射（映射只在容器启动时才会生效或分配）；</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n","site":{"data":{}},"id":"930fe462c744f69ab1d102de2725eca8","excerpt":"","more":"<p>Docker 改变了人们日常从开发到部署的工作流方式。不仅如此，Dokcer 在云计算、大数据处理甚至深度学习基础系统架构等方面都有其用武之地和独到之处。Docker 出现的一个重要应用场景就是可以方便地加强开发环境与部署环境的一致性。</p>\n<h4 id=\"1、新的开发部署流程：\"><a href=\"#1、新的开发部署流程：\" class=\"headerlink\" title=\"1、新的开发部署流程：\"></a>1、新的开发部署流程：</h4><ol>\n<li>开发；</li>\n<li>提交 GIT；</li>\n<li>触发 Hook CI/CD；</li>\n<li>构建 Docker 进行测试；</li>\n<li>推送至私有 Registry；</li>\n<li>运维部署 Dokcer 镜像上线；</li>\n</ol>\n<h4 id=\"2、操作系统级虚拟化：\"><a href=\"#2、操作系统级虚拟化：\" class=\"headerlink\" title=\"2、操作系统级虚拟化：\"></a>2、操作系统级虚拟化：</h4><p>Docker 是操作系统级虚拟化，不同于“管理程序虚拟化（Hypervisor Virtualization, HV）”，它运行在操作系统内核之上的用户态空间中，可以使多个独立用户空间运行在同一台主机上。</p>\n<h4 id=\"3、CentOS-Ubuntu-安装-Docker：\"><a href=\"#3、CentOS-Ubuntu-安装-Docker：\" class=\"headerlink\" title=\"3、CentOS/Ubuntu 安装 Docker：\"></a>3、CentOS/Ubuntu 安装 Docker：</h4><pre><code class=\"bash\">uname -a # 查看当前 Linux 内核版本；\nsudo yum update # 升级包及系统内核（3.8以上）；\n\n# 其他方式：\ncd /etc/yum.repos.d \nwget http://www.hop5.in/yum/el6/hop5.repo # 下载内核描述文件；\nyum install kernel-ml-aufs kernel-ml-aufs-devel  # 升级内核；\nvi /etc/grub.conf # 修改 default=0 默认启动内核顺序；\nreboot \n\n# 检查 Device Mapeer；\ngrep device-mapper /proc/devices\nls -al /sys/class/misc | grep device-mapper\n\n# 安装 Docker；\nyum install docker-io\n\n# 检查版本；\ndocker version\n\n# 启动 Docker 服务；\nservice docker start\ndocker -d &amp;\n\n# 查看 Docker 状态（启动后才能查看）；\ndocker info\n</code></pre>\n<h4 id=\"4、创建-Docker-容器：\"><a href=\"#4、创建-Docker-容器：\" class=\"headerlink\" title=\"4、创建 Docker 容器：\"></a>4、创建 Docker 容器：</h4><pre><code class=\"bash\">docker help &lt;command&gt; # 查看对应 Docker 命里的帮助文档；\ndocker run --name jason_container -i -t ubuntu /bin/bash # 创建一个 Docker 容器（名字，支持 STDIN 和交互式 Shell，启动后打开容器内的 Bash Shell）；\ndocker run --name jason_container -i -t -d ubuntu /bin/bash # 创建一个长期运行的“守护式容器”；\n\ndocker ps -a # 查看所有 Docker 容器；\ndocker inspect &lt;name/id&gt; # 查看容器的详细配置信息；\ndocker rm -f &lt;name/id&gt; # 删除对应名称的 Docker 容器；\ndocker start &lt;name/id&gt; # 启动该对应名称的 Docker 容器；\ndocker restart &lt;name/id&gt; # 重新启动该对应名称的 Docker 容器；\ndocker attach &lt;name/id&gt; # 附着到正在运行的 Docker 容器上；\ndocker logs -ft &lt;name/id&gt; # 查看对应 Docker 容器上的日志信息；\ndocker top &lt;name/id&gt; # 查看对应 Docker 容器上的进程信息；\ndocker stats &lt;name/id&gt; &lt;name/id&gt; ... # 查看 Docker 容器的资源状态；\ndocker exec -d &lt;name/id&gt; &lt;command&gt;\ndocker stop &lt;name/id&gt; # 向容器发送 SIGTERM 信号；\ndocker kill &lt;name/id&gt; # 向容器发送 SIGKILL 信号；\n</code></pre>\n<h4 id=\"5、Docker-镜像：\"><a href=\"#5、Docker-镜像：\" class=\"headerlink\" title=\"5、Docker 镜像：\"></a>5、Docker 镜像：</h4><pre><code class=\"bash\">docker images # 列出所有可用的 Docker 镜像（/var/lib/docker）；\ndocker pull &lt;image&gt; # 拉取镜像；\ndocker search &lt;image&gt; # 在 Docker Hub 上查找公共镜像；\ndocker login # 登陆 Docker Hub （/root/.docker/config.json）；\ndocker logout # 登出 Docker Hub；\ndocker commit -m &quot;&lt;messages&gt;&quot; -a &quot;&lt;author&gt;&quot; &lt;name/id&gt; &lt;repository&gt; # 提交镜像；\n\ndocker tag &lt;name/id&gt; &lt;repository&gt;:&lt;tag&gt; # 为镜像标记 Tag；\n# docker tag nginx repo/static:nginx # 为本地的 nginx 镜像打一个仓库为 repo/static 标记为 nginx 的 Tag；\ndocker push &lt;repository&gt;:&lt;tag&gt; # 提交对应 Tag 的镜像；\n# docker push repo/static # 推送本地所有标记了仓库为 repo/static 的镜像（含多个 Tag）；\n# docker push repo/static:nginx # 推送本地标记了仓库为 repo/static 的同时标签为 nginx 的镜像；\n\ndocker rmi &lt;name/id&gt; # 删除本地的 Docker 镜像；\n</code></pre>\n<h4 id=\"6、使用-Dockerfile-来创建镜像：\"><a href=\"#6、使用-Dockerfile-来创建镜像：\" class=\"headerlink\" title=\"6、使用 Dockerfile 来创建镜像：\"></a>6、使用 Dockerfile 来创建镜像：</h4><p><img src=\"1.png\" alt></p>\n<p>每条 <code>docker run</code> 指令都会创建一个新的镜像层，并进行提交。整个镜像从基础镜像开始向上叠加形成一个镜像栈的结构。整个 Dockerfile 会在构建时传递给 Docker Deamon 守护进程，守护进程会负责整个 Docker 镜像的构建过程。</p>\n<pre><code class=\"bash\"># Version: 0.0.1\nFROM ubuntu:14.04\nMAINTAINER YHSPY &#39;yhorg@hotmail.com&#39;\nENV REFRESHED_AT 2017-11-05\nENV DEBIAN_FRONTEND noninteractive\nRUN apt-get -qq update\nRUN apt-get update &amp;&amp; apt-get install -y nginx\nRUN echo &#39;Hi, I am from your docker container&#39; &gt; /usr/share/nginx/html/index.html\nCMD [&quot;bin/bash&quot;] # Docker 运行时执行的参数；\n# ENTRYPOINT [&quot;/usr/sbin/nginx&quot;, &quot;-g&quot;, &quot;deamon off,&quot;] # 默认的 ENTRYPOINT 是 /bin/sh -c；\n# WORKDIR /opt/webapp # 切换当前工作目录(不能使用～)；\n# USER &lt;user&gt; # 设置用户组；\n# ADD 会自动解压源文件；\n# COPY 只负责复制和粘贴；\n# LABEL\n# ARG\n# STOPSIGNAL\n# ONBUILD\nEXPOSE 80\n</code></pre>\n<p>开始镜像的构建流程。</p>\n<pre><code class=\"bash\">docker build -t &lt;repository&gt; &lt;path&gt; # 依据 Dockerfile 来编译 Docker 镜像；\ndocker history &lt;repository&gt; # 查看 Docker 镜像的构建历史；\n</code></pre>\n<p>通过下图可以看到，在 Docker 守护进程构建镜像的过程中，针对每一次操作（对文件系统的改变）都会进行一次提交，并且生成一个对应的“镜像层”。同样在向 Docker Hub 推送镜像时，也是分别依次推送该镜像对应的每个“镜像层”。</p>\n<p><img src=\"2.png\" alt></p>\n<p><img src=\"3.png\" alt></p>\n<pre><code class=\"bash\">docker port &lt;name/id&gt; &lt;port&gt; # 查看某个容器的端口映射（映射只在容器启动时才会生效或分配）；\n</code></pre>\n"},{"title":"Docker 最佳实践（三）","intro":"本篇将讨论 Docker 用于构建微服务的相关实践。如何将 Docker 用于生产环境，并且构建一个更复杂的多容器应用？同时利用链接和卷等 Docker 特性来管理 Docker 中的应用，以及 Docker 集群等。","comments":1,"date":"2017-11-09T07:53:48.000Z","_content":"\n\n本篇将讨论 Docker 用于构建微服务的相关实践。如何将 Docker 用于生产环境，并且构建一个更复杂的多容器应用？同时利用链接和卷等 Docker 特性来管理 Docker 中的应用，以及 Docker 集群等。\n\n#### 1、Docker Compose：\n\nDocker Compose 可以进行简单的容器编排，将容器服务化。安装 Docker Compose。\n\n\n```bash\n# 安装 Docker Compose；\nsudo curl -L https://github.com/docker/compose/releases/download/1.17.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose\nsudo chmod +x /usr/local/bin/docker-compose\ndocker-compose --version\n```\n\n编写 Dockerfile 以及应用程序相关的文件。\n\n\n```bash\n# Dockerfile；\nFROM python:2.7\nMAINTAINER YHSPY <yhorg@hotmail.com>\nENV REFRESHED_AT 20167-11-09\nADD . /composeapp\nWORKDIR /composeapp\nRUN pip install -r requirements.txt\n\n# Application(app.py/requirements.txt)；\n...\n```\n\n编写 docker-compose.yml 配置 Docker Compose 来创建服务。\n\n```bash\nversion: '3'\nservices:\n  web:\n    image: jamtur01/composeapp\n    command: python app.py\n    ports:\n     - \"5000:5000\"\n    volumes:\n     - .:/composeapp\n    links:\n     - redis\n  redis:\n    image: redis\n```\n\n运行服务。\n\n\n```bash\ndocker-compose up\ndocker-compose logs\ndocker-compose stop\ndocker-compose kill\ndocker-compose rm\ndocker-compose ps\n```\n\n#### 2、Consul、服务发现和 Docker：\n\n（待补充）\n\n#### 3、Docker Swarm：\n\nDocker Swarm 是一个原生的 Docker 集群管理工具，支持容器的跨宿主节点的集群管理。\n\n\n```bash\n# 拉取 Docker Swarm 镜像；\nsudo docker pull swarm\n\n# 初始化主节点；\nsudo docker swarm init --advertise-addr <manager-ip>\nsudo docker info\nsudo docker node ls\n\n# 设置从节点；\n(Optional) sudo docker swarm join --token <token> 127.0.0.1:2377\n\n\n# 创建服务；\nsudo docker service create --replicas 1 --name <name> -p <local>:<remote> -e \"ENV_PASS=yue.lu\" -t <image>\n\n\nsudo docker service ls\nsudo docker service inspect <name>\nsudo docker service rm <name>\n\n```\n\n#### 4、Kubernetes：\n\nKubernetes是一个开放源代码系统，用于跨多个主机来管理 Docker 化等应用程序，为应用程序的部署，维护和扩展提供基本的功能。我们这里使用 Minikube 在本地创建一个单节点单 Kubernetes 集群，同时使用 `kubectl` 命令行工具来管理 Kubernetes 集群（kubectl 是一个用于操作 Kubernetes 集群的命令行接口）。\n\n\n```bash\n# 首先安装 kubectl 命令行工具；\ncurl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl\nchmod +x ./kubectl\nsudo mv ./kubectl /usr/local/bin/kubectl\n```\n\n\n```bash\n# 可选的本机单集群；\n# https://github.com/kubernetes/minikube\ncurl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 && chmod +x minikube && sudo mv minikube /usr/local/bin/\n```\n\n\n```bash\nminikube version\nminikube start\n```\n\n安装依赖 VirtualBox（由于 ECS 等云服务器本身即基于虚拟化的产品，因此并不能在 ECS 等产品上再使用嵌套的虚拟化服务 /proc/xen）。\n\n\n```bash\ncd /etc/yum.repos.d/\nwget http://download.virtualbox.org/virtualbox/rpm/rhel/virtualbox.repo\nyum update\nyum install binutils qt gcc make patch libgomp glibc-headers glibc-devel kernel-headers kernel-devel dkms\nexport KERN_DIR=/usr/src/kernels/<kernels_version>\nyum install VirtualBox-5.2\n```\n\n\n```bash\nkubectl run <name> --image=<image>\nkubectl get pods\nkubectl expose deployment <name> --port <port> --type LoadBalancer\nkubectl get services\n```\n\n通过配置文件来创建 Pods，Pods 是一个或一组容器的集合，每一个 Pods 对应于一个逻辑上的应用程序。Pods 内部还有 Volumes，这些 Volumes 组成了该 Pods 的数据层。整个 Pods 共享一个网络命名空间（IP），内部的容器和 Volumes 之间可以相互访问。\n\n![](1.png)\n\n```bash\n# pods.yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: monolith\n  labels:\n    app: monolith\nspec:\n  containers:\n    - name: monolith\n      image: udacity/example-monolith:1.0.0\n      args:\n        - \"-http=0.0.0.0:80\"\n        - \"-health=0.0.0.0:81\"\n        - \"-secret=secret\"\n      ports:\n        - name: http\n          containerPort: 80\n        - name: health\n          containerPort: 81\n      resources:\n        limits:\n          cpu: 0.2\n          memory: \"10Mi\"\n      livenessProbe:\n        httpGet:\n          path: /healthz\n          port: 81\n          scheme: HTTP\n        initialDelaySeconds: 5\n        periodSeconds: 15\n        timeoutSeconds: 5\n      readinessProbe:\n        httpGet:\n          path: /readiness\n          port: 81\n          scheme: HTTP\n        initialDelaySeconds: 5\n        timeoutSeconds: 1\n```\n\n\n```bash\nkubectl create -f pods.yaml\nkubectl get pods\nkubectl describe pods monolith\n\nkubectl port-forward monolith 10080:80 # 端口代理；\nkubectl logs monolith\nkubectl exec monolith --stdin --tty -c monolith /bin/sh # 打开一个与 Pods 进行交互的终端；\n```\n\nDocker 常用命令总结：\n\n\n```bash\n# remove exited containers:\ndocker ps --filter status=dead --filter status=exited -aq | xargs -r docker rm -v\n    \n# remove unused images:\ndocker images --no-trunc | grep '<none>' | awk '{ print $3 }' | xargs -r docker rmi\n```\n","source":"_posts/Docker-最佳实践（三）.md","raw":"---\ntitle: Docker 最佳实践（三）\nintro: 本篇将讨论 Docker 用于构建微服务的相关实践。如何将 Docker 用于生产环境，并且构建一个更复杂的多容器应用？同时利用链接和卷等 Docker 特性来管理 Docker 中的应用，以及 Docker 集群等。\ncomments: true\ndate: 2017-11-09 15:53:48\ntags:\n- Docker\n---\n\n\n本篇将讨论 Docker 用于构建微服务的相关实践。如何将 Docker 用于生产环境，并且构建一个更复杂的多容器应用？同时利用链接和卷等 Docker 特性来管理 Docker 中的应用，以及 Docker 集群等。\n\n#### 1、Docker Compose：\n\nDocker Compose 可以进行简单的容器编排，将容器服务化。安装 Docker Compose。\n\n\n```bash\n# 安装 Docker Compose；\nsudo curl -L https://github.com/docker/compose/releases/download/1.17.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose\nsudo chmod +x /usr/local/bin/docker-compose\ndocker-compose --version\n```\n\n编写 Dockerfile 以及应用程序相关的文件。\n\n\n```bash\n# Dockerfile；\nFROM python:2.7\nMAINTAINER YHSPY <yhorg@hotmail.com>\nENV REFRESHED_AT 20167-11-09\nADD . /composeapp\nWORKDIR /composeapp\nRUN pip install -r requirements.txt\n\n# Application(app.py/requirements.txt)；\n...\n```\n\n编写 docker-compose.yml 配置 Docker Compose 来创建服务。\n\n```bash\nversion: '3'\nservices:\n  web:\n    image: jamtur01/composeapp\n    command: python app.py\n    ports:\n     - \"5000:5000\"\n    volumes:\n     - .:/composeapp\n    links:\n     - redis\n  redis:\n    image: redis\n```\n\n运行服务。\n\n\n```bash\ndocker-compose up\ndocker-compose logs\ndocker-compose stop\ndocker-compose kill\ndocker-compose rm\ndocker-compose ps\n```\n\n#### 2、Consul、服务发现和 Docker：\n\n（待补充）\n\n#### 3、Docker Swarm：\n\nDocker Swarm 是一个原生的 Docker 集群管理工具，支持容器的跨宿主节点的集群管理。\n\n\n```bash\n# 拉取 Docker Swarm 镜像；\nsudo docker pull swarm\n\n# 初始化主节点；\nsudo docker swarm init --advertise-addr <manager-ip>\nsudo docker info\nsudo docker node ls\n\n# 设置从节点；\n(Optional) sudo docker swarm join --token <token> 127.0.0.1:2377\n\n\n# 创建服务；\nsudo docker service create --replicas 1 --name <name> -p <local>:<remote> -e \"ENV_PASS=yue.lu\" -t <image>\n\n\nsudo docker service ls\nsudo docker service inspect <name>\nsudo docker service rm <name>\n\n```\n\n#### 4、Kubernetes：\n\nKubernetes是一个开放源代码系统，用于跨多个主机来管理 Docker 化等应用程序，为应用程序的部署，维护和扩展提供基本的功能。我们这里使用 Minikube 在本地创建一个单节点单 Kubernetes 集群，同时使用 `kubectl` 命令行工具来管理 Kubernetes 集群（kubectl 是一个用于操作 Kubernetes 集群的命令行接口）。\n\n\n```bash\n# 首先安装 kubectl 命令行工具；\ncurl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl\nchmod +x ./kubectl\nsudo mv ./kubectl /usr/local/bin/kubectl\n```\n\n\n```bash\n# 可选的本机单集群；\n# https://github.com/kubernetes/minikube\ncurl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 && chmod +x minikube && sudo mv minikube /usr/local/bin/\n```\n\n\n```bash\nminikube version\nminikube start\n```\n\n安装依赖 VirtualBox（由于 ECS 等云服务器本身即基于虚拟化的产品，因此并不能在 ECS 等产品上再使用嵌套的虚拟化服务 /proc/xen）。\n\n\n```bash\ncd /etc/yum.repos.d/\nwget http://download.virtualbox.org/virtualbox/rpm/rhel/virtualbox.repo\nyum update\nyum install binutils qt gcc make patch libgomp glibc-headers glibc-devel kernel-headers kernel-devel dkms\nexport KERN_DIR=/usr/src/kernels/<kernels_version>\nyum install VirtualBox-5.2\n```\n\n\n```bash\nkubectl run <name> --image=<image>\nkubectl get pods\nkubectl expose deployment <name> --port <port> --type LoadBalancer\nkubectl get services\n```\n\n通过配置文件来创建 Pods，Pods 是一个或一组容器的集合，每一个 Pods 对应于一个逻辑上的应用程序。Pods 内部还有 Volumes，这些 Volumes 组成了该 Pods 的数据层。整个 Pods 共享一个网络命名空间（IP），内部的容器和 Volumes 之间可以相互访问。\n\n![](1.png)\n\n```bash\n# pods.yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: monolith\n  labels:\n    app: monolith\nspec:\n  containers:\n    - name: monolith\n      image: udacity/example-monolith:1.0.0\n      args:\n        - \"-http=0.0.0.0:80\"\n        - \"-health=0.0.0.0:81\"\n        - \"-secret=secret\"\n      ports:\n        - name: http\n          containerPort: 80\n        - name: health\n          containerPort: 81\n      resources:\n        limits:\n          cpu: 0.2\n          memory: \"10Mi\"\n      livenessProbe:\n        httpGet:\n          path: /healthz\n          port: 81\n          scheme: HTTP\n        initialDelaySeconds: 5\n        periodSeconds: 15\n        timeoutSeconds: 5\n      readinessProbe:\n        httpGet:\n          path: /readiness\n          port: 81\n          scheme: HTTP\n        initialDelaySeconds: 5\n        timeoutSeconds: 1\n```\n\n\n```bash\nkubectl create -f pods.yaml\nkubectl get pods\nkubectl describe pods monolith\n\nkubectl port-forward monolith 10080:80 # 端口代理；\nkubectl logs monolith\nkubectl exec monolith --stdin --tty -c monolith /bin/sh # 打开一个与 Pods 进行交互的终端；\n```\n\nDocker 常用命令总结：\n\n\n```bash\n# remove exited containers:\ndocker ps --filter status=dead --filter status=exited -aq | xargs -r docker rm -v\n    \n# remove unused images:\ndocker images --no-trunc | grep '<none>' | awk '{ print $3 }' | xargs -r docker rmi\n```\n","slug":"Docker-最佳实践（三）","published":1,"updated":"2019-02-20T05:58:36.842Z","layout":"post","photos":[],"link":"","_id":"cjsqwht7f000gknp21kqmiy04","content":"<p>本篇将讨论 Docker 用于构建微服务的相关实践。如何将 Docker 用于生产环境，并且构建一个更复杂的多容器应用？同时利用链接和卷等 Docker 特性来管理 Docker 中的应用，以及 Docker 集群等。</p>\n<h4 id=\"1、Docker-Compose：\"><a href=\"#1、Docker-Compose：\" class=\"headerlink\" title=\"1、Docker Compose：\"></a>1、Docker Compose：</h4><p>Docker Compose 可以进行简单的容器编排，将容器服务化。安装 Docker Compose。</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token comment\" spellcheck=\"true\"># 安装 Docker Compose；</span>\n<span class=\"token function\">sudo</span> curl -L https://github.com/docker/compose/releases/download/1.17.0/docker-compose-<span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">uname</span> -s<span class=\"token variable\">`</span></span>-<span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">uname</span> -m<span class=\"token variable\">`</span></span> -o /usr/local/bin/docker-compose\n<span class=\"token function\">sudo</span> <span class=\"token function\">chmod</span> +x /usr/local/bin/docker-compose\ndocker-compose --version\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>编写 Dockerfile 以及应用程序相关的文件。</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token comment\" spellcheck=\"true\"># Dockerfile；</span>\nFROM python:2.7\nMAINTAINER YHSPY <span class=\"token operator\">&lt;</span>yhorg@hotmail.com<span class=\"token operator\">></span>\nENV REFRESHED_AT 20167-11-09\nADD <span class=\"token keyword\">.</span> /composeapp\nWORKDIR /composeapp\nRUN pip <span class=\"token function\">install</span> -r requirements.txt\n\n<span class=\"token comment\" spellcheck=\"true\"># Application(app.py/requirements.txt)；</span>\n<span class=\"token punctuation\">..</span>.\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>编写 docker-compose.yml 配置 Docker Compose 来创建服务。</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\">version: <span class=\"token string\">'3'</span>\nservices:\n  web:\n    image: jamtur01/composeapp\n    command: python app.py\n    ports:\n     - <span class=\"token string\">\"5000:5000\"</span>\n    volumes:\n     - .:/composeapp\n    links:\n     - redis\n  redis:\n    image: redis\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>运行服务。</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\">docker-compose up\ndocker-compose logs\ndocker-compose stop\ndocker-compose <span class=\"token function\">kill</span>\ndocker-compose <span class=\"token function\">rm</span>\ndocker-compose <span class=\"token function\">ps</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"2、Consul、服务发现和-Docker：\"><a href=\"#2、Consul、服务发现和-Docker：\" class=\"headerlink\" title=\"2、Consul、服务发现和 Docker：\"></a>2、Consul、服务发现和 Docker：</h4><p>（待补充）</p>\n<h4 id=\"3、Docker-Swarm：\"><a href=\"#3、Docker-Swarm：\" class=\"headerlink\" title=\"3、Docker Swarm：\"></a>3、Docker Swarm：</h4><p>Docker Swarm 是一个原生的 Docker 集群管理工具，支持容器的跨宿主节点的集群管理。</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token comment\" spellcheck=\"true\"># 拉取 Docker Swarm 镜像；</span>\n<span class=\"token function\">sudo</span> docker pull swarm\n\n<span class=\"token comment\" spellcheck=\"true\"># 初始化主节点；</span>\n<span class=\"token function\">sudo</span> docker swarm init --advertise-addr <span class=\"token operator\">&lt;</span>manager-ip<span class=\"token operator\">></span>\n<span class=\"token function\">sudo</span> docker info\n<span class=\"token function\">sudo</span> docker node <span class=\"token function\">ls</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 设置从节点；</span>\n<span class=\"token punctuation\">(</span>Optional<span class=\"token punctuation\">)</span> <span class=\"token function\">sudo</span> docker swarm <span class=\"token function\">join</span> --token <span class=\"token operator\">&lt;</span>token<span class=\"token operator\">></span> 127.0.0.1:2377\n\n\n<span class=\"token comment\" spellcheck=\"true\"># 创建服务；</span>\n<span class=\"token function\">sudo</span> docker <span class=\"token function\">service</span> create --replicas 1 --name <span class=\"token operator\">&lt;</span>name<span class=\"token operator\">></span> -p <span class=\"token operator\">&lt;</span>local<span class=\"token operator\">></span>:<span class=\"token operator\">&lt;</span>remote<span class=\"token operator\">></span> -e <span class=\"token string\">\"ENV_PASS=yue.lu\"</span> -t <span class=\"token operator\">&lt;</span>image<span class=\"token operator\">></span>\n\n\n<span class=\"token function\">sudo</span> docker <span class=\"token function\">service</span> <span class=\"token function\">ls</span>\n<span class=\"token function\">sudo</span> docker <span class=\"token function\">service</span> inspect <span class=\"token operator\">&lt;</span>name<span class=\"token operator\">></span>\n<span class=\"token function\">sudo</span> docker <span class=\"token function\">service</span> <span class=\"token function\">rm</span> <span class=\"token operator\">&lt;</span>name<span class=\"token operator\">></span>\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"4、Kubernetes：\"><a href=\"#4、Kubernetes：\" class=\"headerlink\" title=\"4、Kubernetes：\"></a>4、Kubernetes：</h4><p>Kubernetes是一个开放源代码系统，用于跨多个主机来管理 Docker 化等应用程序，为应用程序的部署，维护和扩展提供基本的功能。我们这里使用 Minikube 在本地创建一个单节点单 Kubernetes 集群，同时使用 <code>kubectl</code> 命令行工具来管理 Kubernetes 集群（kubectl 是一个用于操作 Kubernetes 集群的命令行接口）。</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token comment\" spellcheck=\"true\"># 首先安装 kubectl 命令行工具；</span>\ncurl -LO https://storage.googleapis.com/kubernetes-release/release/<span class=\"token variable\"><span class=\"token variable\">$(</span>curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt<span class=\"token variable\">)</span></span>/bin/linux/amd64/kubectl\n<span class=\"token function\">chmod</span> +x ./kubectl\n<span class=\"token function\">sudo</span> <span class=\"token function\">mv</span> ./kubectl /usr/local/bin/kubectl\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token comment\" spellcheck=\"true\"># 可选的本机单集群；</span>\n<span class=\"token comment\" spellcheck=\"true\"># https://github.com/kubernetes/minikube</span>\ncurl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">chmod</span> +x minikube <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">sudo</span> <span class=\"token function\">mv</span> minikube /usr/local/bin/\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\">minikube version\nminikube start\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>安装依赖 VirtualBox（由于 ECS 等云服务器本身即基于虚拟化的产品，因此并不能在 ECS 等产品上再使用嵌套的虚拟化服务 /proc/xen）。</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token function\">cd</span> /etc/yum.repos.d/\n<span class=\"token function\">wget</span> http://download.virtualbox.org/virtualbox/rpm/rhel/virtualbox.repo\nyum update\nyum <span class=\"token function\">install</span> binutils qt gcc <span class=\"token function\">make</span> patch libgomp glibc-headers glibc-devel kernel-headers kernel-devel dkms\n<span class=\"token function\">export</span> KERN_DIR<span class=\"token operator\">=</span>/usr/src/kernels/<span class=\"token operator\">&lt;</span>kernels_version<span class=\"token operator\">></span>\nyum <span class=\"token function\">install</span> VirtualBox-5.2\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\">kubectl run <span class=\"token operator\">&lt;</span>name<span class=\"token operator\">></span> --image<span class=\"token operator\">=</span><span class=\"token operator\">&lt;</span>image<span class=\"token operator\">></span>\nkubectl get pods\nkubectl expose deployment <span class=\"token operator\">&lt;</span>name<span class=\"token operator\">></span> --port <span class=\"token operator\">&lt;</span>port<span class=\"token operator\">></span> --type LoadBalancer\nkubectl get services\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>通过配置文件来创建 Pods，Pods 是一个或一组容器的集合，每一个 Pods 对应于一个逻辑上的应用程序。Pods 内部还有 Volumes，这些 Volumes 组成了该 Pods 的数据层。整个 Pods 共享一个网络命名空间（IP），内部的容器和 Volumes 之间可以相互访问。</p>\n<p><img src=\"1.png\" alt></p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token comment\" spellcheck=\"true\"># pods.yaml</span>\napiVersion: v1\nkind: Pod\nmetadata:\n  name: monolith\n  labels:\n    app: monolith\nspec:\n  containers:\n    - name: monolith\n      image: udacity/example-monolith:1.0.0\n      args:\n        - <span class=\"token string\">\"-http=0.0.0.0:80\"</span>\n        - <span class=\"token string\">\"-health=0.0.0.0:81\"</span>\n        - <span class=\"token string\">\"-secret=secret\"</span>\n      ports:\n        - name: http\n          containerPort: 80\n        - name: health\n          containerPort: 81\n      resources:\n        limits:\n          cpu: 0.2\n          memory: <span class=\"token string\">\"10Mi\"</span>\n      livenessProbe:\n        httpGet:\n          path: /healthz\n          port: 81\n          scheme: HTTP\n        initialDelaySeconds: 5\n        periodSeconds: 15\n        timeoutSeconds: 5\n      readinessProbe:\n        httpGet:\n          path: /readiness\n          port: 81\n          scheme: HTTP\n        initialDelaySeconds: 5\n        timeoutSeconds: 1\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\">kubectl create -f pods.yaml\nkubectl get pods\nkubectl describe pods monolith\n\nkubectl port-forward monolith 10080:80 <span class=\"token comment\" spellcheck=\"true\"># 端口代理；</span>\nkubectl logs monolith\nkubectl <span class=\"token function\">exec</span> monolith --stdin --tty -c monolith /bin/sh <span class=\"token comment\" spellcheck=\"true\"># 打开一个与 Pods 进行交互的终端；</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>Docker 常用命令总结：</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token comment\" spellcheck=\"true\"># remove exited containers:</span>\ndocker <span class=\"token function\">ps</span> --filter status<span class=\"token operator\">=</span>dead --filter status<span class=\"token operator\">=</span>exited -aq <span class=\"token operator\">|</span> <span class=\"token function\">xargs</span> -r docker <span class=\"token function\">rm</span> -v\n\n<span class=\"token comment\" spellcheck=\"true\"># remove unused images:</span>\ndocker images --no-trunc <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> <span class=\"token string\">'&lt;none>'</span> <span class=\"token operator\">|</span> <span class=\"token function\">awk</span> <span class=\"token string\">'{ print <span class=\"token variable\">$3</span> }'</span> <span class=\"token operator\">|</span> <span class=\"token function\">xargs</span> -r docker rmi\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"id":"735484af63d3af597c0d252019506354","excerpt":"","more":"<p>本篇将讨论 Docker 用于构建微服务的相关实践。如何将 Docker 用于生产环境，并且构建一个更复杂的多容器应用？同时利用链接和卷等 Docker 特性来管理 Docker 中的应用，以及 Docker 集群等。</p>\n<h4 id=\"1、Docker-Compose：\"><a href=\"#1、Docker-Compose：\" class=\"headerlink\" title=\"1、Docker Compose：\"></a>1、Docker Compose：</h4><p>Docker Compose 可以进行简单的容器编排，将容器服务化。安装 Docker Compose。</p>\n<pre><code class=\"bash\"># 安装 Docker Compose；\nsudo curl -L https://github.com/docker/compose/releases/download/1.17.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose\nsudo chmod +x /usr/local/bin/docker-compose\ndocker-compose --version\n</code></pre>\n<p>编写 Dockerfile 以及应用程序相关的文件。</p>\n<pre><code class=\"bash\"># Dockerfile；\nFROM python:2.7\nMAINTAINER YHSPY &lt;yhorg@hotmail.com&gt;\nENV REFRESHED_AT 20167-11-09\nADD . /composeapp\nWORKDIR /composeapp\nRUN pip install -r requirements.txt\n\n# Application(app.py/requirements.txt)；\n...\n</code></pre>\n<p>编写 docker-compose.yml 配置 Docker Compose 来创建服务。</p>\n<pre><code class=\"bash\">version: &#39;3&#39;\nservices:\n  web:\n    image: jamtur01/composeapp\n    command: python app.py\n    ports:\n     - &quot;5000:5000&quot;\n    volumes:\n     - .:/composeapp\n    links:\n     - redis\n  redis:\n    image: redis\n</code></pre>\n<p>运行服务。</p>\n<pre><code class=\"bash\">docker-compose up\ndocker-compose logs\ndocker-compose stop\ndocker-compose kill\ndocker-compose rm\ndocker-compose ps\n</code></pre>\n<h4 id=\"2、Consul、服务发现和-Docker：\"><a href=\"#2、Consul、服务发现和-Docker：\" class=\"headerlink\" title=\"2、Consul、服务发现和 Docker：\"></a>2、Consul、服务发现和 Docker：</h4><p>（待补充）</p>\n<h4 id=\"3、Docker-Swarm：\"><a href=\"#3、Docker-Swarm：\" class=\"headerlink\" title=\"3、Docker Swarm：\"></a>3、Docker Swarm：</h4><p>Docker Swarm 是一个原生的 Docker 集群管理工具，支持容器的跨宿主节点的集群管理。</p>\n<pre><code class=\"bash\"># 拉取 Docker Swarm 镜像；\nsudo docker pull swarm\n\n# 初始化主节点；\nsudo docker swarm init --advertise-addr &lt;manager-ip&gt;\nsudo docker info\nsudo docker node ls\n\n# 设置从节点；\n(Optional) sudo docker swarm join --token &lt;token&gt; 127.0.0.1:2377\n\n\n# 创建服务；\nsudo docker service create --replicas 1 --name &lt;name&gt; -p &lt;local&gt;:&lt;remote&gt; -e &quot;ENV_PASS=yue.lu&quot; -t &lt;image&gt;\n\n\nsudo docker service ls\nsudo docker service inspect &lt;name&gt;\nsudo docker service rm &lt;name&gt;\n\n</code></pre>\n<h4 id=\"4、Kubernetes：\"><a href=\"#4、Kubernetes：\" class=\"headerlink\" title=\"4、Kubernetes：\"></a>4、Kubernetes：</h4><p>Kubernetes是一个开放源代码系统，用于跨多个主机来管理 Docker 化等应用程序，为应用程序的部署，维护和扩展提供基本的功能。我们这里使用 Minikube 在本地创建一个单节点单 Kubernetes 集群，同时使用 <code>kubectl</code> 命令行工具来管理 Kubernetes 集群（kubectl 是一个用于操作 Kubernetes 集群的命令行接口）。</p>\n<pre><code class=\"bash\"># 首先安装 kubectl 命令行工具；\ncurl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl\nchmod +x ./kubectl\nsudo mv ./kubectl /usr/local/bin/kubectl\n</code></pre>\n<pre><code class=\"bash\"># 可选的本机单集群；\n# https://github.com/kubernetes/minikube\ncurl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 &amp;&amp; chmod +x minikube &amp;&amp; sudo mv minikube /usr/local/bin/\n</code></pre>\n<pre><code class=\"bash\">minikube version\nminikube start\n</code></pre>\n<p>安装依赖 VirtualBox（由于 ECS 等云服务器本身即基于虚拟化的产品，因此并不能在 ECS 等产品上再使用嵌套的虚拟化服务 /proc/xen）。</p>\n<pre><code class=\"bash\">cd /etc/yum.repos.d/\nwget http://download.virtualbox.org/virtualbox/rpm/rhel/virtualbox.repo\nyum update\nyum install binutils qt gcc make patch libgomp glibc-headers glibc-devel kernel-headers kernel-devel dkms\nexport KERN_DIR=/usr/src/kernels/&lt;kernels_version&gt;\nyum install VirtualBox-5.2\n</code></pre>\n<pre><code class=\"bash\">kubectl run &lt;name&gt; --image=&lt;image&gt;\nkubectl get pods\nkubectl expose deployment &lt;name&gt; --port &lt;port&gt; --type LoadBalancer\nkubectl get services\n</code></pre>\n<p>通过配置文件来创建 Pods，Pods 是一个或一组容器的集合，每一个 Pods 对应于一个逻辑上的应用程序。Pods 内部还有 Volumes，这些 Volumes 组成了该 Pods 的数据层。整个 Pods 共享一个网络命名空间（IP），内部的容器和 Volumes 之间可以相互访问。</p>\n<p><img src=\"1.png\" alt></p>\n<pre><code class=\"bash\"># pods.yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: monolith\n  labels:\n    app: monolith\nspec:\n  containers:\n    - name: monolith\n      image: udacity/example-monolith:1.0.0\n      args:\n        - &quot;-http=0.0.0.0:80&quot;\n        - &quot;-health=0.0.0.0:81&quot;\n        - &quot;-secret=secret&quot;\n      ports:\n        - name: http\n          containerPort: 80\n        - name: health\n          containerPort: 81\n      resources:\n        limits:\n          cpu: 0.2\n          memory: &quot;10Mi&quot;\n      livenessProbe:\n        httpGet:\n          path: /healthz\n          port: 81\n          scheme: HTTP\n        initialDelaySeconds: 5\n        periodSeconds: 15\n        timeoutSeconds: 5\n      readinessProbe:\n        httpGet:\n          path: /readiness\n          port: 81\n          scheme: HTTP\n        initialDelaySeconds: 5\n        timeoutSeconds: 1\n</code></pre>\n<pre><code class=\"bash\">kubectl create -f pods.yaml\nkubectl get pods\nkubectl describe pods monolith\n\nkubectl port-forward monolith 10080:80 # 端口代理；\nkubectl logs monolith\nkubectl exec monolith --stdin --tty -c monolith /bin/sh # 打开一个与 Pods 进行交互的终端；\n</code></pre>\n<p>Docker 常用命令总结：</p>\n<pre><code class=\"bash\"># remove exited containers:\ndocker ps --filter status=dead --filter status=exited -aq | xargs -r docker rm -v\n\n# remove unused images:\ndocker images --no-trunc | grep &#39;&lt;none&gt;&#39; | awk &#39;{ print $3 }&#39; | xargs -r docker rmi\n</code></pre>\n"},{"title":"Docker 最佳实践（二）","intro":"接着上一篇文章，我们继续深入了解并学习关于 Docker 的基础知识以及相关基于 Docker 实现的典型架构解决方案。Docker 在协调线下／上多环境开发等场景下有着其独特的优势。","comments":1,"date":"2017-11-07T05:52:09.000Z","_content":"\n\n接着上一篇文章，我们继续深入了解并学习关于 Docker 的基础知识以及相关基于 Docker 实现的典型架构解决方案。Docker 在协调线下／上多环境开发等场景下有着其独特的优势。\n\n#### 1、Docker 作为本地开发环境：\n\n编写 Dockerfile 文件：\n\n\n```bash\n# Dockerfile\nFROM ubuntu:14.04\nMAINTAINER YHSPY \"yhorg@hotmail.com\"\nENV REFRESHED_AT 2017-11-06\nRUN apt-get -yqq update && apt-get -yqq install nginx # 安装 Nginx；\nRUN mkdir -p /var/www/html/website # 容器内创建文件夹；\nADD nginx/global.conf /etc/nginx/conf.d/ # 复制本地配置文件到镜像中；\nADD nginx/nginx.conf /etc/nginx/nginx.conf \nEXPOSE 80 # 打开 80 端口；\n```\n\n构建镜像：\n\n\n```bash\ndocker build -t becavalier/nginx\n```\n\n通过镜像来构建可用容器：\n\n\n```bash\n# 运行容器，并使用 `-v` 参数来挂载本地目录到容器卷，卷可以在容器间进行共享；\ndocker run -d -p 80 --name=\"website\" -v $PWD/website:/var/www/html/website:rw becavalier/nginx nginx\n# 常用于多个不同的系统环境，多个不同的框架环境，多个不同的运行环境，公用同一份代码；\n```\n\n#### 2、基于 Docker 的微服务容器关联：\n\n![](1.png)\n\n```bash\nip a show docker0 # docker0 网络接口，docker0 是一个虚拟的以太网桥，用来连接容器和本地宿主网络；\n```\n\nDocker 每创建一个容器就会创建一组互联的网络接口，两端分别连接容器里的 eth0 接口和宿主机的 veth* 接口，这些所有的 veth* 接口最后会被绑定到 docker0 的网桥上。\n\n![](2.png)\n\n如果我们在容器内通过 `traceroute` 来跟踪一个 TCP 请求的路由节点，会发现所有在容器内发送的请求都会先发送到由 docker0 创建的虚拟子网的网关地址上。\n\n![](3.png)\n\n1. **通过硬编码 IP 地址进行 Docker 容器之间的互联（如何访问 Container1 的 Http 服务）**：\n\n![](4.png)\n\n2. **通过 Docker Networking（Docker V1.9 以上）**：\n\nDocker Networking 会自动更新各个容器内的 /etc/hosts 文件来保证各个容器的 IP 准确。\n\n\n```bash\ndocker network create app # 创建一个桥接网络；\ndocker network inspect app # 查看桥接网络；\ndocker network ls # 列出所有网络；\ndocker network rm <network> # 删除一个桥接网络；\ndocker network connect <network> <container> # 将已有容器加入到网络；\n\n\n# 在运行容器时指定加入的桥接网络；\ndocker run -d --net=app --name=static_web becavalier/static_web\n\n# 在桥接网络内的容器通过以下方式即可互相访问；\nping <network>.<container>\n```\n\n3. **通过 Docker 链接（Docker V1.9 以下推荐）**：\n\nDocker 容器的名字是唯一的。使用 Docker 链接创建的容器建交互接口是安全，并且不对外开放的。\n\n\n```bash\n# 启动“服务”方；\ndocker run -d --name redis becavalier/redis\n# “客户” 链接 “服务”；\ndocker run -p 4567 --name webapp --link redis:db -t -i -v ...\n```\n\n#### 3、Docker 用于 CI：\n\n构建运行 Docker 的 Jenkins 服务器 -> Docker 递归（Docker in Docker）运行。\n\n\n```bash\n# 用于构建 Jenkins 的 Dockerfile；\nFROM ubuntu:14.04\nMAINTAINER yhorg@hotmail.com\nENV REFRESHED_AT 2017-11-09\nRUN apt-get update -qq && apt-get install -qqy curl apt-transport \n-https\nRUN apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 \n...\nVOLUME /var/lib/docker # Docker 用来存储容器的目录；\n...\n```\n\n\n```bash\n# 创建 Docker-Jenkins 容器；\n# --privileged 标志给予 Docker-Jenkins 足够的权限；\ndocker run -p 8080:8080 --name=jenkins --privileged -d becavalier_jenkins\n```\n","source":"_posts/Docker-最佳实践（二）.md","raw":"---\ntitle: Docker 最佳实践（二）\nintro: 接着上一篇文章，我们继续深入了解并学习关于 Docker 的基础知识以及相关基于 Docker 实现的典型架构解决方案。Docker 在协调线下／上多环境开发等场景下有着其独特的优势。\ncomments: true\ndate: 2017-11-07 13:52:09\ntags:\n- Docker\n---\n\n\n接着上一篇文章，我们继续深入了解并学习关于 Docker 的基础知识以及相关基于 Docker 实现的典型架构解决方案。Docker 在协调线下／上多环境开发等场景下有着其独特的优势。\n\n#### 1、Docker 作为本地开发环境：\n\n编写 Dockerfile 文件：\n\n\n```bash\n# Dockerfile\nFROM ubuntu:14.04\nMAINTAINER YHSPY \"yhorg@hotmail.com\"\nENV REFRESHED_AT 2017-11-06\nRUN apt-get -yqq update && apt-get -yqq install nginx # 安装 Nginx；\nRUN mkdir -p /var/www/html/website # 容器内创建文件夹；\nADD nginx/global.conf /etc/nginx/conf.d/ # 复制本地配置文件到镜像中；\nADD nginx/nginx.conf /etc/nginx/nginx.conf \nEXPOSE 80 # 打开 80 端口；\n```\n\n构建镜像：\n\n\n```bash\ndocker build -t becavalier/nginx\n```\n\n通过镜像来构建可用容器：\n\n\n```bash\n# 运行容器，并使用 `-v` 参数来挂载本地目录到容器卷，卷可以在容器间进行共享；\ndocker run -d -p 80 --name=\"website\" -v $PWD/website:/var/www/html/website:rw becavalier/nginx nginx\n# 常用于多个不同的系统环境，多个不同的框架环境，多个不同的运行环境，公用同一份代码；\n```\n\n#### 2、基于 Docker 的微服务容器关联：\n\n![](1.png)\n\n```bash\nip a show docker0 # docker0 网络接口，docker0 是一个虚拟的以太网桥，用来连接容器和本地宿主网络；\n```\n\nDocker 每创建一个容器就会创建一组互联的网络接口，两端分别连接容器里的 eth0 接口和宿主机的 veth* 接口，这些所有的 veth* 接口最后会被绑定到 docker0 的网桥上。\n\n![](2.png)\n\n如果我们在容器内通过 `traceroute` 来跟踪一个 TCP 请求的路由节点，会发现所有在容器内发送的请求都会先发送到由 docker0 创建的虚拟子网的网关地址上。\n\n![](3.png)\n\n1. **通过硬编码 IP 地址进行 Docker 容器之间的互联（如何访问 Container1 的 Http 服务）**：\n\n![](4.png)\n\n2. **通过 Docker Networking（Docker V1.9 以上）**：\n\nDocker Networking 会自动更新各个容器内的 /etc/hosts 文件来保证各个容器的 IP 准确。\n\n\n```bash\ndocker network create app # 创建一个桥接网络；\ndocker network inspect app # 查看桥接网络；\ndocker network ls # 列出所有网络；\ndocker network rm <network> # 删除一个桥接网络；\ndocker network connect <network> <container> # 将已有容器加入到网络；\n\n\n# 在运行容器时指定加入的桥接网络；\ndocker run -d --net=app --name=static_web becavalier/static_web\n\n# 在桥接网络内的容器通过以下方式即可互相访问；\nping <network>.<container>\n```\n\n3. **通过 Docker 链接（Docker V1.9 以下推荐）**：\n\nDocker 容器的名字是唯一的。使用 Docker 链接创建的容器建交互接口是安全，并且不对外开放的。\n\n\n```bash\n# 启动“服务”方；\ndocker run -d --name redis becavalier/redis\n# “客户” 链接 “服务”；\ndocker run -p 4567 --name webapp --link redis:db -t -i -v ...\n```\n\n#### 3、Docker 用于 CI：\n\n构建运行 Docker 的 Jenkins 服务器 -> Docker 递归（Docker in Docker）运行。\n\n\n```bash\n# 用于构建 Jenkins 的 Dockerfile；\nFROM ubuntu:14.04\nMAINTAINER yhorg@hotmail.com\nENV REFRESHED_AT 2017-11-09\nRUN apt-get update -qq && apt-get install -qqy curl apt-transport \n-https\nRUN apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 \n...\nVOLUME /var/lib/docker # Docker 用来存储容器的目录；\n...\n```\n\n\n```bash\n# 创建 Docker-Jenkins 容器；\n# --privileged 标志给予 Docker-Jenkins 足够的权限；\ndocker run -p 8080:8080 --name=jenkins --privileged -d becavalier_jenkins\n```\n","slug":"Docker-最佳实践（二）","published":1,"updated":"2019-02-20T05:54:20.051Z","layout":"post","photos":[],"link":"","_id":"cjsqwht7g000iknp23mxywy9r","content":"<p>接着上一篇文章，我们继续深入了解并学习关于 Docker 的基础知识以及相关基于 Docker 实现的典型架构解决方案。Docker 在协调线下／上多环境开发等场景下有着其独特的优势。</p>\n<h4 id=\"1、Docker-作为本地开发环境：\"><a href=\"#1、Docker-作为本地开发环境：\" class=\"headerlink\" title=\"1、Docker 作为本地开发环境：\"></a>1、Docker 作为本地开发环境：</h4><p>编写 Dockerfile 文件：</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token comment\" spellcheck=\"true\"># Dockerfile</span>\nFROM ubuntu:14.04\nMAINTAINER YHSPY <span class=\"token string\">\"yhorg@hotmail.com\"</span>\nENV REFRESHED_AT 2017-11-06\nRUN <span class=\"token function\">apt-get</span> -yqq update <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">apt-get</span> -yqq <span class=\"token function\">install</span> nginx <span class=\"token comment\" spellcheck=\"true\"># 安装 Nginx；</span>\nRUN <span class=\"token function\">mkdir</span> -p /var/www/html/website <span class=\"token comment\" spellcheck=\"true\"># 容器内创建文件夹；</span>\nADD nginx/global.conf /etc/nginx/conf.d/ <span class=\"token comment\" spellcheck=\"true\"># 复制本地配置文件到镜像中；</span>\nADD nginx/nginx.conf /etc/nginx/nginx.conf \nEXPOSE 80 <span class=\"token comment\" spellcheck=\"true\"># 打开 80 端口；</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>构建镜像：</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\">docker build -t becavalier/nginx\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>通过镜像来构建可用容器：</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token comment\" spellcheck=\"true\"># 运行容器，并使用 `-v` 参数来挂载本地目录到容器卷，卷可以在容器间进行共享；</span>\ndocker run -d -p 80 --name<span class=\"token operator\">=</span><span class=\"token string\">\"website\"</span> -v <span class=\"token variable\">$PWD</span>/website:/var/www/html/website:rw becavalier/nginx nginx\n<span class=\"token comment\" spellcheck=\"true\"># 常用于多个不同的系统环境，多个不同的框架环境，多个不同的运行环境，公用同一份代码；</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"2、基于-Docker-的微服务容器关联：\"><a href=\"#2、基于-Docker-的微服务容器关联：\" class=\"headerlink\" title=\"2、基于 Docker 的微服务容器关联：\"></a>2、基于 Docker 的微服务容器关联：</h4><p><img src=\"1.png\" alt></p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\">ip a show docker0 <span class=\"token comment\" spellcheck=\"true\"># docker0 网络接口，docker0 是一个虚拟的以太网桥，用来连接容器和本地宿主网络；</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>Docker 每创建一个容器就会创建一组互联的网络接口，两端分别连接容器里的 eth0 接口和宿主机的 veth<em> 接口，这些所有的 veth</em> 接口最后会被绑定到 docker0 的网桥上。</p>\n<p><img src=\"2.png\" alt></p>\n<p>如果我们在容器内通过 <code>traceroute</code> 来跟踪一个 TCP 请求的路由节点，会发现所有在容器内发送的请求都会先发送到由 docker0 创建的虚拟子网的网关地址上。</p>\n<p><img src=\"3.png\" alt></p>\n<ol>\n<li><strong>通过硬编码 IP 地址进行 Docker 容器之间的互联（如何访问 Container1 的 Http 服务）</strong>：</li>\n</ol>\n<p><img src=\"4.png\" alt></p>\n<ol start=\"2\">\n<li><strong>通过 Docker Networking（Docker V1.9 以上）</strong>：</li>\n</ol>\n<p>Docker Networking 会自动更新各个容器内的 /etc/hosts 文件来保证各个容器的 IP 准确。</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\">docker network create app <span class=\"token comment\" spellcheck=\"true\"># 创建一个桥接网络；</span>\ndocker network inspect app <span class=\"token comment\" spellcheck=\"true\"># 查看桥接网络；</span>\ndocker network <span class=\"token function\">ls</span> <span class=\"token comment\" spellcheck=\"true\"># 列出所有网络；</span>\ndocker network <span class=\"token function\">rm</span> <span class=\"token operator\">&lt;</span>network<span class=\"token operator\">></span> <span class=\"token comment\" spellcheck=\"true\"># 删除一个桥接网络；</span>\ndocker network connect <span class=\"token operator\">&lt;</span>network<span class=\"token operator\">></span> <span class=\"token operator\">&lt;</span>container<span class=\"token operator\">></span> <span class=\"token comment\" spellcheck=\"true\"># 将已有容器加入到网络；</span>\n\n\n<span class=\"token comment\" spellcheck=\"true\"># 在运行容器时指定加入的桥接网络；</span>\ndocker run -d --net<span class=\"token operator\">=</span>app --name<span class=\"token operator\">=</span>static_web becavalier/static_web\n\n<span class=\"token comment\" spellcheck=\"true\"># 在桥接网络内的容器通过以下方式即可互相访问；</span>\n<span class=\"token function\">ping</span> <span class=\"token operator\">&lt;</span>network<span class=\"token operator\">></span>.<span class=\"token operator\">&lt;</span>container<span class=\"token operator\">></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ol start=\"3\">\n<li><strong>通过 Docker 链接（Docker V1.9 以下推荐）</strong>：</li>\n</ol>\n<p>Docker 容器的名字是唯一的。使用 Docker 链接创建的容器建交互接口是安全，并且不对外开放的。</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token comment\" spellcheck=\"true\"># 启动“服务”方；</span>\ndocker run -d --name redis becavalier/redis\n<span class=\"token comment\" spellcheck=\"true\"># “客户” 链接 “服务”；</span>\ndocker run -p 4567 --name webapp --link redis:db -t -i -v <span class=\"token punctuation\">..</span>.\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"3、Docker-用于-CI：\"><a href=\"#3、Docker-用于-CI：\" class=\"headerlink\" title=\"3、Docker 用于 CI：\"></a>3、Docker 用于 CI：</h4><p>构建运行 Docker 的 Jenkins 服务器 -&gt; Docker 递归（Docker in Docker）运行。</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token comment\" spellcheck=\"true\"># 用于构建 Jenkins 的 Dockerfile；</span>\nFROM ubuntu:14.04\nMAINTAINER yhorg@hotmail.com\nENV REFRESHED_AT 2017-11-09\nRUN <span class=\"token function\">apt-get</span> update -qq <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> -qqy curl apt-transport \n-https\nRUN apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 \n<span class=\"token punctuation\">..</span>.\nVOLUME /var/lib/docker <span class=\"token comment\" spellcheck=\"true\"># Docker 用来存储容器的目录；</span>\n<span class=\"token punctuation\">..</span>.\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token comment\" spellcheck=\"true\"># 创建 Docker-Jenkins 容器；</span>\n<span class=\"token comment\" spellcheck=\"true\"># --privileged 标志给予 Docker-Jenkins 足够的权限；</span>\ndocker run -p 8080:8080 --name<span class=\"token operator\">=</span>jenkins --privileged -d becavalier_jenkins\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"id":"9dae5e272294cac673f5a8a492eb01a9","excerpt":"","more":"<p>接着上一篇文章，我们继续深入了解并学习关于 Docker 的基础知识以及相关基于 Docker 实现的典型架构解决方案。Docker 在协调线下／上多环境开发等场景下有着其独特的优势。</p>\n<h4 id=\"1、Docker-作为本地开发环境：\"><a href=\"#1、Docker-作为本地开发环境：\" class=\"headerlink\" title=\"1、Docker 作为本地开发环境：\"></a>1、Docker 作为本地开发环境：</h4><p>编写 Dockerfile 文件：</p>\n<pre><code class=\"bash\"># Dockerfile\nFROM ubuntu:14.04\nMAINTAINER YHSPY &quot;yhorg@hotmail.com&quot;\nENV REFRESHED_AT 2017-11-06\nRUN apt-get -yqq update &amp;&amp; apt-get -yqq install nginx # 安装 Nginx；\nRUN mkdir -p /var/www/html/website # 容器内创建文件夹；\nADD nginx/global.conf /etc/nginx/conf.d/ # 复制本地配置文件到镜像中；\nADD nginx/nginx.conf /etc/nginx/nginx.conf \nEXPOSE 80 # 打开 80 端口；\n</code></pre>\n<p>构建镜像：</p>\n<pre><code class=\"bash\">docker build -t becavalier/nginx\n</code></pre>\n<p>通过镜像来构建可用容器：</p>\n<pre><code class=\"bash\"># 运行容器，并使用 `-v` 参数来挂载本地目录到容器卷，卷可以在容器间进行共享；\ndocker run -d -p 80 --name=&quot;website&quot; -v $PWD/website:/var/www/html/website:rw becavalier/nginx nginx\n# 常用于多个不同的系统环境，多个不同的框架环境，多个不同的运行环境，公用同一份代码；\n</code></pre>\n<h4 id=\"2、基于-Docker-的微服务容器关联：\"><a href=\"#2、基于-Docker-的微服务容器关联：\" class=\"headerlink\" title=\"2、基于 Docker 的微服务容器关联：\"></a>2、基于 Docker 的微服务容器关联：</h4><p><img src=\"1.png\" alt></p>\n<pre><code class=\"bash\">ip a show docker0 # docker0 网络接口，docker0 是一个虚拟的以太网桥，用来连接容器和本地宿主网络；\n</code></pre>\n<p>Docker 每创建一个容器就会创建一组互联的网络接口，两端分别连接容器里的 eth0 接口和宿主机的 veth<em> 接口，这些所有的 veth</em> 接口最后会被绑定到 docker0 的网桥上。</p>\n<p><img src=\"2.png\" alt></p>\n<p>如果我们在容器内通过 <code>traceroute</code> 来跟踪一个 TCP 请求的路由节点，会发现所有在容器内发送的请求都会先发送到由 docker0 创建的虚拟子网的网关地址上。</p>\n<p><img src=\"3.png\" alt></p>\n<ol>\n<li><strong>通过硬编码 IP 地址进行 Docker 容器之间的互联（如何访问 Container1 的 Http 服务）</strong>：</li>\n</ol>\n<p><img src=\"4.png\" alt></p>\n<ol start=\"2\">\n<li><strong>通过 Docker Networking（Docker V1.9 以上）</strong>：</li>\n</ol>\n<p>Docker Networking 会自动更新各个容器内的 /etc/hosts 文件来保证各个容器的 IP 准确。</p>\n<pre><code class=\"bash\">docker network create app # 创建一个桥接网络；\ndocker network inspect app # 查看桥接网络；\ndocker network ls # 列出所有网络；\ndocker network rm &lt;network&gt; # 删除一个桥接网络；\ndocker network connect &lt;network&gt; &lt;container&gt; # 将已有容器加入到网络；\n\n\n# 在运行容器时指定加入的桥接网络；\ndocker run -d --net=app --name=static_web becavalier/static_web\n\n# 在桥接网络内的容器通过以下方式即可互相访问；\nping &lt;network&gt;.&lt;container&gt;\n</code></pre>\n<ol start=\"3\">\n<li><strong>通过 Docker 链接（Docker V1.9 以下推荐）</strong>：</li>\n</ol>\n<p>Docker 容器的名字是唯一的。使用 Docker 链接创建的容器建交互接口是安全，并且不对外开放的。</p>\n<pre><code class=\"bash\"># 启动“服务”方；\ndocker run -d --name redis becavalier/redis\n# “客户” 链接 “服务”；\ndocker run -p 4567 --name webapp --link redis:db -t -i -v ...\n</code></pre>\n<h4 id=\"3、Docker-用于-CI：\"><a href=\"#3、Docker-用于-CI：\" class=\"headerlink\" title=\"3、Docker 用于 CI：\"></a>3、Docker 用于 CI：</h4><p>构建运行 Docker 的 Jenkins 服务器 -&gt; Docker 递归（Docker in Docker）运行。</p>\n<pre><code class=\"bash\"># 用于构建 Jenkins 的 Dockerfile；\nFROM ubuntu:14.04\nMAINTAINER yhorg@hotmail.com\nENV REFRESHED_AT 2017-11-09\nRUN apt-get update -qq &amp;&amp; apt-get install -qqy curl apt-transport \n-https\nRUN apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 \n...\nVOLUME /var/lib/docker # Docker 用来存储容器的目录；\n...\n</code></pre>\n<pre><code class=\"bash\"># 创建 Docker-Jenkins 容器；\n# --privileged 标志给予 Docker-Jenkins 足够的权限；\ndocker run -p 8080:8080 --name=jenkins --privileged -d becavalier_jenkins\n</code></pre>\n"},{"title":"ECMAScript6 新特性 - 迭代器和 for-of 循环","intro":"ECMAScript6 已经正式发布了一段时间了，作为一个前端开发者，是时候体验一下最新的 JavaScript 特性与改进了。相比 ECMA5 天花乱坠的改动，ECMA6 显得更加实用与稳重。今天让我来看一下其中第一个重要的新特性 - 迭代器与 “for-of” 循环。","comments":1,"date":"2016-01-08T08:32:54.000Z","_content":"\nECMAScript6 已经正式发布了一段时间了，作为一个前端开发者，是时候体验一下最新的 JavaScript 特性与改进了。相比 ECMA5 天花乱坠的改动，ECMA6 显得更加实用与稳重。今天让我来看一下其中第一个重要的新特性 - 迭代器与 “for-of” 循环。\n\n在 ECMAScript5 中，TC39 标准委员会便加入一个内建的新方法 forEach 以用来遍历数组，其用法如下所示：\n\n```javascript\nvar myArry = new Array(\"Saab\", \"Volvo\", \"BMW\");\nmyArray.forEach(function(value) {\n  console.log(value);\n});\n```\n\n但该方法的缺点也很明显，即：\n\n1. 你不能使用 `break` 语句中断循环；\n2. 你不能使用 `return` 语句返回到外层函数；\n\n所以，在 ECMAScript6 标准中，标准委员会引入了一个新语句 “for-of” 来解决目前的尴尬问题。该语句的用法如下所示：\n\n```javascript\nfor (var value of myArray) {\n  console.log(value);\n}\n```\n\n不但如此，for-of 还可以遍历其他类型的集合，比如：字符串、Set 对象集合、Map 对象集合；\n\n```javascript\n// 遍历字符串；\nfor (var chr of \"ECMA6\") {\n  console.log(chr);\n}\n\n// 遍历 Set 对象集合；\nvar uniqueWords = new Set(words);\nfor (var word of uniqueWords) {\n  console.log(word);\n}\n\n// 遍历 Map 对象集合；\nfor (var [key, value] of phoneBookMap) {\n  console.log(key + \" phone number is: \" + value);\n}\n```\n\n但需要注意的是，for-of 不支持遍历对象的属性，如果想要遍历对象的属性请使用 for-in 方法，或者使用 ECMA6 内建的 `Object.keys()` 方法来获得属性名对象：\n\n```javascript\n// 向控制台输出对象的可枚举属性；\nfor (var key of Object.keys(someObject)) {\n  console.log(key + \": \" + someObject[key]);\n}\n```\n\n**内部技术细节**：\n\n在 ECMA5 中，所有的数组、Set 集合、Map 集合都有一个迭代器方法用来为 for-of 提供遍历帮助，for-of 循环首先调用集合的 `[Symbol.iterator]()` 方法，紧接着返回一个新的迭代器对象。迭代器对象可以是任意具有 `next()` 方法的对象；for-of 循环将重复调用这个方法，每次循环调用一次。你可以为所有的对象添加 `[Symbol.iterator]` 方法来使其支持 for-of 语句的遍历。所有可迭代对象都有类似如下的结构：\n\n```javascript\nvar zeroesForeverIterator = {\n  [Symbol.iterator]: function() {\n    return this;\n  },\n  next: function() {\n    return {done: false, value: 0};\n  }\n};\n```\n\n直接使用 for-of 语句进行遍历：\n```javascript\nfor(var chr of myArray) {\n  console.log(chr);\n}\n```\n\n通过调用其内部的迭代器进行遍历：\n```javascript\nvar $iterator = myArray[Symbol.iterator]();\nvar $result = $iterator.next();\nwhile (!$result.done) {\n  var chr = $result.value;\n  $result = $iterator.next();\n  console.log(chr);\n}\n```","source":"_posts/ECMAScript6-新特性-迭代器和-for-of-循环.md","raw":"---\ntitle: ECMAScript6 新特性 - 迭代器和 for-of 循环\nintro: ECMAScript6 已经正式发布了一段时间了，作为一个前端开发者，是时候体验一下最新的 JavaScript 特性与改进了。相比 ECMA5 天花乱坠的改动，ECMA6 显得更加实用与稳重。今天让我来看一下其中第一个重要的新特性 - 迭代器与 “for-of” 循环。\ncomments: true\ndate: 2016-01-08 16:32:54\ntags:\n- JavaScript\n---\n\nECMAScript6 已经正式发布了一段时间了，作为一个前端开发者，是时候体验一下最新的 JavaScript 特性与改进了。相比 ECMA5 天花乱坠的改动，ECMA6 显得更加实用与稳重。今天让我来看一下其中第一个重要的新特性 - 迭代器与 “for-of” 循环。\n\n在 ECMAScript5 中，TC39 标准委员会便加入一个内建的新方法 forEach 以用来遍历数组，其用法如下所示：\n\n```javascript\nvar myArry = new Array(\"Saab\", \"Volvo\", \"BMW\");\nmyArray.forEach(function(value) {\n  console.log(value);\n});\n```\n\n但该方法的缺点也很明显，即：\n\n1. 你不能使用 `break` 语句中断循环；\n2. 你不能使用 `return` 语句返回到外层函数；\n\n所以，在 ECMAScript6 标准中，标准委员会引入了一个新语句 “for-of” 来解决目前的尴尬问题。该语句的用法如下所示：\n\n```javascript\nfor (var value of myArray) {\n  console.log(value);\n}\n```\n\n不但如此，for-of 还可以遍历其他类型的集合，比如：字符串、Set 对象集合、Map 对象集合；\n\n```javascript\n// 遍历字符串；\nfor (var chr of \"ECMA6\") {\n  console.log(chr);\n}\n\n// 遍历 Set 对象集合；\nvar uniqueWords = new Set(words);\nfor (var word of uniqueWords) {\n  console.log(word);\n}\n\n// 遍历 Map 对象集合；\nfor (var [key, value] of phoneBookMap) {\n  console.log(key + \" phone number is: \" + value);\n}\n```\n\n但需要注意的是，for-of 不支持遍历对象的属性，如果想要遍历对象的属性请使用 for-in 方法，或者使用 ECMA6 内建的 `Object.keys()` 方法来获得属性名对象：\n\n```javascript\n// 向控制台输出对象的可枚举属性；\nfor (var key of Object.keys(someObject)) {\n  console.log(key + \": \" + someObject[key]);\n}\n```\n\n**内部技术细节**：\n\n在 ECMA5 中，所有的数组、Set 集合、Map 集合都有一个迭代器方法用来为 for-of 提供遍历帮助，for-of 循环首先调用集合的 `[Symbol.iterator]()` 方法，紧接着返回一个新的迭代器对象。迭代器对象可以是任意具有 `next()` 方法的对象；for-of 循环将重复调用这个方法，每次循环调用一次。你可以为所有的对象添加 `[Symbol.iterator]` 方法来使其支持 for-of 语句的遍历。所有可迭代对象都有类似如下的结构：\n\n```javascript\nvar zeroesForeverIterator = {\n  [Symbol.iterator]: function() {\n    return this;\n  },\n  next: function() {\n    return {done: false, value: 0};\n  }\n};\n```\n\n直接使用 for-of 语句进行遍历：\n```javascript\nfor(var chr of myArray) {\n  console.log(chr);\n}\n```\n\n通过调用其内部的迭代器进行遍历：\n```javascript\nvar $iterator = myArray[Symbol.iterator]();\nvar $result = $iterator.next();\nwhile (!$result.done) {\n  var chr = $result.value;\n  $result = $iterator.next();\n  console.log(chr);\n}\n```","slug":"ECMAScript6-新特性-迭代器和-for-of-循环","published":1,"updated":"2019-02-05T08:35:55.339Z","layout":"post","photos":[],"link":"","_id":"cjsqwht7h000jknp2mj2l37ir","content":"<p>ECMAScript6 已经正式发布了一段时间了，作为一个前端开发者，是时候体验一下最新的 JavaScript 特性与改进了。相比 ECMA5 天花乱坠的改动，ECMA6 显得更加实用与稳重。今天让我来看一下其中第一个重要的新特性 - 迭代器与 “for-of” 循环。</p>\n<p>在 ECMAScript5 中，TC39 标准委员会便加入一个内建的新方法 forEach 以用来遍历数组，其用法如下所示：</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> myArry <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Array</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Saab\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Volvo\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"BMW\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmyArray<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>但该方法的缺点也很明显，即：</p>\n<ol>\n<li>你不能使用 <code>break</code> 语句中断循环；</li>\n<li>你不能使用 <code>return</code> 语句返回到外层函数；</li>\n</ol>\n<p>所以，在 ECMAScript6 标准中，标准委员会引入了一个新语句 “for-of” 来解决目前的尴尬问题。该语句的用法如下所示：</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> value <span class=\"token keyword\">of</span> myArray<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>不但如此，for-of 还可以遍历其他类型的集合，比如：字符串、Set 对象集合、Map 对象集合；</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">// 遍历字符串；</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> chr <span class=\"token keyword\">of</span> <span class=\"token string\">\"ECMA6\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>chr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 遍历 Set 对象集合；</span>\n<span class=\"token keyword\">var</span> uniqueWords <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Set</span><span class=\"token punctuation\">(</span>words<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> word <span class=\"token keyword\">of</span> uniqueWords<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>word<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 遍历 Map 对象集合；</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> <span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">]</span> <span class=\"token keyword\">of</span> phoneBookMap<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>key <span class=\"token operator\">+</span> <span class=\"token string\">\" phone number is: \"</span> <span class=\"token operator\">+</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>但需要注意的是，for-of 不支持遍历对象的属性，如果想要遍历对象的属性请使用 for-in 方法，或者使用 ECMA6 内建的 <code>Object.keys()</code> 方法来获得属性名对象：</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">// 向控制台输出对象的可枚举属性；</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> key <span class=\"token keyword\">of</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">keys</span><span class=\"token punctuation\">(</span>someObject<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>key <span class=\"token operator\">+</span> <span class=\"token string\">\": \"</span> <span class=\"token operator\">+</span> someObject<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>内部技术细节</strong>：</p>\n<p>在 ECMA5 中，所有的数组、Set 集合、Map 集合都有一个迭代器方法用来为 for-of 提供遍历帮助，for-of 循环首先调用集合的 <code>[Symbol.iterator]()</code> 方法，紧接着返回一个新的迭代器对象。迭代器对象可以是任意具有 <code>next()</code> 方法的对象；for-of 循环将重复调用这个方法，每次循环调用一次。你可以为所有的对象添加 <code>[Symbol.iterator]</code> 方法来使其支持 for-of 语句的遍历。所有可迭代对象都有类似如下的结构：</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> zeroesForeverIterator <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">[</span>Symbol<span class=\"token punctuation\">.</span>iterator<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  next<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>done<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>直接使用 for-of 语句进行遍历：</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> chr <span class=\"token keyword\">of</span> myArray<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>chr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>通过调用其内部的迭代器进行遍历：</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> $iterator <span class=\"token operator\">=</span> myArray<span class=\"token punctuation\">[</span>Symbol<span class=\"token punctuation\">.</span>iterator<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> $result <span class=\"token operator\">=</span> $iterator<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>$result<span class=\"token punctuation\">.</span>done<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> chr <span class=\"token operator\">=</span> $result<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">;</span>\n  $result <span class=\"token operator\">=</span> $iterator<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>chr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"id":"20239bdbbf730f066ebe331034e380d5","excerpt":"","more":"<p>ECMAScript6 已经正式发布了一段时间了，作为一个前端开发者，是时候体验一下最新的 JavaScript 特性与改进了。相比 ECMA5 天花乱坠的改动，ECMA6 显得更加实用与稳重。今天让我来看一下其中第一个重要的新特性 - 迭代器与 “for-of” 循环。</p>\n<p>在 ECMAScript5 中，TC39 标准委员会便加入一个内建的新方法 forEach 以用来遍历数组，其用法如下所示：</p>\n<pre><code class=\"javascript\">var myArry = new Array(&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;);\nmyArray.forEach(function(value) {\n  console.log(value);\n});\n</code></pre>\n<p>但该方法的缺点也很明显，即：</p>\n<ol>\n<li>你不能使用 <code>break</code> 语句中断循环；</li>\n<li>你不能使用 <code>return</code> 语句返回到外层函数；</li>\n</ol>\n<p>所以，在 ECMAScript6 标准中，标准委员会引入了一个新语句 “for-of” 来解决目前的尴尬问题。该语句的用法如下所示：</p>\n<pre><code class=\"javascript\">for (var value of myArray) {\n  console.log(value);\n}\n</code></pre>\n<p>不但如此，for-of 还可以遍历其他类型的集合，比如：字符串、Set 对象集合、Map 对象集合；</p>\n<pre><code class=\"javascript\">// 遍历字符串；\nfor (var chr of &quot;ECMA6&quot;) {\n  console.log(chr);\n}\n\n// 遍历 Set 对象集合；\nvar uniqueWords = new Set(words);\nfor (var word of uniqueWords) {\n  console.log(word);\n}\n\n// 遍历 Map 对象集合；\nfor (var [key, value] of phoneBookMap) {\n  console.log(key + &quot; phone number is: &quot; + value);\n}\n</code></pre>\n<p>但需要注意的是，for-of 不支持遍历对象的属性，如果想要遍历对象的属性请使用 for-in 方法，或者使用 ECMA6 内建的 <code>Object.keys()</code> 方法来获得属性名对象：</p>\n<pre><code class=\"javascript\">// 向控制台输出对象的可枚举属性；\nfor (var key of Object.keys(someObject)) {\n  console.log(key + &quot;: &quot; + someObject[key]);\n}\n</code></pre>\n<p><strong>内部技术细节</strong>：</p>\n<p>在 ECMA5 中，所有的数组、Set 集合、Map 集合都有一个迭代器方法用来为 for-of 提供遍历帮助，for-of 循环首先调用集合的 <code>[Symbol.iterator]()</code> 方法，紧接着返回一个新的迭代器对象。迭代器对象可以是任意具有 <code>next()</code> 方法的对象；for-of 循环将重复调用这个方法，每次循环调用一次。你可以为所有的对象添加 <code>[Symbol.iterator]</code> 方法来使其支持 for-of 语句的遍历。所有可迭代对象都有类似如下的结构：</p>\n<pre><code class=\"javascript\">var zeroesForeverIterator = {\n  [Symbol.iterator]: function() {\n    return this;\n  },\n  next: function() {\n    return {done: false, value: 0};\n  }\n};\n</code></pre>\n<p>直接使用 for-of 语句进行遍历：</p>\n<pre><code class=\"javascript\">for(var chr of myArray) {\n  console.log(chr);\n}\n</code></pre>\n<p>通过调用其内部的迭代器进行遍历：</p>\n<pre><code class=\"javascript\">var $iterator = myArray[Symbol.iterator]();\nvar $result = $iterator.next();\nwhile (!$result.done) {\n  var chr = $result.value;\n  $result = $iterator.next();\n  console.log(chr);\n}\n</code></pre>\n"},{"title":"ES 8 新特性一览","intro":"已经脱离“前端组织”很久了，最近在看前端圈子的进展，发现 ES8 (ECMAScript2018) 已经于上个月发布了。快来看看有哪些新特性吧。2017 年前端迎来了很多东西，而从 Wasm 到 ES8，语言和技术开始走向融合，最终还是会迎来大团圆的结局。","comments":1,"date":"2017-07-06T06:06:03.000Z","_content":"\n已经脱离“前端组织”很久了，最近在看前端圈子的进展，发现 ES8 (ECMAScript2018) 已经于上个月发布了。快来看看有哪些新特性吧。2017 年前端迎来了很多东西，而从 Wasm 到 ES8，语言和技术开始走向融合，最终还是会迎来大团圆的结局。\n\n#### 1、Object.entries()：\n\n```javascript\n// 返回一个该对象对应的键值对数组，使其可以用 for-of 迭代；\nvar obj = { foo: \"bar\", baz: 42};\nconsole.log(Object.entries(obj));\n\n// 只会生成非原型链上的对象数组；\nvar obj = Object.create({}, {\n  getFoo: {\n    value: function() {\n      return this.foo;\n    }\n  }\n});\nobj.foo = \"bar\";\nconsole.log(Object.entries(obj));\n\n// 非对象参数会被强行视为对象;\nconsole.log(Object.entries(\"foo\")); \n\n// 将 Object 转化为 Map 对象；\nvar obj = { foo: \"bar\", baz: 42 }; \nvar map = new Map(Object.entries(obj));\nconsole.log(map); \n```\n\n一个对象通常都有自己的原型,所以一个对象总有一个 “prototype” 键。不过，从 ES5 开始可以使用 `var map = Object.create(null)` 来创建一个没有原型的对象。一个对象的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值。你可以通过 `size` 属性很容易地得到一个 `Map` 的键值对个数，而对象的键值对个数只能手动确认。\n\n#### 2、Object.values()：\n\n\n```javascript\n// 枚举一个对象的值列表；\nvar obj = { foo: \"bar\", baz: 42 };\nconsole.log(Object.values(obj));\n```\n\n#### 3、String.prototype.padStart() / String.prototype.padEnd()：\n\n\n```javascript\n// 从开头填充字符串（另一个从结尾）；\n'abc'.padStart(10);         // \"       abc\"；\n'abc'.padStart(10, \"foo\");  // \"foofoofabc\"；\n'abc'.padStart(6,\"123465\"); // \"123abc\"；\n```\n\n#### 4、Object.getOwnPropertyDescriptors()：\n\n\n```javascript\n// 可用于浅拷贝对象，作用同 Objecet.assign；\nObject.create(\n  Object.getPrototypeOf(obj), \n  Object.getOwnPropertyDescriptors(obj) \n);\n```\n\n#### 5、SharedMemory 和 Atomics：\n\nSharedArrayBuffer 用于开辟一块共享内存，该块共享内存可以在主线程和工作线程之间进行共享。可以通过 Atomics 对指定位置对共享内存进行操作。\n\n```javascript\nvar sab = new SharedArrayBuffer(1024);\nworker.postMessage(sab);\n```\n\n但由于安全问题，最新版本的 Chrome 暂未实现该特性。\n","source":"_posts/ES-8-新特性一览.md","raw":"---\ntitle: ES 8 新特性一览\nintro: 已经脱离“前端组织”很久了，最近在看前端圈子的进展，发现 ES8 (ECMAScript2018) 已经于上个月发布了。快来看看有哪些新特性吧。2017 年前端迎来了很多东西，而从 Wasm 到 ES8，语言和技术开始走向融合，最终还是会迎来大团圆的结局。\ncomments: true\ndate: 2017-07-06 14:06:03\ntags:\n- JavaScript\n---\n\n已经脱离“前端组织”很久了，最近在看前端圈子的进展，发现 ES8 (ECMAScript2018) 已经于上个月发布了。快来看看有哪些新特性吧。2017 年前端迎来了很多东西，而从 Wasm 到 ES8，语言和技术开始走向融合，最终还是会迎来大团圆的结局。\n\n#### 1、Object.entries()：\n\n```javascript\n// 返回一个该对象对应的键值对数组，使其可以用 for-of 迭代；\nvar obj = { foo: \"bar\", baz: 42};\nconsole.log(Object.entries(obj));\n\n// 只会生成非原型链上的对象数组；\nvar obj = Object.create({}, {\n  getFoo: {\n    value: function() {\n      return this.foo;\n    }\n  }\n});\nobj.foo = \"bar\";\nconsole.log(Object.entries(obj));\n\n// 非对象参数会被强行视为对象;\nconsole.log(Object.entries(\"foo\")); \n\n// 将 Object 转化为 Map 对象；\nvar obj = { foo: \"bar\", baz: 42 }; \nvar map = new Map(Object.entries(obj));\nconsole.log(map); \n```\n\n一个对象通常都有自己的原型,所以一个对象总有一个 “prototype” 键。不过，从 ES5 开始可以使用 `var map = Object.create(null)` 来创建一个没有原型的对象。一个对象的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值。你可以通过 `size` 属性很容易地得到一个 `Map` 的键值对个数，而对象的键值对个数只能手动确认。\n\n#### 2、Object.values()：\n\n\n```javascript\n// 枚举一个对象的值列表；\nvar obj = { foo: \"bar\", baz: 42 };\nconsole.log(Object.values(obj));\n```\n\n#### 3、String.prototype.padStart() / String.prototype.padEnd()：\n\n\n```javascript\n// 从开头填充字符串（另一个从结尾）；\n'abc'.padStart(10);         // \"       abc\"；\n'abc'.padStart(10, \"foo\");  // \"foofoofabc\"；\n'abc'.padStart(6,\"123465\"); // \"123abc\"；\n```\n\n#### 4、Object.getOwnPropertyDescriptors()：\n\n\n```javascript\n// 可用于浅拷贝对象，作用同 Objecet.assign；\nObject.create(\n  Object.getPrototypeOf(obj), \n  Object.getOwnPropertyDescriptors(obj) \n);\n```\n\n#### 5、SharedMemory 和 Atomics：\n\nSharedArrayBuffer 用于开辟一块共享内存，该块共享内存可以在主线程和工作线程之间进行共享。可以通过 Atomics 对指定位置对共享内存进行操作。\n\n```javascript\nvar sab = new SharedArrayBuffer(1024);\nworker.postMessage(sab);\n```\n\n但由于安全问题，最新版本的 Chrome 暂未实现该特性。\n","slug":"ES-8-新特性一览","published":1,"updated":"2019-02-19T09:49:57.287Z","layout":"post","photos":[],"link":"","_id":"cjsqwht7i000lknp2vnezwrx4","content":"<p>已经脱离“前端组织”很久了，最近在看前端圈子的进展，发现 ES8 (ECMAScript2018) 已经于上个月发布了。快来看看有哪些新特性吧。2017 年前端迎来了很多东西，而从 Wasm 到 ES8，语言和技术开始走向融合，最终还是会迎来大团圆的结局。</p>\n<h4 id=\"1、Object-entries-：\"><a href=\"#1、Object-entries-：\" class=\"headerlink\" title=\"1、Object.entries()：\"></a>1、Object.entries()：</h4><pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">// 返回一个该对象对应的键值对数组，使其可以用 for-of 迭代；</span>\n<span class=\"token keyword\">var</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> foo<span class=\"token punctuation\">:</span> <span class=\"token string\">\"bar\"</span><span class=\"token punctuation\">,</span> baz<span class=\"token punctuation\">:</span> <span class=\"token number\">42</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>Object<span class=\"token punctuation\">.</span><span class=\"token function\">entries</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 只会生成非原型链上的对象数组；</span>\n<span class=\"token keyword\">var</span> obj <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n  getFoo<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    value<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>foo<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nobj<span class=\"token punctuation\">.</span>foo <span class=\"token operator\">=</span> <span class=\"token string\">\"bar\"</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>Object<span class=\"token punctuation\">.</span><span class=\"token function\">entries</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 非对象参数会被强行视为对象;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>Object<span class=\"token punctuation\">.</span><span class=\"token function\">entries</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"foo\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n\n<span class=\"token comment\" spellcheck=\"true\">// 将 Object 转化为 Map 对象；</span>\n<span class=\"token keyword\">var</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> foo<span class=\"token punctuation\">:</span> <span class=\"token string\">\"bar\"</span><span class=\"token punctuation\">,</span> baz<span class=\"token punctuation\">:</span> <span class=\"token number\">42</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">var</span> map <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Map</span><span class=\"token punctuation\">(</span>Object<span class=\"token punctuation\">.</span><span class=\"token function\">entries</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>一个对象通常都有自己的原型,所以一个对象总有一个 “prototype” 键。不过，从 ES5 开始可以使用 <code>var map = Object.create(null)</code> 来创建一个没有原型的对象。一个对象的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值。你可以通过 <code>size</code> 属性很容易地得到一个 <code>Map</code> 的键值对个数，而对象的键值对个数只能手动确认。</p>\n<h4 id=\"2、Object-values-：\"><a href=\"#2、Object-values-：\" class=\"headerlink\" title=\"2、Object.values()：\"></a>2、Object.values()：</h4><pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">// 枚举一个对象的值列表；</span>\n<span class=\"token keyword\">var</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> foo<span class=\"token punctuation\">:</span> <span class=\"token string\">\"bar\"</span><span class=\"token punctuation\">,</span> baz<span class=\"token punctuation\">:</span> <span class=\"token number\">42</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>Object<span class=\"token punctuation\">.</span><span class=\"token function\">values</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"3、String-prototype-padStart-String-prototype-padEnd-：\"><a href=\"#3、String-prototype-padStart-String-prototype-padEnd-：\" class=\"headerlink\" title=\"3、String.prototype.padStart() / String.prototype.padEnd()：\"></a>3、String.prototype.padStart() / String.prototype.padEnd()：</h4><pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">// 从开头填充字符串（另一个从结尾）；</span>\n<span class=\"token string\">'abc'</span><span class=\"token punctuation\">.</span><span class=\"token function\">padStart</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>         <span class=\"token comment\" spellcheck=\"true\">// \"       abc\"；</span>\n<span class=\"token string\">'abc'</span><span class=\"token punctuation\">.</span><span class=\"token function\">padStart</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"foo\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// \"foofoofabc\"；</span>\n<span class=\"token string\">'abc'</span><span class=\"token punctuation\">.</span><span class=\"token function\">padStart</span><span class=\"token punctuation\">(</span><span class=\"token number\">6</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"123465\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// \"123abc\"；</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"4、Object-getOwnPropertyDescriptors-：\"><a href=\"#4、Object-getOwnPropertyDescriptors-：\" class=\"headerlink\" title=\"4、Object.getOwnPropertyDescriptors()：\"></a>4、Object.getOwnPropertyDescriptors()：</h4><pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">// 可用于浅拷贝对象，作用同 Objecet.assign；</span>\nObject<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span>\n  Object<span class=\"token punctuation\">.</span><span class=\"token function\">getPrototypeOf</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> \n  Object<span class=\"token punctuation\">.</span><span class=\"token function\">getOwnPropertyDescriptors</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"5、SharedMemory-和-Atomics：\"><a href=\"#5、SharedMemory-和-Atomics：\" class=\"headerlink\" title=\"5、SharedMemory 和 Atomics：\"></a>5、SharedMemory 和 Atomics：</h4><p>SharedArrayBuffer 用于开辟一块共享内存，该块共享内存可以在主线程和工作线程之间进行共享。可以通过 Atomics 对指定位置对共享内存进行操作。</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> sab <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SharedArrayBuffer</span><span class=\"token punctuation\">(</span><span class=\"token number\">1024</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nworker<span class=\"token punctuation\">.</span><span class=\"token function\">postMessage</span><span class=\"token punctuation\">(</span>sab<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>但由于安全问题，最新版本的 Chrome 暂未实现该特性。</p>\n","site":{"data":{}},"id":"f9a22260f18a816ec776a022c1431287","excerpt":"","more":"<p>已经脱离“前端组织”很久了，最近在看前端圈子的进展，发现 ES8 (ECMAScript2018) 已经于上个月发布了。快来看看有哪些新特性吧。2017 年前端迎来了很多东西，而从 Wasm 到 ES8，语言和技术开始走向融合，最终还是会迎来大团圆的结局。</p>\n<h4 id=\"1、Object-entries-：\"><a href=\"#1、Object-entries-：\" class=\"headerlink\" title=\"1、Object.entries()：\"></a>1、Object.entries()：</h4><pre><code class=\"javascript\">// 返回一个该对象对应的键值对数组，使其可以用 for-of 迭代；\nvar obj = { foo: &quot;bar&quot;, baz: 42};\nconsole.log(Object.entries(obj));\n\n// 只会生成非原型链上的对象数组；\nvar obj = Object.create({}, {\n  getFoo: {\n    value: function() {\n      return this.foo;\n    }\n  }\n});\nobj.foo = &quot;bar&quot;;\nconsole.log(Object.entries(obj));\n\n// 非对象参数会被强行视为对象;\nconsole.log(Object.entries(&quot;foo&quot;)); \n\n// 将 Object 转化为 Map 对象；\nvar obj = { foo: &quot;bar&quot;, baz: 42 }; \nvar map = new Map(Object.entries(obj));\nconsole.log(map); \n</code></pre>\n<p>一个对象通常都有自己的原型,所以一个对象总有一个 “prototype” 键。不过，从 ES5 开始可以使用 <code>var map = Object.create(null)</code> 来创建一个没有原型的对象。一个对象的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值。你可以通过 <code>size</code> 属性很容易地得到一个 <code>Map</code> 的键值对个数，而对象的键值对个数只能手动确认。</p>\n<h4 id=\"2、Object-values-：\"><a href=\"#2、Object-values-：\" class=\"headerlink\" title=\"2、Object.values()：\"></a>2、Object.values()：</h4><pre><code class=\"javascript\">// 枚举一个对象的值列表；\nvar obj = { foo: &quot;bar&quot;, baz: 42 };\nconsole.log(Object.values(obj));\n</code></pre>\n<h4 id=\"3、String-prototype-padStart-String-prototype-padEnd-：\"><a href=\"#3、String-prototype-padStart-String-prototype-padEnd-：\" class=\"headerlink\" title=\"3、String.prototype.padStart() / String.prototype.padEnd()：\"></a>3、String.prototype.padStart() / String.prototype.padEnd()：</h4><pre><code class=\"javascript\">// 从开头填充字符串（另一个从结尾）；\n&#39;abc&#39;.padStart(10);         // &quot;       abc&quot;；\n&#39;abc&#39;.padStart(10, &quot;foo&quot;);  // &quot;foofoofabc&quot;；\n&#39;abc&#39;.padStart(6,&quot;123465&quot;); // &quot;123abc&quot;；\n</code></pre>\n<h4 id=\"4、Object-getOwnPropertyDescriptors-：\"><a href=\"#4、Object-getOwnPropertyDescriptors-：\" class=\"headerlink\" title=\"4、Object.getOwnPropertyDescriptors()：\"></a>4、Object.getOwnPropertyDescriptors()：</h4><pre><code class=\"javascript\">// 可用于浅拷贝对象，作用同 Objecet.assign；\nObject.create(\n  Object.getPrototypeOf(obj), \n  Object.getOwnPropertyDescriptors(obj) \n);\n</code></pre>\n<h4 id=\"5、SharedMemory-和-Atomics：\"><a href=\"#5、SharedMemory-和-Atomics：\" class=\"headerlink\" title=\"5、SharedMemory 和 Atomics：\"></a>5、SharedMemory 和 Atomics：</h4><p>SharedArrayBuffer 用于开辟一块共享内存，该块共享内存可以在主线程和工作线程之间进行共享。可以通过 Atomics 对指定位置对共享内存进行操作。</p>\n<pre><code class=\"javascript\">var sab = new SharedArrayBuffer(1024);\nworker.postMessage(sab);\n</code></pre>\n<p>但由于安全问题，最新版本的 Chrome 暂未实现该特性。</p>\n"},{"title":"ES 6 / ES 2015 常用知识点归纳","intro":"半年前学习的 ES6 新特性好久没有又生疏了，今天总结一下其中常用的一些特性。这些新特性可能是一些简单的语法糖，可能是一种新的编程理念或者思想。不论如何，ES6 带来的 JavaScript 语言的改变确实可以极大的提高我们的开发效率。同时也是 JS 开始走向多模式编程（函数式、OOP）的第一步。","comments":1,"date":"2016-12-18T09:57:08.000Z","_content":"\n半年前学习的 ES6 新特性好久没有又生疏了，今天总结一下其中常用的一些特性。这些新特性可能是一些简单的语法糖，可能是一种新的编程理念或者思想。不论如何，ES6 带来的 JavaScript 语言的改变确实可以极大的提高我们的开发效率。同时也是 JS 开始走向多模式编程（函数式、OOP）的第一步。\n\n#### 1. 迭代器和 for-of 循环：\n\n遍历数组的 4 种方法：**for 循环**、**for-in 循环**（遍历键名）、**ES5 的 forEach 方法**（不能 `break` 和 `continue`）、**ES6 的 for-of 循环**（遍历键值），其中不建议使用 for-in 来遍历数组，因为 for-in 也会同时遍历数组原型链上的可枚举属性，而且遍历顺序不确定。\n\n**数组、字符串**类型会自动创建内部迭代器 `[Symbol.iterator]`，因此可以直接使用 for-of 进行迭代。甚至一些类数组类型也可以使用 for-of 进行遍历，比如 arguments 对象和 NodeList 对象。对于普通对象，可以使用 `Object.keys` 获得该对象的键名，然后再使用 for-of 进行遍历。也可以自行实现对应的迭代器方法使其可迭代；`[Symbol.iterator]` 方法会返回一个含有 `next` 方法的对象，for-of 每一次迭代时会调用该方法，返回一个含有 value 和 done 两个属性的对象，当 done 的值为 `true` 时迭代结束。\n\n```javascript\nfunction iteratableMethod() {\n  this.value = 0;\n}\n\niteratableMethod.prototype[Symbol.iterator] = function() {\n  var self = this;\n\n  return {\n    next: function() {\n      var isDone = false;\n      if (self.value++ > 5)\n        isDone = true;\n      else \n        isDone = false;\n\n      return {\n        done: isDone,\n        value: self.value\n      }\n  }\n}\n```\n\n#### 2. let 和 const：\n\n使用 `const` 定义的常量不能在程序的其他地方进行修改。使用 `let` 定义的变量拥有块级作用域，比如在 if 语句**内部的** let 变量只在该 if 语句内有效，并且不会对外层的同名变量产生影响；let 声明的全局变量并不属于 `window` 属性；**在 for-in、for-of 和普通的 for 循环中使用 let 关键字定义的变量会使该 for 循环成为一个 for 级块作用域，每次循环都会产生一个级块作用域。并且在该作用域中还保存了当前的词法环境。使用 let 可以解决循环事件绑定的问题**，示例代码如下所示。\n\n\n```javascript\nvar attrs = [1, 2, 3];\nfor(let i = 0; i < attrs.length; i++) {\n  setTimeout(function() {\n    console.log(attrs[i]);\n  }, 2000 + 500 * i);\n}\n```\n\n#### 3. 不定参数和默认参数：\n\n不定参数也很好理解，我们可以使用不定参数来代替 `arguments` 类数组对象来存储函数调用时传递过来的多余的参数；不定参数不会为 `undefined`，但可能为空数组；并且不定参数只能放在函数的最后一个参数的位置上；如果你写过 PHP 程序，应该会对函数的默认参数很熟悉，这里有几点需要注意，传入 undefined 作为参数同没有传参的效果是一样的。\n\n\n```javascript\nfunction method(name = \"apple\", price = 10, ...others) {\n  console.log(name);\n  console.log(price);\n  console.log(others);\n}\n```\n\n#### 4. 模板字符串：\n\n模板字符串为 JavaScript 提供了简单的字符串插值功能，同时我们还可以对模板字符串进行标签模板的功能。\n\n\n```javascript\nlet person = {\n  name: \"Alice\",\n  age: 18\n};\n\nlet hometown = \"USA\";\n// 标签模板；\nlet message = `I am ${person.name}, I'm from ${hometown}`;\n\nconsole.log(message);\n```\n\n#### 5. 箭头函数：\n\n箭头函数**没有自己的 this 指针**，所以只能使用从父作用域继承过来的 this 指针；并且在箭头函数中无法使用 arguments 对象，只能使用不定参数来代替 arguments 对象；\n\n\n```javascript\nfunction method() {\n  return (a, b) => a + b; \n}\n\nfunction method() {\n  return (a, b) => {\n    return a + b;\n  }\n}\n\nfunction method() {\n  // 返回字面量对象时，要用小括号将对象包装起来；\n  return (a, b) => ({a, b});\n}\n```\n\n#### 6. Symbols：\n\nSymbols 是 JS 的第七种原始类型，一般用于创建防止属性名冲突的属性，也就是说可以将 Symbols 作为对象的属性名，那么该属性名则不会与任一个属性名发生冲突。\n\n\n```javascript\nvar obj = {};\nvar mySymbol = Symbol(\"mySymbol\");\nobj[mySymbol] = 1;\n\nSymbol.for(\"mySymbol\") === Symbol.for(\"mySymbol\") // true；\n```\n\n#### 7. 解构：\n\n解构赋值允许你使用类似数组或对象字面量的语法将数组和对象的属性赋给各种变量。当使用数组赋值模式时，被解构的值一定要包含一个迭代器。\n\n\n```javascript\nlet array = [1, 2, 3];\nlet [a, b, c] = array;\n\nlet {name: nameA} = {name: \"Jason\"};\nlet {missing} = {};\n\n// 若没有变量声明符，则需要在整个表达式外部加小括号；\n({blowUp} = {blowUp: 10});\n\n// 设置默认值；\nlet [missing = true] = [];\nlet { message: msg = \"Something went wrong\" } = {};\n\n// 导入 CommonJS 模块；\nconst { SourceMapConsumer, SourceNode } = require(\"source-map\");\n```\n\n#### 8. 生成器 Generator：\n\n本质上，生成器就是一种迭代器，其内部会自动生成 `[Symbol.iterator]` 函数，因此可以对一个迭代器对象使用 for-of 循环进行遍历；由于普通函数没有内置的迭代器，因此不能通过 for-of 进行遍历。而生成器正好可以解决这个问题。生成器函数体每次执行一部分，每当执行到一个 yield 表达式的时候就会暂停。（课题：**通过结合生成器和 Promise 的概念可以解决“回调地狱”的问题**）\n\n\n```javascript\nfunction* range(start, stop) {\n  for (var i = start; i < stop; i++)\n    yield i;\n}\n\nfor(let item of range(1, 10)) {\n  console.log(item);\n}\n\n// 使任意对象可迭代；\nfunction fai() {\n this.i = [1, 2, 3, 4, 5];\n}\n\nfai.prototype.ite = function*() {\n  for(let item of this.i) {\n    yield item;\n  }\n}\n\nfai.prototype[Symbol.iterator] = function() {\n  return this.ite();\n}\n```\n\n#### 9. 类和子类：\n\nES6 中提供了类和子类的实现方法。\n\n\n```javascript\nclass Shape {\n  constructor(color) {\n    this._color = color;\n  };\n}\n    \nclass Circle extends Shape {\n  // 构造函数；\n  constructor(radius) {\n    this.radius = radius;\n    Circle.circlesMade++;\n  };\n  // 静态方法；\n  static draw(circle, canvas) {\n    // Canvas 绘制代码；\n  };\n  static get circlesMade() {\n    return !this._count ? 0 : this._count;\n  };\n  static set circlesMade(val) {\n    this._count = val;\n  };\n  // 实例方法；\n  area() {\n    return Math.pow(this.radius, 2) * Math.PI;\n  };\n  get radius() {\n    return this._radius;\n  };\n  set radius(radius) {\n    if (!Number.isInteger(radius))\n      throw new Error(\"圆的半径必须为整数。\");\n    this._radius = radius;\n  };\n};\n```\n\n#### 10. Promise：\n\nPromise 主要用于解决“回调地狱”的问题，由于对于一个事务的各种情况都要在回调函数中进行处理，导致最终回调的方法一环套一环，失去了代码原有的可读性，并且这种回调的方式也不符合人们正常的逻辑思维方式。**Promise/A+** 规范中规定 Promise 对象是一个有限状态机，它有三个状态，分别是从：**pending -> fulfilled** 或 **pending -> reject**。Promise 的第一个事件节点的状态会沿着 Promise 链一直向下传递，如果其中某一个节点返回了 reject 状态的 Promise 对象或者抛出异常，则整个 Promise 的生命周期结束。我们可以通过在 Promise 链的最后加入 catch 方法来捕捉整个生命周期中发生的错误。`Promise.all`（Promise 全部 resolve 则响应） 和 `Promise.race`（响应最先 resolve 的 Promise）方法用来处理多并发事务的情况。\n\n![](1.png)\n\n```javascript\nvar promise = new Promise((resolve, reject) => {\n  setTimeout(function() {\n    return resolve({data: \"success1\"});\n  }, 2000);\n});\n\npromise.then(data => {\n  console.log(\"success from promise 1: \", data);\n\n  return new Promise((resolve, reject) => {\n    setTimeout(function() {\n      return resolve({data: \"success2\"});\n    }, 2000);\n  });\n}).then(data => {\n  console.log(\"success from promise 2: \", data);\n\n  return new Promise((resolve, reject) => {\n    setTimeout(function() {\n      return reject({data: \"fail3\"});\n    }, 2000);\n  });\n}).then(data =>  {\n  console.log(\"success from promise 3: \", data);\n}).catch(err => {\n  console.log(\"fail from promise 3: \", err);\n});\n```\n\n#### 11. 模块 Modules：\n\nES6 中的模块默认都是在严格模式下执的。\n\n\n```javascript\nexport function detectCats(canvas, options) {\n  var kittydar = new Kittydar(options);\n   return kittydar.detectCats(canvas);\n}\nexport class Kittydar {\n  // ...\n}\n// 该函数没有被导出；\nfunction resizeCanvas() {}\n```\n\n\n```javascript\nimport {detectCats, Kittydar} from \"kittydar.js\";\nfunction go() {\n  var canvas = document.getElementById(\"catpix\");\n  var cats = detectCats(canvas);\n  drawRectangles(canvas, cats);\n}\n```\n","source":"_posts/ES-6-ES-2015-常用知识点归纳.md","raw":"---\ntitle: ES 6 / ES 2015 常用知识点归纳\nintro: 半年前学习的 ES6 新特性好久没有又生疏了，今天总结一下其中常用的一些特性。这些新特性可能是一些简单的语法糖，可能是一种新的编程理念或者思想。不论如何，ES6 带来的 JavaScript 语言的改变确实可以极大的提高我们的开发效率。同时也是 JS 开始走向多模式编程（函数式、OOP）的第一步。\ncomments: true\ndate: 2016-12-18 17:57:08\ntags:\n- JavaScript\n- ECMAScript\n---\n\n半年前学习的 ES6 新特性好久没有又生疏了，今天总结一下其中常用的一些特性。这些新特性可能是一些简单的语法糖，可能是一种新的编程理念或者思想。不论如何，ES6 带来的 JavaScript 语言的改变确实可以极大的提高我们的开发效率。同时也是 JS 开始走向多模式编程（函数式、OOP）的第一步。\n\n#### 1. 迭代器和 for-of 循环：\n\n遍历数组的 4 种方法：**for 循环**、**for-in 循环**（遍历键名）、**ES5 的 forEach 方法**（不能 `break` 和 `continue`）、**ES6 的 for-of 循环**（遍历键值），其中不建议使用 for-in 来遍历数组，因为 for-in 也会同时遍历数组原型链上的可枚举属性，而且遍历顺序不确定。\n\n**数组、字符串**类型会自动创建内部迭代器 `[Symbol.iterator]`，因此可以直接使用 for-of 进行迭代。甚至一些类数组类型也可以使用 for-of 进行遍历，比如 arguments 对象和 NodeList 对象。对于普通对象，可以使用 `Object.keys` 获得该对象的键名，然后再使用 for-of 进行遍历。也可以自行实现对应的迭代器方法使其可迭代；`[Symbol.iterator]` 方法会返回一个含有 `next` 方法的对象，for-of 每一次迭代时会调用该方法，返回一个含有 value 和 done 两个属性的对象，当 done 的值为 `true` 时迭代结束。\n\n```javascript\nfunction iteratableMethod() {\n  this.value = 0;\n}\n\niteratableMethod.prototype[Symbol.iterator] = function() {\n  var self = this;\n\n  return {\n    next: function() {\n      var isDone = false;\n      if (self.value++ > 5)\n        isDone = true;\n      else \n        isDone = false;\n\n      return {\n        done: isDone,\n        value: self.value\n      }\n  }\n}\n```\n\n#### 2. let 和 const：\n\n使用 `const` 定义的常量不能在程序的其他地方进行修改。使用 `let` 定义的变量拥有块级作用域，比如在 if 语句**内部的** let 变量只在该 if 语句内有效，并且不会对外层的同名变量产生影响；let 声明的全局变量并不属于 `window` 属性；**在 for-in、for-of 和普通的 for 循环中使用 let 关键字定义的变量会使该 for 循环成为一个 for 级块作用域，每次循环都会产生一个级块作用域。并且在该作用域中还保存了当前的词法环境。使用 let 可以解决循环事件绑定的问题**，示例代码如下所示。\n\n\n```javascript\nvar attrs = [1, 2, 3];\nfor(let i = 0; i < attrs.length; i++) {\n  setTimeout(function() {\n    console.log(attrs[i]);\n  }, 2000 + 500 * i);\n}\n```\n\n#### 3. 不定参数和默认参数：\n\n不定参数也很好理解，我们可以使用不定参数来代替 `arguments` 类数组对象来存储函数调用时传递过来的多余的参数；不定参数不会为 `undefined`，但可能为空数组；并且不定参数只能放在函数的最后一个参数的位置上；如果你写过 PHP 程序，应该会对函数的默认参数很熟悉，这里有几点需要注意，传入 undefined 作为参数同没有传参的效果是一样的。\n\n\n```javascript\nfunction method(name = \"apple\", price = 10, ...others) {\n  console.log(name);\n  console.log(price);\n  console.log(others);\n}\n```\n\n#### 4. 模板字符串：\n\n模板字符串为 JavaScript 提供了简单的字符串插值功能，同时我们还可以对模板字符串进行标签模板的功能。\n\n\n```javascript\nlet person = {\n  name: \"Alice\",\n  age: 18\n};\n\nlet hometown = \"USA\";\n// 标签模板；\nlet message = `I am ${person.name}, I'm from ${hometown}`;\n\nconsole.log(message);\n```\n\n#### 5. 箭头函数：\n\n箭头函数**没有自己的 this 指针**，所以只能使用从父作用域继承过来的 this 指针；并且在箭头函数中无法使用 arguments 对象，只能使用不定参数来代替 arguments 对象；\n\n\n```javascript\nfunction method() {\n  return (a, b) => a + b; \n}\n\nfunction method() {\n  return (a, b) => {\n    return a + b;\n  }\n}\n\nfunction method() {\n  // 返回字面量对象时，要用小括号将对象包装起来；\n  return (a, b) => ({a, b});\n}\n```\n\n#### 6. Symbols：\n\nSymbols 是 JS 的第七种原始类型，一般用于创建防止属性名冲突的属性，也就是说可以将 Symbols 作为对象的属性名，那么该属性名则不会与任一个属性名发生冲突。\n\n\n```javascript\nvar obj = {};\nvar mySymbol = Symbol(\"mySymbol\");\nobj[mySymbol] = 1;\n\nSymbol.for(\"mySymbol\") === Symbol.for(\"mySymbol\") // true；\n```\n\n#### 7. 解构：\n\n解构赋值允许你使用类似数组或对象字面量的语法将数组和对象的属性赋给各种变量。当使用数组赋值模式时，被解构的值一定要包含一个迭代器。\n\n\n```javascript\nlet array = [1, 2, 3];\nlet [a, b, c] = array;\n\nlet {name: nameA} = {name: \"Jason\"};\nlet {missing} = {};\n\n// 若没有变量声明符，则需要在整个表达式外部加小括号；\n({blowUp} = {blowUp: 10});\n\n// 设置默认值；\nlet [missing = true] = [];\nlet { message: msg = \"Something went wrong\" } = {};\n\n// 导入 CommonJS 模块；\nconst { SourceMapConsumer, SourceNode } = require(\"source-map\");\n```\n\n#### 8. 生成器 Generator：\n\n本质上，生成器就是一种迭代器，其内部会自动生成 `[Symbol.iterator]` 函数，因此可以对一个迭代器对象使用 for-of 循环进行遍历；由于普通函数没有内置的迭代器，因此不能通过 for-of 进行遍历。而生成器正好可以解决这个问题。生成器函数体每次执行一部分，每当执行到一个 yield 表达式的时候就会暂停。（课题：**通过结合生成器和 Promise 的概念可以解决“回调地狱”的问题**）\n\n\n```javascript\nfunction* range(start, stop) {\n  for (var i = start; i < stop; i++)\n    yield i;\n}\n\nfor(let item of range(1, 10)) {\n  console.log(item);\n}\n\n// 使任意对象可迭代；\nfunction fai() {\n this.i = [1, 2, 3, 4, 5];\n}\n\nfai.prototype.ite = function*() {\n  for(let item of this.i) {\n    yield item;\n  }\n}\n\nfai.prototype[Symbol.iterator] = function() {\n  return this.ite();\n}\n```\n\n#### 9. 类和子类：\n\nES6 中提供了类和子类的实现方法。\n\n\n```javascript\nclass Shape {\n  constructor(color) {\n    this._color = color;\n  };\n}\n    \nclass Circle extends Shape {\n  // 构造函数；\n  constructor(radius) {\n    this.radius = radius;\n    Circle.circlesMade++;\n  };\n  // 静态方法；\n  static draw(circle, canvas) {\n    // Canvas 绘制代码；\n  };\n  static get circlesMade() {\n    return !this._count ? 0 : this._count;\n  };\n  static set circlesMade(val) {\n    this._count = val;\n  };\n  // 实例方法；\n  area() {\n    return Math.pow(this.radius, 2) * Math.PI;\n  };\n  get radius() {\n    return this._radius;\n  };\n  set radius(radius) {\n    if (!Number.isInteger(radius))\n      throw new Error(\"圆的半径必须为整数。\");\n    this._radius = radius;\n  };\n};\n```\n\n#### 10. Promise：\n\nPromise 主要用于解决“回调地狱”的问题，由于对于一个事务的各种情况都要在回调函数中进行处理，导致最终回调的方法一环套一环，失去了代码原有的可读性，并且这种回调的方式也不符合人们正常的逻辑思维方式。**Promise/A+** 规范中规定 Promise 对象是一个有限状态机，它有三个状态，分别是从：**pending -> fulfilled** 或 **pending -> reject**。Promise 的第一个事件节点的状态会沿着 Promise 链一直向下传递，如果其中某一个节点返回了 reject 状态的 Promise 对象或者抛出异常，则整个 Promise 的生命周期结束。我们可以通过在 Promise 链的最后加入 catch 方法来捕捉整个生命周期中发生的错误。`Promise.all`（Promise 全部 resolve 则响应） 和 `Promise.race`（响应最先 resolve 的 Promise）方法用来处理多并发事务的情况。\n\n![](1.png)\n\n```javascript\nvar promise = new Promise((resolve, reject) => {\n  setTimeout(function() {\n    return resolve({data: \"success1\"});\n  }, 2000);\n});\n\npromise.then(data => {\n  console.log(\"success from promise 1: \", data);\n\n  return new Promise((resolve, reject) => {\n    setTimeout(function() {\n      return resolve({data: \"success2\"});\n    }, 2000);\n  });\n}).then(data => {\n  console.log(\"success from promise 2: \", data);\n\n  return new Promise((resolve, reject) => {\n    setTimeout(function() {\n      return reject({data: \"fail3\"});\n    }, 2000);\n  });\n}).then(data =>  {\n  console.log(\"success from promise 3: \", data);\n}).catch(err => {\n  console.log(\"fail from promise 3: \", err);\n});\n```\n\n#### 11. 模块 Modules：\n\nES6 中的模块默认都是在严格模式下执的。\n\n\n```javascript\nexport function detectCats(canvas, options) {\n  var kittydar = new Kittydar(options);\n   return kittydar.detectCats(canvas);\n}\nexport class Kittydar {\n  // ...\n}\n// 该函数没有被导出；\nfunction resizeCanvas() {}\n```\n\n\n```javascript\nimport {detectCats, Kittydar} from \"kittydar.js\";\nfunction go() {\n  var canvas = document.getElementById(\"catpix\");\n  var cats = detectCats(canvas);\n  drawRectangles(canvas, cats);\n}\n```\n","slug":"ES-6-ES-2015-常用知识点归纳","published":1,"updated":"2019-02-12T03:39:32.337Z","layout":"post","photos":[],"link":"","_id":"cjsqwht7j000nknp23p896zxj","content":"<p>半年前学习的 ES6 新特性好久没有又生疏了，今天总结一下其中常用的一些特性。这些新特性可能是一些简单的语法糖，可能是一种新的编程理念或者思想。不论如何，ES6 带来的 JavaScript 语言的改变确实可以极大的提高我们的开发效率。同时也是 JS 开始走向多模式编程（函数式、OOP）的第一步。</p>\n<h4 id=\"1-迭代器和-for-of-循环：\"><a href=\"#1-迭代器和-for-of-循环：\" class=\"headerlink\" title=\"1. 迭代器和 for-of 循环：\"></a>1. 迭代器和 for-of 循环：</h4><p>遍历数组的 4 种方法：<strong>for 循环</strong>、<strong>for-in 循环</strong>（遍历键名）、<strong>ES5 的 forEach 方法</strong>（不能 <code>break</code> 和 <code>continue</code>）、<strong>ES6 的 for-of 循环</strong>（遍历键值），其中不建议使用 for-in 来遍历数组，因为 for-in 也会同时遍历数组原型链上的可枚举属性，而且遍历顺序不确定。</p>\n<p><strong>数组、字符串</strong>类型会自动创建内部迭代器 <code>[Symbol.iterator]</code>，因此可以直接使用 for-of 进行迭代。甚至一些类数组类型也可以使用 for-of 进行遍历，比如 arguments 对象和 NodeList 对象。对于普通对象，可以使用 <code>Object.keys</code> 获得该对象的键名，然后再使用 for-of 进行遍历。也可以自行实现对应的迭代器方法使其可迭代；<code>[Symbol.iterator]</code> 方法会返回一个含有 <code>next</code> 方法的对象，for-of 每一次迭代时会调用该方法，返回一个含有 value 和 done 两个属性的对象，当 done 的值为 <code>true</code> 时迭代结束。</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">iteratableMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\niteratableMethod<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">[</span>Symbol<span class=\"token punctuation\">.</span>iterator<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> self <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n    next<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">var</span> isDone <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span>value<span class=\"token operator\">++</span> <span class=\"token operator\">></span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span>\n        isDone <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">else</span> \n        isDone <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n\n      <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n        done<span class=\"token punctuation\">:</span> isDone<span class=\"token punctuation\">,</span>\n        value<span class=\"token punctuation\">:</span> self<span class=\"token punctuation\">.</span>value\n      <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"2-let-和-const：\"><a href=\"#2-let-和-const：\" class=\"headerlink\" title=\"2. let 和 const：\"></a>2. let 和 const：</h4><p>使用 <code>const</code> 定义的常量不能在程序的其他地方进行修改。使用 <code>let</code> 定义的变量拥有块级作用域，比如在 if 语句<strong>内部的</strong> let 变量只在该 if 语句内有效，并且不会对外层的同名变量产生影响；let 声明的全局变量并不属于 <code>window</code> 属性；<strong>在 for-in、for-of 和普通的 for 循环中使用 let 关键字定义的变量会使该 for 循环成为一个 for 级块作用域，每次循环都会产生一个级块作用域。并且在该作用域中还保存了当前的词法环境。使用 let 可以解决循环事件绑定的问题</strong>，示例代码如下所示。</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> attrs <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> attrs<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>attrs<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2000</span> <span class=\"token operator\">+</span> <span class=\"token number\">500</span> <span class=\"token operator\">*</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"3-不定参数和默认参数：\"><a href=\"#3-不定参数和默认参数：\" class=\"headerlink\" title=\"3. 不定参数和默认参数：\"></a>3. 不定参数和默认参数：</h4><p>不定参数也很好理解，我们可以使用不定参数来代替 <code>arguments</code> 类数组对象来存储函数调用时传递过来的多余的参数；不定参数不会为 <code>undefined</code>，但可能为空数组；并且不定参数只能放在函数的最后一个参数的位置上；如果你写过 PHP 程序，应该会对函数的默认参数很熟悉，这里有几点需要注意，传入 undefined 作为参数同没有传参的效果是一样的。</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">method</span><span class=\"token punctuation\">(</span>name <span class=\"token operator\">=</span> <span class=\"token string\">\"apple\"</span><span class=\"token punctuation\">,</span> price <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>others<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>price<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>others<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"4-模板字符串：\"><a href=\"#4-模板字符串：\" class=\"headerlink\" title=\"4. 模板字符串：\"></a>4. 模板字符串：</h4><p>模板字符串为 JavaScript 提供了简单的字符串插值功能，同时我们还可以对模板字符串进行标签模板的功能。</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> person <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Alice\"</span><span class=\"token punctuation\">,</span>\n  age<span class=\"token punctuation\">:</span> <span class=\"token number\">18</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> hometown <span class=\"token operator\">=</span> <span class=\"token string\">\"USA\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// 标签模板；</span>\n<span class=\"token keyword\">let</span> message <span class=\"token operator\">=</span> <span class=\"token template-string\"><span class=\"token string\">`I am </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>person<span class=\"token punctuation\">.</span>name<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">, I'm from </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>hometown<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"5-箭头函数：\"><a href=\"#5-箭头函数：\" class=\"headerlink\" title=\"5. 箭头函数：\"></a>5. 箭头函数：</h4><p>箭头函数<strong>没有自己的 this 指针</strong>，所以只能使用从父作用域继承过来的 this 指针；并且在箭头函数中无法使用 arguments 对象，只能使用不定参数来代替 arguments 对象；</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">method</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">method</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">method</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 返回字面量对象时，要用小括号将对象包装起来；</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"6-Symbols：\"><a href=\"#6-Symbols：\" class=\"headerlink\" title=\"6. Symbols：\"></a>6. Symbols：</h4><p>Symbols 是 JS 的第七种原始类型，一般用于创建防止属性名冲突的属性，也就是说可以将 Symbols 作为对象的属性名，那么该属性名则不会与任一个属性名发生冲突。</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> mySymbol <span class=\"token operator\">=</span> <span class=\"token function\">Symbol</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"mySymbol\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nobj<span class=\"token punctuation\">[</span>mySymbol<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\nSymbol<span class=\"token punctuation\">.</span><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"mySymbol\"</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> Symbol<span class=\"token punctuation\">.</span><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"mySymbol\"</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// true；</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"7-解构：\"><a href=\"#7-解构：\" class=\"headerlink\" title=\"7. 解构：\"></a>7. 解构：</h4><p>解构赋值允许你使用类似数组或对象字面量的语法将数组和对象的属性赋给各种变量。当使用数组赋值模式时，被解构的值一定要包含一个迭代器。</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> array <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> <span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> array<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> <span class=\"token punctuation\">{</span>name<span class=\"token punctuation\">:</span> nameA<span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>name<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Jason\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> <span class=\"token punctuation\">{</span>missing<span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 若没有变量声明符，则需要在整个表达式外部加小括号；</span>\n<span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>blowUp<span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>blowUp<span class=\"token punctuation\">:</span> <span class=\"token number\">10</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 设置默认值；</span>\n<span class=\"token keyword\">let</span> <span class=\"token punctuation\">[</span>missing <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> <span class=\"token punctuation\">{</span> message<span class=\"token punctuation\">:</span> msg <span class=\"token operator\">=</span> <span class=\"token string\">\"Something went wrong\"</span> <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 导入 CommonJS 模块；</span>\n<span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> SourceMapConsumer<span class=\"token punctuation\">,</span> SourceNode <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"source-map\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"8-生成器-Generator：\"><a href=\"#8-生成器-Generator：\" class=\"headerlink\" title=\"8. 生成器 Generator：\"></a>8. 生成器 Generator：</h4><p>本质上，生成器就是一种迭代器，其内部会自动生成 <code>[Symbol.iterator]</code> 函数，因此可以对一个迭代器对象使用 for-of 循环进行遍历；由于普通函数没有内置的迭代器，因此不能通过 for-of 进行遍历。而生成器正好可以解决这个问题。生成器函数体每次执行一部分，每当执行到一个 yield 表达式的时候就会暂停。（课题：<strong>通过结合生成器和 Promise 的概念可以解决“回调地狱”的问题</strong>）</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">range</span><span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">,</span> stop<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> start<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> stop<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">yield</span> i<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> item <span class=\"token keyword\">of</span> <span class=\"token function\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 使任意对象可迭代；</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">fai</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>i <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nfai<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>ite <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> item <span class=\"token keyword\">of</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">yield</span> item<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\nfai<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">[</span>Symbol<span class=\"token punctuation\">.</span>iterator<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">ite</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"9-类和子类：\"><a href=\"#9-类和子类：\" class=\"headerlink\" title=\"9. 类和子类：\"></a>9. 类和子类：</h4><p>ES6 中提供了类和子类的实现方法。</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Shape</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>color<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_color <span class=\"token operator\">=</span> color<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Circle</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Shape</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 构造函数；</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>radius<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>radius <span class=\"token operator\">=</span> radius<span class=\"token punctuation\">;</span>\n    Circle<span class=\"token punctuation\">.</span>circlesMade<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 静态方法；</span>\n  <span class=\"token keyword\">static</span> <span class=\"token function\">draw</span><span class=\"token punctuation\">(</span>circle<span class=\"token punctuation\">,</span> canvas<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Canvas 绘制代码；</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">static</span> <span class=\"token keyword\">get</span> <span class=\"token function\">circlesMade</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">!</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_count <span class=\"token operator\">?</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">:</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_count<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">static</span> <span class=\"token keyword\">set</span> <span class=\"token function\">circlesMade</span><span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_count <span class=\"token operator\">=</span> val<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 实例方法；</span>\n  <span class=\"token function\">area</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">pow</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>radius<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> Math<span class=\"token punctuation\">.</span>PI<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">get</span> <span class=\"token function\">radius</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_radius<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">set</span> <span class=\"token function\">radius</span><span class=\"token punctuation\">(</span>radius<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>Number<span class=\"token punctuation\">.</span><span class=\"token function\">isInteger</span><span class=\"token punctuation\">(</span>radius<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"圆的半径必须为整数。\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_radius <span class=\"token operator\">=</span> radius<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"10-Promise：\"><a href=\"#10-Promise：\" class=\"headerlink\" title=\"10. Promise：\"></a>10. Promise：</h4><p>Promise 主要用于解决“回调地狱”的问题，由于对于一个事务的各种情况都要在回调函数中进行处理，导致最终回调的方法一环套一环，失去了代码原有的可读性，并且这种回调的方式也不符合人们正常的逻辑思维方式。<strong>Promise/A+</strong> 规范中规定 Promise 对象是一个有限状态机，它有三个状态，分别是从：<strong>pending -&gt; fulfilled</strong> 或 <strong>pending -&gt; reject</strong>。Promise 的第一个事件节点的状态会沿着 Promise 链一直向下传递，如果其中某一个节点返回了 reject 状态的 Promise 对象或者抛出异常，则整个 Promise 的生命周期结束。我们可以通过在 Promise 链的最后加入 catch 方法来捕捉整个生命周期中发生的错误。<code>Promise.all</code>（Promise 全部 resolve 则响应） 和 <code>Promise.race</code>（响应最先 resolve 的 Promise）方法用来处理多并发事务的情况。</p>\n<p><img src=\"1.png\" alt></p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> promise <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>data<span class=\"token punctuation\">:</span> <span class=\"token string\">\"success1\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\npromise<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>data <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"success from promise 1: \"</span><span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>data<span class=\"token punctuation\">:</span> <span class=\"token string\">\"success2\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>data <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"success from promise 2: \"</span><span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>data<span class=\"token punctuation\">:</span> <span class=\"token string\">\"fail3\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>data <span class=\"token operator\">=</span><span class=\"token operator\">></span>  <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"success from promise 3: \"</span><span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span>err <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"fail from promise 3: \"</span><span class=\"token punctuation\">,</span> err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"11-模块-Modules：\"><a href=\"#11-模块-Modules：\" class=\"headerlink\" title=\"11. 模块 Modules：\"></a>11. 模块 Modules：</h4><p>ES6 中的模块默认都是在严格模式下执的。</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">detectCats</span><span class=\"token punctuation\">(</span>canvas<span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> kittydar <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Kittydar</span><span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   <span class=\"token keyword\">return</span> kittydar<span class=\"token punctuation\">.</span><span class=\"token function\">detectCats</span><span class=\"token punctuation\">(</span>canvas<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Kittydar</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">// 该函数没有被导出；</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">resizeCanvas</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span>detectCats<span class=\"token punctuation\">,</span> Kittydar<span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"kittydar.js\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">go</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> canvas <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"catpix\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> cats <span class=\"token operator\">=</span> <span class=\"token function\">detectCats</span><span class=\"token punctuation\">(</span>canvas<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">drawRectangles</span><span class=\"token punctuation\">(</span>canvas<span class=\"token punctuation\">,</span> cats<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"id":"c491b934260cc984f2c4e878c214a0d3","excerpt":"","more":"<p>半年前学习的 ES6 新特性好久没有又生疏了，今天总结一下其中常用的一些特性。这些新特性可能是一些简单的语法糖，可能是一种新的编程理念或者思想。不论如何，ES6 带来的 JavaScript 语言的改变确实可以极大的提高我们的开发效率。同时也是 JS 开始走向多模式编程（函数式、OOP）的第一步。</p>\n<h4 id=\"1-迭代器和-for-of-循环：\"><a href=\"#1-迭代器和-for-of-循环：\" class=\"headerlink\" title=\"1. 迭代器和 for-of 循环：\"></a>1. 迭代器和 for-of 循环：</h4><p>遍历数组的 4 种方法：<strong>for 循环</strong>、<strong>for-in 循环</strong>（遍历键名）、<strong>ES5 的 forEach 方法</strong>（不能 <code>break</code> 和 <code>continue</code>）、<strong>ES6 的 for-of 循环</strong>（遍历键值），其中不建议使用 for-in 来遍历数组，因为 for-in 也会同时遍历数组原型链上的可枚举属性，而且遍历顺序不确定。</p>\n<p><strong>数组、字符串</strong>类型会自动创建内部迭代器 <code>[Symbol.iterator]</code>，因此可以直接使用 for-of 进行迭代。甚至一些类数组类型也可以使用 for-of 进行遍历，比如 arguments 对象和 NodeList 对象。对于普通对象，可以使用 <code>Object.keys</code> 获得该对象的键名，然后再使用 for-of 进行遍历。也可以自行实现对应的迭代器方法使其可迭代；<code>[Symbol.iterator]</code> 方法会返回一个含有 <code>next</code> 方法的对象，for-of 每一次迭代时会调用该方法，返回一个含有 value 和 done 两个属性的对象，当 done 的值为 <code>true</code> 时迭代结束。</p>\n<pre><code class=\"javascript\">function iteratableMethod() {\n  this.value = 0;\n}\n\niteratableMethod.prototype[Symbol.iterator] = function() {\n  var self = this;\n\n  return {\n    next: function() {\n      var isDone = false;\n      if (self.value++ &gt; 5)\n        isDone = true;\n      else \n        isDone = false;\n\n      return {\n        done: isDone,\n        value: self.value\n      }\n  }\n}\n</code></pre>\n<h4 id=\"2-let-和-const：\"><a href=\"#2-let-和-const：\" class=\"headerlink\" title=\"2. let 和 const：\"></a>2. let 和 const：</h4><p>使用 <code>const</code> 定义的常量不能在程序的其他地方进行修改。使用 <code>let</code> 定义的变量拥有块级作用域，比如在 if 语句<strong>内部的</strong> let 变量只在该 if 语句内有效，并且不会对外层的同名变量产生影响；let 声明的全局变量并不属于 <code>window</code> 属性；<strong>在 for-in、for-of 和普通的 for 循环中使用 let 关键字定义的变量会使该 for 循环成为一个 for 级块作用域，每次循环都会产生一个级块作用域。并且在该作用域中还保存了当前的词法环境。使用 let 可以解决循环事件绑定的问题</strong>，示例代码如下所示。</p>\n<pre><code class=\"javascript\">var attrs = [1, 2, 3];\nfor(let i = 0; i &lt; attrs.length; i++) {\n  setTimeout(function() {\n    console.log(attrs[i]);\n  }, 2000 + 500 * i);\n}\n</code></pre>\n<h4 id=\"3-不定参数和默认参数：\"><a href=\"#3-不定参数和默认参数：\" class=\"headerlink\" title=\"3. 不定参数和默认参数：\"></a>3. 不定参数和默认参数：</h4><p>不定参数也很好理解，我们可以使用不定参数来代替 <code>arguments</code> 类数组对象来存储函数调用时传递过来的多余的参数；不定参数不会为 <code>undefined</code>，但可能为空数组；并且不定参数只能放在函数的最后一个参数的位置上；如果你写过 PHP 程序，应该会对函数的默认参数很熟悉，这里有几点需要注意，传入 undefined 作为参数同没有传参的效果是一样的。</p>\n<pre><code class=\"javascript\">function method(name = &quot;apple&quot;, price = 10, ...others) {\n  console.log(name);\n  console.log(price);\n  console.log(others);\n}\n</code></pre>\n<h4 id=\"4-模板字符串：\"><a href=\"#4-模板字符串：\" class=\"headerlink\" title=\"4. 模板字符串：\"></a>4. 模板字符串：</h4><p>模板字符串为 JavaScript 提供了简单的字符串插值功能，同时我们还可以对模板字符串进行标签模板的功能。</p>\n<pre><code class=\"javascript\">let person = {\n  name: &quot;Alice&quot;,\n  age: 18\n};\n\nlet hometown = &quot;USA&quot;;\n// 标签模板；\nlet message = `I am ${person.name}, I&#39;m from ${hometown}`;\n\nconsole.log(message);\n</code></pre>\n<h4 id=\"5-箭头函数：\"><a href=\"#5-箭头函数：\" class=\"headerlink\" title=\"5. 箭头函数：\"></a>5. 箭头函数：</h4><p>箭头函数<strong>没有自己的 this 指针</strong>，所以只能使用从父作用域继承过来的 this 指针；并且在箭头函数中无法使用 arguments 对象，只能使用不定参数来代替 arguments 对象；</p>\n<pre><code class=\"javascript\">function method() {\n  return (a, b) =&gt; a + b; \n}\n\nfunction method() {\n  return (a, b) =&gt; {\n    return a + b;\n  }\n}\n\nfunction method() {\n  // 返回字面量对象时，要用小括号将对象包装起来；\n  return (a, b) =&gt; ({a, b});\n}\n</code></pre>\n<h4 id=\"6-Symbols：\"><a href=\"#6-Symbols：\" class=\"headerlink\" title=\"6. Symbols：\"></a>6. Symbols：</h4><p>Symbols 是 JS 的第七种原始类型，一般用于创建防止属性名冲突的属性，也就是说可以将 Symbols 作为对象的属性名，那么该属性名则不会与任一个属性名发生冲突。</p>\n<pre><code class=\"javascript\">var obj = {};\nvar mySymbol = Symbol(&quot;mySymbol&quot;);\nobj[mySymbol] = 1;\n\nSymbol.for(&quot;mySymbol&quot;) === Symbol.for(&quot;mySymbol&quot;) // true；\n</code></pre>\n<h4 id=\"7-解构：\"><a href=\"#7-解构：\" class=\"headerlink\" title=\"7. 解构：\"></a>7. 解构：</h4><p>解构赋值允许你使用类似数组或对象字面量的语法将数组和对象的属性赋给各种变量。当使用数组赋值模式时，被解构的值一定要包含一个迭代器。</p>\n<pre><code class=\"javascript\">let array = [1, 2, 3];\nlet [a, b, c] = array;\n\nlet {name: nameA} = {name: &quot;Jason&quot;};\nlet {missing} = {};\n\n// 若没有变量声明符，则需要在整个表达式外部加小括号；\n({blowUp} = {blowUp: 10});\n\n// 设置默认值；\nlet [missing = true] = [];\nlet { message: msg = &quot;Something went wrong&quot; } = {};\n\n// 导入 CommonJS 模块；\nconst { SourceMapConsumer, SourceNode } = require(&quot;source-map&quot;);\n</code></pre>\n<h4 id=\"8-生成器-Generator：\"><a href=\"#8-生成器-Generator：\" class=\"headerlink\" title=\"8. 生成器 Generator：\"></a>8. 生成器 Generator：</h4><p>本质上，生成器就是一种迭代器，其内部会自动生成 <code>[Symbol.iterator]</code> 函数，因此可以对一个迭代器对象使用 for-of 循环进行遍历；由于普通函数没有内置的迭代器，因此不能通过 for-of 进行遍历。而生成器正好可以解决这个问题。生成器函数体每次执行一部分，每当执行到一个 yield 表达式的时候就会暂停。（课题：<strong>通过结合生成器和 Promise 的概念可以解决“回调地狱”的问题</strong>）</p>\n<pre><code class=\"javascript\">function* range(start, stop) {\n  for (var i = start; i &lt; stop; i++)\n    yield i;\n}\n\nfor(let item of range(1, 10)) {\n  console.log(item);\n}\n\n// 使任意对象可迭代；\nfunction fai() {\n this.i = [1, 2, 3, 4, 5];\n}\n\nfai.prototype.ite = function*() {\n  for(let item of this.i) {\n    yield item;\n  }\n}\n\nfai.prototype[Symbol.iterator] = function() {\n  return this.ite();\n}\n</code></pre>\n<h4 id=\"9-类和子类：\"><a href=\"#9-类和子类：\" class=\"headerlink\" title=\"9. 类和子类：\"></a>9. 类和子类：</h4><p>ES6 中提供了类和子类的实现方法。</p>\n<pre><code class=\"javascript\">class Shape {\n  constructor(color) {\n    this._color = color;\n  };\n}\n\nclass Circle extends Shape {\n  // 构造函数；\n  constructor(radius) {\n    this.radius = radius;\n    Circle.circlesMade++;\n  };\n  // 静态方法；\n  static draw(circle, canvas) {\n    // Canvas 绘制代码；\n  };\n  static get circlesMade() {\n    return !this._count ? 0 : this._count;\n  };\n  static set circlesMade(val) {\n    this._count = val;\n  };\n  // 实例方法；\n  area() {\n    return Math.pow(this.radius, 2) * Math.PI;\n  };\n  get radius() {\n    return this._radius;\n  };\n  set radius(radius) {\n    if (!Number.isInteger(radius))\n      throw new Error(&quot;圆的半径必须为整数。&quot;);\n    this._radius = radius;\n  };\n};\n</code></pre>\n<h4 id=\"10-Promise：\"><a href=\"#10-Promise：\" class=\"headerlink\" title=\"10. Promise：\"></a>10. Promise：</h4><p>Promise 主要用于解决“回调地狱”的问题，由于对于一个事务的各种情况都要在回调函数中进行处理，导致最终回调的方法一环套一环，失去了代码原有的可读性，并且这种回调的方式也不符合人们正常的逻辑思维方式。<strong>Promise/A+</strong> 规范中规定 Promise 对象是一个有限状态机，它有三个状态，分别是从：<strong>pending -&gt; fulfilled</strong> 或 <strong>pending -&gt; reject</strong>。Promise 的第一个事件节点的状态会沿着 Promise 链一直向下传递，如果其中某一个节点返回了 reject 状态的 Promise 对象或者抛出异常，则整个 Promise 的生命周期结束。我们可以通过在 Promise 链的最后加入 catch 方法来捕捉整个生命周期中发生的错误。<code>Promise.all</code>（Promise 全部 resolve 则响应） 和 <code>Promise.race</code>（响应最先 resolve 的 Promise）方法用来处理多并发事务的情况。</p>\n<p><img src=\"1.png\" alt></p>\n<pre><code class=\"javascript\">var promise = new Promise((resolve, reject) =&gt; {\n  setTimeout(function() {\n    return resolve({data: &quot;success1&quot;});\n  }, 2000);\n});\n\npromise.then(data =&gt; {\n  console.log(&quot;success from promise 1: &quot;, data);\n\n  return new Promise((resolve, reject) =&gt; {\n    setTimeout(function() {\n      return resolve({data: &quot;success2&quot;});\n    }, 2000);\n  });\n}).then(data =&gt; {\n  console.log(&quot;success from promise 2: &quot;, data);\n\n  return new Promise((resolve, reject) =&gt; {\n    setTimeout(function() {\n      return reject({data: &quot;fail3&quot;});\n    }, 2000);\n  });\n}).then(data =&gt;  {\n  console.log(&quot;success from promise 3: &quot;, data);\n}).catch(err =&gt; {\n  console.log(&quot;fail from promise 3: &quot;, err);\n});\n</code></pre>\n<h4 id=\"11-模块-Modules：\"><a href=\"#11-模块-Modules：\" class=\"headerlink\" title=\"11. 模块 Modules：\"></a>11. 模块 Modules：</h4><p>ES6 中的模块默认都是在严格模式下执的。</p>\n<pre><code class=\"javascript\">export function detectCats(canvas, options) {\n  var kittydar = new Kittydar(options);\n   return kittydar.detectCats(canvas);\n}\nexport class Kittydar {\n  // ...\n}\n// 该函数没有被导出；\nfunction resizeCanvas() {}\n</code></pre>\n<pre><code class=\"javascript\">import {detectCats, Kittydar} from &quot;kittydar.js&quot;;\nfunction go() {\n  var canvas = document.getElementById(&quot;catpix&quot;);\n  var cats = detectCats(canvas);\n  drawRectangles(canvas, cats);\n}\n</code></pre>\n"},{"title":"Flush & Reload Attack 与 Meltdown","intro":"今天听了银奎老师分享的最近火热技术圈的 Meltdown 漏洞的基本原理，才知道原来底层系统的世界是如此的丰富多彩。Meltdown 漏洞的 POC 实现基于了一种名为 “Flush & Reload” 的黑客攻击技术，这项技术的基本原理是利用 Memory 和 Cache 之间的关系，同时利用统计学的置信程度来筛选关键信息的。","comments":1,"date":"2018-01-07T16:05:08.000Z","_content":"\n今天听了银奎老师分享的最近火热技术圈的 Meltdown 漏洞的基本原理，才知道原来底层系统的世界是如此的丰富多彩。Meltdown 漏洞的 POC 实现基于了一种名为 “Flush & Reload” 的黑客攻击技术，这项技术的基本原理是利用 Memory 和 Cache 之间的关系，同时利用统计学的置信程度来筛选关键信息的。 \n\n![](1.png)\n\nCache 主要用来环境 CPU 和内存直接的数据处理速度差异。 \n\n![](2.png)\n\n在 Cache 和内存中所存储的数据内容可能并不一致，此时则需要清空 Cache 中的数据，让 CPU 直接从内存中读取数据。 \n\n![](3.png)\n\n根据 Memory 和 Cache 之间的关系，应用程序从 Cache 和直接从 Memory 中读取数据所花费的时间片是不相同的。CPU 会将会将最近一次从 Memory 读取到的值存放到 Cache 中以方便 CPU 直接进行使用。在 CPU 和实际的 Memory Line 直接存在中从 L1 到 L5 甚至更多层级的中间 Cache，这些 Cache 分别有着各自的作用，但总体来说都是为了减少 Memory 读写速度和 CPU 处理数据之间的速度差异。 \n\n“Meltdown” 漏洞的出现本身是由于 X86 CPU 硬件层的**投机执行和乱序执行**导致的。当应用程序在用户态访问内核态的数据时，当内核态从宏观层面在向用户态抛出“段错误”的异常时，其实 CPU 在微观层面已经将这些内核态的数据读取到了相应的内部寄存器中，只不过在 “Flush & Reload” 技术出现之前，我们无法从用户态读取到这些寄存器中的数据而已。 \n\n由于 CPU 的投机执行和乱序执行问题，假如我们在程序中加入了一段用于访问内核态数据的代码。程序运行时，CPU 发现这句代码越权操作，但是其实在向用户态报告错误之前，并行流水线便已经执行完这条用于读取内核态数据的指令了，而这部分被读取到的数据被存放到了 CPU 的内部寄存器中。由于数据被存储在 CPU 的内部寄存器中，因而无法直接被用户态的程序获取，这里我们就要通过 “Flush & Reload” 方法来获取这个存储在内部寄存器的值。 \n\n实际上，CPU 的并行流水线会在当前异常结果（比如由于越权读取等操作造成的）上报后恢复现场，即将相关的“越权”用户态操作全部抛弃掉，因此我们无法直接将这个获取到的内核数据赋值给一个变量，因为这句代码本身也会被视为越权操作。但是由于 CPU 本身的设计缺陷，通过 “Flush & Reload” 这种方式来获取数据并不会被 CPU 认为是越权操作。我们通过在用户态环境中维护一个大数组来实现 “Flush & Reload” 操作。通过在获取到内核数据时，访问该大数组对应该内核数据加特定偏移位置的数组项，我们可以强制将数组该位置的内容存储到 Cache 中。而后通过测量这个大数组中各个索引位置的访问时间来推测对应的数据值，即测量数组各个位置的“温度”来反推获取到的内核数据值是多少。 \n","source":"_posts/Flush-Reload-Attack-与-Meltdown.md","raw":"---\ntitle: Flush & Reload Attack 与 Meltdown\nintro: 今天听了银奎老师分享的最近火热技术圈的 Meltdown 漏洞的基本原理，才知道原来底层系统的世界是如此的丰富多彩。Meltdown 漏洞的 POC 实现基于了一种名为 “Flush & Reload” 的黑客攻击技术，这项技术的基本原理是利用 Memory 和 Cache 之间的关系，同时利用统计学的置信程度来筛选关键信息的。\ncomments: true\ndate: 2018-01-08 00:05:08\ntags:\n- 漏洞\n---\n\n今天听了银奎老师分享的最近火热技术圈的 Meltdown 漏洞的基本原理，才知道原来底层系统的世界是如此的丰富多彩。Meltdown 漏洞的 POC 实现基于了一种名为 “Flush & Reload” 的黑客攻击技术，这项技术的基本原理是利用 Memory 和 Cache 之间的关系，同时利用统计学的置信程度来筛选关键信息的。 \n\n![](1.png)\n\nCache 主要用来环境 CPU 和内存直接的数据处理速度差异。 \n\n![](2.png)\n\n在 Cache 和内存中所存储的数据内容可能并不一致，此时则需要清空 Cache 中的数据，让 CPU 直接从内存中读取数据。 \n\n![](3.png)\n\n根据 Memory 和 Cache 之间的关系，应用程序从 Cache 和直接从 Memory 中读取数据所花费的时间片是不相同的。CPU 会将会将最近一次从 Memory 读取到的值存放到 Cache 中以方便 CPU 直接进行使用。在 CPU 和实际的 Memory Line 直接存在中从 L1 到 L5 甚至更多层级的中间 Cache，这些 Cache 分别有着各自的作用，但总体来说都是为了减少 Memory 读写速度和 CPU 处理数据之间的速度差异。 \n\n“Meltdown” 漏洞的出现本身是由于 X86 CPU 硬件层的**投机执行和乱序执行**导致的。当应用程序在用户态访问内核态的数据时，当内核态从宏观层面在向用户态抛出“段错误”的异常时，其实 CPU 在微观层面已经将这些内核态的数据读取到了相应的内部寄存器中，只不过在 “Flush & Reload” 技术出现之前，我们无法从用户态读取到这些寄存器中的数据而已。 \n\n由于 CPU 的投机执行和乱序执行问题，假如我们在程序中加入了一段用于访问内核态数据的代码。程序运行时，CPU 发现这句代码越权操作，但是其实在向用户态报告错误之前，并行流水线便已经执行完这条用于读取内核态数据的指令了，而这部分被读取到的数据被存放到了 CPU 的内部寄存器中。由于数据被存储在 CPU 的内部寄存器中，因而无法直接被用户态的程序获取，这里我们就要通过 “Flush & Reload” 方法来获取这个存储在内部寄存器的值。 \n\n实际上，CPU 的并行流水线会在当前异常结果（比如由于越权读取等操作造成的）上报后恢复现场，即将相关的“越权”用户态操作全部抛弃掉，因此我们无法直接将这个获取到的内核数据赋值给一个变量，因为这句代码本身也会被视为越权操作。但是由于 CPU 本身的设计缺陷，通过 “Flush & Reload” 这种方式来获取数据并不会被 CPU 认为是越权操作。我们通过在用户态环境中维护一个大数组来实现 “Flush & Reload” 操作。通过在获取到内核数据时，访问该大数组对应该内核数据加特定偏移位置的数组项，我们可以强制将数组该位置的内容存储到 Cache 中。而后通过测量这个大数组中各个索引位置的访问时间来推测对应的数据值，即测量数组各个位置的“温度”来反推获取到的内核数据值是多少。 \n","slug":"Flush-Reload-Attack-与-Meltdown","published":1,"updated":"2019-02-20T06:19:17.161Z","layout":"post","photos":[],"link":"","_id":"cjsqwht7k000pknp201gp1a9h","content":"<p>今天听了银奎老师分享的最近火热技术圈的 Meltdown 漏洞的基本原理，才知道原来底层系统的世界是如此的丰富多彩。Meltdown 漏洞的 POC 实现基于了一种名为 “Flush &amp; Reload” 的黑客攻击技术，这项技术的基本原理是利用 Memory 和 Cache 之间的关系，同时利用统计学的置信程度来筛选关键信息的。 </p>\n<p><img src=\"1.png\" alt></p>\n<p>Cache 主要用来环境 CPU 和内存直接的数据处理速度差异。 </p>\n<p><img src=\"2.png\" alt></p>\n<p>在 Cache 和内存中所存储的数据内容可能并不一致，此时则需要清空 Cache 中的数据，让 CPU 直接从内存中读取数据。 </p>\n<p><img src=\"3.png\" alt></p>\n<p>根据 Memory 和 Cache 之间的关系，应用程序从 Cache 和直接从 Memory 中读取数据所花费的时间片是不相同的。CPU 会将会将最近一次从 Memory 读取到的值存放到 Cache 中以方便 CPU 直接进行使用。在 CPU 和实际的 Memory Line 直接存在中从 L1 到 L5 甚至更多层级的中间 Cache，这些 Cache 分别有着各自的作用，但总体来说都是为了减少 Memory 读写速度和 CPU 处理数据之间的速度差异。 </p>\n<p>“Meltdown” 漏洞的出现本身是由于 X86 CPU 硬件层的<strong>投机执行和乱序执行</strong>导致的。当应用程序在用户态访问内核态的数据时，当内核态从宏观层面在向用户态抛出“段错误”的异常时，其实 CPU 在微观层面已经将这些内核态的数据读取到了相应的内部寄存器中，只不过在 “Flush &amp; Reload” 技术出现之前，我们无法从用户态读取到这些寄存器中的数据而已。 </p>\n<p>由于 CPU 的投机执行和乱序执行问题，假如我们在程序中加入了一段用于访问内核态数据的代码。程序运行时，CPU 发现这句代码越权操作，但是其实在向用户态报告错误之前，并行流水线便已经执行完这条用于读取内核态数据的指令了，而这部分被读取到的数据被存放到了 CPU 的内部寄存器中。由于数据被存储在 CPU 的内部寄存器中，因而无法直接被用户态的程序获取，这里我们就要通过 “Flush &amp; Reload” 方法来获取这个存储在内部寄存器的值。 </p>\n<p>实际上，CPU 的并行流水线会在当前异常结果（比如由于越权读取等操作造成的）上报后恢复现场，即将相关的“越权”用户态操作全部抛弃掉，因此我们无法直接将这个获取到的内核数据赋值给一个变量，因为这句代码本身也会被视为越权操作。但是由于 CPU 本身的设计缺陷，通过 “Flush &amp; Reload” 这种方式来获取数据并不会被 CPU 认为是越权操作。我们通过在用户态环境中维护一个大数组来实现 “Flush &amp; Reload” 操作。通过在获取到内核数据时，访问该大数组对应该内核数据加特定偏移位置的数组项，我们可以强制将数组该位置的内容存储到 Cache 中。而后通过测量这个大数组中各个索引位置的访问时间来推测对应的数据值，即测量数组各个位置的“温度”来反推获取到的内核数据值是多少。 </p>\n","site":{"data":{}},"id":"346bf2c9e053e04f1c308f79aac7bbd1","excerpt":"","more":"<p>今天听了银奎老师分享的最近火热技术圈的 Meltdown 漏洞的基本原理，才知道原来底层系统的世界是如此的丰富多彩。Meltdown 漏洞的 POC 实现基于了一种名为 “Flush &amp; Reload” 的黑客攻击技术，这项技术的基本原理是利用 Memory 和 Cache 之间的关系，同时利用统计学的置信程度来筛选关键信息的。 </p>\n<p><img src=\"1.png\" alt></p>\n<p>Cache 主要用来环境 CPU 和内存直接的数据处理速度差异。 </p>\n<p><img src=\"2.png\" alt></p>\n<p>在 Cache 和内存中所存储的数据内容可能并不一致，此时则需要清空 Cache 中的数据，让 CPU 直接从内存中读取数据。 </p>\n<p><img src=\"3.png\" alt></p>\n<p>根据 Memory 和 Cache 之间的关系，应用程序从 Cache 和直接从 Memory 中读取数据所花费的时间片是不相同的。CPU 会将会将最近一次从 Memory 读取到的值存放到 Cache 中以方便 CPU 直接进行使用。在 CPU 和实际的 Memory Line 直接存在中从 L1 到 L5 甚至更多层级的中间 Cache，这些 Cache 分别有着各自的作用，但总体来说都是为了减少 Memory 读写速度和 CPU 处理数据之间的速度差异。 </p>\n<p>“Meltdown” 漏洞的出现本身是由于 X86 CPU 硬件层的<strong>投机执行和乱序执行</strong>导致的。当应用程序在用户态访问内核态的数据时，当内核态从宏观层面在向用户态抛出“段错误”的异常时，其实 CPU 在微观层面已经将这些内核态的数据读取到了相应的内部寄存器中，只不过在 “Flush &amp; Reload” 技术出现之前，我们无法从用户态读取到这些寄存器中的数据而已。 </p>\n<p>由于 CPU 的投机执行和乱序执行问题，假如我们在程序中加入了一段用于访问内核态数据的代码。程序运行时，CPU 发现这句代码越权操作，但是其实在向用户态报告错误之前，并行流水线便已经执行完这条用于读取内核态数据的指令了，而这部分被读取到的数据被存放到了 CPU 的内部寄存器中。由于数据被存储在 CPU 的内部寄存器中，因而无法直接被用户态的程序获取，这里我们就要通过 “Flush &amp; Reload” 方法来获取这个存储在内部寄存器的值。 </p>\n<p>实际上，CPU 的并行流水线会在当前异常结果（比如由于越权读取等操作造成的）上报后恢复现场，即将相关的“越权”用户态操作全部抛弃掉，因此我们无法直接将这个获取到的内核数据赋值给一个变量，因为这句代码本身也会被视为越权操作。但是由于 CPU 本身的设计缺陷，通过 “Flush &amp; Reload” 这种方式来获取数据并不会被 CPU 认为是越权操作。我们通过在用户态环境中维护一个大数组来实现 “Flush &amp; Reload” 操作。通过在获取到内核数据时，访问该大数组对应该内核数据加特定偏移位置的数组项，我们可以强制将数组该位置的内容存储到 Cache 中。而后通过测量这个大数组中各个索引位置的访问时间来推测对应的数据值，即测量数组各个位置的“温度”来反推获取到的内核数据值是多少。 </p>\n"},{"title":"GeekBank C++ 线下班学习心得（一）","intro":"随着今年七月份毕业，到现在已经工作了“三月有余”（包括实习）。对学习的欲望从来没有减弱过，记得上一次参加“博览网”的线下活动时，还想和建忠老师讨论商业合作的事情。不过也是因为自己太年轻，想法过于 冲动，准备的不充分，最后也没能和博览达成合作。不过为了增强自己的学习能力和社交能力，我毅然决然的来到了博览的线下“极客班”。既然想成为极客，那么也需要付出“一定的”代价，来吧，我已经准备好了。","comments":1,"date":"2015-07-21T13:12:42.000Z","_content":"\n随着今年七月份毕业，到现在已经工作了“三月有余”（包括实习）。对学习的欲望从来没有减弱过，记得上一次参加“博览网”的线下活动时，还想和建忠老师讨论商业合作的事情。不过也是因为自己太年轻，想法过于 冲动，准备的不充分，最后也没能和博览达成合作。不过为了增强自己的学习能力和社交能力，我毅然决然的来到了博览的线下“极客班”。既然想成为极客，那么也需要付出“一定的”代价，来吧，我已经准备好了。\n\n伴着晨光和湿润的空气，早上八点半打的直奔线下课的目的地 - 浦东软件园。在浦东软件园上班真是有利有弊，早高峰有的时候连续等两辆公交车都不一定能挤上去。不过废话少说，我们直奔干货。\n\n说实话，不管怎么来说，我在大学也是独自一人开过技术讲座的人。可是这次线下课的第一个任务 - 自我介绍，不知道为何会这么紧张。也许是因为大家都是很厉害的人，有的人有着连续八九年的工作经验，各种各样的创业经历也是“琳琅满目”。作为93年的我，基本上也是年龄最小的。\n\n极客班的线下课以团队组队的方式进行，绿色名牌的是 IOS 学员，红色的是 C++ 学员，蓝色则是产品经理学员。而每一个团队都要由 IOS，C++ 和产品经理三种类型的学员组成。团队将要在线下课这两个月时间内要竭尽所能地做出一款产品，当然最重要的是学会如何与团队成员进行交流，比如如何协调和维护程序员与产品经理之间的关系。团队所选择的创作项目部分我们后边再说。\n\n在上午的时光里，文杰老师和 Tiny 老师分别介绍了极客班的“样本项目”，同时建中和各位老师也叙述了自己对创业以及产品相关等各种各样的想法。遵从 Tiny 的教导，我们在具体的项目开发过程中，要从 MVP（最简化的可实行产品）开始，然后进行“迭代开发”，根据功能的 Priority(优先级) 来构建各种版本。并且在每一个版本中可以将 Issue 拆分成三个等级，同时评估各个部分的时间来提高开发效率。总结起来：MVP -> 调研 -> V1 -> V2 以此类推。\n\n**ISO 部分样本项目：**\n\n* 移动 BLOG：支持新媒体、社交分享、极简交互设计；\n* 交互式白板：支持基本笔画、多人协作、实时投影、录制存储；\n* 多媒体相册：支持多张图片组合转换成视频、添加文字、模板特效、社交分享；\n\n\n**C++ 部分样本项目：**\n\n* 录屏软件：支持Windows屏幕录制；\n* Simple Key-Value DB (NOSQL)：简单的非关系型数据库；\n* Simple Local DB (SQL)：本地存储的关系型数据库，带有基本SQL操作；\n\n\n“中场休息”的时候，建中老师自费请各位学员吃午饭，各种披萨鸡块“横飞”在教室里。借着午休的时间我也和“文杰”老师聊了很多。如何才能学好 C++？注重基础语法，多写代码、如何掌握 Windows 开发？推荐了几本书。以及如何理解网络协议等各种“奇怪”的问题。\n\n茶余饭后便开始了下午的“正餐”- “项目选拔”。各位小伙伴只要有对于产品的新想法、新点子，就可以直接冲上台去给大家讲解自己心中的产品，并将名字写在黑板上等待大家最后的投票，票数最多的项目将有最高的优先级来选择项目成员。然而经过一番紧张激烈的讲解，最后一共有13个同学阐述了自己的想法。不过在这里真的很遗憾自己没有上台，并不是因为紧张害怕，而是真的没有什么好的想法，如果有我可能早早就做起来了。毕竟想法若只停留在脑中，那不是产品，只是一股脑电流罢了。并且，我认为一款好的产品不是刻意想就能想出来的，而是不经意间的灵感。\n\n**头脑风暴项目及对应票数：**\n\n* P2P换物网：暂无；\n* 多屏互动白板：7；\n* 信贷管理：5；\n* 书法比对：3；\n* 科技词典：5；\n* 酷玩视频：4；\n* 音乐弹幕：3；\n* 摄影教程：12；\n* 阿姨版饿了么：4；\n* 亲人互动平台：3；\n* 电视遥控器：2；\n* IT技能树：1；\n* 个人版历史上的今天：6；\n\n\n​“头脑风暴”之后，是由董飞老师带来的“真干货” - 《算法和系统设计导读》。“董飞”老师分别介绍了系统设计中需要掌握的基本算法和数据类型，包括排序和选择算法，数据类型包括了常见的树和链表。同时还介绍了一些 Coding 的小技巧，包括使用 Dummy Code，通过双指针追逐判断一个链表是否有环等干货。\n\n虽然没有“扎实”的工作经验，也没有工作多年前辈们的“睿智镇定”，但我有一颗充满梦想的心，和执着的学习欲望。无论是像技术一样的“硬实力”，还是像“社交、演讲”这样的软实力，必须兼顾，且从不服输。\n","source":"_posts/GeekBank-C-线下班学习心得（一）.md","raw":"---\ntitle: GeekBank C++ 线下班学习心得（一）\nintro: 随着今年七月份毕业，到现在已经工作了“三月有余”（包括实习）。对学习的欲望从来没有减弱过，记得上一次参加“博览网”的线下活动时，还想和建忠老师讨论商业合作的事情。不过也是因为自己太年轻，想法过于 冲动，准备的不充分，最后也没能和博览达成合作。不过为了增强自己的学习能力和社交能力，我毅然决然的来到了博览的线下“极客班”。既然想成为极客，那么也需要付出“一定的”代价，来吧，我已经准备好了。\ncomments: true\ndate: 2015-07-21 21:12:42\ntags:\n- 日记\n---\n\n随着今年七月份毕业，到现在已经工作了“三月有余”（包括实习）。对学习的欲望从来没有减弱过，记得上一次参加“博览网”的线下活动时，还想和建忠老师讨论商业合作的事情。不过也是因为自己太年轻，想法过于 冲动，准备的不充分，最后也没能和博览达成合作。不过为了增强自己的学习能力和社交能力，我毅然决然的来到了博览的线下“极客班”。既然想成为极客，那么也需要付出“一定的”代价，来吧，我已经准备好了。\n\n伴着晨光和湿润的空气，早上八点半打的直奔线下课的目的地 - 浦东软件园。在浦东软件园上班真是有利有弊，早高峰有的时候连续等两辆公交车都不一定能挤上去。不过废话少说，我们直奔干货。\n\n说实话，不管怎么来说，我在大学也是独自一人开过技术讲座的人。可是这次线下课的第一个任务 - 自我介绍，不知道为何会这么紧张。也许是因为大家都是很厉害的人，有的人有着连续八九年的工作经验，各种各样的创业经历也是“琳琅满目”。作为93年的我，基本上也是年龄最小的。\n\n极客班的线下课以团队组队的方式进行，绿色名牌的是 IOS 学员，红色的是 C++ 学员，蓝色则是产品经理学员。而每一个团队都要由 IOS，C++ 和产品经理三种类型的学员组成。团队将要在线下课这两个月时间内要竭尽所能地做出一款产品，当然最重要的是学会如何与团队成员进行交流，比如如何协调和维护程序员与产品经理之间的关系。团队所选择的创作项目部分我们后边再说。\n\n在上午的时光里，文杰老师和 Tiny 老师分别介绍了极客班的“样本项目”，同时建中和各位老师也叙述了自己对创业以及产品相关等各种各样的想法。遵从 Tiny 的教导，我们在具体的项目开发过程中，要从 MVP（最简化的可实行产品）开始，然后进行“迭代开发”，根据功能的 Priority(优先级) 来构建各种版本。并且在每一个版本中可以将 Issue 拆分成三个等级，同时评估各个部分的时间来提高开发效率。总结起来：MVP -> 调研 -> V1 -> V2 以此类推。\n\n**ISO 部分样本项目：**\n\n* 移动 BLOG：支持新媒体、社交分享、极简交互设计；\n* 交互式白板：支持基本笔画、多人协作、实时投影、录制存储；\n* 多媒体相册：支持多张图片组合转换成视频、添加文字、模板特效、社交分享；\n\n\n**C++ 部分样本项目：**\n\n* 录屏软件：支持Windows屏幕录制；\n* Simple Key-Value DB (NOSQL)：简单的非关系型数据库；\n* Simple Local DB (SQL)：本地存储的关系型数据库，带有基本SQL操作；\n\n\n“中场休息”的时候，建中老师自费请各位学员吃午饭，各种披萨鸡块“横飞”在教室里。借着午休的时间我也和“文杰”老师聊了很多。如何才能学好 C++？注重基础语法，多写代码、如何掌握 Windows 开发？推荐了几本书。以及如何理解网络协议等各种“奇怪”的问题。\n\n茶余饭后便开始了下午的“正餐”- “项目选拔”。各位小伙伴只要有对于产品的新想法、新点子，就可以直接冲上台去给大家讲解自己心中的产品，并将名字写在黑板上等待大家最后的投票，票数最多的项目将有最高的优先级来选择项目成员。然而经过一番紧张激烈的讲解，最后一共有13个同学阐述了自己的想法。不过在这里真的很遗憾自己没有上台，并不是因为紧张害怕，而是真的没有什么好的想法，如果有我可能早早就做起来了。毕竟想法若只停留在脑中，那不是产品，只是一股脑电流罢了。并且，我认为一款好的产品不是刻意想就能想出来的，而是不经意间的灵感。\n\n**头脑风暴项目及对应票数：**\n\n* P2P换物网：暂无；\n* 多屏互动白板：7；\n* 信贷管理：5；\n* 书法比对：3；\n* 科技词典：5；\n* 酷玩视频：4；\n* 音乐弹幕：3；\n* 摄影教程：12；\n* 阿姨版饿了么：4；\n* 亲人互动平台：3；\n* 电视遥控器：2；\n* IT技能树：1；\n* 个人版历史上的今天：6；\n\n\n​“头脑风暴”之后，是由董飞老师带来的“真干货” - 《算法和系统设计导读》。“董飞”老师分别介绍了系统设计中需要掌握的基本算法和数据类型，包括排序和选择算法，数据类型包括了常见的树和链表。同时还介绍了一些 Coding 的小技巧，包括使用 Dummy Code，通过双指针追逐判断一个链表是否有环等干货。\n\n虽然没有“扎实”的工作经验，也没有工作多年前辈们的“睿智镇定”，但我有一颗充满梦想的心，和执着的学习欲望。无论是像技术一样的“硬实力”，还是像“社交、演讲”这样的软实力，必须兼顾，且从不服输。\n","slug":"GeekBank-C-线下班学习心得（一）","published":1,"updated":"2019-02-04T12:28:28.860Z","layout":"post","photos":[],"link":"","_id":"cjsqwht7l000sknp2l8t4mcpc","content":"<p>随着今年七月份毕业，到现在已经工作了“三月有余”（包括实习）。对学习的欲望从来没有减弱过，记得上一次参加“博览网”的线下活动时，还想和建忠老师讨论商业合作的事情。不过也是因为自己太年轻，想法过于 冲动，准备的不充分，最后也没能和博览达成合作。不过为了增强自己的学习能力和社交能力，我毅然决然的来到了博览的线下“极客班”。既然想成为极客，那么也需要付出“一定的”代价，来吧，我已经准备好了。</p>\n<p>伴着晨光和湿润的空气，早上八点半打的直奔线下课的目的地 - 浦东软件园。在浦东软件园上班真是有利有弊，早高峰有的时候连续等两辆公交车都不一定能挤上去。不过废话少说，我们直奔干货。</p>\n<p>说实话，不管怎么来说，我在大学也是独自一人开过技术讲座的人。可是这次线下课的第一个任务 - 自我介绍，不知道为何会这么紧张。也许是因为大家都是很厉害的人，有的人有着连续八九年的工作经验，各种各样的创业经历也是“琳琅满目”。作为93年的我，基本上也是年龄最小的。</p>\n<p>极客班的线下课以团队组队的方式进行，绿色名牌的是 IOS 学员，红色的是 C++ 学员，蓝色则是产品经理学员。而每一个团队都要由 IOS，C++ 和产品经理三种类型的学员组成。团队将要在线下课这两个月时间内要竭尽所能地做出一款产品，当然最重要的是学会如何与团队成员进行交流，比如如何协调和维护程序员与产品经理之间的关系。团队所选择的创作项目部分我们后边再说。</p>\n<p>在上午的时光里，文杰老师和 Tiny 老师分别介绍了极客班的“样本项目”，同时建中和各位老师也叙述了自己对创业以及产品相关等各种各样的想法。遵从 Tiny 的教导，我们在具体的项目开发过程中，要从 MVP（最简化的可实行产品）开始，然后进行“迭代开发”，根据功能的 Priority(优先级) 来构建各种版本。并且在每一个版本中可以将 Issue 拆分成三个等级，同时评估各个部分的时间来提高开发效率。总结起来：MVP -&gt; 调研 -&gt; V1 -&gt; V2 以此类推。</p>\n<p><strong>ISO 部分样本项目：</strong></p>\n<ul>\n<li>移动 BLOG：支持新媒体、社交分享、极简交互设计；</li>\n<li>交互式白板：支持基本笔画、多人协作、实时投影、录制存储；</li>\n<li>多媒体相册：支持多张图片组合转换成视频、添加文字、模板特效、社交分享；</li>\n</ul>\n<p><strong>C++ 部分样本项目：</strong></p>\n<ul>\n<li>录屏软件：支持Windows屏幕录制；</li>\n<li>Simple Key-Value DB (NOSQL)：简单的非关系型数据库；</li>\n<li>Simple Local DB (SQL)：本地存储的关系型数据库，带有基本SQL操作；</li>\n</ul>\n<p>“中场休息”的时候，建中老师自费请各位学员吃午饭，各种披萨鸡块“横飞”在教室里。借着午休的时间我也和“文杰”老师聊了很多。如何才能学好 C++？注重基础语法，多写代码、如何掌握 Windows 开发？推荐了几本书。以及如何理解网络协议等各种“奇怪”的问题。</p>\n<p>茶余饭后便开始了下午的“正餐”- “项目选拔”。各位小伙伴只要有对于产品的新想法、新点子，就可以直接冲上台去给大家讲解自己心中的产品，并将名字写在黑板上等待大家最后的投票，票数最多的项目将有最高的优先级来选择项目成员。然而经过一番紧张激烈的讲解，最后一共有13个同学阐述了自己的想法。不过在这里真的很遗憾自己没有上台，并不是因为紧张害怕，而是真的没有什么好的想法，如果有我可能早早就做起来了。毕竟想法若只停留在脑中，那不是产品，只是一股脑电流罢了。并且，我认为一款好的产品不是刻意想就能想出来的，而是不经意间的灵感。</p>\n<p><strong>头脑风暴项目及对应票数：</strong></p>\n<ul>\n<li>P2P换物网：暂无；</li>\n<li>多屏互动白板：7；</li>\n<li>信贷管理：5；</li>\n<li>书法比对：3；</li>\n<li>科技词典：5；</li>\n<li>酷玩视频：4；</li>\n<li>音乐弹幕：3；</li>\n<li>摄影教程：12；</li>\n<li>阿姨版饿了么：4；</li>\n<li>亲人互动平台：3；</li>\n<li>电视遥控器：2；</li>\n<li>IT技能树：1；</li>\n<li>个人版历史上的今天：6；</li>\n</ul>\n<p>​“头脑风暴”之后，是由董飞老师带来的“真干货” - 《算法和系统设计导读》。“董飞”老师分别介绍了系统设计中需要掌握的基本算法和数据类型，包括排序和选择算法，数据类型包括了常见的树和链表。同时还介绍了一些 Coding 的小技巧，包括使用 Dummy Code，通过双指针追逐判断一个链表是否有环等干货。</p>\n<p>虽然没有“扎实”的工作经验，也没有工作多年前辈们的“睿智镇定”，但我有一颗充满梦想的心，和执着的学习欲望。无论是像技术一样的“硬实力”，还是像“社交、演讲”这样的软实力，必须兼顾，且从不服输。</p>\n","site":{"data":{}},"id":"6d15155a66d1d50111eed16a5acb2c9e","excerpt":"","more":"<p>随着今年七月份毕业，到现在已经工作了“三月有余”（包括实习）。对学习的欲望从来没有减弱过，记得上一次参加“博览网”的线下活动时，还想和建忠老师讨论商业合作的事情。不过也是因为自己太年轻，想法过于 冲动，准备的不充分，最后也没能和博览达成合作。不过为了增强自己的学习能力和社交能力，我毅然决然的来到了博览的线下“极客班”。既然想成为极客，那么也需要付出“一定的”代价，来吧，我已经准备好了。</p>\n<p>伴着晨光和湿润的空气，早上八点半打的直奔线下课的目的地 - 浦东软件园。在浦东软件园上班真是有利有弊，早高峰有的时候连续等两辆公交车都不一定能挤上去。不过废话少说，我们直奔干货。</p>\n<p>说实话，不管怎么来说，我在大学也是独自一人开过技术讲座的人。可是这次线下课的第一个任务 - 自我介绍，不知道为何会这么紧张。也许是因为大家都是很厉害的人，有的人有着连续八九年的工作经验，各种各样的创业经历也是“琳琅满目”。作为93年的我，基本上也是年龄最小的。</p>\n<p>极客班的线下课以团队组队的方式进行，绿色名牌的是 IOS 学员，红色的是 C++ 学员，蓝色则是产品经理学员。而每一个团队都要由 IOS，C++ 和产品经理三种类型的学员组成。团队将要在线下课这两个月时间内要竭尽所能地做出一款产品，当然最重要的是学会如何与团队成员进行交流，比如如何协调和维护程序员与产品经理之间的关系。团队所选择的创作项目部分我们后边再说。</p>\n<p>在上午的时光里，文杰老师和 Tiny 老师分别介绍了极客班的“样本项目”，同时建中和各位老师也叙述了自己对创业以及产品相关等各种各样的想法。遵从 Tiny 的教导，我们在具体的项目开发过程中，要从 MVP（最简化的可实行产品）开始，然后进行“迭代开发”，根据功能的 Priority(优先级) 来构建各种版本。并且在每一个版本中可以将 Issue 拆分成三个等级，同时评估各个部分的时间来提高开发效率。总结起来：MVP -&gt; 调研 -&gt; V1 -&gt; V2 以此类推。</p>\n<p><strong>ISO 部分样本项目：</strong></p>\n<ul>\n<li>移动 BLOG：支持新媒体、社交分享、极简交互设计；</li>\n<li>交互式白板：支持基本笔画、多人协作、实时投影、录制存储；</li>\n<li>多媒体相册：支持多张图片组合转换成视频、添加文字、模板特效、社交分享；</li>\n</ul>\n<p><strong>C++ 部分样本项目：</strong></p>\n<ul>\n<li>录屏软件：支持Windows屏幕录制；</li>\n<li>Simple Key-Value DB (NOSQL)：简单的非关系型数据库；</li>\n<li>Simple Local DB (SQL)：本地存储的关系型数据库，带有基本SQL操作；</li>\n</ul>\n<p>“中场休息”的时候，建中老师自费请各位学员吃午饭，各种披萨鸡块“横飞”在教室里。借着午休的时间我也和“文杰”老师聊了很多。如何才能学好 C++？注重基础语法，多写代码、如何掌握 Windows 开发？推荐了几本书。以及如何理解网络协议等各种“奇怪”的问题。</p>\n<p>茶余饭后便开始了下午的“正餐”- “项目选拔”。各位小伙伴只要有对于产品的新想法、新点子，就可以直接冲上台去给大家讲解自己心中的产品，并将名字写在黑板上等待大家最后的投票，票数最多的项目将有最高的优先级来选择项目成员。然而经过一番紧张激烈的讲解，最后一共有13个同学阐述了自己的想法。不过在这里真的很遗憾自己没有上台，并不是因为紧张害怕，而是真的没有什么好的想法，如果有我可能早早就做起来了。毕竟想法若只停留在脑中，那不是产品，只是一股脑电流罢了。并且，我认为一款好的产品不是刻意想就能想出来的，而是不经意间的灵感。</p>\n<p><strong>头脑风暴项目及对应票数：</strong></p>\n<ul>\n<li>P2P换物网：暂无；</li>\n<li>多屏互动白板：7；</li>\n<li>信贷管理：5；</li>\n<li>书法比对：3；</li>\n<li>科技词典：5；</li>\n<li>酷玩视频：4；</li>\n<li>音乐弹幕：3；</li>\n<li>摄影教程：12；</li>\n<li>阿姨版饿了么：4；</li>\n<li>亲人互动平台：3；</li>\n<li>电视遥控器：2；</li>\n<li>IT技能树：1；</li>\n<li>个人版历史上的今天：6；</li>\n</ul>\n<p>​“头脑风暴”之后，是由董飞老师带来的“真干货” - 《算法和系统设计导读》。“董飞”老师分别介绍了系统设计中需要掌握的基本算法和数据类型，包括排序和选择算法，数据类型包括了常见的树和链表。同时还介绍了一些 Coding 的小技巧，包括使用 Dummy Code，通过双指针追逐判断一个链表是否有环等干货。</p>\n<p>虽然没有“扎实”的工作经验，也没有工作多年前辈们的“睿智镇定”，但我有一颗充满梦想的心，和执着的学习欲望。无论是像技术一样的“硬实力”，还是像“社交、演讲”这样的软实力，必须兼顾，且从不服输。</p>\n"},{"title":"GeekBank C++ 线下班学习心得（三）","intro":"今天是“GeekBand 极客班线下 C++ 培训”的第三周课程，本篇文章记录了大部分与产品设计及其整体生命周期相关的知识要点。","comments":1,"date":"2015-08-01T09:34:18.000Z","_content":"\n#### 淘宝产品经理分享：\n\n* **王程远**（淘宝“闲鱼” APP 项目组项目经理）；\n\n* 淘宝规则部门 -> 淘宝基础产品部门 -> 手机淘宝 -> 闲鱼；\n\n* 996 朝九晚九每周六天；\n\n\n#### 团队合作：\n\n* 产品 = 商业模式 + 功能 + 设计 + 技术 + 内容；\n\n* 产品的成功是归功于整个团队的精诚合作，产品的失败只归咎于产品负责人 - Marty Cagan；\n\n* **基本团队组成**：产品经理、交互设计师、视觉设计师、服务端开发、客户端前端开发、测试、投资人、产品运营、用户运营、内容运营、市场运营、BI、安全、客服、用研、法务；\n\n* **PRD**：产品需求文档（Product Requirement Document）；\n\n* **KPI**：关键绩效指标（Key Performance Indicator）；\n\n* **UED**：用户体验设计（User Experience Design）；\n\n* **MRD**：市场需求文档（Market Requirements Document）；\n\n* **TC**：测试用例（Test Case）；\n\n\n产品经理需要具备对于技术和视觉设计和交互设计的基础了解，不关注具体的技术实现，而关注技术实现对产品方面的影响。不要过多的干涉设计，让设计师进行主导。\n\n产品经理需要思考战略：有对产品的整体观，看终局（市场最终的结局是什么样子、未来的方向）、做布局（必须做哪几件重要的事情）、定位（告诉自己和用户：我是谁，我在哪来，我能为你解决什么）、策略（哪些路径可以走，选择哪些路径，用什么样的节奏和方法）；\n\n注重看产品的更新版本，看连续两次版本更新的功能差别；\n\n\n\n#### 项目启动前到产品上线：\n\n**MRD的内容**：（大体包括：怎么做，用什么方法做）\n\n1. 为谁解决这个问题（目标用户）；\n2. 产品要解决的问题（产品价值）；\n3. 市场有多大（市场规模）；\n4. 成功的必要条件（解决方案的关键点）；\n5. 有哪些同类产品（竞争格局）；\n6. 如何把产品推向市场（营销组合策略）；\n7. 怎样判断产品的成功（KPI）；\n\n**投资评估**：\n\n* 投入：时间成本，产品开发成本，运营成本，市场成本；\n* 回报：可量化的回报指标；\n* 风险：风险概率，严重程度和可控性；\n* 评估周期：快速；（功能不能太多，否则评估过程会耗费很多时间）\n\n**投资和投机**：\n\n* 投资：合作关系，共同的利益点，利益最大化；\n* 投机：以自己的利益最大化为主；\n\n\n**功能需求**：（从一个输入框说起）\n\n1. 前置条件（进入页面）:\n1.1. 用户状态：用户状态正常，完成支付宝实名认证；\n1.2. 登录状态：已登录；\n\n2. 标题属性：\n2.1. 是否必填；\n2.2. 字数限制；\n2.3. 默认提示文案；\n\n3. 内容安全校验：\n3.1. 触发校验点；\n3.2. 先分清，再调用违禁词表；\n3.3. 命中关键字，弹出提示；\n3.4. 提交时判断违禁词类型；\n3.5. emoji 加入到违禁词表；\n\n4. 失焦后越策类型：\n4.1. 调用类目预测接口，返回类目 ID 和类目名称；\n4.2. 返回值为空时，缺省类目“ID=1278786”；\n4.3. 修改失焦后重新调用；\n\n5. 提交校验项：\n5.1. 字数校验；\n5.2. 违禁词校验；\n\n\n**非功能需求**：\n\n1. 数据采集，用于评估产品效果；\n1.1. 设计评估指标；\n1.2. 设计客户端数据埋点，PC 埋点；\n\n2. 灰度要求：\n2.1. A/B Test;\n\n3. 项目要求：时间、资源；\n\n4. 初始化数据；\n\n5. 风险评估和方案：\n5.1. Anti-Spam 反垃圾；\n5.2. 安全风险；\n5.3. 开关；\n\n6. 关键性能需求：\n6.1. 响应时长：时间结降级方案；\n6.2 流量消耗：图片降级方案；\n\n7. 帮助和反馈课题；\n\n后台设置开关控制前端的控件显示（防止错误出现影响用户体验）；\n\n\n**PRD评审**：（功能评审，版本评审）\n\n1. 功能没有价值 => 回到问题和目标，数据和经验先明确提出来，引导建设性问题；\n2. 过度设计，成本太高 => 尽量避免完美主义；\n3. 产品设计失误或缺失 => 定位问题，引导讨论优化方案；\n4. 技术细节过度讨论 => 指定相关人给出方案，迅速推进；\n\n\n**设计评审**：\n\n\n* 项目初期：“How” and “Why”；\n* 项目中期：“Strength” and “Weather”；\n* 项目后期：“Variable” and “Wrap up details”；\n\n\n**如何优雅的参加设计评审**：\n\n* 先听后说；\n* 在表达个人看法喜好时一定要提前声明；\n* 关键的问题先提问；\n* 找出当前设计方案中的精华部分；\n* 找出问题，指出设计师可能遗漏的方向，避免直接给出解决方案；\n\n\n**技术方案评审关注的几个重点**：\n\n* 底层设计的拓展性；\n* Native or H5（Web 页面）；\n* 接口设计；\n* 数据结构；\n* 跨平台的一致性；\n* Kickoff：确定需求、设计、技术方案、沟通方式、项目时间点；\n\n\n\n**3P（产品经理、设计师、开发工程师）的爱恨情仇**：不要以专业自居（比如设计和开发之间）；\n\n**发布上线**：（两周开发一周测试）\n1. 灰度发布：检验 BUG 性能指标关键指标监控；\n2. APP 发布到渠道；\n3. Web、H5 和服务端发布；\n\n\n#### 项目启动后：\n\n**３种典型的运营**：\n\n* 用户运营（KPI = 拉新 + 暂存 +流失召回）；\n* 内容/社区运营（KPI = 内容质量 +　数量 + 互动 + 建立模式）；\n* 市场/营销运营（KPI = 品牌影响力 +　营销指标）；\n\n\n**用户运营**：\n\n* 获取新用户：用户分类和分层，获取用户渠道，数据：各种 ROI；\n* 留存和流失：找到用户暂留关键，流失用户召回，数据：用户留存；\n* 核心体现：建立 HOOK Model，数据：关键漏斗转化率；\n\n**常用指标**：\n\n* 用户获取成本：CAC；\n* 用户活跃：DAU（APP 的核心价值）；\n* 周活跃用户数：WAU；\n* 月活跃用户数：MAU；\n* 日参与次数：DEC；\n* 日均使用市场：DAOT/AT；\n* 留存 + 流失：\n* 次日留存；\n* 三日留存；\n* 七日留存；\n\n**内容 / 社区运营**：\n\n* 设计用户发现内容的路径；\n* 直接产生内容；\n* 驱动用户产生内容；\n* 设计浮现机制；\n* 驱动内容消费；\n\n**用户发现内容的路径：**\n\n* 类目、广告、属性、搜索、人、算法推荐；\n","source":"_posts/GeekBank-C-线下班学习心得（三）.md","raw":"---\ntitle: GeekBank C++ 线下班学习心得（三）\nintro: 今天是“GeekBand 极客班线下 C++ 培训”的第三周课程，本篇文章记录了大部分与产品设计及其整体生命周期相关的知识要点。\ncomments: true\ndate: 2015-08-01 17:34:18\ntags:\n- 日记\n---\n\n#### 淘宝产品经理分享：\n\n* **王程远**（淘宝“闲鱼” APP 项目组项目经理）；\n\n* 淘宝规则部门 -> 淘宝基础产品部门 -> 手机淘宝 -> 闲鱼；\n\n* 996 朝九晚九每周六天；\n\n\n#### 团队合作：\n\n* 产品 = 商业模式 + 功能 + 设计 + 技术 + 内容；\n\n* 产品的成功是归功于整个团队的精诚合作，产品的失败只归咎于产品负责人 - Marty Cagan；\n\n* **基本团队组成**：产品经理、交互设计师、视觉设计师、服务端开发、客户端前端开发、测试、投资人、产品运营、用户运营、内容运营、市场运营、BI、安全、客服、用研、法务；\n\n* **PRD**：产品需求文档（Product Requirement Document）；\n\n* **KPI**：关键绩效指标（Key Performance Indicator）；\n\n* **UED**：用户体验设计（User Experience Design）；\n\n* **MRD**：市场需求文档（Market Requirements Document）；\n\n* **TC**：测试用例（Test Case）；\n\n\n产品经理需要具备对于技术和视觉设计和交互设计的基础了解，不关注具体的技术实现，而关注技术实现对产品方面的影响。不要过多的干涉设计，让设计师进行主导。\n\n产品经理需要思考战略：有对产品的整体观，看终局（市场最终的结局是什么样子、未来的方向）、做布局（必须做哪几件重要的事情）、定位（告诉自己和用户：我是谁，我在哪来，我能为你解决什么）、策略（哪些路径可以走，选择哪些路径，用什么样的节奏和方法）；\n\n注重看产品的更新版本，看连续两次版本更新的功能差别；\n\n\n\n#### 项目启动前到产品上线：\n\n**MRD的内容**：（大体包括：怎么做，用什么方法做）\n\n1. 为谁解决这个问题（目标用户）；\n2. 产品要解决的问题（产品价值）；\n3. 市场有多大（市场规模）；\n4. 成功的必要条件（解决方案的关键点）；\n5. 有哪些同类产品（竞争格局）；\n6. 如何把产品推向市场（营销组合策略）；\n7. 怎样判断产品的成功（KPI）；\n\n**投资评估**：\n\n* 投入：时间成本，产品开发成本，运营成本，市场成本；\n* 回报：可量化的回报指标；\n* 风险：风险概率，严重程度和可控性；\n* 评估周期：快速；（功能不能太多，否则评估过程会耗费很多时间）\n\n**投资和投机**：\n\n* 投资：合作关系，共同的利益点，利益最大化；\n* 投机：以自己的利益最大化为主；\n\n\n**功能需求**：（从一个输入框说起）\n\n1. 前置条件（进入页面）:\n1.1. 用户状态：用户状态正常，完成支付宝实名认证；\n1.2. 登录状态：已登录；\n\n2. 标题属性：\n2.1. 是否必填；\n2.2. 字数限制；\n2.3. 默认提示文案；\n\n3. 内容安全校验：\n3.1. 触发校验点；\n3.2. 先分清，再调用违禁词表；\n3.3. 命中关键字，弹出提示；\n3.4. 提交时判断违禁词类型；\n3.5. emoji 加入到违禁词表；\n\n4. 失焦后越策类型：\n4.1. 调用类目预测接口，返回类目 ID 和类目名称；\n4.2. 返回值为空时，缺省类目“ID=1278786”；\n4.3. 修改失焦后重新调用；\n\n5. 提交校验项：\n5.1. 字数校验；\n5.2. 违禁词校验；\n\n\n**非功能需求**：\n\n1. 数据采集，用于评估产品效果；\n1.1. 设计评估指标；\n1.2. 设计客户端数据埋点，PC 埋点；\n\n2. 灰度要求：\n2.1. A/B Test;\n\n3. 项目要求：时间、资源；\n\n4. 初始化数据；\n\n5. 风险评估和方案：\n5.1. Anti-Spam 反垃圾；\n5.2. 安全风险；\n5.3. 开关；\n\n6. 关键性能需求：\n6.1. 响应时长：时间结降级方案；\n6.2 流量消耗：图片降级方案；\n\n7. 帮助和反馈课题；\n\n后台设置开关控制前端的控件显示（防止错误出现影响用户体验）；\n\n\n**PRD评审**：（功能评审，版本评审）\n\n1. 功能没有价值 => 回到问题和目标，数据和经验先明确提出来，引导建设性问题；\n2. 过度设计，成本太高 => 尽量避免完美主义；\n3. 产品设计失误或缺失 => 定位问题，引导讨论优化方案；\n4. 技术细节过度讨论 => 指定相关人给出方案，迅速推进；\n\n\n**设计评审**：\n\n\n* 项目初期：“How” and “Why”；\n* 项目中期：“Strength” and “Weather”；\n* 项目后期：“Variable” and “Wrap up details”；\n\n\n**如何优雅的参加设计评审**：\n\n* 先听后说；\n* 在表达个人看法喜好时一定要提前声明；\n* 关键的问题先提问；\n* 找出当前设计方案中的精华部分；\n* 找出问题，指出设计师可能遗漏的方向，避免直接给出解决方案；\n\n\n**技术方案评审关注的几个重点**：\n\n* 底层设计的拓展性；\n* Native or H5（Web 页面）；\n* 接口设计；\n* 数据结构；\n* 跨平台的一致性；\n* Kickoff：确定需求、设计、技术方案、沟通方式、项目时间点；\n\n\n\n**3P（产品经理、设计师、开发工程师）的爱恨情仇**：不要以专业自居（比如设计和开发之间）；\n\n**发布上线**：（两周开发一周测试）\n1. 灰度发布：检验 BUG 性能指标关键指标监控；\n2. APP 发布到渠道；\n3. Web、H5 和服务端发布；\n\n\n#### 项目启动后：\n\n**３种典型的运营**：\n\n* 用户运营（KPI = 拉新 + 暂存 +流失召回）；\n* 内容/社区运营（KPI = 内容质量 +　数量 + 互动 + 建立模式）；\n* 市场/营销运营（KPI = 品牌影响力 +　营销指标）；\n\n\n**用户运营**：\n\n* 获取新用户：用户分类和分层，获取用户渠道，数据：各种 ROI；\n* 留存和流失：找到用户暂留关键，流失用户召回，数据：用户留存；\n* 核心体现：建立 HOOK Model，数据：关键漏斗转化率；\n\n**常用指标**：\n\n* 用户获取成本：CAC；\n* 用户活跃：DAU（APP 的核心价值）；\n* 周活跃用户数：WAU；\n* 月活跃用户数：MAU；\n* 日参与次数：DEC；\n* 日均使用市场：DAOT/AT；\n* 留存 + 流失：\n* 次日留存；\n* 三日留存；\n* 七日留存；\n\n**内容 / 社区运营**：\n\n* 设计用户发现内容的路径；\n* 直接产生内容；\n* 驱动用户产生内容；\n* 设计浮现机制；\n* 驱动内容消费；\n\n**用户发现内容的路径：**\n\n* 类目、广告、属性、搜索、人、算法推荐；\n","slug":"GeekBank-C-线下班学习心得（三）","published":1,"updated":"2019-02-04T16:36:26.717Z","layout":"post","photos":[],"link":"","_id":"cjsqwht7m000uknp22od2x9m7","content":"<h4 id=\"淘宝产品经理分享：\"><a href=\"#淘宝产品经理分享：\" class=\"headerlink\" title=\"淘宝产品经理分享：\"></a>淘宝产品经理分享：</h4><ul>\n<li><p><strong>王程远</strong>（淘宝“闲鱼” APP 项目组项目经理）；</p>\n</li>\n<li><p>淘宝规则部门 -&gt; 淘宝基础产品部门 -&gt; 手机淘宝 -&gt; 闲鱼；</p>\n</li>\n<li><p>996 朝九晚九每周六天；</p>\n</li>\n</ul>\n<h4 id=\"团队合作：\"><a href=\"#团队合作：\" class=\"headerlink\" title=\"团队合作：\"></a>团队合作：</h4><ul>\n<li><p>产品 = 商业模式 + 功能 + 设计 + 技术 + 内容；</p>\n</li>\n<li><p>产品的成功是归功于整个团队的精诚合作，产品的失败只归咎于产品负责人 - Marty Cagan；</p>\n</li>\n<li><p><strong>基本团队组成</strong>：产品经理、交互设计师、视觉设计师、服务端开发、客户端前端开发、测试、投资人、产品运营、用户运营、内容运营、市场运营、BI、安全、客服、用研、法务；</p>\n</li>\n<li><p><strong>PRD</strong>：产品需求文档（Product Requirement Document）；</p>\n</li>\n<li><p><strong>KPI</strong>：关键绩效指标（Key Performance Indicator）；</p>\n</li>\n<li><p><strong>UED</strong>：用户体验设计（User Experience Design）；</p>\n</li>\n<li><p><strong>MRD</strong>：市场需求文档（Market Requirements Document）；</p>\n</li>\n<li><p><strong>TC</strong>：测试用例（Test Case）；</p>\n</li>\n</ul>\n<p>产品经理需要具备对于技术和视觉设计和交互设计的基础了解，不关注具体的技术实现，而关注技术实现对产品方面的影响。不要过多的干涉设计，让设计师进行主导。</p>\n<p>产品经理需要思考战略：有对产品的整体观，看终局（市场最终的结局是什么样子、未来的方向）、做布局（必须做哪几件重要的事情）、定位（告诉自己和用户：我是谁，我在哪来，我能为你解决什么）、策略（哪些路径可以走，选择哪些路径，用什么样的节奏和方法）；</p>\n<p>注重看产品的更新版本，看连续两次版本更新的功能差别；</p>\n<h4 id=\"项目启动前到产品上线：\"><a href=\"#项目启动前到产品上线：\" class=\"headerlink\" title=\"项目启动前到产品上线：\"></a>项目启动前到产品上线：</h4><p><strong>MRD的内容</strong>：（大体包括：怎么做，用什么方法做）</p>\n<ol>\n<li>为谁解决这个问题（目标用户）；</li>\n<li>产品要解决的问题（产品价值）；</li>\n<li>市场有多大（市场规模）；</li>\n<li>成功的必要条件（解决方案的关键点）；</li>\n<li>有哪些同类产品（竞争格局）；</li>\n<li>如何把产品推向市场（营销组合策略）；</li>\n<li>怎样判断产品的成功（KPI）；</li>\n</ol>\n<p><strong>投资评估</strong>：</p>\n<ul>\n<li>投入：时间成本，产品开发成本，运营成本，市场成本；</li>\n<li>回报：可量化的回报指标；</li>\n<li>风险：风险概率，严重程度和可控性；</li>\n<li>评估周期：快速；（功能不能太多，否则评估过程会耗费很多时间）</li>\n</ul>\n<p><strong>投资和投机</strong>：</p>\n<ul>\n<li>投资：合作关系，共同的利益点，利益最大化；</li>\n<li>投机：以自己的利益最大化为主；</li>\n</ul>\n<p><strong>功能需求</strong>：（从一个输入框说起）</p>\n<ol>\n<li><p>前置条件（进入页面）:<br>1.1. 用户状态：用户状态正常，完成支付宝实名认证；<br>1.2. 登录状态：已登录；</p>\n</li>\n<li><p>标题属性：<br>2.1. 是否必填；<br>2.2. 字数限制；<br>2.3. 默认提示文案；</p>\n</li>\n<li><p>内容安全校验：<br>3.1. 触发校验点；<br>3.2. 先分清，再调用违禁词表；<br>3.3. 命中关键字，弹出提示；<br>3.4. 提交时判断违禁词类型；<br>3.5. emoji 加入到违禁词表；</p>\n</li>\n<li><p>失焦后越策类型：<br>4.1. 调用类目预测接口，返回类目 ID 和类目名称；<br>4.2. 返回值为空时，缺省类目“ID=1278786”；<br>4.3. 修改失焦后重新调用；</p>\n</li>\n<li><p>提交校验项：<br>5.1. 字数校验；<br>5.2. 违禁词校验；</p>\n</li>\n</ol>\n<p><strong>非功能需求</strong>：</p>\n<ol>\n<li><p>数据采集，用于评估产品效果；<br>1.1. 设计评估指标；<br>1.2. 设计客户端数据埋点，PC 埋点；</p>\n</li>\n<li><p>灰度要求：<br>2.1. A/B Test;</p>\n</li>\n<li><p>项目要求：时间、资源；</p>\n</li>\n<li><p>初始化数据；</p>\n</li>\n<li><p>风险评估和方案：<br>5.1. Anti-Spam 反垃圾；<br>5.2. 安全风险；<br>5.3. 开关；</p>\n</li>\n<li><p>关键性能需求：<br>6.1. 响应时长：时间结降级方案；<br>6.2 流量消耗：图片降级方案；</p>\n</li>\n<li><p>帮助和反馈课题；</p>\n</li>\n</ol>\n<p>后台设置开关控制前端的控件显示（防止错误出现影响用户体验）；</p>\n<p><strong>PRD评审</strong>：（功能评审，版本评审）</p>\n<ol>\n<li>功能没有价值 =&gt; 回到问题和目标，数据和经验先明确提出来，引导建设性问题；</li>\n<li>过度设计，成本太高 =&gt; 尽量避免完美主义；</li>\n<li>产品设计失误或缺失 =&gt; 定位问题，引导讨论优化方案；</li>\n<li>技术细节过度讨论 =&gt; 指定相关人给出方案，迅速推进；</li>\n</ol>\n<p><strong>设计评审</strong>：</p>\n<ul>\n<li>项目初期：“How” and “Why”；</li>\n<li>项目中期：“Strength” and “Weather”；</li>\n<li>项目后期：“Variable” and “Wrap up details”；</li>\n</ul>\n<p><strong>如何优雅的参加设计评审</strong>：</p>\n<ul>\n<li>先听后说；</li>\n<li>在表达个人看法喜好时一定要提前声明；</li>\n<li>关键的问题先提问；</li>\n<li>找出当前设计方案中的精华部分；</li>\n<li>找出问题，指出设计师可能遗漏的方向，避免直接给出解决方案；</li>\n</ul>\n<p><strong>技术方案评审关注的几个重点</strong>：</p>\n<ul>\n<li>底层设计的拓展性；</li>\n<li>Native or H5（Web 页面）；</li>\n<li>接口设计；</li>\n<li>数据结构；</li>\n<li>跨平台的一致性；</li>\n<li>Kickoff：确定需求、设计、技术方案、沟通方式、项目时间点；</li>\n</ul>\n<p><strong>3P（产品经理、设计师、开发工程师）的爱恨情仇</strong>：不要以专业自居（比如设计和开发之间）；</p>\n<p><strong>发布上线</strong>：（两周开发一周测试）</p>\n<ol>\n<li>灰度发布：检验 BUG 性能指标关键指标监控；</li>\n<li>APP 发布到渠道；</li>\n<li>Web、H5 和服务端发布；</li>\n</ol>\n<h4 id=\"项目启动后：\"><a href=\"#项目启动后：\" class=\"headerlink\" title=\"项目启动后：\"></a>项目启动后：</h4><p><strong>３种典型的运营</strong>：</p>\n<ul>\n<li>用户运营（KPI = 拉新 + 暂存 +流失召回）；</li>\n<li>内容/社区运营（KPI = 内容质量 +　数量 + 互动 + 建立模式）；</li>\n<li>市场/营销运营（KPI = 品牌影响力 +　营销指标）；</li>\n</ul>\n<p><strong>用户运营</strong>：</p>\n<ul>\n<li>获取新用户：用户分类和分层，获取用户渠道，数据：各种 ROI；</li>\n<li>留存和流失：找到用户暂留关键，流失用户召回，数据：用户留存；</li>\n<li>核心体现：建立 HOOK Model，数据：关键漏斗转化率；</li>\n</ul>\n<p><strong>常用指标</strong>：</p>\n<ul>\n<li>用户获取成本：CAC；</li>\n<li>用户活跃：DAU（APP 的核心价值）；</li>\n<li>周活跃用户数：WAU；</li>\n<li>月活跃用户数：MAU；</li>\n<li>日参与次数：DEC；</li>\n<li>日均使用市场：DAOT/AT；</li>\n<li>留存 + 流失：</li>\n<li>次日留存；</li>\n<li>三日留存；</li>\n<li>七日留存；</li>\n</ul>\n<p><strong>内容 / 社区运营</strong>：</p>\n<ul>\n<li>设计用户发现内容的路径；</li>\n<li>直接产生内容；</li>\n<li>驱动用户产生内容；</li>\n<li>设计浮现机制；</li>\n<li>驱动内容消费；</li>\n</ul>\n<p><strong>用户发现内容的路径：</strong></p>\n<ul>\n<li>类目、广告、属性、搜索、人、算法推荐；</li>\n</ul>\n","site":{"data":{}},"id":"25acdea42eee9a96b775cd5b185495f7","excerpt":"","more":"<h4 id=\"淘宝产品经理分享：\"><a href=\"#淘宝产品经理分享：\" class=\"headerlink\" title=\"淘宝产品经理分享：\"></a>淘宝产品经理分享：</h4><ul>\n<li><p><strong>王程远</strong>（淘宝“闲鱼” APP 项目组项目经理）；</p>\n</li>\n<li><p>淘宝规则部门 -&gt; 淘宝基础产品部门 -&gt; 手机淘宝 -&gt; 闲鱼；</p>\n</li>\n<li><p>996 朝九晚九每周六天；</p>\n</li>\n</ul>\n<h4 id=\"团队合作：\"><a href=\"#团队合作：\" class=\"headerlink\" title=\"团队合作：\"></a>团队合作：</h4><ul>\n<li><p>产品 = 商业模式 + 功能 + 设计 + 技术 + 内容；</p>\n</li>\n<li><p>产品的成功是归功于整个团队的精诚合作，产品的失败只归咎于产品负责人 - Marty Cagan；</p>\n</li>\n<li><p><strong>基本团队组成</strong>：产品经理、交互设计师、视觉设计师、服务端开发、客户端前端开发、测试、投资人、产品运营、用户运营、内容运营、市场运营、BI、安全、客服、用研、法务；</p>\n</li>\n<li><p><strong>PRD</strong>：产品需求文档（Product Requirement Document）；</p>\n</li>\n<li><p><strong>KPI</strong>：关键绩效指标（Key Performance Indicator）；</p>\n</li>\n<li><p><strong>UED</strong>：用户体验设计（User Experience Design）；</p>\n</li>\n<li><p><strong>MRD</strong>：市场需求文档（Market Requirements Document）；</p>\n</li>\n<li><p><strong>TC</strong>：测试用例（Test Case）；</p>\n</li>\n</ul>\n<p>产品经理需要具备对于技术和视觉设计和交互设计的基础了解，不关注具体的技术实现，而关注技术实现对产品方面的影响。不要过多的干涉设计，让设计师进行主导。</p>\n<p>产品经理需要思考战略：有对产品的整体观，看终局（市场最终的结局是什么样子、未来的方向）、做布局（必须做哪几件重要的事情）、定位（告诉自己和用户：我是谁，我在哪来，我能为你解决什么）、策略（哪些路径可以走，选择哪些路径，用什么样的节奏和方法）；</p>\n<p>注重看产品的更新版本，看连续两次版本更新的功能差别；</p>\n<h4 id=\"项目启动前到产品上线：\"><a href=\"#项目启动前到产品上线：\" class=\"headerlink\" title=\"项目启动前到产品上线：\"></a>项目启动前到产品上线：</h4><p><strong>MRD的内容</strong>：（大体包括：怎么做，用什么方法做）</p>\n<ol>\n<li>为谁解决这个问题（目标用户）；</li>\n<li>产品要解决的问题（产品价值）；</li>\n<li>市场有多大（市场规模）；</li>\n<li>成功的必要条件（解决方案的关键点）；</li>\n<li>有哪些同类产品（竞争格局）；</li>\n<li>如何把产品推向市场（营销组合策略）；</li>\n<li>怎样判断产品的成功（KPI）；</li>\n</ol>\n<p><strong>投资评估</strong>：</p>\n<ul>\n<li>投入：时间成本，产品开发成本，运营成本，市场成本；</li>\n<li>回报：可量化的回报指标；</li>\n<li>风险：风险概率，严重程度和可控性；</li>\n<li>评估周期：快速；（功能不能太多，否则评估过程会耗费很多时间）</li>\n</ul>\n<p><strong>投资和投机</strong>：</p>\n<ul>\n<li>投资：合作关系，共同的利益点，利益最大化；</li>\n<li>投机：以自己的利益最大化为主；</li>\n</ul>\n<p><strong>功能需求</strong>：（从一个输入框说起）</p>\n<ol>\n<li><p>前置条件（进入页面）:<br>1.1. 用户状态：用户状态正常，完成支付宝实名认证；<br>1.2. 登录状态：已登录；</p>\n</li>\n<li><p>标题属性：<br>2.1. 是否必填；<br>2.2. 字数限制；<br>2.3. 默认提示文案；</p>\n</li>\n<li><p>内容安全校验：<br>3.1. 触发校验点；<br>3.2. 先分清，再调用违禁词表；<br>3.3. 命中关键字，弹出提示；<br>3.4. 提交时判断违禁词类型；<br>3.5. emoji 加入到违禁词表；</p>\n</li>\n<li><p>失焦后越策类型：<br>4.1. 调用类目预测接口，返回类目 ID 和类目名称；<br>4.2. 返回值为空时，缺省类目“ID=1278786”；<br>4.3. 修改失焦后重新调用；</p>\n</li>\n<li><p>提交校验项：<br>5.1. 字数校验；<br>5.2. 违禁词校验；</p>\n</li>\n</ol>\n<p><strong>非功能需求</strong>：</p>\n<ol>\n<li><p>数据采集，用于评估产品效果；<br>1.1. 设计评估指标；<br>1.2. 设计客户端数据埋点，PC 埋点；</p>\n</li>\n<li><p>灰度要求：<br>2.1. A/B Test;</p>\n</li>\n<li><p>项目要求：时间、资源；</p>\n</li>\n<li><p>初始化数据；</p>\n</li>\n<li><p>风险评估和方案：<br>5.1. Anti-Spam 反垃圾；<br>5.2. 安全风险；<br>5.3. 开关；</p>\n</li>\n<li><p>关键性能需求：<br>6.1. 响应时长：时间结降级方案；<br>6.2 流量消耗：图片降级方案；</p>\n</li>\n<li><p>帮助和反馈课题；</p>\n</li>\n</ol>\n<p>后台设置开关控制前端的控件显示（防止错误出现影响用户体验）；</p>\n<p><strong>PRD评审</strong>：（功能评审，版本评审）</p>\n<ol>\n<li>功能没有价值 =&gt; 回到问题和目标，数据和经验先明确提出来，引导建设性问题；</li>\n<li>过度设计，成本太高 =&gt; 尽量避免完美主义；</li>\n<li>产品设计失误或缺失 =&gt; 定位问题，引导讨论优化方案；</li>\n<li>技术细节过度讨论 =&gt; 指定相关人给出方案，迅速推进；</li>\n</ol>\n<p><strong>设计评审</strong>：</p>\n<ul>\n<li>项目初期：“How” and “Why”；</li>\n<li>项目中期：“Strength” and “Weather”；</li>\n<li>项目后期：“Variable” and “Wrap up details”；</li>\n</ul>\n<p><strong>如何优雅的参加设计评审</strong>：</p>\n<ul>\n<li>先听后说；</li>\n<li>在表达个人看法喜好时一定要提前声明；</li>\n<li>关键的问题先提问；</li>\n<li>找出当前设计方案中的精华部分；</li>\n<li>找出问题，指出设计师可能遗漏的方向，避免直接给出解决方案；</li>\n</ul>\n<p><strong>技术方案评审关注的几个重点</strong>：</p>\n<ul>\n<li>底层设计的拓展性；</li>\n<li>Native or H5（Web 页面）；</li>\n<li>接口设计；</li>\n<li>数据结构；</li>\n<li>跨平台的一致性；</li>\n<li>Kickoff：确定需求、设计、技术方案、沟通方式、项目时间点；</li>\n</ul>\n<p><strong>3P（产品经理、设计师、开发工程师）的爱恨情仇</strong>：不要以专业自居（比如设计和开发之间）；</p>\n<p><strong>发布上线</strong>：（两周开发一周测试）</p>\n<ol>\n<li>灰度发布：检验 BUG 性能指标关键指标监控；</li>\n<li>APP 发布到渠道；</li>\n<li>Web、H5 和服务端发布；</li>\n</ol>\n<h4 id=\"项目启动后：\"><a href=\"#项目启动后：\" class=\"headerlink\" title=\"项目启动后：\"></a>项目启动后：</h4><p><strong>３种典型的运营</strong>：</p>\n<ul>\n<li>用户运营（KPI = 拉新 + 暂存 +流失召回）；</li>\n<li>内容/社区运营（KPI = 内容质量 +　数量 + 互动 + 建立模式）；</li>\n<li>市场/营销运营（KPI = 品牌影响力 +　营销指标）；</li>\n</ul>\n<p><strong>用户运营</strong>：</p>\n<ul>\n<li>获取新用户：用户分类和分层，获取用户渠道，数据：各种 ROI；</li>\n<li>留存和流失：找到用户暂留关键，流失用户召回，数据：用户留存；</li>\n<li>核心体现：建立 HOOK Model，数据：关键漏斗转化率；</li>\n</ul>\n<p><strong>常用指标</strong>：</p>\n<ul>\n<li>用户获取成本：CAC；</li>\n<li>用户活跃：DAU（APP 的核心价值）；</li>\n<li>周活跃用户数：WAU；</li>\n<li>月活跃用户数：MAU；</li>\n<li>日参与次数：DEC；</li>\n<li>日均使用市场：DAOT/AT；</li>\n<li>留存 + 流失：</li>\n<li>次日留存；</li>\n<li>三日留存；</li>\n<li>七日留存；</li>\n</ul>\n<p><strong>内容 / 社区运营</strong>：</p>\n<ul>\n<li>设计用户发现内容的路径；</li>\n<li>直接产生内容；</li>\n<li>驱动用户产生内容；</li>\n<li>设计浮现机制；</li>\n<li>驱动内容消费；</li>\n</ul>\n<p><strong>用户发现内容的路径：</strong></p>\n<ul>\n<li>类目、广告、属性、搜索、人、算法推荐；</li>\n</ul>\n"},{"title":"GeekBank C++ 线下班学习心得（二）","intro":"今天是“GeekBand 极客班线下 C++ 培训”的第二周课程，浦东12路依旧挤得不行。上午先是产品经理部分的课程答疑与培训，一些课程重点的总结如下。","comments":1,"date":"2015-07-25T13:08:31.000Z","_content":"\n今天是“GeekBand 极客班线下 C++ 培训的第二周课程”，浦东12路依旧挤得不行。上午先是产品经理部分的课程答疑与培训，一些课程重点的总结如下：\n\n* **用户：**使用产品的人（不一定付钱）；\n* **客户：**通常是付钱的人（用户从来不买单）；\n* **调查问卷：**尽量用电话，微信语音相比较更好，不要让用户看到你要问什么问题；\n* **AB 测试：**A用户群使用第一个版本，B用户群使用第二个版本；\n* **灰度发布：**对一小部分人群进行产品发布（相对成熟的产品），并及时了解反馈建议；\n* **MVP：**产品可以使用，虽然用户体验并不一定好，但是却可以解决用户的问题；\n* **快速迭代：**一周到两周发布一个新的版本；\n\n#### 产品经理必读书：\n\n* 《系统化思维导论》（Jerry Weinberg 著）：训练逻辑思维。\n* 《精英数据分析》\n* 《从0到1》\n\n#### 产品经验总结：\n\n1. 策划产品时要对产品面向的用户群体进行细分（必须进行量化），不能使用模糊的群体分类（比如极客），要有明确的定位，并在生活中可以找到实例；\n2. 表达能力重要性和逻辑推理的重要性；\n3. 从创意去思考背后的问题，%99用户的主意都是无用的；\n4. 走出办公楼，去面对自己的用户；\n\n\n\n#### “IOS 应用开发与实战”课总结：\n\n1. 写代码：代码整体的干净程度，像说明文，易于后来人接手，代码的优美；\n2. 不要去死记硬背，写得多自然就记住了；\n\n\n\n#### “C++辅导课培训”总结：\n\n**栈：**\n\n* 由系统自动管理，以执行函数为单位；MyClass c(10)；\n* 空间大小编译时确定（参数 + 局部变量）；\n* 函数执行时，系统自动分配一个 Stack；\n* 函数执行结束时，系统立即回收 Stact；\n\n\n**堆：**\n\n* 在 C++ 中由程序员手动控制 “New” 出来的对象在堆上；\n* 手动分配 `new` 和 `malloc`；\n* 手动释放 `delete` 和 `free`；\n* 具有全局性，总体大小无限制；\n* 容易造成内存泄露；\n\n\n\n**避免悬浮指针：**\n\n```cpp\nMyClass *func() {\n    MyClass c(10);\n    return &c;\n}\n```\n\n**栈是属于函数的：指向栈对象的指针比较危险：**\n\n```cpp\nMyClass func() {\n    MyClass c(10);\n    AClass a(100);\n    c.pa = $a;\n    return c;\n}\n```\n\n**返回值尽量不要反悔指针，谁分配内存谁释放内存：**\n\n```cpp\nMyClass *func() {\n    MyClass * pa = new MyClass();\n    return pa;\n}\nMyClass *p = func();\n```\n\n* 栈上存放指针，堆上存储真正的对象;\n* 栈对象：对象内存直接存储于栈对象;\n\n\n#### C++ 变量模型与使用：\n\n**传参：**\n\n```cpp\n// 传对象不好，对象较大，只要传参就是拷贝；\nvoid func1(MyClass c) {\n    // 这里 “c” 的大小依赖于各个字段的大小，32位机器若有虚函数加 4byte，64位则加 8byte；\n}\nvoid func2(MyClass *pc) {\n    // 尽量不用，不能 delete 栈对象；\n}\n```\n\n**后续删除指针：**\n\n```cpp\nMyClass *pc = new MyClass();\nfunc2(pc);\ndelete(pc);\n```\n\n```cpp\nvoid func3(MyClass &mc) {\n    // 传参成本低，效率高，背后是指针，不用考虑是栈对象还是堆对象；\n}\nvoid func3(MyClass &mc) {\n    // 若 “mc” 是堆对象，则函数没问题，但 “mc” 是外部参数，函数不负责释放；\n    MyClass *p = &mc;\n    delete p;\n}\n// ByValue 的替代，传 const 引用；\nvoid func3(const MyClass &mc) {}\n```\n\n**传参：**\n\n\n```cpp\nMyClass c1；\nfunc1(c1);\nfunc2(&c1);\nfunc3(c1);\t\n```\n\n**返回值：**\n\n```cpp\nMyClass func1() {\n    MyClass c1;\n    return c1;\n\n    MyClass* pc2 = new MyClass();\n    return *pc2;\n    // 返回对象常见；\n    // 这里 “pc2” 指针不会被释放；\n}\n\nMyClass *func2() {\n    MyClass c1;\n    return &c1;\n    // OR；\n    MyClass *pc2 = new MyClass();\n    return pc2;\n    // 只能返回堆对象的指针；\n}\n\nMyClass& func4(MyClass &c) {\n    return c;\n}\t\n```\n\n* 栈的大小是确定的，堆具有灵活性，大小可以随意分配，没有栈就没有函数，没有变量；\n\n**总结：**\n\n* 掌握内存模型的分析方法 — 画运行时内存图；\n* 掌握堆、栈的概念；\n* 掌握指针、引用、对象；\n* 探微知著：魔鬼尽在细节中；\n\n","source":"_posts/GeekBank-C-线下班学习心得（二）.md","raw":"---\ntitle: GeekBank C++ 线下班学习心得（二）\nintro: 今天是“GeekBand 极客班线下 C++ 培训”的第二周课程，浦东12路依旧挤得不行。上午先是产品经理部分的课程答疑与培训，一些课程重点的总结如下。\ncomments: true\ndate: 2015-07-25 21:08:31\ntags:\n- 日记\n---\n\n今天是“GeekBand 极客班线下 C++ 培训的第二周课程”，浦东12路依旧挤得不行。上午先是产品经理部分的课程答疑与培训，一些课程重点的总结如下：\n\n* **用户：**使用产品的人（不一定付钱）；\n* **客户：**通常是付钱的人（用户从来不买单）；\n* **调查问卷：**尽量用电话，微信语音相比较更好，不要让用户看到你要问什么问题；\n* **AB 测试：**A用户群使用第一个版本，B用户群使用第二个版本；\n* **灰度发布：**对一小部分人群进行产品发布（相对成熟的产品），并及时了解反馈建议；\n* **MVP：**产品可以使用，虽然用户体验并不一定好，但是却可以解决用户的问题；\n* **快速迭代：**一周到两周发布一个新的版本；\n\n#### 产品经理必读书：\n\n* 《系统化思维导论》（Jerry Weinberg 著）：训练逻辑思维。\n* 《精英数据分析》\n* 《从0到1》\n\n#### 产品经验总结：\n\n1. 策划产品时要对产品面向的用户群体进行细分（必须进行量化），不能使用模糊的群体分类（比如极客），要有明确的定位，并在生活中可以找到实例；\n2. 表达能力重要性和逻辑推理的重要性；\n3. 从创意去思考背后的问题，%99用户的主意都是无用的；\n4. 走出办公楼，去面对自己的用户；\n\n\n\n#### “IOS 应用开发与实战”课总结：\n\n1. 写代码：代码整体的干净程度，像说明文，易于后来人接手，代码的优美；\n2. 不要去死记硬背，写得多自然就记住了；\n\n\n\n#### “C++辅导课培训”总结：\n\n**栈：**\n\n* 由系统自动管理，以执行函数为单位；MyClass c(10)；\n* 空间大小编译时确定（参数 + 局部变量）；\n* 函数执行时，系统自动分配一个 Stack；\n* 函数执行结束时，系统立即回收 Stact；\n\n\n**堆：**\n\n* 在 C++ 中由程序员手动控制 “New” 出来的对象在堆上；\n* 手动分配 `new` 和 `malloc`；\n* 手动释放 `delete` 和 `free`；\n* 具有全局性，总体大小无限制；\n* 容易造成内存泄露；\n\n\n\n**避免悬浮指针：**\n\n```cpp\nMyClass *func() {\n    MyClass c(10);\n    return &c;\n}\n```\n\n**栈是属于函数的：指向栈对象的指针比较危险：**\n\n```cpp\nMyClass func() {\n    MyClass c(10);\n    AClass a(100);\n    c.pa = $a;\n    return c;\n}\n```\n\n**返回值尽量不要反悔指针，谁分配内存谁释放内存：**\n\n```cpp\nMyClass *func() {\n    MyClass * pa = new MyClass();\n    return pa;\n}\nMyClass *p = func();\n```\n\n* 栈上存放指针，堆上存储真正的对象;\n* 栈对象：对象内存直接存储于栈对象;\n\n\n#### C++ 变量模型与使用：\n\n**传参：**\n\n```cpp\n// 传对象不好，对象较大，只要传参就是拷贝；\nvoid func1(MyClass c) {\n    // 这里 “c” 的大小依赖于各个字段的大小，32位机器若有虚函数加 4byte，64位则加 8byte；\n}\nvoid func2(MyClass *pc) {\n    // 尽量不用，不能 delete 栈对象；\n}\n```\n\n**后续删除指针：**\n\n```cpp\nMyClass *pc = new MyClass();\nfunc2(pc);\ndelete(pc);\n```\n\n```cpp\nvoid func3(MyClass &mc) {\n    // 传参成本低，效率高，背后是指针，不用考虑是栈对象还是堆对象；\n}\nvoid func3(MyClass &mc) {\n    // 若 “mc” 是堆对象，则函数没问题，但 “mc” 是外部参数，函数不负责释放；\n    MyClass *p = &mc;\n    delete p;\n}\n// ByValue 的替代，传 const 引用；\nvoid func3(const MyClass &mc) {}\n```\n\n**传参：**\n\n\n```cpp\nMyClass c1；\nfunc1(c1);\nfunc2(&c1);\nfunc3(c1);\t\n```\n\n**返回值：**\n\n```cpp\nMyClass func1() {\n    MyClass c1;\n    return c1;\n\n    MyClass* pc2 = new MyClass();\n    return *pc2;\n    // 返回对象常见；\n    // 这里 “pc2” 指针不会被释放；\n}\n\nMyClass *func2() {\n    MyClass c1;\n    return &c1;\n    // OR；\n    MyClass *pc2 = new MyClass();\n    return pc2;\n    // 只能返回堆对象的指针；\n}\n\nMyClass& func4(MyClass &c) {\n    return c;\n}\t\n```\n\n* 栈的大小是确定的，堆具有灵活性，大小可以随意分配，没有栈就没有函数，没有变量；\n\n**总结：**\n\n* 掌握内存模型的分析方法 — 画运行时内存图；\n* 掌握堆、栈的概念；\n* 掌握指针、引用、对象；\n* 探微知著：魔鬼尽在细节中；\n\n","slug":"GeekBank-C-线下班学习心得（二）","published":1,"updated":"2019-02-04T16:36:06.121Z","layout":"post","photos":[],"link":"","_id":"cjsqwht7n000xknp2xndncldb","content":"<p>今天是“GeekBand 极客班线下 C++ 培训的第二周课程”，浦东12路依旧挤得不行。上午先是产品经理部分的课程答疑与培训，一些课程重点的总结如下：</p>\n<ul>\n<li><strong>用户：</strong>使用产品的人（不一定付钱）；</li>\n<li><strong>客户：</strong>通常是付钱的人（用户从来不买单）；</li>\n<li><strong>调查问卷：</strong>尽量用电话，微信语音相比较更好，不要让用户看到你要问什么问题；</li>\n<li><strong>AB 测试：</strong>A用户群使用第一个版本，B用户群使用第二个版本；</li>\n<li><strong>灰度发布：</strong>对一小部分人群进行产品发布（相对成熟的产品），并及时了解反馈建议；</li>\n<li><strong>MVP：</strong>产品可以使用，虽然用户体验并不一定好，但是却可以解决用户的问题；</li>\n<li><strong>快速迭代：</strong>一周到两周发布一个新的版本；</li>\n</ul>\n<h4 id=\"产品经理必读书：\"><a href=\"#产品经理必读书：\" class=\"headerlink\" title=\"产品经理必读书：\"></a>产品经理必读书：</h4><ul>\n<li>《系统化思维导论》（Jerry Weinberg 著）：训练逻辑思维。</li>\n<li>《精英数据分析》</li>\n<li>《从0到1》</li>\n</ul>\n<h4 id=\"产品经验总结：\"><a href=\"#产品经验总结：\" class=\"headerlink\" title=\"产品经验总结：\"></a>产品经验总结：</h4><ol>\n<li>策划产品时要对产品面向的用户群体进行细分（必须进行量化），不能使用模糊的群体分类（比如极客），要有明确的定位，并在生活中可以找到实例；</li>\n<li>表达能力重要性和逻辑推理的重要性；</li>\n<li>从创意去思考背后的问题，%99用户的主意都是无用的；</li>\n<li>走出办公楼，去面对自己的用户；</li>\n</ol>\n<h4 id=\"“IOS-应用开发与实战”课总结：\"><a href=\"#“IOS-应用开发与实战”课总结：\" class=\"headerlink\" title=\"“IOS 应用开发与实战”课总结：\"></a>“IOS 应用开发与实战”课总结：</h4><ol>\n<li>写代码：代码整体的干净程度，像说明文，易于后来人接手，代码的优美；</li>\n<li>不要去死记硬背，写得多自然就记住了；</li>\n</ol>\n<h4 id=\"“C-辅导课培训”总结：\"><a href=\"#“C-辅导课培训”总结：\" class=\"headerlink\" title=\"“C++辅导课培训”总结：\"></a>“C++辅导课培训”总结：</h4><p><strong>栈：</strong></p>\n<ul>\n<li>由系统自动管理，以执行函数为单位；MyClass c(10)；</li>\n<li>空间大小编译时确定（参数 + 局部变量）；</li>\n<li>函数执行时，系统自动分配一个 Stack；</li>\n<li>函数执行结束时，系统立即回收 Stact；</li>\n</ul>\n<p><strong>堆：</strong></p>\n<ul>\n<li>在 C++ 中由程序员手动控制 “New” 出来的对象在堆上；</li>\n<li>手动分配 <code>new</code> 和 <code>malloc</code>；</li>\n<li>手动释放 <code>delete</code> 和 <code>free</code>；</li>\n<li>具有全局性，总体大小无限制；</li>\n<li>容易造成内存泄露；</li>\n</ul>\n<p><strong>避免悬浮指针：</strong></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">MyClass <span class=\"token operator\">*</span><span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    MyClass <span class=\"token class-name\">c</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">&amp;</span>c<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>栈是属于函数的：指向栈对象的指针比较危险：</strong></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">MyClass <span class=\"token class-name\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    MyClass <span class=\"token class-name\">c</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    AClass <span class=\"token class-name\">a</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    c<span class=\"token punctuation\">.</span>pa <span class=\"token operator\">=</span> $a<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> c<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>返回值尽量不要反悔指针，谁分配内存谁释放内存：</strong></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">MyClass <span class=\"token operator\">*</span><span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    MyClass <span class=\"token operator\">*</span> pa <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token function\">MyClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> pa<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\nMyClass <span class=\"token operator\">*</span>p <span class=\"token operator\">=</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>栈上存放指针，堆上存储真正的对象;</li>\n<li>栈对象：对象内存直接存储于栈对象;</li>\n</ul>\n<h4 id=\"C-变量模型与使用：\"><a href=\"#C-变量模型与使用：\" class=\"headerlink\" title=\"C++ 变量模型与使用：\"></a>C++ 变量模型与使用：</h4><p><strong>传参：</strong></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\" spellcheck=\"true\">// 传对象不好，对象较大，只要传参就是拷贝；</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">func1</span><span class=\"token punctuation\">(</span>MyClass <span class=\"token class-name\">c</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 这里 “c” 的大小依赖于各个字段的大小，32位机器若有虚函数加 4byte，64位则加 8byte；</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">func2</span><span class=\"token punctuation\">(</span>MyClass <span class=\"token operator\">*</span>pc<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 尽量不用，不能 delete 栈对象；</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>后续删除指针：</strong></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">MyClass <span class=\"token operator\">*</span>pc <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token function\">MyClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">func2</span><span class=\"token punctuation\">(</span>pc<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">delete</span><span class=\"token punctuation\">(</span>pc<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">void</span> <span class=\"token function\">func3</span><span class=\"token punctuation\">(</span>MyClass <span class=\"token operator\">&amp;</span>mc<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 传参成本低，效率高，背后是指针，不用考虑是栈对象还是堆对象；</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">func3</span><span class=\"token punctuation\">(</span>MyClass <span class=\"token operator\">&amp;</span>mc<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 若 “mc” 是堆对象，则函数没问题，但 “mc” 是外部参数，函数不负责释放；</span>\n    MyClass <span class=\"token operator\">*</span>p <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>mc<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">delete</span> p<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">// ByValue 的替代，传 const 引用；</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">func3</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> MyClass <span class=\"token operator\">&amp;</span>mc<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>传参：</strong></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">MyClass <span class=\"token class-name\">c1</span>；\n<span class=\"token function\">func1</span><span class=\"token punctuation\">(</span>c1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">func2</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>c1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">func3</span><span class=\"token punctuation\">(</span>c1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    \n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>返回值：</strong></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\">MyClass <span class=\"token class-name\">func1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    MyClass <span class=\"token class-name\">c1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> c1<span class=\"token punctuation\">;</span>\n\n    MyClass<span class=\"token operator\">*</span> pc2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token function\">MyClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">*</span>pc2<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 返回对象常见；</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 这里 “pc2” 指针不会被释放；</span>\n<span class=\"token punctuation\">}</span>\n\nMyClass <span class=\"token operator\">*</span><span class=\"token function\">func2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    MyClass <span class=\"token class-name\">c1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">&amp;</span>c1<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// OR；</span>\n    MyClass <span class=\"token operator\">*</span>pc2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token function\">MyClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> pc2<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 只能返回堆对象的指针；</span>\n<span class=\"token punctuation\">}</span>\n\nMyClass<span class=\"token operator\">&amp;</span> <span class=\"token function\">func4</span><span class=\"token punctuation\">(</span>MyClass <span class=\"token operator\">&amp;</span>c<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> c<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>    \n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>栈的大小是确定的，堆具有灵活性，大小可以随意分配，没有栈就没有函数，没有变量；</li>\n</ul>\n<p><strong>总结：</strong></p>\n<ul>\n<li>掌握内存模型的分析方法 — 画运行时内存图；</li>\n<li>掌握堆、栈的概念；</li>\n<li>掌握指针、引用、对象；</li>\n<li>探微知著：魔鬼尽在细节中；</li>\n</ul>\n","site":{"data":{}},"id":"784a648eb98dd4852871e512c22bc6e6","excerpt":"","more":"<p>今天是“GeekBand 极客班线下 C++ 培训的第二周课程”，浦东12路依旧挤得不行。上午先是产品经理部分的课程答疑与培训，一些课程重点的总结如下：</p>\n<ul>\n<li><strong>用户：</strong>使用产品的人（不一定付钱）；</li>\n<li><strong>客户：</strong>通常是付钱的人（用户从来不买单）；</li>\n<li><strong>调查问卷：</strong>尽量用电话，微信语音相比较更好，不要让用户看到你要问什么问题；</li>\n<li><strong>AB 测试：</strong>A用户群使用第一个版本，B用户群使用第二个版本；</li>\n<li><strong>灰度发布：</strong>对一小部分人群进行产品发布（相对成熟的产品），并及时了解反馈建议；</li>\n<li><strong>MVP：</strong>产品可以使用，虽然用户体验并不一定好，但是却可以解决用户的问题；</li>\n<li><strong>快速迭代：</strong>一周到两周发布一个新的版本；</li>\n</ul>\n<h4 id=\"产品经理必读书：\"><a href=\"#产品经理必读书：\" class=\"headerlink\" title=\"产品经理必读书：\"></a>产品经理必读书：</h4><ul>\n<li>《系统化思维导论》（Jerry Weinberg 著）：训练逻辑思维。</li>\n<li>《精英数据分析》</li>\n<li>《从0到1》</li>\n</ul>\n<h4 id=\"产品经验总结：\"><a href=\"#产品经验总结：\" class=\"headerlink\" title=\"产品经验总结：\"></a>产品经验总结：</h4><ol>\n<li>策划产品时要对产品面向的用户群体进行细分（必须进行量化），不能使用模糊的群体分类（比如极客），要有明确的定位，并在生活中可以找到实例；</li>\n<li>表达能力重要性和逻辑推理的重要性；</li>\n<li>从创意去思考背后的问题，%99用户的主意都是无用的；</li>\n<li>走出办公楼，去面对自己的用户；</li>\n</ol>\n<h4 id=\"“IOS-应用开发与实战”课总结：\"><a href=\"#“IOS-应用开发与实战”课总结：\" class=\"headerlink\" title=\"“IOS 应用开发与实战”课总结：\"></a>“IOS 应用开发与实战”课总结：</h4><ol>\n<li>写代码：代码整体的干净程度，像说明文，易于后来人接手，代码的优美；</li>\n<li>不要去死记硬背，写得多自然就记住了；</li>\n</ol>\n<h4 id=\"“C-辅导课培训”总结：\"><a href=\"#“C-辅导课培训”总结：\" class=\"headerlink\" title=\"“C++辅导课培训”总结：\"></a>“C++辅导课培训”总结：</h4><p><strong>栈：</strong></p>\n<ul>\n<li>由系统自动管理，以执行函数为单位；MyClass c(10)；</li>\n<li>空间大小编译时确定（参数 + 局部变量）；</li>\n<li>函数执行时，系统自动分配一个 Stack；</li>\n<li>函数执行结束时，系统立即回收 Stact；</li>\n</ul>\n<p><strong>堆：</strong></p>\n<ul>\n<li>在 C++ 中由程序员手动控制 “New” 出来的对象在堆上；</li>\n<li>手动分配 <code>new</code> 和 <code>malloc</code>；</li>\n<li>手动释放 <code>delete</code> 和 <code>free</code>；</li>\n<li>具有全局性，总体大小无限制；</li>\n<li>容易造成内存泄露；</li>\n</ul>\n<p><strong>避免悬浮指针：</strong></p>\n<pre><code class=\"cpp\">MyClass *func() {\n    MyClass c(10);\n    return &amp;c;\n}\n</code></pre>\n<p><strong>栈是属于函数的：指向栈对象的指针比较危险：</strong></p>\n<pre><code class=\"cpp\">MyClass func() {\n    MyClass c(10);\n    AClass a(100);\n    c.pa = $a;\n    return c;\n}\n</code></pre>\n<p><strong>返回值尽量不要反悔指针，谁分配内存谁释放内存：</strong></p>\n<pre><code class=\"cpp\">MyClass *func() {\n    MyClass * pa = new MyClass();\n    return pa;\n}\nMyClass *p = func();\n</code></pre>\n<ul>\n<li>栈上存放指针，堆上存储真正的对象;</li>\n<li>栈对象：对象内存直接存储于栈对象;</li>\n</ul>\n<h4 id=\"C-变量模型与使用：\"><a href=\"#C-变量模型与使用：\" class=\"headerlink\" title=\"C++ 变量模型与使用：\"></a>C++ 变量模型与使用：</h4><p><strong>传参：</strong></p>\n<pre><code class=\"cpp\">// 传对象不好，对象较大，只要传参就是拷贝；\nvoid func1(MyClass c) {\n    // 这里 “c” 的大小依赖于各个字段的大小，32位机器若有虚函数加 4byte，64位则加 8byte；\n}\nvoid func2(MyClass *pc) {\n    // 尽量不用，不能 delete 栈对象；\n}\n</code></pre>\n<p><strong>后续删除指针：</strong></p>\n<pre><code class=\"cpp\">MyClass *pc = new MyClass();\nfunc2(pc);\ndelete(pc);\n</code></pre>\n<pre><code class=\"cpp\">void func3(MyClass &amp;mc) {\n    // 传参成本低，效率高，背后是指针，不用考虑是栈对象还是堆对象；\n}\nvoid func3(MyClass &amp;mc) {\n    // 若 “mc” 是堆对象，则函数没问题，但 “mc” 是外部参数，函数不负责释放；\n    MyClass *p = &amp;mc;\n    delete p;\n}\n// ByValue 的替代，传 const 引用；\nvoid func3(const MyClass &amp;mc) {}\n</code></pre>\n<p><strong>传参：</strong></p>\n<pre><code class=\"cpp\">MyClass c1；\nfunc1(c1);\nfunc2(&amp;c1);\nfunc3(c1);    \n</code></pre>\n<p><strong>返回值：</strong></p>\n<pre><code class=\"cpp\">MyClass func1() {\n    MyClass c1;\n    return c1;\n\n    MyClass* pc2 = new MyClass();\n    return *pc2;\n    // 返回对象常见；\n    // 这里 “pc2” 指针不会被释放；\n}\n\nMyClass *func2() {\n    MyClass c1;\n    return &amp;c1;\n    // OR；\n    MyClass *pc2 = new MyClass();\n    return pc2;\n    // 只能返回堆对象的指针；\n}\n\nMyClass&amp; func4(MyClass &amp;c) {\n    return c;\n}    \n</code></pre>\n<ul>\n<li>栈的大小是确定的，堆具有灵活性，大小可以随意分配，没有栈就没有函数，没有变量；</li>\n</ul>\n<p><strong>总结：</strong></p>\n<ul>\n<li>掌握内存模型的分析方法 — 画运行时内存图；</li>\n<li>掌握堆、栈的概念；</li>\n<li>掌握指针、引用、对象；</li>\n<li>探微知著：魔鬼尽在细节中；</li>\n</ul>\n"},{"title":"Git 你需要具备的基础知识","intro":"Git 是一款免费、开源的分布式版本控制系统，相比于之前的 CVS、SVN 等版本控制系统，Git 的优势大大凸显。Git 是分布式的版本控制系统，相比之前的集中式系统，分布式版本控制系统的安全性要高很多。因为每个人电脑里都有完整的版本库副本，使得整个版本库不会轻易的丢失。","comments":1,"date":"2015-03-24T14:25:27.000Z","_content":"\nGit 是一款免费、开源的分布式版本控制系统，相比于之前的 CVS、SVN 等版本控制系统，Git 的优势大大凸显。Git 是分布式的版本控制系统，相比之前的集中式系统，分布式版本控制系统的安全性要高很多。因为每个人电脑里都有完整的版本库副本，使得整个版本库不会轻易的丢失。\n\n本文不会介绍 Git 的发展历史及其入门的使用方法，而主要介绍在日常开发中需要具备的 Git 基本操作，即相关概念和对应的指令方法。\n\n1. 在 Linux 上安装 Git：\n```bash\nsudo apt-get install git\n```\n\n2. 在 Windows 上安装 Git 直接使用 Git Bash，并设置 Name 和 Email，`global` 代表本地所有 Git 仓库均使用此设置：\n```bash\ngit config --global user.name \"Name\"\ngit config --global user.email \"Email\"\ngit config --global core.editor vim;\ngit config --list  # 查看所有配置项；\ngit config --global alias.<short> <command>  # 设置命令别名；\n```\n\n3. 创建版本库：\n```bash\ngit init\n```\n\n4. 添加改动到暂存区：\n```bash\ngit add <filepath>\n```\n\n5. 提交文件到仓库：\n```bash\ngit commit -m \"msg\"\ngit commit -a -m \"msg\"  # 跳过将改动加入到暂存区的过程；\ngit commit --amend  # 修改上一次提交的描述信息（会合并当前暂存区的改动）；\n```\n\n6. 查看仓库状态：\n```bash\ngit status\n```\n\n7. 查看仓库修改的内容：\n```bash\ngit diff  # 默认只查看当前分支和未暂存改动间的区别；\ngit diff --cached/--staged  # 查看暂存区和待提交分支的区别；\ngit difftool  # 使用 GUI 界面工具查看区别；\n```\n\n8. 查看仓库提交日志：\n```bash\ngit log --pretty=oneline\ngit log --pretty=format:\"<format>\"\ngit log -p -<n>  # 查看最近 n 次提交的差异；\ngit log --stat  # 查看最近提交的简略总结信息；\ngit log --since/--until=<time>  # 筛选特定日期的提交；\ngit log -p -S<functionName>   # 查看跟特定关键字相关的提交细节；\ngit log --oneline --decorate  # 查看各分支对应的提交情况；\ngit log --oneline --decorate --graph --all  # 显示详细的分支和提交情况；\ngit show <commitHash>  # 查看某一个提交的详情；\ngit show HEAD^^  # 查看当前分支的祖父提交；\ngit show HEAD~2  # 查看当前分支的祖父提交；\ngit show HEAD~~  # 查看当前分支的祖父提交；\ngit show HEAD^2  # 查看当前分支的第二父提交（被合并分支）；\n``` \n\n9. 版本回退：\n```bash\ngit reset --hard HEAD^\ngit reset --hard HEAD~100\ngit reset --hard HEAD <commitid>\n```\n\n10. 查看分支引用变动历史：\n```bash\ngit reflog\ngit show HEAD@{n}  # 查看变动历史对应提交的详情；\n```\n\n11. 丢弃工作区修改：\n```bash\ngit checkout -- <filepath>\n```\n\n12. 丢弃暂存区修改：\n```bash\ngit reset HEAD <filepath>\n```\n\n13. 删除仓库文件：\n```bash\ngit rm <filepath>\ngit rm <filepath> --cached  # 从 Git 索引中移除，但不删除文件实体；\ngit commit -m \"msg\"\n```\n\n14. 代码暂存与恢复（到当前分支）：\n```bash\ngit stash\ngit stash pop\ngit stash drop <stashId>\ngit stash apply <stashId>  # 应用某个暂存到当前分支；\n```\n\n15. “变基”的基本用法：\n```bash\ngit rebase <baseBranch> <topicBranch>  # 将 topicBranch 分支变基到 baseBranch 分支；\n```\n\n16. 移动文件：\n```bash\ngit mv <org> <des>  # 常用于更换文件名；\n```\n\n17. 管理远程仓库：\n```bash\ngit remote -v\ngit remote add <shortname> <url>    # 添加上游仓库；\ngit remote show <remote>\n```\n\n18. 拉取资源：\n```bash\ngit fetch  # 只拉取，不合并；\n```\n\n19. 标签：\n```bash\ngit tag <tagName>  # 轻量标签；\ngit tag -a <tagName> <commitId> -m <message>  # 附注标签；\n```\n\n20. 分支操作：\n```bash\ngit checkout -b <branchName> [<tagName>/<remote/branchName>]\ngit checkout -- .  # 丢弃本地当前所有改动；\ngit branch -v  # 查看每一个分支的最后一次提交；\ngit branch --merged/--no-merged  # 查看已经合并/未合并到当前分支的分支；\ngit checkout --track <remote/branchName>\ngit branch -u <remote/branchName>  # 为本地已有分支指定上游跟踪分支；\ngit branch -vv  # 查看本地分支的远程跟踪情况；\ngit push <remote> :<branchName>  # 删除远程分支(1)\ngit push <remote> --delete <branchName>  # 删除远程分支(2)\n```","source":"_posts/Git-你需要具备的基础知识.md","raw":"---\ntitle: Git 你需要具备的基础知识\nintro: Git 是一款免费、开源的分布式版本控制系统，相比于之前的 CVS、SVN 等版本控制系统，Git 的优势大大凸显。Git 是分布式的版本控制系统，相比之前的集中式系统，分布式版本控制系统的安全性要高很多。因为每个人电脑里都有完整的版本库副本，使得整个版本库不会轻易的丢失。\ncomments: true\ndate: 2015-03-24 22:25:27\ntags:\n- Git\n---\n\nGit 是一款免费、开源的分布式版本控制系统，相比于之前的 CVS、SVN 等版本控制系统，Git 的优势大大凸显。Git 是分布式的版本控制系统，相比之前的集中式系统，分布式版本控制系统的安全性要高很多。因为每个人电脑里都有完整的版本库副本，使得整个版本库不会轻易的丢失。\n\n本文不会介绍 Git 的发展历史及其入门的使用方法，而主要介绍在日常开发中需要具备的 Git 基本操作，即相关概念和对应的指令方法。\n\n1. 在 Linux 上安装 Git：\n```bash\nsudo apt-get install git\n```\n\n2. 在 Windows 上安装 Git 直接使用 Git Bash，并设置 Name 和 Email，`global` 代表本地所有 Git 仓库均使用此设置：\n```bash\ngit config --global user.name \"Name\"\ngit config --global user.email \"Email\"\ngit config --global core.editor vim;\ngit config --list  # 查看所有配置项；\ngit config --global alias.<short> <command>  # 设置命令别名；\n```\n\n3. 创建版本库：\n```bash\ngit init\n```\n\n4. 添加改动到暂存区：\n```bash\ngit add <filepath>\n```\n\n5. 提交文件到仓库：\n```bash\ngit commit -m \"msg\"\ngit commit -a -m \"msg\"  # 跳过将改动加入到暂存区的过程；\ngit commit --amend  # 修改上一次提交的描述信息（会合并当前暂存区的改动）；\n```\n\n6. 查看仓库状态：\n```bash\ngit status\n```\n\n7. 查看仓库修改的内容：\n```bash\ngit diff  # 默认只查看当前分支和未暂存改动间的区别；\ngit diff --cached/--staged  # 查看暂存区和待提交分支的区别；\ngit difftool  # 使用 GUI 界面工具查看区别；\n```\n\n8. 查看仓库提交日志：\n```bash\ngit log --pretty=oneline\ngit log --pretty=format:\"<format>\"\ngit log -p -<n>  # 查看最近 n 次提交的差异；\ngit log --stat  # 查看最近提交的简略总结信息；\ngit log --since/--until=<time>  # 筛选特定日期的提交；\ngit log -p -S<functionName>   # 查看跟特定关键字相关的提交细节；\ngit log --oneline --decorate  # 查看各分支对应的提交情况；\ngit log --oneline --decorate --graph --all  # 显示详细的分支和提交情况；\ngit show <commitHash>  # 查看某一个提交的详情；\ngit show HEAD^^  # 查看当前分支的祖父提交；\ngit show HEAD~2  # 查看当前分支的祖父提交；\ngit show HEAD~~  # 查看当前分支的祖父提交；\ngit show HEAD^2  # 查看当前分支的第二父提交（被合并分支）；\n``` \n\n9. 版本回退：\n```bash\ngit reset --hard HEAD^\ngit reset --hard HEAD~100\ngit reset --hard HEAD <commitid>\n```\n\n10. 查看分支引用变动历史：\n```bash\ngit reflog\ngit show HEAD@{n}  # 查看变动历史对应提交的详情；\n```\n\n11. 丢弃工作区修改：\n```bash\ngit checkout -- <filepath>\n```\n\n12. 丢弃暂存区修改：\n```bash\ngit reset HEAD <filepath>\n```\n\n13. 删除仓库文件：\n```bash\ngit rm <filepath>\ngit rm <filepath> --cached  # 从 Git 索引中移除，但不删除文件实体；\ngit commit -m \"msg\"\n```\n\n14. 代码暂存与恢复（到当前分支）：\n```bash\ngit stash\ngit stash pop\ngit stash drop <stashId>\ngit stash apply <stashId>  # 应用某个暂存到当前分支；\n```\n\n15. “变基”的基本用法：\n```bash\ngit rebase <baseBranch> <topicBranch>  # 将 topicBranch 分支变基到 baseBranch 分支；\n```\n\n16. 移动文件：\n```bash\ngit mv <org> <des>  # 常用于更换文件名；\n```\n\n17. 管理远程仓库：\n```bash\ngit remote -v\ngit remote add <shortname> <url>    # 添加上游仓库；\ngit remote show <remote>\n```\n\n18. 拉取资源：\n```bash\ngit fetch  # 只拉取，不合并；\n```\n\n19. 标签：\n```bash\ngit tag <tagName>  # 轻量标签；\ngit tag -a <tagName> <commitId> -m <message>  # 附注标签；\n```\n\n20. 分支操作：\n```bash\ngit checkout -b <branchName> [<tagName>/<remote/branchName>]\ngit checkout -- .  # 丢弃本地当前所有改动；\ngit branch -v  # 查看每一个分支的最后一次提交；\ngit branch --merged/--no-merged  # 查看已经合并/未合并到当前分支的分支；\ngit checkout --track <remote/branchName>\ngit branch -u <remote/branchName>  # 为本地已有分支指定上游跟踪分支；\ngit branch -vv  # 查看本地分支的远程跟踪情况；\ngit push <remote> :<branchName>  # 删除远程分支(1)\ngit push <remote> --delete <branchName>  # 删除远程分支(2)\n```","slug":"Git-你需要具备的基础知识","published":1,"updated":"2019-02-04T09:58:30.726Z","layout":"post","photos":[],"link":"","_id":"cjsqwht7o000zknp209lpfveh","content":"<p>Git 是一款免费、开源的分布式版本控制系统，相比于之前的 CVS、SVN 等版本控制系统，Git 的优势大大凸显。Git 是分布式的版本控制系统，相比之前的集中式系统，分布式版本控制系统的安全性要高很多。因为每个人电脑里都有完整的版本库副本，使得整个版本库不会轻易的丢失。</p>\n<p>本文不会介绍 Git 的发展历史及其入门的使用方法，而主要介绍在日常开发中需要具备的 Git 基本操作，即相关概念和对应的指令方法。</p>\n<ol>\n<li><p>在 Linux 上安装 Git：</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> <span class=\"token function\">git</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>在 Windows 上安装 Git 直接使用 Git Bash，并设置 Name 和 Email，<code>global</code> 代表本地所有 Git 仓库均使用此设置：</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> config --global user.name <span class=\"token string\">\"Name\"</span>\n<span class=\"token function\">git</span> config --global user.email <span class=\"token string\">\"Email\"</span>\n<span class=\"token function\">git</span> config --global core.editor vim<span class=\"token punctuation\">;</span>\n<span class=\"token function\">git</span> config --list  <span class=\"token comment\" spellcheck=\"true\"># 查看所有配置项；</span>\n<span class=\"token function\">git</span> config --global alias.<span class=\"token operator\">&lt;</span>short<span class=\"token operator\">></span> <span class=\"token operator\">&lt;</span>command<span class=\"token operator\">></span>  <span class=\"token comment\" spellcheck=\"true\"># 设置命令别名；</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>创建版本库：</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> init\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>添加改动到暂存区：</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> add <span class=\"token operator\">&lt;</span>filepath<span class=\"token operator\">></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>提交文件到仓库：</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> commit -m <span class=\"token string\">\"msg\"</span>\n<span class=\"token function\">git</span> commit -a -m <span class=\"token string\">\"msg\"</span>  <span class=\"token comment\" spellcheck=\"true\"># 跳过将改动加入到暂存区的过程；</span>\n<span class=\"token function\">git</span> commit --amend  <span class=\"token comment\" spellcheck=\"true\"># 修改上一次提交的描述信息（会合并当前暂存区的改动）；</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>查看仓库状态：</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> status\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>查看仓库修改的内容：</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> <span class=\"token function\">diff</span>  <span class=\"token comment\" spellcheck=\"true\"># 默认只查看当前分支和未暂存改动间的区别；</span>\n<span class=\"token function\">git</span> <span class=\"token function\">diff</span> --cached/--staged  <span class=\"token comment\" spellcheck=\"true\"># 查看暂存区和待提交分支的区别；</span>\n<span class=\"token function\">git</span> difftool  <span class=\"token comment\" spellcheck=\"true\"># 使用 GUI 界面工具查看区别；</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>查看仓库提交日志：</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> log --pretty<span class=\"token operator\">=</span>oneline\n<span class=\"token function\">git</span> log --pretty<span class=\"token operator\">=</span>format:<span class=\"token string\">\"&lt;format>\"</span>\n<span class=\"token function\">git</span> log -p -<span class=\"token operator\">&lt;</span>n<span class=\"token operator\">></span>  <span class=\"token comment\" spellcheck=\"true\"># 查看最近 n 次提交的差异；</span>\n<span class=\"token function\">git</span> log --stat  <span class=\"token comment\" spellcheck=\"true\"># 查看最近提交的简略总结信息；</span>\n<span class=\"token function\">git</span> log --since/--until<span class=\"token operator\">=</span><span class=\"token operator\">&lt;</span>time<span class=\"token operator\">></span>  <span class=\"token comment\" spellcheck=\"true\"># 筛选特定日期的提交；</span>\n<span class=\"token function\">git</span> log -p -S<span class=\"token operator\">&lt;</span>functionName<span class=\"token operator\">></span>   <span class=\"token comment\" spellcheck=\"true\"># 查看跟特定关键字相关的提交细节；</span>\n<span class=\"token function\">git</span> log --oneline --decorate  <span class=\"token comment\" spellcheck=\"true\"># 查看各分支对应的提交情况；</span>\n<span class=\"token function\">git</span> log --oneline --decorate --graph --all  <span class=\"token comment\" spellcheck=\"true\"># 显示详细的分支和提交情况；</span>\n<span class=\"token function\">git</span> show <span class=\"token operator\">&lt;</span>commitHash<span class=\"token operator\">></span>  <span class=\"token comment\" spellcheck=\"true\"># 查看某一个提交的详情；</span>\n<span class=\"token function\">git</span> show HEAD^^  <span class=\"token comment\" spellcheck=\"true\"># 查看当前分支的祖父提交；</span>\n<span class=\"token function\">git</span> show HEAD~2  <span class=\"token comment\" spellcheck=\"true\"># 查看当前分支的祖父提交；</span>\n<span class=\"token function\">git</span> show HEAD~~  <span class=\"token comment\" spellcheck=\"true\"># 查看当前分支的祖父提交；</span>\n<span class=\"token function\">git</span> show HEAD^2  <span class=\"token comment\" spellcheck=\"true\"># 查看当前分支的第二父提交（被合并分支）；</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>版本回退：</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> reset --hard HEAD^\n<span class=\"token function\">git</span> reset --hard HEAD~100\n<span class=\"token function\">git</span> reset --hard HEAD <span class=\"token operator\">&lt;</span>commitid<span class=\"token operator\">></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>查看分支引用变动历史：</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> reflog\n<span class=\"token function\">git</span> show HEAD@<span class=\"token punctuation\">{</span>n<span class=\"token punctuation\">}</span>  <span class=\"token comment\" spellcheck=\"true\"># 查看变动历史对应提交的详情；</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p>丢弃工作区修改：</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> checkout -- <span class=\"token operator\">&lt;</span>filepath<span class=\"token operator\">></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>丢弃暂存区修改：</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> reset HEAD <span class=\"token operator\">&lt;</span>filepath<span class=\"token operator\">></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>删除仓库文件：</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> <span class=\"token function\">rm</span> <span class=\"token operator\">&lt;</span>filepath<span class=\"token operator\">></span>\n<span class=\"token function\">git</span> <span class=\"token function\">rm</span> <span class=\"token operator\">&lt;</span>filepath<span class=\"token operator\">></span> --cached  <span class=\"token comment\" spellcheck=\"true\"># 从 Git 索引中移除，但不删除文件实体；</span>\n<span class=\"token function\">git</span> commit -m <span class=\"token string\">\"msg\"</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>代码暂存与恢复（到当前分支）：</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> stash\n<span class=\"token function\">git</span> stash pop\n<span class=\"token function\">git</span> stash drop <span class=\"token operator\">&lt;</span>stashId<span class=\"token operator\">></span>\n<span class=\"token function\">git</span> stash apply <span class=\"token operator\">&lt;</span>stashId<span class=\"token operator\">></span>  <span class=\"token comment\" spellcheck=\"true\"># 应用某个暂存到当前分支；</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>“变基”的基本用法：</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> rebase <span class=\"token operator\">&lt;</span>baseBranch<span class=\"token operator\">></span> <span class=\"token operator\">&lt;</span>topicBranch<span class=\"token operator\">></span>  <span class=\"token comment\" spellcheck=\"true\"># 将 topicBranch 分支变基到 baseBranch 分支；</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>移动文件：</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> <span class=\"token function\">mv</span> <span class=\"token operator\">&lt;</span>org<span class=\"token operator\">></span> <span class=\"token operator\">&lt;</span>des<span class=\"token operator\">></span>  <span class=\"token comment\" spellcheck=\"true\"># 常用于更换文件名；</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>管理远程仓库：</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> remote -v\n<span class=\"token function\">git</span> remote add <span class=\"token operator\">&lt;</span>shortname<span class=\"token operator\">></span> <span class=\"token operator\">&lt;</span>url<span class=\"token operator\">></span>    <span class=\"token comment\" spellcheck=\"true\"># 添加上游仓库；</span>\n<span class=\"token function\">git</span> remote show <span class=\"token operator\">&lt;</span>remote<span class=\"token operator\">></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>拉取资源：</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> fetch  <span class=\"token comment\" spellcheck=\"true\"># 只拉取，不合并；</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>标签：</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> tag <span class=\"token operator\">&lt;</span>tagName<span class=\"token operator\">></span>  <span class=\"token comment\" spellcheck=\"true\"># 轻量标签；</span>\n<span class=\"token function\">git</span> tag -a <span class=\"token operator\">&lt;</span>tagName<span class=\"token operator\">></span> <span class=\"token operator\">&lt;</span>commitId<span class=\"token operator\">></span> -m <span class=\"token operator\">&lt;</span>message<span class=\"token operator\">></span>  <span class=\"token comment\" spellcheck=\"true\"># 附注标签；</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p>分支操作：</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> checkout -b <span class=\"token operator\">&lt;</span>branchName<span class=\"token operator\">></span> <span class=\"token punctuation\">[</span><span class=\"token operator\">&lt;</span>tagName<span class=\"token operator\">></span>/<span class=\"token operator\">&lt;</span>remote/branchName<span class=\"token operator\">></span><span class=\"token punctuation\">]</span>\n<span class=\"token function\">git</span> checkout -- <span class=\"token keyword\">.</span>  <span class=\"token comment\" spellcheck=\"true\"># 丢弃本地当前所有改动；</span>\n<span class=\"token function\">git</span> branch -v  <span class=\"token comment\" spellcheck=\"true\"># 查看每一个分支的最后一次提交；</span>\n<span class=\"token function\">git</span> branch --merged/--no-merged  <span class=\"token comment\" spellcheck=\"true\"># 查看已经合并/未合并到当前分支的分支；</span>\n<span class=\"token function\">git</span> checkout --track <span class=\"token operator\">&lt;</span>remote/branchName<span class=\"token operator\">></span>\n<span class=\"token function\">git</span> branch -u <span class=\"token operator\">&lt;</span>remote/branchName<span class=\"token operator\">></span>  <span class=\"token comment\" spellcheck=\"true\"># 为本地已有分支指定上游跟踪分支；</span>\n<span class=\"token function\">git</span> branch -vv  <span class=\"token comment\" spellcheck=\"true\"># 查看本地分支的远程跟踪情况；</span>\n<span class=\"token function\">git</span> push <span class=\"token operator\">&lt;</span>remote<span class=\"token operator\">></span> :<span class=\"token operator\">&lt;</span>branchName<span class=\"token operator\">></span>  <span class=\"token comment\" spellcheck=\"true\"># 删除远程分支(1)</span>\n<span class=\"token function\">git</span> push <span class=\"token operator\">&lt;</span>remote<span class=\"token operator\">></span> --delete <span class=\"token operator\">&lt;</span>branchName<span class=\"token operator\">></span>  <span class=\"token comment\" spellcheck=\"true\"># 删除远程分支(2)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ol>\n","site":{"data":{}},"id":"367cf892ecee07f0e3d74784d610b86a","excerpt":"","more":"<p>Git 是一款免费、开源的分布式版本控制系统，相比于之前的 CVS、SVN 等版本控制系统，Git 的优势大大凸显。Git 是分布式的版本控制系统，相比之前的集中式系统，分布式版本控制系统的安全性要高很多。因为每个人电脑里都有完整的版本库副本，使得整个版本库不会轻易的丢失。</p>\n<p>本文不会介绍 Git 的发展历史及其入门的使用方法，而主要介绍在日常开发中需要具备的 Git 基本操作，即相关概念和对应的指令方法。</p>\n<ol>\n<li><p>在 Linux 上安装 Git：</p>\n<pre><code class=\"bash\">sudo apt-get install git\n</code></pre>\n</li>\n<li><p>在 Windows 上安装 Git 直接使用 Git Bash，并设置 Name 和 Email，<code>global</code> 代表本地所有 Git 仓库均使用此设置：</p>\n<pre><code class=\"bash\">git config --global user.name &quot;Name&quot;\ngit config --global user.email &quot;Email&quot;\ngit config --global core.editor vim;\ngit config --list  # 查看所有配置项；\ngit config --global alias.&lt;short&gt; &lt;command&gt;  # 设置命令别名；\n</code></pre>\n</li>\n<li><p>创建版本库：</p>\n<pre><code class=\"bash\">git init\n</code></pre>\n</li>\n<li><p>添加改动到暂存区：</p>\n<pre><code class=\"bash\">git add &lt;filepath&gt;\n</code></pre>\n</li>\n<li><p>提交文件到仓库：</p>\n<pre><code class=\"bash\">git commit -m &quot;msg&quot;\ngit commit -a -m &quot;msg&quot;  # 跳过将改动加入到暂存区的过程；\ngit commit --amend  # 修改上一次提交的描述信息（会合并当前暂存区的改动）；\n</code></pre>\n</li>\n<li><p>查看仓库状态：</p>\n<pre><code class=\"bash\">git status\n</code></pre>\n</li>\n<li><p>查看仓库修改的内容：</p>\n<pre><code class=\"bash\">git diff  # 默认只查看当前分支和未暂存改动间的区别；\ngit diff --cached/--staged  # 查看暂存区和待提交分支的区别；\ngit difftool  # 使用 GUI 界面工具查看区别；\n</code></pre>\n</li>\n<li><p>查看仓库提交日志：</p>\n<pre><code class=\"bash\">git log --pretty=oneline\ngit log --pretty=format:&quot;&lt;format&gt;&quot;\ngit log -p -&lt;n&gt;  # 查看最近 n 次提交的差异；\ngit log --stat  # 查看最近提交的简略总结信息；\ngit log --since/--until=&lt;time&gt;  # 筛选特定日期的提交；\ngit log -p -S&lt;functionName&gt;   # 查看跟特定关键字相关的提交细节；\ngit log --oneline --decorate  # 查看各分支对应的提交情况；\ngit log --oneline --decorate --graph --all  # 显示详细的分支和提交情况；\ngit show &lt;commitHash&gt;  # 查看某一个提交的详情；\ngit show HEAD^^  # 查看当前分支的祖父提交；\ngit show HEAD~2  # 查看当前分支的祖父提交；\ngit show HEAD~~  # 查看当前分支的祖父提交；\ngit show HEAD^2  # 查看当前分支的第二父提交（被合并分支）；\n</code></pre>\n</li>\n<li><p>版本回退：</p>\n<pre><code class=\"bash\">git reset --hard HEAD^\ngit reset --hard HEAD~100\ngit reset --hard HEAD &lt;commitid&gt;\n</code></pre>\n</li>\n<li><p>查看分支引用变动历史：</p>\n<pre><code class=\"bash\">git reflog\ngit show HEAD@{n}  # 查看变动历史对应提交的详情；\n</code></pre>\n</li>\n<li><p>丢弃工作区修改：</p>\n<pre><code class=\"bash\">git checkout -- &lt;filepath&gt;\n</code></pre>\n</li>\n<li><p>丢弃暂存区修改：</p>\n<pre><code class=\"bash\">git reset HEAD &lt;filepath&gt;\n</code></pre>\n</li>\n<li><p>删除仓库文件：</p>\n<pre><code class=\"bash\">git rm &lt;filepath&gt;\ngit rm &lt;filepath&gt; --cached  # 从 Git 索引中移除，但不删除文件实体；\ngit commit -m &quot;msg&quot;\n</code></pre>\n</li>\n<li><p>代码暂存与恢复（到当前分支）：</p>\n<pre><code class=\"bash\">git stash\ngit stash pop\ngit stash drop &lt;stashId&gt;\ngit stash apply &lt;stashId&gt;  # 应用某个暂存到当前分支；\n</code></pre>\n</li>\n<li><p>“变基”的基本用法：</p>\n<pre><code class=\"bash\">git rebase &lt;baseBranch&gt; &lt;topicBranch&gt;  # 将 topicBranch 分支变基到 baseBranch 分支；\n</code></pre>\n</li>\n<li><p>移动文件：</p>\n<pre><code class=\"bash\">git mv &lt;org&gt; &lt;des&gt;  # 常用于更换文件名；\n</code></pre>\n</li>\n<li><p>管理远程仓库：</p>\n<pre><code class=\"bash\">git remote -v\ngit remote add &lt;shortname&gt; &lt;url&gt;    # 添加上游仓库；\ngit remote show &lt;remote&gt;\n</code></pre>\n</li>\n<li><p>拉取资源：</p>\n<pre><code class=\"bash\">git fetch  # 只拉取，不合并；\n</code></pre>\n</li>\n<li><p>标签：</p>\n<pre><code class=\"bash\">git tag &lt;tagName&gt;  # 轻量标签；\ngit tag -a &lt;tagName&gt; &lt;commitId&gt; -m &lt;message&gt;  # 附注标签；\n</code></pre>\n</li>\n<li><p>分支操作：</p>\n<pre><code class=\"bash\">git checkout -b &lt;branchName&gt; [&lt;tagName&gt;/&lt;remote/branchName&gt;]\ngit checkout -- .  # 丢弃本地当前所有改动；\ngit branch -v  # 查看每一个分支的最后一次提交；\ngit branch --merged/--no-merged  # 查看已经合并/未合并到当前分支的分支；\ngit checkout --track &lt;remote/branchName&gt;\ngit branch -u &lt;remote/branchName&gt;  # 为本地已有分支指定上游跟踪分支；\ngit branch -vv  # 查看本地分支的远程跟踪情况；\ngit push &lt;remote&gt; :&lt;branchName&gt;  # 删除远程分支(1)\ngit push &lt;remote&gt; --delete &lt;branchName&gt;  # 删除远程分支(2)\n</code></pre>\n</li>\n</ol>\n"},{"title":"Git 最佳实践","intro":"Git 是一款免费、开源的分布式版本控制系统，相比于之前的 CVS、SVN 等版本控制系统，Git 的优势大大凸显。Git 是分布式的版本控制系统，相比之前的集中式系统，分布式版本控制系统的安全性要高很多。因为每个人电脑里都有完整的版本库，使得整个版本库不会轻易的丢失。","comments":1,"date":"2018-11-29T03:55:05.000Z","_content":"\nGit 是一款免费、开源的分布式版本控制系统，相比于之前的 CVS、SVN 等版本控制系统，Git 的优势大大凸显。Git 是分布式的版本控制系统，相比之前的集中式系统，分布式版本控制系统的安全性要高很多。因为每个人电脑里都有完整的版本库，使得整个版本库不会轻易的丢失。 \n\n\n#### 1. 选择修订版本： \n```bash\ngit log <notin>..<in>  # 列出在 in 分支而不在 notin 分支的提交；\ngit log <in1> <in2> --not <notin>  # 列出在 in1/in2 分支而不在 notin 分支的提交；\ngit log --left-right <branch1>...<branch2>  # 并集提交，并显示所属；\n```\n\n#### 2. 交互式暂存： \n```bash\ngit add -i\ngit stash -u  # 暂存 untracked 状态的文件；\ngit stahs -a  # 暂存所有改动；\ngit stash --patch  # 交互式暂存；\ngit stash branch <branchName>  # 从上一次暂存恢复，并创建新分支；\ngit clean -d(n)f  # 移除(仅查看)所有 untracked 文件；\n```\n\n#### 3. 搜索： \n```bash\ngit grep --heading --break -n (-p) -e <key> -C <lineCount>  # 搜索关键字，是否显示所在函数定义；\ngit log -S<keyword> --oneline  # 查看特定关键字发生变动（新增/删除）时对应的提交；\ngit log -L :<functionName>:<sourceFile>  # 查看某文件内某个函数的变动历史；\n```\n\n#### 4. 重写历史： \n```bash\ngit commit --amend  # 重写最后一次提交（会自动合并缓存区中的修改）；\ngit rebase -i HEAD^<n>  # 修改最后的n次提交（修改、压缩、合并、拆分）；\ngit filter-branch --tree-filter '<cmd>' HEAD --all  # 同时改写每一个分支的所有提交；\n```\n","source":"_posts/Git-最佳实践.md","raw":"---\ntitle: Git 最佳实践\nintro: Git 是一款免费、开源的分布式版本控制系统，相比于之前的 CVS、SVN 等版本控制系统，Git 的优势大大凸显。Git 是分布式的版本控制系统，相比之前的集中式系统，分布式版本控制系统的安全性要高很多。因为每个人电脑里都有完整的版本库，使得整个版本库不会轻易的丢失。 \ncomments: true\ndate: 2018-11-29 11:55:05\ntags:\n- Git\n---\n\nGit 是一款免费、开源的分布式版本控制系统，相比于之前的 CVS、SVN 等版本控制系统，Git 的优势大大凸显。Git 是分布式的版本控制系统，相比之前的集中式系统，分布式版本控制系统的安全性要高很多。因为每个人电脑里都有完整的版本库，使得整个版本库不会轻易的丢失。 \n\n\n#### 1. 选择修订版本： \n```bash\ngit log <notin>..<in>  # 列出在 in 分支而不在 notin 分支的提交；\ngit log <in1> <in2> --not <notin>  # 列出在 in1/in2 分支而不在 notin 分支的提交；\ngit log --left-right <branch1>...<branch2>  # 并集提交，并显示所属；\n```\n\n#### 2. 交互式暂存： \n```bash\ngit add -i\ngit stash -u  # 暂存 untracked 状态的文件；\ngit stahs -a  # 暂存所有改动；\ngit stash --patch  # 交互式暂存；\ngit stash branch <branchName>  # 从上一次暂存恢复，并创建新分支；\ngit clean -d(n)f  # 移除(仅查看)所有 untracked 文件；\n```\n\n#### 3. 搜索： \n```bash\ngit grep --heading --break -n (-p) -e <key> -C <lineCount>  # 搜索关键字，是否显示所在函数定义；\ngit log -S<keyword> --oneline  # 查看特定关键字发生变动（新增/删除）时对应的提交；\ngit log -L :<functionName>:<sourceFile>  # 查看某文件内某个函数的变动历史；\n```\n\n#### 4. 重写历史： \n```bash\ngit commit --amend  # 重写最后一次提交（会自动合并缓存区中的修改）；\ngit rebase -i HEAD^<n>  # 修改最后的n次提交（修改、压缩、合并、拆分）；\ngit filter-branch --tree-filter '<cmd>' HEAD --all  # 同时改写每一个分支的所有提交；\n```\n","slug":"Git-最佳实践","published":1,"updated":"2019-02-20T06:22:42.813Z","layout":"post","photos":[],"link":"","_id":"cjsqwht7p0012knp2s06v37kj","content":"<p>Git 是一款免费、开源的分布式版本控制系统，相比于之前的 CVS、SVN 等版本控制系统，Git 的优势大大凸显。Git 是分布式的版本控制系统，相比之前的集中式系统，分布式版本控制系统的安全性要高很多。因为每个人电脑里都有完整的版本库，使得整个版本库不会轻易的丢失。 </p>\n<h4 id=\"1-选择修订版本：\"><a href=\"#1-选择修订版本：\" class=\"headerlink\" title=\"1. 选择修订版本：\"></a>1. 选择修订版本：</h4><pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> log <span class=\"token operator\">&lt;</span>notin<span class=\"token operator\">></span><span class=\"token punctuation\">..</span><span class=\"token operator\">&lt;</span>in<span class=\"token operator\">></span>  <span class=\"token comment\" spellcheck=\"true\"># 列出在 in 分支而不在 notin 分支的提交；</span>\n<span class=\"token function\">git</span> log <span class=\"token operator\">&lt;</span>in1<span class=\"token operator\">></span> <span class=\"token operator\">&lt;</span>in2<span class=\"token operator\">></span> --not <span class=\"token operator\">&lt;</span>notin<span class=\"token operator\">></span>  <span class=\"token comment\" spellcheck=\"true\"># 列出在 in1/in2 分支而不在 notin 分支的提交；</span>\n<span class=\"token function\">git</span> log --left-right <span class=\"token operator\">&lt;</span>branch1<span class=\"token operator\">></span><span class=\"token punctuation\">..</span>.<span class=\"token operator\">&lt;</span>branch2<span class=\"token operator\">></span>  <span class=\"token comment\" spellcheck=\"true\"># 并集提交，并显示所属；</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"2-交互式暂存：\"><a href=\"#2-交互式暂存：\" class=\"headerlink\" title=\"2. 交互式暂存：\"></a>2. 交互式暂存：</h4><pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> add -i\n<span class=\"token function\">git</span> stash -u  <span class=\"token comment\" spellcheck=\"true\"># 暂存 untracked 状态的文件；</span>\n<span class=\"token function\">git</span> stahs -a  <span class=\"token comment\" spellcheck=\"true\"># 暂存所有改动；</span>\n<span class=\"token function\">git</span> stash --patch  <span class=\"token comment\" spellcheck=\"true\"># 交互式暂存；</span>\n<span class=\"token function\">git</span> stash branch <span class=\"token operator\">&lt;</span>branchName<span class=\"token operator\">></span>  <span class=\"token comment\" spellcheck=\"true\"># 从上一次暂存恢复，并创建新分支；</span>\n<span class=\"token function\">git</span> clean -d<span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span>f  <span class=\"token comment\" spellcheck=\"true\"># 移除(仅查看)所有 untracked 文件；</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"3-搜索：\"><a href=\"#3-搜索：\" class=\"headerlink\" title=\"3. 搜索：\"></a>3. 搜索：</h4><pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> <span class=\"token function\">grep</span> --heading --break -n <span class=\"token punctuation\">(</span>-p<span class=\"token punctuation\">)</span> -e <span class=\"token operator\">&lt;</span>key<span class=\"token operator\">></span> -C <span class=\"token operator\">&lt;</span>lineCount<span class=\"token operator\">></span>  <span class=\"token comment\" spellcheck=\"true\"># 搜索关键字，是否显示所在函数定义；</span>\n<span class=\"token function\">git</span> log -S<span class=\"token operator\">&lt;</span>keyword<span class=\"token operator\">></span> --oneline  <span class=\"token comment\" spellcheck=\"true\"># 查看特定关键字发生变动（新增/删除）时对应的提交；</span>\n<span class=\"token function\">git</span> log -L :<span class=\"token operator\">&lt;</span>functionName<span class=\"token operator\">></span>:<span class=\"token operator\">&lt;</span>sourceFile<span class=\"token operator\">></span>  <span class=\"token comment\" spellcheck=\"true\"># 查看某文件内某个函数的变动历史；</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"4-重写历史：\"><a href=\"#4-重写历史：\" class=\"headerlink\" title=\"4. 重写历史：\"></a>4. 重写历史：</h4><pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> commit --amend  <span class=\"token comment\" spellcheck=\"true\"># 重写最后一次提交（会自动合并缓存区中的修改）；</span>\n<span class=\"token function\">git</span> rebase -i HEAD^<span class=\"token operator\">&lt;</span>n<span class=\"token operator\">></span>  <span class=\"token comment\" spellcheck=\"true\"># 修改最后的n次提交（修改、压缩、合并、拆分）；</span>\n<span class=\"token function\">git</span> filter-branch --tree-filter <span class=\"token string\">'&lt;cmd>'</span> HEAD --all  <span class=\"token comment\" spellcheck=\"true\"># 同时改写每一个分支的所有提交；</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"id":"4060ad19f123c42bf5657cfed76cf1d8","excerpt":"","more":"<p>Git 是一款免费、开源的分布式版本控制系统，相比于之前的 CVS、SVN 等版本控制系统，Git 的优势大大凸显。Git 是分布式的版本控制系统，相比之前的集中式系统，分布式版本控制系统的安全性要高很多。因为每个人电脑里都有完整的版本库，使得整个版本库不会轻易的丢失。 </p>\n<h4 id=\"1-选择修订版本：\"><a href=\"#1-选择修订版本：\" class=\"headerlink\" title=\"1. 选择修订版本：\"></a>1. 选择修订版本：</h4><pre><code class=\"bash\">git log &lt;notin&gt;..&lt;in&gt;  # 列出在 in 分支而不在 notin 分支的提交；\ngit log &lt;in1&gt; &lt;in2&gt; --not &lt;notin&gt;  # 列出在 in1/in2 分支而不在 notin 分支的提交；\ngit log --left-right &lt;branch1&gt;...&lt;branch2&gt;  # 并集提交，并显示所属；\n</code></pre>\n<h4 id=\"2-交互式暂存：\"><a href=\"#2-交互式暂存：\" class=\"headerlink\" title=\"2. 交互式暂存：\"></a>2. 交互式暂存：</h4><pre><code class=\"bash\">git add -i\ngit stash -u  # 暂存 untracked 状态的文件；\ngit stahs -a  # 暂存所有改动；\ngit stash --patch  # 交互式暂存；\ngit stash branch &lt;branchName&gt;  # 从上一次暂存恢复，并创建新分支；\ngit clean -d(n)f  # 移除(仅查看)所有 untracked 文件；\n</code></pre>\n<h4 id=\"3-搜索：\"><a href=\"#3-搜索：\" class=\"headerlink\" title=\"3. 搜索：\"></a>3. 搜索：</h4><pre><code class=\"bash\">git grep --heading --break -n (-p) -e &lt;key&gt; -C &lt;lineCount&gt;  # 搜索关键字，是否显示所在函数定义；\ngit log -S&lt;keyword&gt; --oneline  # 查看特定关键字发生变动（新增/删除）时对应的提交；\ngit log -L :&lt;functionName&gt;:&lt;sourceFile&gt;  # 查看某文件内某个函数的变动历史；\n</code></pre>\n<h4 id=\"4-重写历史：\"><a href=\"#4-重写历史：\" class=\"headerlink\" title=\"4. 重写历史：\"></a>4. 重写历史：</h4><pre><code class=\"bash\">git commit --amend  # 重写最后一次提交（会自动合并缓存区中的修改）；\ngit rebase -i HEAD^&lt;n&gt;  # 修改最后的n次提交（修改、压缩、合并、拆分）；\ngit filter-branch --tree-filter &#39;&lt;cmd&gt;&#39; HEAD --all  # 同时改写每一个分支的所有提交；\n</code></pre>\n"},{"title":"HTML5 随记录","intro":"在此总结记录一些 HTML5 相关的基础知识，主要内容包括一些不经常使用但是却又比较重要的 HTML5 特性。对于需要系统性了解 HTML5 特性的同学可以对照此文查缺补漏。但本文不会记录所有的 HTML5 特性，只挑选一些笔者不常用的特性加以记录与整理。","comments":1,"date":"2016-07-27T14:45:25.000Z","_content":"\n在此总结记录一些 HTML5 相关的基础知识，主要内容包括一些不经常使用但是却又比较重要的 HTML5 特性。对于需要系统性了解 HTML5 特性的同学可以对照此文查缺补漏。但本文不会记录所有的 HTML5 特性，只挑选一些笔者不常用的特性加以记录与整理。\n\n**1、从 HTML4.01 到 XHTML 再到 HTML5：**\n\nXHMTL 是一种更严格、更纯洁的 HTML 代码，W3C 制定了 XHTML 主要用于取代原有的 HTML。W3C 建议使用 XML 规范来加以约束 HTML 文档，将 HTML 和 XML 的长处结合在一起便形成了 XHTML。在 HTML4.01 和 XHTML 中需要指定 DTD（文档类型定义）来定义 HTML 文档的语义约束（支持的元素和属性），而在 HTML5 中则不再需要，这也算是一种“妥协式”的规范。\n\n**2、属性值简写：**\n\n\n```html\n<!-- XHTML Request: xxx.php?x,y （x,y 为用户点击图像的相对位置）-->\n<a href=\"xxx.php\">\n    <img src=\"xxx.jpg\" ismap=\"ismap\" alt=\"\" />\n</a>\n<!-- XHTML 外部脚本会在当页面已完成加载后，才会执行 -->\n<script src=\"xxx.js\" defer=\"defer\"></script>\n\n<!-- HTML5 Request: xxx.php?x,y （x,y 为用户点击图像的相对位置）-->\n<a href=\"xxx.php\">\n    <img src=\"xxx.jpg\" ismap alt=\"\" />\n</a>\n<!-- HTML5 外部脚本会在当页面已完成加载后，才会执行 -->\n<script src=\"xxx.js\" defer></script>\n```\n\n**3、语义化的文本格式化标签：**\n\n\n```html\n<em>定义强调文本，效果与斜体文本相似</em>\n**定义重要文本**\n<small>定义小字印刷体，诸如免责声明、注意事项、版权相关文字等</small>\n<sup>定义上标文本</sup>\n<sub>定义下标文本</sub>\n<bdo dir=\"ltr\">定义文本显示方向，左至右</bdo>\n<bdo dir=\"rtl\">定义文本显示方向，右至左</bdo>\n<abbr>定义缩写文本</abbr>\n<address>定义地址文本</address>\n<blockquote>定义长引用文本</blockquote>\n<q>定义短引用文本</q>\n<cite>定义作品标题</cite>\n<code>定义计算机代码</code>\n<var>定义一个变量</var>\n<dfn>定义一个专业用语</dfn>\n<del>定义被删除的文本</del>\n<ins>定义插入的文本</ins>\n<kbd>定义键盘文本（计算机文档常用）</kbd>\n<samp>定义示范文本</samp>\n\n<!-- 以下为 HTML5 新增元素 -->\n<article></article>\n<section></section>\n<nav></nav>\n<aside></aside>\n<header></header>\n<footer></footer>\n<time></time>\n<mark></mark>\n```\n\n\n**4、其他标签元素：**\n\n\n```html\n<!-- 定义有序列表 -->\n<ol start=\"2\" type=\"I\">\n    <li></li>\n</ol>\n\n<!-- 定义图片映射 -->\n<img src=\"xxx.png\" usemap=\"imgmap\"/>\n<map name=\"imgmap\">\n<area shape=\"poly\" coords=\"188,27,34,89,38,99\" href=\"xxx.html\" />\n</map>\n\n<!-- 标准表格 -->\n<table>\n    <caption>表格标题</caption>\n    <colgroup>\n    <col />\n    <col span=\"2\" />\n    </colgroup>\n    <thead><tr></tr></thead>\n    <tfoot><tr></tr></tfoot>\n    <tbody><tr></tr></tbody>&nbsp;   \n</table>\n\n<!-- <meter> 和 <progress> -->\n<meter value=\"120\" min=\"0\" max=\"220\" low=\"0\" high=\"160\">\n<progress value=\"30\" max=\"100\"></progress>\n\n<!-- 用 <base> 为页面所有链接指定基准链接 -->\n<base target=\"_blank\" href=\"http://xxx.com/\">\n```\n\n\n**5、新增属性：**\n\n```html\n<!-- \n    “contentEditable” 属性： 使某一 HTML 的内容（innerHTML）可编辑（向下继承）；\n    “isContentEditable” 属性：判断当前元素内容是否可编辑 ；\n\n    *而对于全局的 HTML 页面，可以使用 “document.designMode = true;” 来使整个页面可编辑；\n-->\n<p contentEditable=\"true\">这是一段可编辑的段落</p>\n<!-- 设置 “hidden“ 属性为 “true” 相当于设置 “display: none;” 样式 -->\n<div hidden=\"true\">内容文字</div>\n<!-- “spellCheck” 属性：若设置该属性，浏览器会对容器内的文本进行语法检查 -->\n<textarea spellCheck=\"true\">内容文字</textarea>\n```\n\n**6、表单部分：**\n\n三种表单数据编码方式：\n\n* **application/x-www-form-urlencoded**：\n\n默认的编码方式，只处理表单控件里的 value 属性值，并将这些值处理成 URL 编码格式；\n\n* **multipart/form-data**：\n\n以二进制流的方式处理表单数据，上传文件时使用；\n\n* **text/plain**：\n\n一般在邮件链接（mailto: URL）时使用；\n\n<br>\n\n为表单控件添加 **tabIndex** 属性，便可以用 Tab 键来根据 `tabIndex` 的值转换各个控件的焦点。\n\n使用 **label** 定义标签：`<label>` 标签可以自动与对应的表单元素相关联，当用户点击标签时对应的表单域会自动获得焦点。\n\n\n```html\n<!-- 显式关联 -->\n<label for=\"username\">Please input your username:</label>\n<input id=\"username\" name=\"username\" type=\"text\"/>\n\n<!-- 隐式关联 -->\n<label>Username: <input name=\"username\" type=\"text\"/></label>\n```\n\n使用 **button** 定义按钮：`<button>` 标签内部可以包含普通文本、文本格式化标签以及图像等等，这是相对于 `<input>` 标签的优势。\n\n\n```html\n<button type=\"submit\"><img src=\"xxx.png\"/></button>\n```\n\n使用表单的 **form** 属性：该属性可以使表单控件不用全部放到 `<form>` 标签内部，可以在外部指定表单的控件元素。\n\n\n```html\n<form id=\"form\" action=\"\">\n    <input type=\"text\" name=\"name\" />\n</form>\n\n<!-- 利用 form 的 “id” 属性来进行关系连接 -->\n<input type=\"submit\" value=\"Submit\" form=\"form\"/>\n```\n\n使用表单的 **formaction** 属性：该属性可以使表单具备多提交入口的功能，即可以实现不同按钮提交到不同服务器接口的功能。\n\n\n```html\n<form id=\"form\" action=\"\">\n    <input type=\"text\" name=\"name\" />\n    <input type=\"submit\" value=\"Submit Entrance One\" formaction=\"interface_one\" formmethod=\"get\"/>\n    <input type=\"submit\" value=\"Submit Entrance Two\" formaction=\"interface_two\" formmethod=\"post\"/>\n</form>\n```\n\n使用表单的 **formtarget** 和 **formenctype** 属性：`formtarget` 属性可以动态改变表单提交所使用的 target 方式，`formenctype` 属性可以动态改变标题提交时使用的编码方式。\n","source":"_posts/HTML5-随记录.md","raw":"---\ntitle: HTML5 随记录\nintro: 在此总结记录一些 HTML5 相关的基础知识，主要内容包括一些不经常使用但是却又比较重要的 HTML5 特性。对于需要系统性了解 HTML5 特性的同学可以对照此文查缺补漏。但本文不会记录所有的 HTML5 特性，只挑选一些笔者不常用的特性加以记录与整理。\ncomments: true\ndate: 2016-07-27 22:45:25\ntags:\n- HTML\n---\n\n在此总结记录一些 HTML5 相关的基础知识，主要内容包括一些不经常使用但是却又比较重要的 HTML5 特性。对于需要系统性了解 HTML5 特性的同学可以对照此文查缺补漏。但本文不会记录所有的 HTML5 特性，只挑选一些笔者不常用的特性加以记录与整理。\n\n**1、从 HTML4.01 到 XHTML 再到 HTML5：**\n\nXHMTL 是一种更严格、更纯洁的 HTML 代码，W3C 制定了 XHTML 主要用于取代原有的 HTML。W3C 建议使用 XML 规范来加以约束 HTML 文档，将 HTML 和 XML 的长处结合在一起便形成了 XHTML。在 HTML4.01 和 XHTML 中需要指定 DTD（文档类型定义）来定义 HTML 文档的语义约束（支持的元素和属性），而在 HTML5 中则不再需要，这也算是一种“妥协式”的规范。\n\n**2、属性值简写：**\n\n\n```html\n<!-- XHTML Request: xxx.php?x,y （x,y 为用户点击图像的相对位置）-->\n<a href=\"xxx.php\">\n    <img src=\"xxx.jpg\" ismap=\"ismap\" alt=\"\" />\n</a>\n<!-- XHTML 外部脚本会在当页面已完成加载后，才会执行 -->\n<script src=\"xxx.js\" defer=\"defer\"></script>\n\n<!-- HTML5 Request: xxx.php?x,y （x,y 为用户点击图像的相对位置）-->\n<a href=\"xxx.php\">\n    <img src=\"xxx.jpg\" ismap alt=\"\" />\n</a>\n<!-- HTML5 外部脚本会在当页面已完成加载后，才会执行 -->\n<script src=\"xxx.js\" defer></script>\n```\n\n**3、语义化的文本格式化标签：**\n\n\n```html\n<em>定义强调文本，效果与斜体文本相似</em>\n**定义重要文本**\n<small>定义小字印刷体，诸如免责声明、注意事项、版权相关文字等</small>\n<sup>定义上标文本</sup>\n<sub>定义下标文本</sub>\n<bdo dir=\"ltr\">定义文本显示方向，左至右</bdo>\n<bdo dir=\"rtl\">定义文本显示方向，右至左</bdo>\n<abbr>定义缩写文本</abbr>\n<address>定义地址文本</address>\n<blockquote>定义长引用文本</blockquote>\n<q>定义短引用文本</q>\n<cite>定义作品标题</cite>\n<code>定义计算机代码</code>\n<var>定义一个变量</var>\n<dfn>定义一个专业用语</dfn>\n<del>定义被删除的文本</del>\n<ins>定义插入的文本</ins>\n<kbd>定义键盘文本（计算机文档常用）</kbd>\n<samp>定义示范文本</samp>\n\n<!-- 以下为 HTML5 新增元素 -->\n<article></article>\n<section></section>\n<nav></nav>\n<aside></aside>\n<header></header>\n<footer></footer>\n<time></time>\n<mark></mark>\n```\n\n\n**4、其他标签元素：**\n\n\n```html\n<!-- 定义有序列表 -->\n<ol start=\"2\" type=\"I\">\n    <li></li>\n</ol>\n\n<!-- 定义图片映射 -->\n<img src=\"xxx.png\" usemap=\"imgmap\"/>\n<map name=\"imgmap\">\n<area shape=\"poly\" coords=\"188,27,34,89,38,99\" href=\"xxx.html\" />\n</map>\n\n<!-- 标准表格 -->\n<table>\n    <caption>表格标题</caption>\n    <colgroup>\n    <col />\n    <col span=\"2\" />\n    </colgroup>\n    <thead><tr></tr></thead>\n    <tfoot><tr></tr></tfoot>\n    <tbody><tr></tr></tbody>&nbsp;   \n</table>\n\n<!-- <meter> 和 <progress> -->\n<meter value=\"120\" min=\"0\" max=\"220\" low=\"0\" high=\"160\">\n<progress value=\"30\" max=\"100\"></progress>\n\n<!-- 用 <base> 为页面所有链接指定基准链接 -->\n<base target=\"_blank\" href=\"http://xxx.com/\">\n```\n\n\n**5、新增属性：**\n\n```html\n<!-- \n    “contentEditable” 属性： 使某一 HTML 的内容（innerHTML）可编辑（向下继承）；\n    “isContentEditable” 属性：判断当前元素内容是否可编辑 ；\n\n    *而对于全局的 HTML 页面，可以使用 “document.designMode = true;” 来使整个页面可编辑；\n-->\n<p contentEditable=\"true\">这是一段可编辑的段落</p>\n<!-- 设置 “hidden“ 属性为 “true” 相当于设置 “display: none;” 样式 -->\n<div hidden=\"true\">内容文字</div>\n<!-- “spellCheck” 属性：若设置该属性，浏览器会对容器内的文本进行语法检查 -->\n<textarea spellCheck=\"true\">内容文字</textarea>\n```\n\n**6、表单部分：**\n\n三种表单数据编码方式：\n\n* **application/x-www-form-urlencoded**：\n\n默认的编码方式，只处理表单控件里的 value 属性值，并将这些值处理成 URL 编码格式；\n\n* **multipart/form-data**：\n\n以二进制流的方式处理表单数据，上传文件时使用；\n\n* **text/plain**：\n\n一般在邮件链接（mailto: URL）时使用；\n\n<br>\n\n为表单控件添加 **tabIndex** 属性，便可以用 Tab 键来根据 `tabIndex` 的值转换各个控件的焦点。\n\n使用 **label** 定义标签：`<label>` 标签可以自动与对应的表单元素相关联，当用户点击标签时对应的表单域会自动获得焦点。\n\n\n```html\n<!-- 显式关联 -->\n<label for=\"username\">Please input your username:</label>\n<input id=\"username\" name=\"username\" type=\"text\"/>\n\n<!-- 隐式关联 -->\n<label>Username: <input name=\"username\" type=\"text\"/></label>\n```\n\n使用 **button** 定义按钮：`<button>` 标签内部可以包含普通文本、文本格式化标签以及图像等等，这是相对于 `<input>` 标签的优势。\n\n\n```html\n<button type=\"submit\"><img src=\"xxx.png\"/></button>\n```\n\n使用表单的 **form** 属性：该属性可以使表单控件不用全部放到 `<form>` 标签内部，可以在外部指定表单的控件元素。\n\n\n```html\n<form id=\"form\" action=\"\">\n    <input type=\"text\" name=\"name\" />\n</form>\n\n<!-- 利用 form 的 “id” 属性来进行关系连接 -->\n<input type=\"submit\" value=\"Submit\" form=\"form\"/>\n```\n\n使用表单的 **formaction** 属性：该属性可以使表单具备多提交入口的功能，即可以实现不同按钮提交到不同服务器接口的功能。\n\n\n```html\n<form id=\"form\" action=\"\">\n    <input type=\"text\" name=\"name\" />\n    <input type=\"submit\" value=\"Submit Entrance One\" formaction=\"interface_one\" formmethod=\"get\"/>\n    <input type=\"submit\" value=\"Submit Entrance Two\" formaction=\"interface_two\" formmethod=\"post\"/>\n</form>\n```\n\n使用表单的 **formtarget** 和 **formenctype** 属性：`formtarget` 属性可以动态改变表单提交所使用的 target 方式，`formenctype` 属性可以动态改变标题提交时使用的编码方式。\n","slug":"HTML5-随记录","published":1,"updated":"2019-02-09T15:44:08.232Z","layout":"post","photos":[],"link":"","_id":"cjsqwht7p0014knp2txjwl8w4","content":"<p>在此总结记录一些 HTML5 相关的基础知识，主要内容包括一些不经常使用但是却又比较重要的 HTML5 特性。对于需要系统性了解 HTML5 特性的同学可以对照此文查缺补漏。但本文不会记录所有的 HTML5 特性，只挑选一些笔者不常用的特性加以记录与整理。</p>\n<p><strong>1、从 HTML4.01 到 XHTML 再到 HTML5：</strong></p>\n<p>XHMTL 是一种更严格、更纯洁的 HTML 代码，W3C 制定了 XHTML 主要用于取代原有的 HTML。W3C 建议使用 XML 规范来加以约束 HTML 文档，将 HTML 和 XML 的长处结合在一起便形成了 XHTML。在 HTML4.01 和 XHTML 中需要指定 DTD（文档类型定义）来定义 HTML 文档的语义约束（支持的元素和属性），而在 HTML5 中则不再需要，这也算是一种“妥协式”的规范。</p>\n<p><strong>2、属性值简写：</strong></p>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token comment\" spellcheck=\"true\">&lt;!-- XHTML Request: xxx.php?x,y （x,y 为用户点击图像的相对位置）--></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>a</span> <span class=\"token attr-name\">href</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>xxx.php<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>img</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>xxx.jpg<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">ismap</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>ismap<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">alt</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span><span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>a</span><span class=\"token punctuation\">></span></span>\n<span class=\"token comment\" spellcheck=\"true\">&lt;!-- XHTML 外部脚本会在当页面已完成加载后，才会执行 --></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>xxx.js<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">defer</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>defer<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token script language-javascript\"></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n\n<span class=\"token comment\" spellcheck=\"true\">&lt;!-- HTML5 Request: xxx.php?x,y （x,y 为用户点击图像的相对位置）--></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>a</span> <span class=\"token attr-name\">href</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>xxx.php<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>img</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>xxx.jpg<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">ismap</span> <span class=\"token attr-name\">alt</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span><span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>a</span><span class=\"token punctuation\">></span></span>\n<span class=\"token comment\" spellcheck=\"true\">&lt;!-- HTML5 外部脚本会在当页面已完成加载后，才会执行 --></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>xxx.js<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">defer</span><span class=\"token punctuation\">></span></span><span class=\"token script language-javascript\"></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>3、语义化的文本格式化标签：</strong></p>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>em</span><span class=\"token punctuation\">></span></span>定义强调文本，效果与斜体文本相似<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>em</span><span class=\"token punctuation\">></span></span>\n**定义重要文本**\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>small</span><span class=\"token punctuation\">></span></span>定义小字印刷体，诸如免责声明、注意事项、版权相关文字等<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>small</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>sup</span><span class=\"token punctuation\">></span></span>定义上标文本<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>sup</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>sub</span><span class=\"token punctuation\">></span></span>定义下标文本<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>sub</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>bdo</span> <span class=\"token attr-name\">dir</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>ltr<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>定义文本显示方向，左至右<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>bdo</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>bdo</span> <span class=\"token attr-name\">dir</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>rtl<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>定义文本显示方向，右至左<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>bdo</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>abbr</span><span class=\"token punctuation\">></span></span>定义缩写文本<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>abbr</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>address</span><span class=\"token punctuation\">></span></span>定义地址文本<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>address</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>blockquote</span><span class=\"token punctuation\">></span></span>定义长引用文本<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>blockquote</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>q</span><span class=\"token punctuation\">></span></span>定义短引用文本<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>q</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>cite</span><span class=\"token punctuation\">></span></span>定义作品标题<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>cite</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>code</span><span class=\"token punctuation\">></span></span>定义计算机代码<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>code</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>var</span><span class=\"token punctuation\">></span></span>定义一个变量<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>var</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dfn</span><span class=\"token punctuation\">></span></span>定义一个专业用语<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dfn</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>del</span><span class=\"token punctuation\">></span></span>定义被删除的文本<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>del</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>ins</span><span class=\"token punctuation\">></span></span>定义插入的文本<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>ins</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>kbd</span><span class=\"token punctuation\">></span></span>定义键盘文本（计算机文档常用）<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>kbd</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>samp</span><span class=\"token punctuation\">></span></span>定义示范文本<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>samp</span><span class=\"token punctuation\">></span></span>\n\n<span class=\"token comment\" spellcheck=\"true\">&lt;!-- 以下为 HTML5 新增元素 --></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>article</span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>article</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>section</span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>section</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>nav</span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>nav</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>aside</span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>aside</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>header</span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>header</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>footer</span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>footer</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>time</span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>time</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>mark</span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>mark</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>4、其他标签元素：</strong></p>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token comment\" spellcheck=\"true\">&lt;!-- 定义有序列表 --></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>ol</span> <span class=\"token attr-name\">start</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>2<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>I<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>li</span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>li</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>ol</span><span class=\"token punctuation\">></span></span>\n\n<span class=\"token comment\" spellcheck=\"true\">&lt;!-- 定义图片映射 --></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>img</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>xxx.png<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">usemap</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>imgmap<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>map</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>imgmap<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>area</span> <span class=\"token attr-name\">shape</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>poly<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">coords</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>188,27,34,89,38,99<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">href</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>xxx.html<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>map</span><span class=\"token punctuation\">></span></span>\n\n<span class=\"token comment\" spellcheck=\"true\">&lt;!-- 标准表格 --></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>table</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>caption</span><span class=\"token punctuation\">></span></span>表格标题<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>caption</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>colgroup</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>col</span> <span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>col</span> <span class=\"token attr-name\">span</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>2<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>colgroup</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>thead</span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>tr</span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>tr</span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>thead</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>tfoot</span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>tr</span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>tr</span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>tfoot</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>tbody</span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>tr</span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>tr</span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>tbody</span><span class=\"token punctuation\">></span></span><span class=\"token entity\" title=\"&nbsp;\">&amp;nbsp;</span>   \n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>table</span><span class=\"token punctuation\">></span></span>\n\n<span class=\"token comment\" spellcheck=\"true\">&lt;!-- &lt;meter> 和 &lt;progress> --></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>meter</span> <span class=\"token attr-name\">value</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>120<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">min</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>0<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">max</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>220<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">low</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>0<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">high</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>160<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>progress</span> <span class=\"token attr-name\">value</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>30<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">max</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>100<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>progress</span><span class=\"token punctuation\">></span></span>\n\n<span class=\"token comment\" spellcheck=\"true\">&lt;!-- 用 &lt;base> 为页面所有链接指定基准链接 --></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>base</span> <span class=\"token attr-name\">target</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>_blank<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">href</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>http://xxx.com/<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>5、新增属性：</strong></p>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token comment\" spellcheck=\"true\">&lt;!-- \n    “contentEditable” 属性： 使某一 HTML 的内容（innerHTML）可编辑（向下继承）；\n    “isContentEditable” 属性：判断当前元素内容是否可编辑 ；\n\n    *而对于全局的 HTML 页面，可以使用 “document.designMode = true;” 来使整个页面可编辑；\n--></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span> <span class=\"token attr-name\">contentEditable</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>true<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>这是一段可编辑的段落<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span>\n<span class=\"token comment\" spellcheck=\"true\">&lt;!-- 设置 “hidden“ 属性为 “true” 相当于设置 “display: none;” 样式 --></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">hidden</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>true<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>内容文字<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n<span class=\"token comment\" spellcheck=\"true\">&lt;!-- “spellCheck” 属性：若设置该属性，浏览器会对容器内的文本进行语法检查 --></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>textarea</span> <span class=\"token attr-name\">spellCheck</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>true<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>内容文字<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>textarea</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>6、表单部分：</strong></p>\n<p>三种表单数据编码方式：</p>\n<ul>\n<li><strong>application/x-www-form-urlencoded</strong>：</li>\n</ul>\n<p>默认的编码方式，只处理表单控件里的 value 属性值，并将这些值处理成 URL 编码格式；</p>\n<ul>\n<li><strong>multipart/form-data</strong>：</li>\n</ul>\n<p>以二进制流的方式处理表单数据，上传文件时使用；</p>\n<ul>\n<li><strong>text/plain</strong>：</li>\n</ul>\n<p>一般在邮件链接（mailto: URL）时使用；</p>\n<p><br></p>\n<p>为表单控件添加 <strong>tabIndex</strong> 属性，便可以用 Tab 键来根据 <code>tabIndex</code> 的值转换各个控件的焦点。</p>\n<p>使用 <strong>label</strong> 定义标签：<code>&lt;label&gt;</code> 标签可以自动与对应的表单元素相关联，当用户点击标签时对应的表单域会自动获得焦点。</p>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token comment\" spellcheck=\"true\">&lt;!-- 显式关联 --></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>label</span> <span class=\"token attr-name\">for</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>username<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>Please input your username:<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>label</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>username<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>username<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>text<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n\n<span class=\"token comment\" spellcheck=\"true\">&lt;!-- 隐式关联 --></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>label</span><span class=\"token punctuation\">></span></span>Username: <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>username<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>text<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>label</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>使用 <strong>button</strong> 定义按钮：<code>&lt;button&gt;</code> 标签内部可以包含普通文本、文本格式化标签以及图像等等，这是相对于 <code>&lt;input&gt;</code> 标签的优势。</p>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>submit<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>img</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>xxx.png<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>button</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>使用表单的 <strong>form</strong> 属性：该属性可以使表单控件不用全部放到 <code>&lt;form&gt;</code> 标签内部，可以在外部指定表单的控件元素。</p>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>form</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>form<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">action</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span><span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>text<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>name<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>form</span><span class=\"token punctuation\">></span></span>\n\n<span class=\"token comment\" spellcheck=\"true\">&lt;!-- 利用 form 的 “id” 属性来进行关系连接 --></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>submit<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">value</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>Submit<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">form</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>form<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>使用表单的 <strong>formaction</strong> 属性：该属性可以使表单具备多提交入口的功能，即可以实现不同按钮提交到不同服务器接口的功能。</p>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>form</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>form<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">action</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span><span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>text<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>name<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>submit<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">value</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>Submit Entrance One<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">formaction</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>interface_one<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">formmethod</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>get<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>submit<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">value</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>Submit Entrance Two<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">formaction</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>interface_two<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">formmethod</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>post<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>form</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>使用表单的 <strong>formtarget</strong> 和 <strong>formenctype</strong> 属性：<code>formtarget</code> 属性可以动态改变表单提交所使用的 target 方式，<code>formenctype</code> 属性可以动态改变标题提交时使用的编码方式。</p>\n","site":{"data":{}},"id":"6914caddcbb7e096615ae2be8a1de5c1","excerpt":"","more":"<p>在此总结记录一些 HTML5 相关的基础知识，主要内容包括一些不经常使用但是却又比较重要的 HTML5 特性。对于需要系统性了解 HTML5 特性的同学可以对照此文查缺补漏。但本文不会记录所有的 HTML5 特性，只挑选一些笔者不常用的特性加以记录与整理。</p>\n<p><strong>1、从 HTML4.01 到 XHTML 再到 HTML5：</strong></p>\n<p>XHMTL 是一种更严格、更纯洁的 HTML 代码，W3C 制定了 XHTML 主要用于取代原有的 HTML。W3C 建议使用 XML 规范来加以约束 HTML 文档，将 HTML 和 XML 的长处结合在一起便形成了 XHTML。在 HTML4.01 和 XHTML 中需要指定 DTD（文档类型定义）来定义 HTML 文档的语义约束（支持的元素和属性），而在 HTML5 中则不再需要，这也算是一种“妥协式”的规范。</p>\n<p><strong>2、属性值简写：</strong></p>\n<pre><code class=\"html\">&lt;!-- XHTML Request: xxx.php?x,y （x,y 为用户点击图像的相对位置）--&gt;\n&lt;a href=&quot;xxx.php&quot;&gt;\n    &lt;img src=&quot;xxx.jpg&quot; ismap=&quot;ismap&quot; alt=&quot;&quot; /&gt;\n&lt;/a&gt;\n&lt;!-- XHTML 外部脚本会在当页面已完成加载后，才会执行 --&gt;\n&lt;script src=&quot;xxx.js&quot; defer=&quot;defer&quot;&gt;&lt;/script&gt;\n\n&lt;!-- HTML5 Request: xxx.php?x,y （x,y 为用户点击图像的相对位置）--&gt;\n&lt;a href=&quot;xxx.php&quot;&gt;\n    &lt;img src=&quot;xxx.jpg&quot; ismap alt=&quot;&quot; /&gt;\n&lt;/a&gt;\n&lt;!-- HTML5 外部脚本会在当页面已完成加载后，才会执行 --&gt;\n&lt;script src=&quot;xxx.js&quot; defer&gt;&lt;/script&gt;\n</code></pre>\n<p><strong>3、语义化的文本格式化标签：</strong></p>\n<pre><code class=\"html\">&lt;em&gt;定义强调文本，效果与斜体文本相似&lt;/em&gt;\n**定义重要文本**\n&lt;small&gt;定义小字印刷体，诸如免责声明、注意事项、版权相关文字等&lt;/small&gt;\n&lt;sup&gt;定义上标文本&lt;/sup&gt;\n&lt;sub&gt;定义下标文本&lt;/sub&gt;\n&lt;bdo dir=&quot;ltr&quot;&gt;定义文本显示方向，左至右&lt;/bdo&gt;\n&lt;bdo dir=&quot;rtl&quot;&gt;定义文本显示方向，右至左&lt;/bdo&gt;\n&lt;abbr&gt;定义缩写文本&lt;/abbr&gt;\n&lt;address&gt;定义地址文本&lt;/address&gt;\n&lt;blockquote&gt;定义长引用文本&lt;/blockquote&gt;\n&lt;q&gt;定义短引用文本&lt;/q&gt;\n&lt;cite&gt;定义作品标题&lt;/cite&gt;\n&lt;code&gt;定义计算机代码&lt;/code&gt;\n&lt;var&gt;定义一个变量&lt;/var&gt;\n&lt;dfn&gt;定义一个专业用语&lt;/dfn&gt;\n&lt;del&gt;定义被删除的文本&lt;/del&gt;\n&lt;ins&gt;定义插入的文本&lt;/ins&gt;\n&lt;kbd&gt;定义键盘文本（计算机文档常用）&lt;/kbd&gt;\n&lt;samp&gt;定义示范文本&lt;/samp&gt;\n\n&lt;!-- 以下为 HTML5 新增元素 --&gt;\n&lt;article&gt;&lt;/article&gt;\n&lt;section&gt;&lt;/section&gt;\n&lt;nav&gt;&lt;/nav&gt;\n&lt;aside&gt;&lt;/aside&gt;\n&lt;header&gt;&lt;/header&gt;\n&lt;footer&gt;&lt;/footer&gt;\n&lt;time&gt;&lt;/time&gt;\n&lt;mark&gt;&lt;/mark&gt;\n</code></pre>\n<p><strong>4、其他标签元素：</strong></p>\n<pre><code class=\"html\">&lt;!-- 定义有序列表 --&gt;\n&lt;ol start=&quot;2&quot; type=&quot;I&quot;&gt;\n    &lt;li&gt;&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;!-- 定义图片映射 --&gt;\n&lt;img src=&quot;xxx.png&quot; usemap=&quot;imgmap&quot;/&gt;\n&lt;map name=&quot;imgmap&quot;&gt;\n&lt;area shape=&quot;poly&quot; coords=&quot;188,27,34,89,38,99&quot; href=&quot;xxx.html&quot; /&gt;\n&lt;/map&gt;\n\n&lt;!-- 标准表格 --&gt;\n&lt;table&gt;\n    &lt;caption&gt;表格标题&lt;/caption&gt;\n    &lt;colgroup&gt;\n    &lt;col /&gt;\n    &lt;col span=&quot;2&quot; /&gt;\n    &lt;/colgroup&gt;\n    &lt;thead&gt;&lt;tr&gt;&lt;/tr&gt;&lt;/thead&gt;\n    &lt;tfoot&gt;&lt;tr&gt;&lt;/tr&gt;&lt;/tfoot&gt;\n    &lt;tbody&gt;&lt;tr&gt;&lt;/tr&gt;&lt;/tbody&gt;&amp;nbsp;   \n&lt;/table&gt;\n\n&lt;!-- &lt;meter&gt; 和 &lt;progress&gt; --&gt;\n&lt;meter value=&quot;120&quot; min=&quot;0&quot; max=&quot;220&quot; low=&quot;0&quot; high=&quot;160&quot;&gt;\n&lt;progress value=&quot;30&quot; max=&quot;100&quot;&gt;&lt;/progress&gt;\n\n&lt;!-- 用 &lt;base&gt; 为页面所有链接指定基准链接 --&gt;\n&lt;base target=&quot;_blank&quot; href=&quot;http://xxx.com/&quot;&gt;\n</code></pre>\n<p><strong>5、新增属性：</strong></p>\n<pre><code class=\"html\">&lt;!-- \n    “contentEditable” 属性： 使某一 HTML 的内容（innerHTML）可编辑（向下继承）；\n    “isContentEditable” 属性：判断当前元素内容是否可编辑 ；\n\n    *而对于全局的 HTML 页面，可以使用 “document.designMode = true;” 来使整个页面可编辑；\n--&gt;\n&lt;p contentEditable=&quot;true&quot;&gt;这是一段可编辑的段落&lt;/p&gt;\n&lt;!-- 设置 “hidden“ 属性为 “true” 相当于设置 “display: none;” 样式 --&gt;\n&lt;div hidden=&quot;true&quot;&gt;内容文字&lt;/div&gt;\n&lt;!-- “spellCheck” 属性：若设置该属性，浏览器会对容器内的文本进行语法检查 --&gt;\n&lt;textarea spellCheck=&quot;true&quot;&gt;内容文字&lt;/textarea&gt;\n</code></pre>\n<p><strong>6、表单部分：</strong></p>\n<p>三种表单数据编码方式：</p>\n<ul>\n<li><strong>application/x-www-form-urlencoded</strong>：</li>\n</ul>\n<p>默认的编码方式，只处理表单控件里的 value 属性值，并将这些值处理成 URL 编码格式；</p>\n<ul>\n<li><strong>multipart/form-data</strong>：</li>\n</ul>\n<p>以二进制流的方式处理表单数据，上传文件时使用；</p>\n<ul>\n<li><strong>text/plain</strong>：</li>\n</ul>\n<p>一般在邮件链接（mailto: URL）时使用；</p>\n<p><br></p>\n<p>为表单控件添加 <strong>tabIndex</strong> 属性，便可以用 Tab 键来根据 <code>tabIndex</code> 的值转换各个控件的焦点。</p>\n<p>使用 <strong>label</strong> 定义标签：<code>&lt;label&gt;</code> 标签可以自动与对应的表单元素相关联，当用户点击标签时对应的表单域会自动获得焦点。</p>\n<pre><code class=\"html\">&lt;!-- 显式关联 --&gt;\n&lt;label for=&quot;username&quot;&gt;Please input your username:&lt;/label&gt;\n&lt;input id=&quot;username&quot; name=&quot;username&quot; type=&quot;text&quot;/&gt;\n\n&lt;!-- 隐式关联 --&gt;\n&lt;label&gt;Username: &lt;input name=&quot;username&quot; type=&quot;text&quot;/&gt;&lt;/label&gt;\n</code></pre>\n<p>使用 <strong>button</strong> 定义按钮：<code>&lt;button&gt;</code> 标签内部可以包含普通文本、文本格式化标签以及图像等等，这是相对于 <code>&lt;input&gt;</code> 标签的优势。</p>\n<pre><code class=\"html\">&lt;button type=&quot;submit&quot;&gt;&lt;img src=&quot;xxx.png&quot;/&gt;&lt;/button&gt;\n</code></pre>\n<p>使用表单的 <strong>form</strong> 属性：该属性可以使表单控件不用全部放到 <code>&lt;form&gt;</code> 标签内部，可以在外部指定表单的控件元素。</p>\n<pre><code class=\"html\">&lt;form id=&quot;form&quot; action=&quot;&quot;&gt;\n    &lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;\n&lt;/form&gt;\n\n&lt;!-- 利用 form 的 “id” 属性来进行关系连接 --&gt;\n&lt;input type=&quot;submit&quot; value=&quot;Submit&quot; form=&quot;form&quot;/&gt;\n</code></pre>\n<p>使用表单的 <strong>formaction</strong> 属性：该属性可以使表单具备多提交入口的功能，即可以实现不同按钮提交到不同服务器接口的功能。</p>\n<pre><code class=\"html\">&lt;form id=&quot;form&quot; action=&quot;&quot;&gt;\n    &lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;\n    &lt;input type=&quot;submit&quot; value=&quot;Submit Entrance One&quot; formaction=&quot;interface_one&quot; formmethod=&quot;get&quot;/&gt;\n    &lt;input type=&quot;submit&quot; value=&quot;Submit Entrance Two&quot; formaction=&quot;interface_two&quot; formmethod=&quot;post&quot;/&gt;\n&lt;/form&gt;\n</code></pre>\n<p>使用表单的 <strong>formtarget</strong> 和 <strong>formenctype</strong> 属性：<code>formtarget</code> 属性可以动态改变表单提交所使用的 target 方式，<code>formenctype</code> 属性可以动态改变标题提交时使用的编码方式。</p>\n"},{"title":"HTTP 基础整理","intro":"最近花了点时间稍微整理了一下常见的 HTTP 相关的知识点，没有特别的往计算机网络的深度去挖，但常见的请求与相应的相关知识点还是需要清楚的。这里只会记录一些不是经常使用但是却需要了解的部分，并不是一个完整的知识列表，在阅读文章之前请知晓。","comments":1,"date":"2017-03-09T05:15:24.000Z","_content":"\n\n最近花了点时间稍微整理了一下常见的 HTTP 相关的知识点，没有特别的往计算机网络的深度去挖，但常见的请求与相应的相关知识点还是需要清楚的。这里只会记录一些不是经常使用但是却需要了解的部分，并不是一个完整的知识列表，在阅读文章之前请知晓。\n\n#### 1. TCP/IP 协议族：\n\n如果基于常用的四层网络体系，TCP 协议位于传输层，IP 协议位于网络层。传输层还包含常用的 UDP 协议。\n\n#### 2. 三次握手：\n\n在建立基于 TCP 协议的连接时，客户端与服务器端会采用三次握手机制。首先客户端发送一个含有 SYN 标识的数据包，服务器返回一个含有 SYN/ACK 标识的数据包，最后客户端再返回一个 ACK 标识的确认数据包。如果在握手中的某一个阶段莫名中断，TCP 协议会再次以相同的顺序发送相同的数据包。\n\n#### 3. ARP 协议与 DNS 协议：\n\nDNS 协议用于将域名解析为 IP 地址。ARP 协议用于通过 IP 地址找到对应设备的 MAC 地址。ARP 广播机制：如果在当前的 ARP 本地缓存中没有找到对应 IP 的 MAC 地址，那么 ARP 协议会在当前域内发送一个广播请求，所有的客户机都会收到该广播请求，只有客户机发现该广播对应要询问的 IP 与自己相同时，该客户机会把自己的 MAC 地址作为响应返回。\n\n#### 4. URL 与 URI：\n\nURI 是统一资源定位符的简写，主要用对应的定位符来定位某一种资源。URL 是 URI 的一个子集，主要用来表示资源在互联网中的地点。URI 格式：**http://user:pass@www.example.com:80/dir/index.html?uid=1#ch1**。这里扩展一下“HTTP基本认证（Basic Authentication）”。上述的 URI 完整格式中“user:pass@”部分即对应一个基本认证的登录部分。基本认证主要需要服务器返回一个 “**WWW-Authenticate Basic realm=\"My Realm\"**” 头部，在该头部指定了服务器需要的认证方式和显示给用户的备注信息。服务器端可以通过 `$_SERVER[\"PHP_AUTH_USER\"]` 和 `$_SERVER[\"PHP_AUTH_PW\"]`来获得用户输入的验证信息。\n\n\n```php\nif (!validate($_SERVER[\"PHP_AUTH_USER\"], $_SERVER[\"PHP_AUTH_PW\"])) {\n    http_response_code(401);    // 401 未授权: (Unauthorized)；\n    header(\"WWW-Authenticate:Basic realm='Please input you username and password!'\");\n    echo \"Please input you username and password!\";\n    exit;\n}\n```\n\n#### 5. HTTP 无状态. 无连接：\n\nHTTP 协议不会保留之前的请求或者响应，意味着每当有新的请求产生，就会有新的响应，这样做的好处是：可以做到快速的响应；缺点是：每次的请求可能包含大量的重复信息；HTTP 协议的无连接是指在每一次发送请求之前都需要重新进行三次握手连接，每次请求结束后连接都会被释放。直到 HTTP 1.1 中，引入了 “***Connection: Keep-Alive***” 这个头部的字段，使得 HTTP 请求的连接得以保持，具体保持连接的时间可以在服务器端进行控制。\n\n#### 6. 常用的 HTTP 方法：\n\n* ***GET：***获取资源；传输非机密信息，大小在 1024 比特以内；\n* ***POST：***获得传输实体主体；一般用于提交表单，登录或者注册等，理论上没有传输大小限制；\n* ***PUT：***传输文件；一般需要配合服务器的验证机制，协议本身不提供验证方法；\n* ***HEAD：***获得报文首部；同 GET 方法，但是不返回报文主体，只返回响应头部，用于验证 URL 有效性等；\n* ***DELETE：***删除文件；同 PUT 方法；\n* ***OPTIONS：***询问支持的方法；一般用于 CORS 复杂验证的预检请求，比如在 CORS 中使用了 PUT 或者 DELETE 方法（同时在头部携带了一个 Origin 字段）；\n* ***CONNECT：***使用隧道协议连接代理；主要用于请求使用 SSL/TSL 进行连接加密的情况；不常用；\n* ***TRACE：***追踪路径；不常用；\n\n#### 7. 四次握手：\n\n由于 TCP 协议是全双工的，所以在关闭连接时，要从客户端和服务端两个方向分别关闭。客户端先发送一个带有 FIN 标识的请求，服务器端返回一个 ACK 请求，完成一次关闭。服务器端同上。\n\n#### 8. HTTP 管线化技术：\n\n该技术可以同时把多个 HTTP 请求放到一个 TCP/Socket 连接中，批量发送连接，仅支持 HTTP 1.1。本质是把多个 HTTP 消息放到同一个 TCP 分组中进行传输，在低延迟的连接里效果尤为突出。\n\n#### 9. 报文结构：\n\n请求/响应报文首部和主体之间通过空行（CR+LF 0X0d, 0X0a）进行分割，报文首部中包含各种传输头部信息。\n\n#### 10. 报文实体压缩：\n\n在传输二进制数据时，常常需要在服务器端将报文的实体数据进行压缩，常用的压缩技术有：\n\n* ***gzip：***GUN zip；\n* ***compress：***Unix 系统标准压缩方式；\n* ***deflate：***zlib 是一种 deflate 实现，deflate 本身是使用 LZ77 和哈弗曼进行编码的；\n* ***identify：***不压缩；\n\n#### 11. 分块传输编码：\n\n服务器在响应请求并返回数据时可以实体主体分割成多个块（chunk），分块传输。每一个分块都会用一个十六进制的数来标记自己的大小，而分块的最后一个将会使用 “CR+LF” 来标记自己。该技术可以让客户端分段显示页面。\n\n#### 12. 多部分对象集合：\n\n* ***multipart/form-data：***在提交表单时如果含有图像或文件时使用；\n* ***multipart/byteranges：***响应报文包含了多个范围的内容，状态码206。很少使用；\n\n对应于每一个类型的对象实体，HTTP 协议都会采用一个 “boundary” 作为分隔符来进行区分。\n\n#### 13. 不常见状态码：\n\n* **204：**服务器成功处理请求，但是不返回任何实体部分的数据；No-Content；\n* **206：**服务器成功处理请求，返回由响应头中 Content-Range 指定范围内的实体数据；Partial-Content；\n* **303：**表示资源的地址被暂时更新，同时应该使用 GET 方法来访问新的资源地址；（301. 302. 303 对于 POST 请求都会自动转换成 GET 请求，因此会导致 POST 参数丢失）\n\n#### 14. 代理技术：\n\n代理服务器的基本行为就是转发接收到的客户端请求，代理并不对 URL 做任何的处理。无论是请求还是响应，每次经过一个代理服务器的转发都会向其头部追加一个 “Via” 字段，指明当前通过的代理主机信息。设置代理服务器主要用于以下几个方面。\n\n* **代理缓存：**代理服务器可以作为缓存服务器，在合适的条件下不直接访问目的服务器，而是将代理上的缓存返回给浏览器；\n* **访问控制：**可以对内部网络的访问进行过滤；\n* **日志服务器：**内部网络可以以一个单一的代理作为内部日志服务器，标记所有请求的 URL 信息。\n\n#### 15. End to end / Hop by hop：\n\n端到端首部（End to end）此类首部不会在通过缓存代理时丢失，规定在缓存代理服务器转发时也要携带对应的首部直到发送到终点；逐跳首部（Hop by hop）该类别的首部只对单次转发有效，若通过缓存或者代理则不再向后转发，主要包括：Connection、Keep-Alive、Proxy 相关、Trailer、Upgrade、Transfer-Encoding 等首部。\n\n\n","source":"_posts/HTTP-基础整理.md","raw":"---\ntitle: HTTP 基础整理\nintro: 最近花了点时间稍微整理了一下常见的 HTTP 相关的知识点，没有特别的往计算机网络的深度去挖，但常见的请求与相应的相关知识点还是需要清楚的。这里只会记录一些不是经常使用但是却需要了解的部分，并不是一个完整的知识列表，在阅读文章之前请知晓。\ncomments: true\ndate: 2017-03-09 13:15:24\ntags:\n- HTTP\n---\n\n\n最近花了点时间稍微整理了一下常见的 HTTP 相关的知识点，没有特别的往计算机网络的深度去挖，但常见的请求与相应的相关知识点还是需要清楚的。这里只会记录一些不是经常使用但是却需要了解的部分，并不是一个完整的知识列表，在阅读文章之前请知晓。\n\n#### 1. TCP/IP 协议族：\n\n如果基于常用的四层网络体系，TCP 协议位于传输层，IP 协议位于网络层。传输层还包含常用的 UDP 协议。\n\n#### 2. 三次握手：\n\n在建立基于 TCP 协议的连接时，客户端与服务器端会采用三次握手机制。首先客户端发送一个含有 SYN 标识的数据包，服务器返回一个含有 SYN/ACK 标识的数据包，最后客户端再返回一个 ACK 标识的确认数据包。如果在握手中的某一个阶段莫名中断，TCP 协议会再次以相同的顺序发送相同的数据包。\n\n#### 3. ARP 协议与 DNS 协议：\n\nDNS 协议用于将域名解析为 IP 地址。ARP 协议用于通过 IP 地址找到对应设备的 MAC 地址。ARP 广播机制：如果在当前的 ARP 本地缓存中没有找到对应 IP 的 MAC 地址，那么 ARP 协议会在当前域内发送一个广播请求，所有的客户机都会收到该广播请求，只有客户机发现该广播对应要询问的 IP 与自己相同时，该客户机会把自己的 MAC 地址作为响应返回。\n\n#### 4. URL 与 URI：\n\nURI 是统一资源定位符的简写，主要用对应的定位符来定位某一种资源。URL 是 URI 的一个子集，主要用来表示资源在互联网中的地点。URI 格式：**http://user:pass@www.example.com:80/dir/index.html?uid=1#ch1**。这里扩展一下“HTTP基本认证（Basic Authentication）”。上述的 URI 完整格式中“user:pass@”部分即对应一个基本认证的登录部分。基本认证主要需要服务器返回一个 “**WWW-Authenticate Basic realm=\"My Realm\"**” 头部，在该头部指定了服务器需要的认证方式和显示给用户的备注信息。服务器端可以通过 `$_SERVER[\"PHP_AUTH_USER\"]` 和 `$_SERVER[\"PHP_AUTH_PW\"]`来获得用户输入的验证信息。\n\n\n```php\nif (!validate($_SERVER[\"PHP_AUTH_USER\"], $_SERVER[\"PHP_AUTH_PW\"])) {\n    http_response_code(401);    // 401 未授权: (Unauthorized)；\n    header(\"WWW-Authenticate:Basic realm='Please input you username and password!'\");\n    echo \"Please input you username and password!\";\n    exit;\n}\n```\n\n#### 5. HTTP 无状态. 无连接：\n\nHTTP 协议不会保留之前的请求或者响应，意味着每当有新的请求产生，就会有新的响应，这样做的好处是：可以做到快速的响应；缺点是：每次的请求可能包含大量的重复信息；HTTP 协议的无连接是指在每一次发送请求之前都需要重新进行三次握手连接，每次请求结束后连接都会被释放。直到 HTTP 1.1 中，引入了 “***Connection: Keep-Alive***” 这个头部的字段，使得 HTTP 请求的连接得以保持，具体保持连接的时间可以在服务器端进行控制。\n\n#### 6. 常用的 HTTP 方法：\n\n* ***GET：***获取资源；传输非机密信息，大小在 1024 比特以内；\n* ***POST：***获得传输实体主体；一般用于提交表单，登录或者注册等，理论上没有传输大小限制；\n* ***PUT：***传输文件；一般需要配合服务器的验证机制，协议本身不提供验证方法；\n* ***HEAD：***获得报文首部；同 GET 方法，但是不返回报文主体，只返回响应头部，用于验证 URL 有效性等；\n* ***DELETE：***删除文件；同 PUT 方法；\n* ***OPTIONS：***询问支持的方法；一般用于 CORS 复杂验证的预检请求，比如在 CORS 中使用了 PUT 或者 DELETE 方法（同时在头部携带了一个 Origin 字段）；\n* ***CONNECT：***使用隧道协议连接代理；主要用于请求使用 SSL/TSL 进行连接加密的情况；不常用；\n* ***TRACE：***追踪路径；不常用；\n\n#### 7. 四次握手：\n\n由于 TCP 协议是全双工的，所以在关闭连接时，要从客户端和服务端两个方向分别关闭。客户端先发送一个带有 FIN 标识的请求，服务器端返回一个 ACK 请求，完成一次关闭。服务器端同上。\n\n#### 8. HTTP 管线化技术：\n\n该技术可以同时把多个 HTTP 请求放到一个 TCP/Socket 连接中，批量发送连接，仅支持 HTTP 1.1。本质是把多个 HTTP 消息放到同一个 TCP 分组中进行传输，在低延迟的连接里效果尤为突出。\n\n#### 9. 报文结构：\n\n请求/响应报文首部和主体之间通过空行（CR+LF 0X0d, 0X0a）进行分割，报文首部中包含各种传输头部信息。\n\n#### 10. 报文实体压缩：\n\n在传输二进制数据时，常常需要在服务器端将报文的实体数据进行压缩，常用的压缩技术有：\n\n* ***gzip：***GUN zip；\n* ***compress：***Unix 系统标准压缩方式；\n* ***deflate：***zlib 是一种 deflate 实现，deflate 本身是使用 LZ77 和哈弗曼进行编码的；\n* ***identify：***不压缩；\n\n#### 11. 分块传输编码：\n\n服务器在响应请求并返回数据时可以实体主体分割成多个块（chunk），分块传输。每一个分块都会用一个十六进制的数来标记自己的大小，而分块的最后一个将会使用 “CR+LF” 来标记自己。该技术可以让客户端分段显示页面。\n\n#### 12. 多部分对象集合：\n\n* ***multipart/form-data：***在提交表单时如果含有图像或文件时使用；\n* ***multipart/byteranges：***响应报文包含了多个范围的内容，状态码206。很少使用；\n\n对应于每一个类型的对象实体，HTTP 协议都会采用一个 “boundary” 作为分隔符来进行区分。\n\n#### 13. 不常见状态码：\n\n* **204：**服务器成功处理请求，但是不返回任何实体部分的数据；No-Content；\n* **206：**服务器成功处理请求，返回由响应头中 Content-Range 指定范围内的实体数据；Partial-Content；\n* **303：**表示资源的地址被暂时更新，同时应该使用 GET 方法来访问新的资源地址；（301. 302. 303 对于 POST 请求都会自动转换成 GET 请求，因此会导致 POST 参数丢失）\n\n#### 14. 代理技术：\n\n代理服务器的基本行为就是转发接收到的客户端请求，代理并不对 URL 做任何的处理。无论是请求还是响应，每次经过一个代理服务器的转发都会向其头部追加一个 “Via” 字段，指明当前通过的代理主机信息。设置代理服务器主要用于以下几个方面。\n\n* **代理缓存：**代理服务器可以作为缓存服务器，在合适的条件下不直接访问目的服务器，而是将代理上的缓存返回给浏览器；\n* **访问控制：**可以对内部网络的访问进行过滤；\n* **日志服务器：**内部网络可以以一个单一的代理作为内部日志服务器，标记所有请求的 URL 信息。\n\n#### 15. End to end / Hop by hop：\n\n端到端首部（End to end）此类首部不会在通过缓存代理时丢失，规定在缓存代理服务器转发时也要携带对应的首部直到发送到终点；逐跳首部（Hop by hop）该类别的首部只对单次转发有效，若通过缓存或者代理则不再向后转发，主要包括：Connection、Keep-Alive、Proxy 相关、Trailer、Upgrade、Transfer-Encoding 等首部。\n\n\n","slug":"HTTP-基础整理","published":1,"updated":"2019-02-12T05:58:55.744Z","layout":"post","photos":[],"link":"","_id":"cjsqwht7q0017knp2fwfpm201","content":"<p>最近花了点时间稍微整理了一下常见的 HTTP 相关的知识点，没有特别的往计算机网络的深度去挖，但常见的请求与相应的相关知识点还是需要清楚的。这里只会记录一些不是经常使用但是却需要了解的部分，并不是一个完整的知识列表，在阅读文章之前请知晓。</p>\n<h4 id=\"1-TCP-IP-协议族：\"><a href=\"#1-TCP-IP-协议族：\" class=\"headerlink\" title=\"1. TCP/IP 协议族：\"></a>1. TCP/IP 协议族：</h4><p>如果基于常用的四层网络体系，TCP 协议位于传输层，IP 协议位于网络层。传输层还包含常用的 UDP 协议。</p>\n<h4 id=\"2-三次握手：\"><a href=\"#2-三次握手：\" class=\"headerlink\" title=\"2. 三次握手：\"></a>2. 三次握手：</h4><p>在建立基于 TCP 协议的连接时，客户端与服务器端会采用三次握手机制。首先客户端发送一个含有 SYN 标识的数据包，服务器返回一个含有 SYN/ACK 标识的数据包，最后客户端再返回一个 ACK 标识的确认数据包。如果在握手中的某一个阶段莫名中断，TCP 协议会再次以相同的顺序发送相同的数据包。</p>\n<h4 id=\"3-ARP-协议与-DNS-协议：\"><a href=\"#3-ARP-协议与-DNS-协议：\" class=\"headerlink\" title=\"3. ARP 协议与 DNS 协议：\"></a>3. ARP 协议与 DNS 协议：</h4><p>DNS 协议用于将域名解析为 IP 地址。ARP 协议用于通过 IP 地址找到对应设备的 MAC 地址。ARP 广播机制：如果在当前的 ARP 本地缓存中没有找到对应 IP 的 MAC 地址，那么 ARP 协议会在当前域内发送一个广播请求，所有的客户机都会收到该广播请求，只有客户机发现该广播对应要询问的 IP 与自己相同时，该客户机会把自己的 MAC 地址作为响应返回。</p>\n<h4 id=\"4-URL-与-URI：\"><a href=\"#4-URL-与-URI：\" class=\"headerlink\" title=\"4. URL 与 URI：\"></a>4. URL 与 URI：</h4><p>URI 是统一资源定位符的简写，主要用对应的定位符来定位某一种资源。URL 是 URI 的一个子集，主要用来表示资源在互联网中的地点。URI 格式：<strong><a href=\"http://user:pass@www.example.com:80/dir/index.html?uid=1#ch1\" target=\"_blank\" rel=\"noopener\">http://user:pass@www.example.com:80/dir/index.html?uid=1#ch1</a></strong>。这里扩展一下“HTTP基本认证（Basic Authentication）”。上述的 URI 完整格式中“user:pass@”部分即对应一个基本认证的登录部分。基本认证主要需要服务器返回一个 “<strong>WWW-Authenticate Basic realm=”My Realm”</strong>” 头部，在该头部指定了服务器需要的认证方式和显示给用户的备注信息。服务器端可以通过 <code>$_SERVER[&quot;PHP_AUTH_USER&quot;]</code> 和 <code>$_SERVER[&quot;PHP_AUTH_PW&quot;]</code>来获得用户输入的验证信息。</p>\n<pre class=\"line-numbers language-php\"><code class=\"language-php\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">validate</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$_SERVER</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"PHP_AUTH_USER\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token variable\">$_SERVER</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"PHP_AUTH_PW\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">http_response_code</span><span class=\"token punctuation\">(</span><span class=\"token number\">401</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">// 401 未授权: (Unauthorized)；</span>\n    <span class=\"token function\">header</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"WWW-Authenticate:Basic realm='Please input you username and password!'\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">echo</span> <span class=\"token string\">\"Please input you username and password!\"</span><span class=\"token punctuation\">;</span>\n    exit<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"5-HTTP-无状态-无连接：\"><a href=\"#5-HTTP-无状态-无连接：\" class=\"headerlink\" title=\"5. HTTP 无状态. 无连接：\"></a>5. HTTP 无状态. 无连接：</h4><p>HTTP 协议不会保留之前的请求或者响应，意味着每当有新的请求产生，就会有新的响应，这样做的好处是：可以做到快速的响应；缺点是：每次的请求可能包含大量的重复信息；HTTP 协议的无连接是指在每一次发送请求之前都需要重新进行三次握手连接，每次请求结束后连接都会被释放。直到 HTTP 1.1 中，引入了 “<strong><em>Connection: Keep-Alive</em></strong>” 这个头部的字段，使得 HTTP 请求的连接得以保持，具体保持连接的时间可以在服务器端进行控制。</p>\n<h4 id=\"6-常用的-HTTP-方法：\"><a href=\"#6-常用的-HTTP-方法：\" class=\"headerlink\" title=\"6. 常用的 HTTP 方法：\"></a>6. 常用的 HTTP 方法：</h4><ul>\n<li><strong><em>GET：</em></strong>获取资源；传输非机密信息，大小在 1024 比特以内；</li>\n<li><strong><em>POST：</em></strong>获得传输实体主体；一般用于提交表单，登录或者注册等，理论上没有传输大小限制；</li>\n<li><strong><em>PUT：</em></strong>传输文件；一般需要配合服务器的验证机制，协议本身不提供验证方法；</li>\n<li><strong><em>HEAD：</em></strong>获得报文首部；同 GET 方法，但是不返回报文主体，只返回响应头部，用于验证 URL 有效性等；</li>\n<li><strong><em>DELETE：</em></strong>删除文件；同 PUT 方法；</li>\n<li><strong><em>OPTIONS：</em></strong>询问支持的方法；一般用于 CORS 复杂验证的预检请求，比如在 CORS 中使用了 PUT 或者 DELETE 方法（同时在头部携带了一个 Origin 字段）；</li>\n<li><strong><em>CONNECT：</em></strong>使用隧道协议连接代理；主要用于请求使用 SSL/TSL 进行连接加密的情况；不常用；</li>\n<li><strong><em>TRACE：</em></strong>追踪路径；不常用；</li>\n</ul>\n<h4 id=\"7-四次握手：\"><a href=\"#7-四次握手：\" class=\"headerlink\" title=\"7. 四次握手：\"></a>7. 四次握手：</h4><p>由于 TCP 协议是全双工的，所以在关闭连接时，要从客户端和服务端两个方向分别关闭。客户端先发送一个带有 FIN 标识的请求，服务器端返回一个 ACK 请求，完成一次关闭。服务器端同上。</p>\n<h4 id=\"8-HTTP-管线化技术：\"><a href=\"#8-HTTP-管线化技术：\" class=\"headerlink\" title=\"8. HTTP 管线化技术：\"></a>8. HTTP 管线化技术：</h4><p>该技术可以同时把多个 HTTP 请求放到一个 TCP/Socket 连接中，批量发送连接，仅支持 HTTP 1.1。本质是把多个 HTTP 消息放到同一个 TCP 分组中进行传输，在低延迟的连接里效果尤为突出。</p>\n<h4 id=\"9-报文结构：\"><a href=\"#9-报文结构：\" class=\"headerlink\" title=\"9. 报文结构：\"></a>9. 报文结构：</h4><p>请求/响应报文首部和主体之间通过空行（CR+LF 0X0d, 0X0a）进行分割，报文首部中包含各种传输头部信息。</p>\n<h4 id=\"10-报文实体压缩：\"><a href=\"#10-报文实体压缩：\" class=\"headerlink\" title=\"10. 报文实体压缩：\"></a>10. 报文实体压缩：</h4><p>在传输二进制数据时，常常需要在服务器端将报文的实体数据进行压缩，常用的压缩技术有：</p>\n<ul>\n<li><strong><em>gzip：</em></strong>GUN zip；</li>\n<li><strong><em>compress：</em></strong>Unix 系统标准压缩方式；</li>\n<li><strong><em>deflate：</em></strong>zlib 是一种 deflate 实现，deflate 本身是使用 LZ77 和哈弗曼进行编码的；</li>\n<li><strong><em>identify：</em></strong>不压缩；</li>\n</ul>\n<h4 id=\"11-分块传输编码：\"><a href=\"#11-分块传输编码：\" class=\"headerlink\" title=\"11. 分块传输编码：\"></a>11. 分块传输编码：</h4><p>服务器在响应请求并返回数据时可以实体主体分割成多个块（chunk），分块传输。每一个分块都会用一个十六进制的数来标记自己的大小，而分块的最后一个将会使用 “CR+LF” 来标记自己。该技术可以让客户端分段显示页面。</p>\n<h4 id=\"12-多部分对象集合：\"><a href=\"#12-多部分对象集合：\" class=\"headerlink\" title=\"12. 多部分对象集合：\"></a>12. 多部分对象集合：</h4><ul>\n<li><strong><em>multipart/form-data：</em></strong>在提交表单时如果含有图像或文件时使用；</li>\n<li><strong><em>multipart/byteranges：</em></strong>响应报文包含了多个范围的内容，状态码206。很少使用；</li>\n</ul>\n<p>对应于每一个类型的对象实体，HTTP 协议都会采用一个 “boundary” 作为分隔符来进行区分。</p>\n<h4 id=\"13-不常见状态码：\"><a href=\"#13-不常见状态码：\" class=\"headerlink\" title=\"13. 不常见状态码：\"></a>13. 不常见状态码：</h4><ul>\n<li><strong>204：</strong>服务器成功处理请求，但是不返回任何实体部分的数据；No-Content；</li>\n<li><strong>206：</strong>服务器成功处理请求，返回由响应头中 Content-Range 指定范围内的实体数据；Partial-Content；</li>\n<li><strong>303：</strong>表示资源的地址被暂时更新，同时应该使用 GET 方法来访问新的资源地址；（301. 302. 303 对于 POST 请求都会自动转换成 GET 请求，因此会导致 POST 参数丢失）</li>\n</ul>\n<h4 id=\"14-代理技术：\"><a href=\"#14-代理技术：\" class=\"headerlink\" title=\"14. 代理技术：\"></a>14. 代理技术：</h4><p>代理服务器的基本行为就是转发接收到的客户端请求，代理并不对 URL 做任何的处理。无论是请求还是响应，每次经过一个代理服务器的转发都会向其头部追加一个 “Via” 字段，指明当前通过的代理主机信息。设置代理服务器主要用于以下几个方面。</p>\n<ul>\n<li><strong>代理缓存：</strong>代理服务器可以作为缓存服务器，在合适的条件下不直接访问目的服务器，而是将代理上的缓存返回给浏览器；</li>\n<li><strong>访问控制：</strong>可以对内部网络的访问进行过滤；</li>\n<li><strong>日志服务器：</strong>内部网络可以以一个单一的代理作为内部日志服务器，标记所有请求的 URL 信息。</li>\n</ul>\n<h4 id=\"15-End-to-end-Hop-by-hop：\"><a href=\"#15-End-to-end-Hop-by-hop：\" class=\"headerlink\" title=\"15. End to end / Hop by hop：\"></a>15. End to end / Hop by hop：</h4><p>端到端首部（End to end）此类首部不会在通过缓存代理时丢失，规定在缓存代理服务器转发时也要携带对应的首部直到发送到终点；逐跳首部（Hop by hop）该类别的首部只对单次转发有效，若通过缓存或者代理则不再向后转发，主要包括：Connection、Keep-Alive、Proxy 相关、Trailer、Upgrade、Transfer-Encoding 等首部。</p>\n","site":{"data":{}},"id":"72586516f94aa7c079ed965509b24873","excerpt":"","more":"<p>最近花了点时间稍微整理了一下常见的 HTTP 相关的知识点，没有特别的往计算机网络的深度去挖，但常见的请求与相应的相关知识点还是需要清楚的。这里只会记录一些不是经常使用但是却需要了解的部分，并不是一个完整的知识列表，在阅读文章之前请知晓。</p>\n<h4 id=\"1-TCP-IP-协议族：\"><a href=\"#1-TCP-IP-协议族：\" class=\"headerlink\" title=\"1. TCP/IP 协议族：\"></a>1. TCP/IP 协议族：</h4><p>如果基于常用的四层网络体系，TCP 协议位于传输层，IP 协议位于网络层。传输层还包含常用的 UDP 协议。</p>\n<h4 id=\"2-三次握手：\"><a href=\"#2-三次握手：\" class=\"headerlink\" title=\"2. 三次握手：\"></a>2. 三次握手：</h4><p>在建立基于 TCP 协议的连接时，客户端与服务器端会采用三次握手机制。首先客户端发送一个含有 SYN 标识的数据包，服务器返回一个含有 SYN/ACK 标识的数据包，最后客户端再返回一个 ACK 标识的确认数据包。如果在握手中的某一个阶段莫名中断，TCP 协议会再次以相同的顺序发送相同的数据包。</p>\n<h4 id=\"3-ARP-协议与-DNS-协议：\"><a href=\"#3-ARP-协议与-DNS-协议：\" class=\"headerlink\" title=\"3. ARP 协议与 DNS 协议：\"></a>3. ARP 协议与 DNS 协议：</h4><p>DNS 协议用于将域名解析为 IP 地址。ARP 协议用于通过 IP 地址找到对应设备的 MAC 地址。ARP 广播机制：如果在当前的 ARP 本地缓存中没有找到对应 IP 的 MAC 地址，那么 ARP 协议会在当前域内发送一个广播请求，所有的客户机都会收到该广播请求，只有客户机发现该广播对应要询问的 IP 与自己相同时，该客户机会把自己的 MAC 地址作为响应返回。</p>\n<h4 id=\"4-URL-与-URI：\"><a href=\"#4-URL-与-URI：\" class=\"headerlink\" title=\"4. URL 与 URI：\"></a>4. URL 与 URI：</h4><p>URI 是统一资源定位符的简写，主要用对应的定位符来定位某一种资源。URL 是 URI 的一个子集，主要用来表示资源在互联网中的地点。URI 格式：<strong><a href=\"http://user:pass@www.example.com:80/dir/index.html?uid=1#ch1\" target=\"_blank\" rel=\"noopener\">http://user:pass@www.example.com:80/dir/index.html?uid=1#ch1</a></strong>。这里扩展一下“HTTP基本认证（Basic Authentication）”。上述的 URI 完整格式中“user:pass@”部分即对应一个基本认证的登录部分。基本认证主要需要服务器返回一个 “<strong>WWW-Authenticate Basic realm=”My Realm”</strong>” 头部，在该头部指定了服务器需要的认证方式和显示给用户的备注信息。服务器端可以通过 <code>$_SERVER[&quot;PHP_AUTH_USER&quot;]</code> 和 <code>$_SERVER[&quot;PHP_AUTH_PW&quot;]</code>来获得用户输入的验证信息。</p>\n<pre><code class=\"php\">if (!validate($_SERVER[&quot;PHP_AUTH_USER&quot;], $_SERVER[&quot;PHP_AUTH_PW&quot;])) {\n    http_response_code(401);    // 401 未授权: (Unauthorized)；\n    header(&quot;WWW-Authenticate:Basic realm=&#39;Please input you username and password!&#39;&quot;);\n    echo &quot;Please input you username and password!&quot;;\n    exit;\n}\n</code></pre>\n<h4 id=\"5-HTTP-无状态-无连接：\"><a href=\"#5-HTTP-无状态-无连接：\" class=\"headerlink\" title=\"5. HTTP 无状态. 无连接：\"></a>5. HTTP 无状态. 无连接：</h4><p>HTTP 协议不会保留之前的请求或者响应，意味着每当有新的请求产生，就会有新的响应，这样做的好处是：可以做到快速的响应；缺点是：每次的请求可能包含大量的重复信息；HTTP 协议的无连接是指在每一次发送请求之前都需要重新进行三次握手连接，每次请求结束后连接都会被释放。直到 HTTP 1.1 中，引入了 “<strong><em>Connection: Keep-Alive</em></strong>” 这个头部的字段，使得 HTTP 请求的连接得以保持，具体保持连接的时间可以在服务器端进行控制。</p>\n<h4 id=\"6-常用的-HTTP-方法：\"><a href=\"#6-常用的-HTTP-方法：\" class=\"headerlink\" title=\"6. 常用的 HTTP 方法：\"></a>6. 常用的 HTTP 方法：</h4><ul>\n<li><strong><em>GET：</em></strong>获取资源；传输非机密信息，大小在 1024 比特以内；</li>\n<li><strong><em>POST：</em></strong>获得传输实体主体；一般用于提交表单，登录或者注册等，理论上没有传输大小限制；</li>\n<li><strong><em>PUT：</em></strong>传输文件；一般需要配合服务器的验证机制，协议本身不提供验证方法；</li>\n<li><strong><em>HEAD：</em></strong>获得报文首部；同 GET 方法，但是不返回报文主体，只返回响应头部，用于验证 URL 有效性等；</li>\n<li><strong><em>DELETE：</em></strong>删除文件；同 PUT 方法；</li>\n<li><strong><em>OPTIONS：</em></strong>询问支持的方法；一般用于 CORS 复杂验证的预检请求，比如在 CORS 中使用了 PUT 或者 DELETE 方法（同时在头部携带了一个 Origin 字段）；</li>\n<li><strong><em>CONNECT：</em></strong>使用隧道协议连接代理；主要用于请求使用 SSL/TSL 进行连接加密的情况；不常用；</li>\n<li><strong><em>TRACE：</em></strong>追踪路径；不常用；</li>\n</ul>\n<h4 id=\"7-四次握手：\"><a href=\"#7-四次握手：\" class=\"headerlink\" title=\"7. 四次握手：\"></a>7. 四次握手：</h4><p>由于 TCP 协议是全双工的，所以在关闭连接时，要从客户端和服务端两个方向分别关闭。客户端先发送一个带有 FIN 标识的请求，服务器端返回一个 ACK 请求，完成一次关闭。服务器端同上。</p>\n<h4 id=\"8-HTTP-管线化技术：\"><a href=\"#8-HTTP-管线化技术：\" class=\"headerlink\" title=\"8. HTTP 管线化技术：\"></a>8. HTTP 管线化技术：</h4><p>该技术可以同时把多个 HTTP 请求放到一个 TCP/Socket 连接中，批量发送连接，仅支持 HTTP 1.1。本质是把多个 HTTP 消息放到同一个 TCP 分组中进行传输，在低延迟的连接里效果尤为突出。</p>\n<h4 id=\"9-报文结构：\"><a href=\"#9-报文结构：\" class=\"headerlink\" title=\"9. 报文结构：\"></a>9. 报文结构：</h4><p>请求/响应报文首部和主体之间通过空行（CR+LF 0X0d, 0X0a）进行分割，报文首部中包含各种传输头部信息。</p>\n<h4 id=\"10-报文实体压缩：\"><a href=\"#10-报文实体压缩：\" class=\"headerlink\" title=\"10. 报文实体压缩：\"></a>10. 报文实体压缩：</h4><p>在传输二进制数据时，常常需要在服务器端将报文的实体数据进行压缩，常用的压缩技术有：</p>\n<ul>\n<li><strong><em>gzip：</em></strong>GUN zip；</li>\n<li><strong><em>compress：</em></strong>Unix 系统标准压缩方式；</li>\n<li><strong><em>deflate：</em></strong>zlib 是一种 deflate 实现，deflate 本身是使用 LZ77 和哈弗曼进行编码的；</li>\n<li><strong><em>identify：</em></strong>不压缩；</li>\n</ul>\n<h4 id=\"11-分块传输编码：\"><a href=\"#11-分块传输编码：\" class=\"headerlink\" title=\"11. 分块传输编码：\"></a>11. 分块传输编码：</h4><p>服务器在响应请求并返回数据时可以实体主体分割成多个块（chunk），分块传输。每一个分块都会用一个十六进制的数来标记自己的大小，而分块的最后一个将会使用 “CR+LF” 来标记自己。该技术可以让客户端分段显示页面。</p>\n<h4 id=\"12-多部分对象集合：\"><a href=\"#12-多部分对象集合：\" class=\"headerlink\" title=\"12. 多部分对象集合：\"></a>12. 多部分对象集合：</h4><ul>\n<li><strong><em>multipart/form-data：</em></strong>在提交表单时如果含有图像或文件时使用；</li>\n<li><strong><em>multipart/byteranges：</em></strong>响应报文包含了多个范围的内容，状态码206。很少使用；</li>\n</ul>\n<p>对应于每一个类型的对象实体，HTTP 协议都会采用一个 “boundary” 作为分隔符来进行区分。</p>\n<h4 id=\"13-不常见状态码：\"><a href=\"#13-不常见状态码：\" class=\"headerlink\" title=\"13. 不常见状态码：\"></a>13. 不常见状态码：</h4><ul>\n<li><strong>204：</strong>服务器成功处理请求，但是不返回任何实体部分的数据；No-Content；</li>\n<li><strong>206：</strong>服务器成功处理请求，返回由响应头中 Content-Range 指定范围内的实体数据；Partial-Content；</li>\n<li><strong>303：</strong>表示资源的地址被暂时更新，同时应该使用 GET 方法来访问新的资源地址；（301. 302. 303 对于 POST 请求都会自动转换成 GET 请求，因此会导致 POST 参数丢失）</li>\n</ul>\n<h4 id=\"14-代理技术：\"><a href=\"#14-代理技术：\" class=\"headerlink\" title=\"14. 代理技术：\"></a>14. 代理技术：</h4><p>代理服务器的基本行为就是转发接收到的客户端请求，代理并不对 URL 做任何的处理。无论是请求还是响应，每次经过一个代理服务器的转发都会向其头部追加一个 “Via” 字段，指明当前通过的代理主机信息。设置代理服务器主要用于以下几个方面。</p>\n<ul>\n<li><strong>代理缓存：</strong>代理服务器可以作为缓存服务器，在合适的条件下不直接访问目的服务器，而是将代理上的缓存返回给浏览器；</li>\n<li><strong>访问控制：</strong>可以对内部网络的访问进行过滤；</li>\n<li><strong>日志服务器：</strong>内部网络可以以一个单一的代理作为内部日志服务器，标记所有请求的 URL 信息。</li>\n</ul>\n<h4 id=\"15-End-to-end-Hop-by-hop：\"><a href=\"#15-End-to-end-Hop-by-hop：\" class=\"headerlink\" title=\"15. End to end / Hop by hop：\"></a>15. End to end / Hop by hop：</h4><p>端到端首部（End to end）此类首部不会在通过缓存代理时丢失，规定在缓存代理服务器转发时也要携带对应的首部直到发送到终点；逐跳首部（Hop by hop）该类别的首部只对单次转发有效，若通过缓存或者代理则不再向后转发，主要包括：Connection、Keep-Alive、Proxy 相关、Trailer、Upgrade、Transfer-Encoding 等首部。</p>\n"},{"title":"IT 行业的入门与精通","intro":"在互联网行业总有这样一句话广为流传，即“什么技能都会但只是入门，不如只会一门技术但是却很精通”。我从来不会反对这句话所传达的意义，如果是为了找到一份更好的工作，那么这句话提供的参考价值确实十分高。但是抛开找工作层面，这句话真的正确吗？我看不见得。","comments":1,"date":"2015-01-01T16:51:39.000Z","_content":"\n在互联网行业总有这样一句话广为流传，即“什么技能都会但只是入门，不如只会一门技术但是却很精通”。我从来不会反对这句话所传达的意义，如果是为了找到一份更好的工作，那么这句话提供的参考价值确实十分高。但是抛开找工作层面，这句话真的正确吗？我看不见得。\n\n现在的IT公司职位分工很明确，确实更加需要专一技术水平很高的人才。相对于什么技能都会但是却并不精通的人，企业更倾向于只钻研一门技术的人，哪怕他在这一门技术上并不十分精通。因为企业相信，只钻研一门技术的人会在这门技术的领域一直走下去，从而会在这一专业职位上做的更好，而不会去像什么技能都会一点的人一样，“漫无目的”的学习。他们认为，这种“漫无目的”式的学习纯属是在浪费时间。\n\n但真的是这样吗？现在的互联网企业融合度非常高，所需要的 IT 技术众多，所以导致企业内部职位的分化十分详细，比如 Web 前端需要 CSS，HTML，JS 等技术，大公司可能会将前端的职位分成前端 CSS + HTML 工程师岗位以及前端 JS 工程师岗位等如此之详细。\n\n作为企业中的一员，这样倒尚可。但倘若把你从企业中独立出来，那会怎样？你只会一门技术，你一个人无法完成一个完整的项目。你的内心有着很多不错的想法，但是因为你只懂得一门技术，虽然钻研的很深，但若没有其他技术的辅助，你便只能够完成整个项目中的一小部分功能。你很失落，但却没有办法。就这样，你被企业束缚住了。\n\nIT 行业的知识很深很广，一个人可能穷其一生也不可全部学精学透。但是 IT 行业却又有着另一种景象，虽然知识众多，但是入门却很简单。一旦有了几种知识的入门，就可以用这些知识来实现小的功能，完成小的项目。那有人要问了“你的意思是更深入的知识就没有用了？”。“NONONO”，更深入的知识是用来进一步优化之前用入门知识构建的项目的。也就是说：入门知识，**用于构建基础项目 **；深入知识，**用于优化基础项目 **。\n\n对企业而言，专精的技能更好。而对一个人需要用于完成自己创意的 MVP 产品来说，众多基础的技能显得更为重要。但如何抉择，还是听你的。\n","source":"_posts/IT-行业的入门与精通.md","raw":"---\ntitle: IT 行业的入门与精通\nintro: 在互联网行业总有这样一句话广为流传，即“什么技能都会但只是入门，不如只会一门技术但是却很精通”。我从来不会反对这句话所传达的意义，如果是为了找到一份更好的工作，那么这句话提供的参考价值确实十分高。但是抛开找工作层面，这句话真的正确吗？我看不见得。\ncomments: true\ndate: 2015-01-02 00:51:39\ntags:\n- 互联网思考\n---\n\n在互联网行业总有这样一句话广为流传，即“什么技能都会但只是入门，不如只会一门技术但是却很精通”。我从来不会反对这句话所传达的意义，如果是为了找到一份更好的工作，那么这句话提供的参考价值确实十分高。但是抛开找工作层面，这句话真的正确吗？我看不见得。\n\n现在的IT公司职位分工很明确，确实更加需要专一技术水平很高的人才。相对于什么技能都会但是却并不精通的人，企业更倾向于只钻研一门技术的人，哪怕他在这一门技术上并不十分精通。因为企业相信，只钻研一门技术的人会在这门技术的领域一直走下去，从而会在这一专业职位上做的更好，而不会去像什么技能都会一点的人一样，“漫无目的”的学习。他们认为，这种“漫无目的”式的学习纯属是在浪费时间。\n\n但真的是这样吗？现在的互联网企业融合度非常高，所需要的 IT 技术众多，所以导致企业内部职位的分化十分详细，比如 Web 前端需要 CSS，HTML，JS 等技术，大公司可能会将前端的职位分成前端 CSS + HTML 工程师岗位以及前端 JS 工程师岗位等如此之详细。\n\n作为企业中的一员，这样倒尚可。但倘若把你从企业中独立出来，那会怎样？你只会一门技术，你一个人无法完成一个完整的项目。你的内心有着很多不错的想法，但是因为你只懂得一门技术，虽然钻研的很深，但若没有其他技术的辅助，你便只能够完成整个项目中的一小部分功能。你很失落，但却没有办法。就这样，你被企业束缚住了。\n\nIT 行业的知识很深很广，一个人可能穷其一生也不可全部学精学透。但是 IT 行业却又有着另一种景象，虽然知识众多，但是入门却很简单。一旦有了几种知识的入门，就可以用这些知识来实现小的功能，完成小的项目。那有人要问了“你的意思是更深入的知识就没有用了？”。“NONONO”，更深入的知识是用来进一步优化之前用入门知识构建的项目的。也就是说：入门知识，**用于构建基础项目 **；深入知识，**用于优化基础项目 **。\n\n对企业而言，专精的技能更好。而对一个人需要用于完成自己创意的 MVP 产品来说，众多基础的技能显得更为重要。但如何抉择，还是听你的。\n","slug":"IT-行业的入门与精通","published":1,"updated":"2019-02-03T15:21:37.364Z","layout":"post","photos":[],"link":"","_id":"cjsqwht7w0019knp2oy1ykfo0","content":"<p>在互联网行业总有这样一句话广为流传，即“什么技能都会但只是入门，不如只会一门技术但是却很精通”。我从来不会反对这句话所传达的意义，如果是为了找到一份更好的工作，那么这句话提供的参考价值确实十分高。但是抛开找工作层面，这句话真的正确吗？我看不见得。</p>\n<p>现在的IT公司职位分工很明确，确实更加需要专一技术水平很高的人才。相对于什么技能都会但是却并不精通的人，企业更倾向于只钻研一门技术的人，哪怕他在这一门技术上并不十分精通。因为企业相信，只钻研一门技术的人会在这门技术的领域一直走下去，从而会在这一专业职位上做的更好，而不会去像什么技能都会一点的人一样，“漫无目的”的学习。他们认为，这种“漫无目的”式的学习纯属是在浪费时间。</p>\n<p>但真的是这样吗？现在的互联网企业融合度非常高，所需要的 IT 技术众多，所以导致企业内部职位的分化十分详细，比如 Web 前端需要 CSS，HTML，JS 等技术，大公司可能会将前端的职位分成前端 CSS + HTML 工程师岗位以及前端 JS 工程师岗位等如此之详细。</p>\n<p>作为企业中的一员，这样倒尚可。但倘若把你从企业中独立出来，那会怎样？你只会一门技术，你一个人无法完成一个完整的项目。你的内心有着很多不错的想法，但是因为你只懂得一门技术，虽然钻研的很深，但若没有其他技术的辅助，你便只能够完成整个项目中的一小部分功能。你很失落，但却没有办法。就这样，你被企业束缚住了。</p>\n<p>IT 行业的知识很深很广，一个人可能穷其一生也不可全部学精学透。但是 IT 行业却又有着另一种景象，虽然知识众多，但是入门却很简单。一旦有了几种知识的入门，就可以用这些知识来实现小的功能，完成小的项目。那有人要问了“你的意思是更深入的知识就没有用了？”。“NONONO”，更深入的知识是用来进一步优化之前用入门知识构建的项目的。也就是说：入门知识，<strong>用于构建基础项目 </strong>；深入知识，<strong>用于优化基础项目 </strong>。</p>\n<p>对企业而言，专精的技能更好。而对一个人需要用于完成自己创意的 MVP 产品来说，众多基础的技能显得更为重要。但如何抉择，还是听你的。</p>\n","site":{"data":{}},"id":"42b01125e49837bb8113664631b82061","excerpt":"","more":"<p>在互联网行业总有这样一句话广为流传，即“什么技能都会但只是入门，不如只会一门技术但是却很精通”。我从来不会反对这句话所传达的意义，如果是为了找到一份更好的工作，那么这句话提供的参考价值确实十分高。但是抛开找工作层面，这句话真的正确吗？我看不见得。</p>\n<p>现在的IT公司职位分工很明确，确实更加需要专一技术水平很高的人才。相对于什么技能都会但是却并不精通的人，企业更倾向于只钻研一门技术的人，哪怕他在这一门技术上并不十分精通。因为企业相信，只钻研一门技术的人会在这门技术的领域一直走下去，从而会在这一专业职位上做的更好，而不会去像什么技能都会一点的人一样，“漫无目的”的学习。他们认为，这种“漫无目的”式的学习纯属是在浪费时间。</p>\n<p>但真的是这样吗？现在的互联网企业融合度非常高，所需要的 IT 技术众多，所以导致企业内部职位的分化十分详细，比如 Web 前端需要 CSS，HTML，JS 等技术，大公司可能会将前端的职位分成前端 CSS + HTML 工程师岗位以及前端 JS 工程师岗位等如此之详细。</p>\n<p>作为企业中的一员，这样倒尚可。但倘若把你从企业中独立出来，那会怎样？你只会一门技术，你一个人无法完成一个完整的项目。你的内心有着很多不错的想法，但是因为你只懂得一门技术，虽然钻研的很深，但若没有其他技术的辅助，你便只能够完成整个项目中的一小部分功能。你很失落，但却没有办法。就这样，你被企业束缚住了。</p>\n<p>IT 行业的知识很深很广，一个人可能穷其一生也不可全部学精学透。但是 IT 行业却又有着另一种景象，虽然知识众多，但是入门却很简单。一旦有了几种知识的入门，就可以用这些知识来实现小的功能，完成小的项目。那有人要问了“你的意思是更深入的知识就没有用了？”。“NONONO”，更深入的知识是用来进一步优化之前用入门知识构建的项目的。也就是说：入门知识，<strong>用于构建基础项目 </strong>；深入知识，<strong>用于优化基础项目 </strong>。</p>\n<p>对企业而言，专精的技能更好。而对一个人需要用于完成自己创意的 MVP 产品来说，众多基础的技能显得更为重要。但如何抉择，还是听你的。</p>\n"},{"title":"Java 基础语法特性记录","intro":"本文不是针对 Java 的 “step by step” 手把手教程，但你可以通过本文来回顾 Java 的一些基础特性。“对象”是 Java 语言中的主要元素，它将生活中事物之间的逻辑抽象成了类与类之间的关系，这是 Jave 语言的基本思想之一，即“一切元素皆为对象”。","comments":1,"date":"2016-03-20T14:47:47.000Z","_content":"\n本文不是针对 Java 的 “step by step” 手把手教程，但你可以通过本文来回顾 Java 的一些基础特性。“对象”是 Java 语言中的主要元素，它将生活中事物之间的逻辑抽象成了类与类之间的关系，这是 Jave 语言的基本思想之一，即“一切元素皆为对象”。\n\n**1. 创建引用和初始化对象**：\n```java\nString s;  // 创建一个引用；\nString s = \"init object\";  // 初始化一个对象；\n```\n\n**2. 堆与栈**：\n\n“栈”位于通用 RAM（内存）中，栈指针向下移动则会分配新内存；若向上移动则释放内存；由于创建程序时，Java 系统必须知道所有存在于栈内的对象的生命周期，以便随时释放和分配内存。这一特性限制了程序的灵活性，所以“栈”中一般只存储对象引用，并不存储对象本身。\n\n而“堆”同样位于通用 RAM 中，用于存放所有的 Java 对象，不同于“栈”的是，编译器不需要知道存储的数据在堆里存储多长时间。因此，在堆里分配存储有很大的灵活性。但相对应的，用“堆”进行存储分配和清理可能比“栈”花费更多的时间。\n\n**3. 特例：“基本类型”**：\n\n由于 `new` 操作符将生成的对象存储在“堆”里，所以用 `new` 操作符来创建一些小的、简单的变量往往不是很有效。因此，对于这些变量，Java 采用和 C/C++ 相同的方法，不使用 `new` 操作符，而是创建一个并非是“引用”的自动变量并直接存储其值到“栈”中，这样更加高效。\n\n```java\nString s = new String(\"init object\");  // 引用存储于“栈”中，对象存于“堆”中；\nString s = \"init object\";  // 变量值存储于“栈”中；\n```\n\n相对于 C/C++，Java 的每种基本类型所确定的存储空间都是固定的。这一点奠定了它良好的可移植性。\n\n**4. GC（垃圾收集器）**：\n\n```java\n{\n    Stirng s = new String(\"init object\");\n}\n```\n\n在上面所示的代码中，引用 “s” 以及其所指向的对象在大括号之后的作用域中便不可以再进行调用了，但由 `new` 在“堆”中一直存在着（即便已经不能调用）。在 C++ 中你可能需要手动去清理这些对象来防止内存被填满。但在 Java 中，你完全可以不必担心。你只需创建对象，一旦不再需要，它们就会自动被 Java 的垃圾收集器自动回收，同时这也防止了“内存泄露”的问题。\n\n**5. 默认值**：\n\n如果一个 Java 类的成员属性是基本数据类型之一，那么 Java 会自动给没有初始值的成员属性进行自动初始化默认值。但对于局部变量来说，没有初始值的变量会被赋予一个系统随机产生的默认值，同时 Java 会在编译时返回一个错误。\n\n**6. 包**：\n\n在所有的 Java 应用程序中，`java.lang` 包是被默认自动导入到每个 Java 文件中的。\n\n**7. 编译与链接**：\n\n在 Java 中，我们一般使用 `javac` 命令（安装于 JDK 中）来编译源文件，`java` 命令来链接并执行程序。但也可以选择使用 “build.xml” 文件和 `ant` 命令来自动化构建和运行 Java 程序。\n\n**8. 文档**：\n\n使用 Javadoc 来编辑和维护 Java 文档。\n\n**9. 编码风格**：\n\n类名首字母大写，不要使用下划线来分割名字，其中每个内部单词的首字母都要大写。对于其他方法、字段、成员变量、引用等类型，则首字母小写。","source":"_posts/Java-基础语法特性记录.md","raw":"---\ntitle: Java 基础语法特性记录\nintro: 本文不是针对 Java 的 “step by step” 手把手教程，但你可以通过本文来回顾 Java 的一些基础特性。“对象”是 Java 语言中的主要元素，它将生活中事物之间的逻辑抽象成了类与类之间的关系，这是 Jave 语言的基本思想之一，即“一切元素皆为对象”。\ncomments: true\ndate: 2016-03-20 22:47:47\ntags:\n- Java\n---\n\n本文不是针对 Java 的 “step by step” 手把手教程，但你可以通过本文来回顾 Java 的一些基础特性。“对象”是 Java 语言中的主要元素，它将生活中事物之间的逻辑抽象成了类与类之间的关系，这是 Jave 语言的基本思想之一，即“一切元素皆为对象”。\n\n**1. 创建引用和初始化对象**：\n```java\nString s;  // 创建一个引用；\nString s = \"init object\";  // 初始化一个对象；\n```\n\n**2. 堆与栈**：\n\n“栈”位于通用 RAM（内存）中，栈指针向下移动则会分配新内存；若向上移动则释放内存；由于创建程序时，Java 系统必须知道所有存在于栈内的对象的生命周期，以便随时释放和分配内存。这一特性限制了程序的灵活性，所以“栈”中一般只存储对象引用，并不存储对象本身。\n\n而“堆”同样位于通用 RAM 中，用于存放所有的 Java 对象，不同于“栈”的是，编译器不需要知道存储的数据在堆里存储多长时间。因此，在堆里分配存储有很大的灵活性。但相对应的，用“堆”进行存储分配和清理可能比“栈”花费更多的时间。\n\n**3. 特例：“基本类型”**：\n\n由于 `new` 操作符将生成的对象存储在“堆”里，所以用 `new` 操作符来创建一些小的、简单的变量往往不是很有效。因此，对于这些变量，Java 采用和 C/C++ 相同的方法，不使用 `new` 操作符，而是创建一个并非是“引用”的自动变量并直接存储其值到“栈”中，这样更加高效。\n\n```java\nString s = new String(\"init object\");  // 引用存储于“栈”中，对象存于“堆”中；\nString s = \"init object\";  // 变量值存储于“栈”中；\n```\n\n相对于 C/C++，Java 的每种基本类型所确定的存储空间都是固定的。这一点奠定了它良好的可移植性。\n\n**4. GC（垃圾收集器）**：\n\n```java\n{\n    Stirng s = new String(\"init object\");\n}\n```\n\n在上面所示的代码中，引用 “s” 以及其所指向的对象在大括号之后的作用域中便不可以再进行调用了，但由 `new` 在“堆”中一直存在着（即便已经不能调用）。在 C++ 中你可能需要手动去清理这些对象来防止内存被填满。但在 Java 中，你完全可以不必担心。你只需创建对象，一旦不再需要，它们就会自动被 Java 的垃圾收集器自动回收，同时这也防止了“内存泄露”的问题。\n\n**5. 默认值**：\n\n如果一个 Java 类的成员属性是基本数据类型之一，那么 Java 会自动给没有初始值的成员属性进行自动初始化默认值。但对于局部变量来说，没有初始值的变量会被赋予一个系统随机产生的默认值，同时 Java 会在编译时返回一个错误。\n\n**6. 包**：\n\n在所有的 Java 应用程序中，`java.lang` 包是被默认自动导入到每个 Java 文件中的。\n\n**7. 编译与链接**：\n\n在 Java 中，我们一般使用 `javac` 命令（安装于 JDK 中）来编译源文件，`java` 命令来链接并执行程序。但也可以选择使用 “build.xml” 文件和 `ant` 命令来自动化构建和运行 Java 程序。\n\n**8. 文档**：\n\n使用 Javadoc 来编辑和维护 Java 文档。\n\n**9. 编码风格**：\n\n类名首字母大写，不要使用下划线来分割名字，其中每个内部单词的首字母都要大写。对于其他方法、字段、成员变量、引用等类型，则首字母小写。","slug":"Java-基础语法特性记录","published":1,"updated":"2019-02-05T10:02:06.721Z","layout":"post","photos":[],"link":"","_id":"cjsqwht80001bknp2ld4dv10c","content":"<p>本文不是针对 Java 的 “step by step” 手把手教程，但你可以通过本文来回顾 Java 的一些基础特性。“对象”是 Java 语言中的主要元素，它将生活中事物之间的逻辑抽象成了类与类之间的关系，这是 Jave 语言的基本思想之一，即“一切元素皆为对象”。</p>\n<p><strong>1. 创建引用和初始化对象</strong>：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\">String s<span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 创建一个引用；</span>\nString s <span class=\"token operator\">=</span> <span class=\"token string\">\"init object\"</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 初始化一个对象；</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p><strong>2. 堆与栈</strong>：</p>\n<p>“栈”位于通用 RAM（内存）中，栈指针向下移动则会分配新内存；若向上移动则释放内存；由于创建程序时，Java 系统必须知道所有存在于栈内的对象的生命周期，以便随时释放和分配内存。这一特性限制了程序的灵活性，所以“栈”中一般只存储对象引用，并不存储对象本身。</p>\n<p>而“堆”同样位于通用 RAM 中，用于存放所有的 Java 对象，不同于“栈”的是，编译器不需要知道存储的数据在堆里存储多长时间。因此，在堆里分配存储有很大的灵活性。但相对应的，用“堆”进行存储分配和清理可能比“栈”花费更多的时间。</p>\n<p><strong>3. 特例：“基本类型”</strong>：</p>\n<p>由于 <code>new</code> 操作符将生成的对象存储在“堆”里，所以用 <code>new</code> 操作符来创建一些小的、简单的变量往往不是很有效。因此，对于这些变量，Java 采用和 C/C++ 相同的方法，不使用 <code>new</code> 操作符，而是创建一个并非是“引用”的自动变量并直接存储其值到“栈”中，这样更加高效。</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\">String s <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"init object\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 引用存储于“栈”中，对象存于“堆”中；</span>\nString s <span class=\"token operator\">=</span> <span class=\"token string\">\"init object\"</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 变量值存储于“栈”中；</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>相对于 C/C++，Java 的每种基本类型所确定的存储空间都是固定的。这一点奠定了它良好的可移植性。</p>\n<p><strong>4. GC（垃圾收集器）</strong>：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token punctuation\">{</span>\n    Stirng s <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"init object\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>在上面所示的代码中，引用 “s” 以及其所指向的对象在大括号之后的作用域中便不可以再进行调用了，但由 <code>new</code> 在“堆”中一直存在着（即便已经不能调用）。在 C++ 中你可能需要手动去清理这些对象来防止内存被填满。但在 Java 中，你完全可以不必担心。你只需创建对象，一旦不再需要，它们就会自动被 Java 的垃圾收集器自动回收，同时这也防止了“内存泄露”的问题。</p>\n<p><strong>5. 默认值</strong>：</p>\n<p>如果一个 Java 类的成员属性是基本数据类型之一，那么 Java 会自动给没有初始值的成员属性进行自动初始化默认值。但对于局部变量来说，没有初始值的变量会被赋予一个系统随机产生的默认值，同时 Java 会在编译时返回一个错误。</p>\n<p><strong>6. 包</strong>：</p>\n<p>在所有的 Java 应用程序中，<code>java.lang</code> 包是被默认自动导入到每个 Java 文件中的。</p>\n<p><strong>7. 编译与链接</strong>：</p>\n<p>在 Java 中，我们一般使用 <code>javac</code> 命令（安装于 JDK 中）来编译源文件，<code>java</code> 命令来链接并执行程序。但也可以选择使用 “build.xml” 文件和 <code>ant</code> 命令来自动化构建和运行 Java 程序。</p>\n<p><strong>8. 文档</strong>：</p>\n<p>使用 Javadoc 来编辑和维护 Java 文档。</p>\n<p><strong>9. 编码风格</strong>：</p>\n<p>类名首字母大写，不要使用下划线来分割名字，其中每个内部单词的首字母都要大写。对于其他方法、字段、成员变量、引用等类型，则首字母小写。</p>\n","site":{"data":{}},"id":"7a1e247e21dda04b6f44be9340da9820","excerpt":"","more":"<p>本文不是针对 Java 的 “step by step” 手把手教程，但你可以通过本文来回顾 Java 的一些基础特性。“对象”是 Java 语言中的主要元素，它将生活中事物之间的逻辑抽象成了类与类之间的关系，这是 Jave 语言的基本思想之一，即“一切元素皆为对象”。</p>\n<p><strong>1. 创建引用和初始化对象</strong>：</p>\n<pre><code class=\"java\">String s;  // 创建一个引用；\nString s = &quot;init object&quot;;  // 初始化一个对象；\n</code></pre>\n<p><strong>2. 堆与栈</strong>：</p>\n<p>“栈”位于通用 RAM（内存）中，栈指针向下移动则会分配新内存；若向上移动则释放内存；由于创建程序时，Java 系统必须知道所有存在于栈内的对象的生命周期，以便随时释放和分配内存。这一特性限制了程序的灵活性，所以“栈”中一般只存储对象引用，并不存储对象本身。</p>\n<p>而“堆”同样位于通用 RAM 中，用于存放所有的 Java 对象，不同于“栈”的是，编译器不需要知道存储的数据在堆里存储多长时间。因此，在堆里分配存储有很大的灵活性。但相对应的，用“堆”进行存储分配和清理可能比“栈”花费更多的时间。</p>\n<p><strong>3. 特例：“基本类型”</strong>：</p>\n<p>由于 <code>new</code> 操作符将生成的对象存储在“堆”里，所以用 <code>new</code> 操作符来创建一些小的、简单的变量往往不是很有效。因此，对于这些变量，Java 采用和 C/C++ 相同的方法，不使用 <code>new</code> 操作符，而是创建一个并非是“引用”的自动变量并直接存储其值到“栈”中，这样更加高效。</p>\n<pre><code class=\"java\">String s = new String(&quot;init object&quot;);  // 引用存储于“栈”中，对象存于“堆”中；\nString s = &quot;init object&quot;;  // 变量值存储于“栈”中；\n</code></pre>\n<p>相对于 C/C++，Java 的每种基本类型所确定的存储空间都是固定的。这一点奠定了它良好的可移植性。</p>\n<p><strong>4. GC（垃圾收集器）</strong>：</p>\n<pre><code class=\"java\">{\n    Stirng s = new String(&quot;init object&quot;);\n}\n</code></pre>\n<p>在上面所示的代码中，引用 “s” 以及其所指向的对象在大括号之后的作用域中便不可以再进行调用了，但由 <code>new</code> 在“堆”中一直存在着（即便已经不能调用）。在 C++ 中你可能需要手动去清理这些对象来防止内存被填满。但在 Java 中，你完全可以不必担心。你只需创建对象，一旦不再需要，它们就会自动被 Java 的垃圾收集器自动回收，同时这也防止了“内存泄露”的问题。</p>\n<p><strong>5. 默认值</strong>：</p>\n<p>如果一个 Java 类的成员属性是基本数据类型之一，那么 Java 会自动给没有初始值的成员属性进行自动初始化默认值。但对于局部变量来说，没有初始值的变量会被赋予一个系统随机产生的默认值，同时 Java 会在编译时返回一个错误。</p>\n<p><strong>6. 包</strong>：</p>\n<p>在所有的 Java 应用程序中，<code>java.lang</code> 包是被默认自动导入到每个 Java 文件中的。</p>\n<p><strong>7. 编译与链接</strong>：</p>\n<p>在 Java 中，我们一般使用 <code>javac</code> 命令（安装于 JDK 中）来编译源文件，<code>java</code> 命令来链接并执行程序。但也可以选择使用 “build.xml” 文件和 <code>ant</code> 命令来自动化构建和运行 Java 程序。</p>\n<p><strong>8. 文档</strong>：</p>\n<p>使用 Javadoc 来编辑和维护 Java 文档。</p>\n<p><strong>9. 编码风格</strong>：</p>\n<p>类名首字母大写，不要使用下划线来分割名字，其中每个内部单词的首字母都要大写。对于其他方法、字段、成员变量、引用等类型，则首字母小写。</p>\n"},{"title":"JavaScript 核心特性揭秘（一）","intro":"我们在日常使用 JavaScript（后面简称 “JS”） 的过程中可能只关注到了 JS 本身带来的，在页面动态交互方面的功能与其对应实现，而 JS 的背后到底是怎么运行代码和处理数据的呢？本文及接下来的几篇文章将会介绍一些 JavaScript 的内部核心特性。","comments":1,"date":"2016-03-26T14:43:16.000Z","_content":"\n我们在日常使用 JavaScript（后面简称 “JS”） 的过程中可能只关注到了 JS 本身带来的，在页面动态交互方面的功能与其对应实现，而 JS 的背后到底是怎么运行代码和处理数据的呢？本文及接下来的几篇文章将会介绍一些 JavaScript 的内部核心特性。\n\n1. 在 JavaScript 定义函数的过程中，只为必须进行传递的 (Required) 参数“显式”的指定参数，其他可选参数请通过 `arguments` 数组进行传递；\n\n```javascript\nfunction myFunction(arg1, arg2) {\n  var arg3 = arguments[2];\n  var arg4 = arguments[3];\n  console.log(arg1 + arg2 + arg3 + arg4);\n}\n// 调用函数，并传递参数；\nmyFunction(1, 2, 3, 4); // 输出10；\n```\n\n2. JavaScript 的五种基本数据类型（Undefined、Null、Number、String、Boolean）对应变量同 Java 一样均存在于**栈**上，只有用 `new` 操作符生成的**对象类型**不同，其对象的数据本身存在堆上，而该对象对应的引用则存在于栈上。\n\n3. JavaScript 中函数的参数传递均为**值传递**（包括对象类型 Object），当传入的参数为基本类型变量时，变量本身不会受到影响。当传入的参数为一个对象的引用时，引用本身不会受到影响，即该引用所指向的对象地址不会改变，代码如下所示。\n\n```javascript\nfunction setName(obj) {\n  obj.name = \"ObjectA\";\n  obj = new Object();  // 使参数指向一个新的对象；\n  obj.name = \"ObjectB\";\n}\nvar person = new Object();\nsetName(person);\nconsole.log(person.name); // 此处仍然打印 \"ObjectA\"，即引用本身不会被改变；\n```\n\n\n4. JavaScript 中的基本类型（Undefined, Null, Number, String, Boolean）变量在赋值给其他变量时会在栈上重新生成一个该变量对应值副本，而在将对象类型变量复制给其他变量时则仅仅复制该对象所对应的引用（指针），而不会复制存在于堆上的对象本身。\n\n5. JavaScript 中有些语句不会产生块级作用域，比如在 `if` 语句内声明的变量可以在 `if` 语句之外使用，即 `if` 语句并不会产生新的块级作用域。同样的， `for` 语句和 `if` 语句均不会产生新的块级作用域。\n\n6. JavaScript 垃圾收集机制有**标记清除**和**引用计数**两种方式：\n\n* **标记清除：**即当变量进入环境时就为该变量标记为“进入环境”。而当变量离开环境时，同理会被标记为“离开环境”。“进入环境”的变量永远不会被释放。被标记为“离开环境”的变量将被视为准备被释放的变量，因为环境中所有的变量都已经无法访问到这些变量了。最后，垃圾收集器将会完成垃圾清理工作。\n\n* **引用计数：**该方法的基本思路是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型的值赋给该变量时，则这个值的引用次数便加一。相反，如果包含对这个值引用的变量又取得另外一个值，则这个值的引用次数便减一。如果引用次数变为0，则垃圾收集器将回收该值所占用的内存空间。\n\n通常大部分浏览器均会采用标记清除的方式来作为基本的垃圾回收方式，而早期的 “Netscape Navigator3.0” 浏览器则使用了引用计数的方式。但这个方式很快便暴露出了一个严重的问题，即“**循环引用**”。\n\n```javascript\nfunction myFunction() {\n  var objectA = new Object();\n  var objectB = new Object();\n \n  objectA.instanceB = objectB;\n  objectB.instanceA = objectA;\n}\n```\n\n**循环引用**：是指对象 A 中包含一个指向对象 B 的引用（指针），而对象 B 中也包含一个指向对象 A 的引用（指针）。如上所示代码中，对象 A 和对象 B 通过各自的属性互相引用，在引用计数的方式中，对象 A 和对象 B 由于其引用次数永远不会变成0，因此对象 A 和对象 B 占用的内存永远不会被释放，而如果这些对象被大量生产和使用，则会有大量的内存被占用而得不到释放。因此后期 Netscape 放弃了引用计数的方式。这个问题在早期 IE9 之前的浏览器中的 DOM 对象和 BOM 对象中也曾存在，其根本原因是由于当时 IE 对 “COM” 对象的垃圾收集机制采用了引用计数方式。\n\n7. 函数声明与函数表达式：\n\n在 JavaScript 代码被解释运行时，代码解释器会率先读取函数声明，并使其在执行任何代码之前可用；至于函数表达式，则必须等到解释器执行到它所在的代码行，才会真正被解释执行。\n\n```javascript\n// sum 为函数声明，此段代码可以执行；\nalert(sum(10, 20));\nfunction sum(arg1, arg2) {\n  return arg1 + arg2;\n}\n```\n\n下面给出的代码中声明的函数 sum 为函数表达式，因此如果想要调用 sum 函数，只能够将调用过程放在 sum 函数的函数表达式之后再进行。\n\n```javascript\n// sum 为函数表达式，此段代码无法执行；\nalert(sum(10, 20));\nvar sum = function(arg1, arg2) {\n  return arg1 + arg2;\n}\n```","source":"_posts/JavaScript-核心特性揭秘（一）.md","raw":"---\ntitle: JavaScript 核心特性揭秘（一）\nintro: 我们在日常使用 JavaScript（后面简称 “JS”） 的过程中可能只关注到了 JS 本身带来的，在页面动态交互方面的功能与其对应实现，而 JS 的背后到底是怎么运行代码和处理数据的呢？本文及接下来的几篇文章将会介绍一些 JavaScript 的内部核心特性。\ncomments: true\ndate: 2016-03-26 22:43:16\ntags:\n- JavaScript\n---\n\n我们在日常使用 JavaScript（后面简称 “JS”） 的过程中可能只关注到了 JS 本身带来的，在页面动态交互方面的功能与其对应实现，而 JS 的背后到底是怎么运行代码和处理数据的呢？本文及接下来的几篇文章将会介绍一些 JavaScript 的内部核心特性。\n\n1. 在 JavaScript 定义函数的过程中，只为必须进行传递的 (Required) 参数“显式”的指定参数，其他可选参数请通过 `arguments` 数组进行传递；\n\n```javascript\nfunction myFunction(arg1, arg2) {\n  var arg3 = arguments[2];\n  var arg4 = arguments[3];\n  console.log(arg1 + arg2 + arg3 + arg4);\n}\n// 调用函数，并传递参数；\nmyFunction(1, 2, 3, 4); // 输出10；\n```\n\n2. JavaScript 的五种基本数据类型（Undefined、Null、Number、String、Boolean）对应变量同 Java 一样均存在于**栈**上，只有用 `new` 操作符生成的**对象类型**不同，其对象的数据本身存在堆上，而该对象对应的引用则存在于栈上。\n\n3. JavaScript 中函数的参数传递均为**值传递**（包括对象类型 Object），当传入的参数为基本类型变量时，变量本身不会受到影响。当传入的参数为一个对象的引用时，引用本身不会受到影响，即该引用所指向的对象地址不会改变，代码如下所示。\n\n```javascript\nfunction setName(obj) {\n  obj.name = \"ObjectA\";\n  obj = new Object();  // 使参数指向一个新的对象；\n  obj.name = \"ObjectB\";\n}\nvar person = new Object();\nsetName(person);\nconsole.log(person.name); // 此处仍然打印 \"ObjectA\"，即引用本身不会被改变；\n```\n\n\n4. JavaScript 中的基本类型（Undefined, Null, Number, String, Boolean）变量在赋值给其他变量时会在栈上重新生成一个该变量对应值副本，而在将对象类型变量复制给其他变量时则仅仅复制该对象所对应的引用（指针），而不会复制存在于堆上的对象本身。\n\n5. JavaScript 中有些语句不会产生块级作用域，比如在 `if` 语句内声明的变量可以在 `if` 语句之外使用，即 `if` 语句并不会产生新的块级作用域。同样的， `for` 语句和 `if` 语句均不会产生新的块级作用域。\n\n6. JavaScript 垃圾收集机制有**标记清除**和**引用计数**两种方式：\n\n* **标记清除：**即当变量进入环境时就为该变量标记为“进入环境”。而当变量离开环境时，同理会被标记为“离开环境”。“进入环境”的变量永远不会被释放。被标记为“离开环境”的变量将被视为准备被释放的变量，因为环境中所有的变量都已经无法访问到这些变量了。最后，垃圾收集器将会完成垃圾清理工作。\n\n* **引用计数：**该方法的基本思路是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型的值赋给该变量时，则这个值的引用次数便加一。相反，如果包含对这个值引用的变量又取得另外一个值，则这个值的引用次数便减一。如果引用次数变为0，则垃圾收集器将回收该值所占用的内存空间。\n\n通常大部分浏览器均会采用标记清除的方式来作为基本的垃圾回收方式，而早期的 “Netscape Navigator3.0” 浏览器则使用了引用计数的方式。但这个方式很快便暴露出了一个严重的问题，即“**循环引用**”。\n\n```javascript\nfunction myFunction() {\n  var objectA = new Object();\n  var objectB = new Object();\n \n  objectA.instanceB = objectB;\n  objectB.instanceA = objectA;\n}\n```\n\n**循环引用**：是指对象 A 中包含一个指向对象 B 的引用（指针），而对象 B 中也包含一个指向对象 A 的引用（指针）。如上所示代码中，对象 A 和对象 B 通过各自的属性互相引用，在引用计数的方式中，对象 A 和对象 B 由于其引用次数永远不会变成0，因此对象 A 和对象 B 占用的内存永远不会被释放，而如果这些对象被大量生产和使用，则会有大量的内存被占用而得不到释放。因此后期 Netscape 放弃了引用计数的方式。这个问题在早期 IE9 之前的浏览器中的 DOM 对象和 BOM 对象中也曾存在，其根本原因是由于当时 IE 对 “COM” 对象的垃圾收集机制采用了引用计数方式。\n\n7. 函数声明与函数表达式：\n\n在 JavaScript 代码被解释运行时，代码解释器会率先读取函数声明，并使其在执行任何代码之前可用；至于函数表达式，则必须等到解释器执行到它所在的代码行，才会真正被解释执行。\n\n```javascript\n// sum 为函数声明，此段代码可以执行；\nalert(sum(10, 20));\nfunction sum(arg1, arg2) {\n  return arg1 + arg2;\n}\n```\n\n下面给出的代码中声明的函数 sum 为函数表达式，因此如果想要调用 sum 函数，只能够将调用过程放在 sum 函数的函数表达式之后再进行。\n\n```javascript\n// sum 为函数表达式，此段代码无法执行；\nalert(sum(10, 20));\nvar sum = function(arg1, arg2) {\n  return arg1 + arg2;\n}\n```","slug":"JavaScript-核心特性揭秘（一）","published":1,"updated":"2019-02-05T10:40:46.570Z","layout":"post","photos":[],"link":"","_id":"cjsqwht83001eknp2b9t6ydag","content":"<p>我们在日常使用 JavaScript（后面简称 “JS”） 的过程中可能只关注到了 JS 本身带来的，在页面动态交互方面的功能与其对应实现，而 JS 的背后到底是怎么运行代码和处理数据的呢？本文及接下来的几篇文章将会介绍一些 JavaScript 的内部核心特性。</p>\n<ol>\n<li>在 JavaScript 定义函数的过程中，只为必须进行传递的 (Required) 参数“显式”的指定参数，其他可选参数请通过 <code>arguments</code> 数组进行传递；</li>\n</ol>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">myFunction</span><span class=\"token punctuation\">(</span>arg1<span class=\"token punctuation\">,</span> arg2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> arg3 <span class=\"token operator\">=</span> arguments<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> arg4 <span class=\"token operator\">=</span> arguments<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>arg1 <span class=\"token operator\">+</span> arg2 <span class=\"token operator\">+</span> arg3 <span class=\"token operator\">+</span> arg4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">// 调用函数，并传递参数；</span>\n<span class=\"token function\">myFunction</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 输出10；</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ol start=\"2\">\n<li><p>JavaScript 的五种基本数据类型（Undefined、Null、Number、String、Boolean）对应变量同 Java 一样均存在于<strong>栈</strong>上，只有用 <code>new</code> 操作符生成的<strong>对象类型</strong>不同，其对象的数据本身存在堆上，而该对象对应的引用则存在于栈上。</p>\n</li>\n<li><p>JavaScript 中函数的参数传递均为<strong>值传递</strong>（包括对象类型 Object），当传入的参数为基本类型变量时，变量本身不会受到影响。当传入的参数为一个对象的引用时，引用本身不会受到影响，即该引用所指向的对象地址不会改变，代码如下所示。</p>\n</li>\n</ol>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">setName</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  obj<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">\"ObjectA\"</span><span class=\"token punctuation\">;</span>\n  obj <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 使参数指向一个新的对象；</span>\n  obj<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">\"ObjectB\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">var</span> person <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">setName</span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 此处仍然打印 \"ObjectA\"，即引用本身不会被改变；</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ol start=\"4\">\n<li><p>JavaScript 中的基本类型（Undefined, Null, Number, String, Boolean）变量在赋值给其他变量时会在栈上重新生成一个该变量对应值副本，而在将对象类型变量复制给其他变量时则仅仅复制该对象所对应的引用（指针），而不会复制存在于堆上的对象本身。</p>\n</li>\n<li><p>JavaScript 中有些语句不会产生块级作用域，比如在 <code>if</code> 语句内声明的变量可以在 <code>if</code> 语句之外使用，即 <code>if</code> 语句并不会产生新的块级作用域。同样的， <code>for</code> 语句和 <code>if</code> 语句均不会产生新的块级作用域。</p>\n</li>\n<li><p>JavaScript 垃圾收集机制有<strong>标记清除</strong>和<strong>引用计数</strong>两种方式：</p>\n</li>\n</ol>\n<ul>\n<li><p><strong>标记清除：</strong>即当变量进入环境时就为该变量标记为“进入环境”。而当变量离开环境时，同理会被标记为“离开环境”。“进入环境”的变量永远不会被释放。被标记为“离开环境”的变量将被视为准备被释放的变量，因为环境中所有的变量都已经无法访问到这些变量了。最后，垃圾收集器将会完成垃圾清理工作。</p>\n</li>\n<li><p><strong>引用计数：</strong>该方法的基本思路是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型的值赋给该变量时，则这个值的引用次数便加一。相反，如果包含对这个值引用的变量又取得另外一个值，则这个值的引用次数便减一。如果引用次数变为0，则垃圾收集器将回收该值所占用的内存空间。</p>\n</li>\n</ul>\n<p>通常大部分浏览器均会采用标记清除的方式来作为基本的垃圾回收方式，而早期的 “Netscape Navigator3.0” 浏览器则使用了引用计数的方式。但这个方式很快便暴露出了一个严重的问题，即“<strong>循环引用</strong>”。</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">myFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> objectA <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> objectB <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  objectA<span class=\"token punctuation\">.</span>instanceB <span class=\"token operator\">=</span> objectB<span class=\"token punctuation\">;</span>\n  objectB<span class=\"token punctuation\">.</span>instanceA <span class=\"token operator\">=</span> objectA<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>循环引用</strong>：是指对象 A 中包含一个指向对象 B 的引用（指针），而对象 B 中也包含一个指向对象 A 的引用（指针）。如上所示代码中，对象 A 和对象 B 通过各自的属性互相引用，在引用计数的方式中，对象 A 和对象 B 由于其引用次数永远不会变成0，因此对象 A 和对象 B 占用的内存永远不会被释放，而如果这些对象被大量生产和使用，则会有大量的内存被占用而得不到释放。因此后期 Netscape 放弃了引用计数的方式。这个问题在早期 IE9 之前的浏览器中的 DOM 对象和 BOM 对象中也曾存在，其根本原因是由于当时 IE 对 “COM” 对象的垃圾收集机制采用了引用计数方式。</p>\n<ol start=\"7\">\n<li>函数声明与函数表达式：</li>\n</ol>\n<p>在 JavaScript 代码被解释运行时，代码解释器会率先读取函数声明，并使其在执行任何代码之前可用；至于函数表达式，则必须等到解释器执行到它所在的代码行，才会真正被解释执行。</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">// sum 为函数声明，此段代码可以执行；</span>\n<span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token function\">sum</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">sum</span><span class=\"token punctuation\">(</span>arg1<span class=\"token punctuation\">,</span> arg2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> arg1 <span class=\"token operator\">+</span> arg2<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>下面给出的代码中声明的函数 sum 为函数表达式，因此如果想要调用 sum 函数，只能够将调用过程放在 sum 函数的函数表达式之后再进行。</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">// sum 为函数表达式，此段代码无法执行；</span>\n<span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token function\">sum</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> sum <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>arg1<span class=\"token punctuation\">,</span> arg2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> arg1 <span class=\"token operator\">+</span> arg2<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"id":"17642705f00fecabfea6ca3a3930cd87","excerpt":"","more":"<p>我们在日常使用 JavaScript（后面简称 “JS”） 的过程中可能只关注到了 JS 本身带来的，在页面动态交互方面的功能与其对应实现，而 JS 的背后到底是怎么运行代码和处理数据的呢？本文及接下来的几篇文章将会介绍一些 JavaScript 的内部核心特性。</p>\n<ol>\n<li>在 JavaScript 定义函数的过程中，只为必须进行传递的 (Required) 参数“显式”的指定参数，其他可选参数请通过 <code>arguments</code> 数组进行传递；</li>\n</ol>\n<pre><code class=\"javascript\">function myFunction(arg1, arg2) {\n  var arg3 = arguments[2];\n  var arg4 = arguments[3];\n  console.log(arg1 + arg2 + arg3 + arg4);\n}\n// 调用函数，并传递参数；\nmyFunction(1, 2, 3, 4); // 输出10；\n</code></pre>\n<ol start=\"2\">\n<li><p>JavaScript 的五种基本数据类型（Undefined、Null、Number、String、Boolean）对应变量同 Java 一样均存在于<strong>栈</strong>上，只有用 <code>new</code> 操作符生成的<strong>对象类型</strong>不同，其对象的数据本身存在堆上，而该对象对应的引用则存在于栈上。</p>\n</li>\n<li><p>JavaScript 中函数的参数传递均为<strong>值传递</strong>（包括对象类型 Object），当传入的参数为基本类型变量时，变量本身不会受到影响。当传入的参数为一个对象的引用时，引用本身不会受到影响，即该引用所指向的对象地址不会改变，代码如下所示。</p>\n</li>\n</ol>\n<pre><code class=\"javascript\">function setName(obj) {\n  obj.name = &quot;ObjectA&quot;;\n  obj = new Object();  // 使参数指向一个新的对象；\n  obj.name = &quot;ObjectB&quot;;\n}\nvar person = new Object();\nsetName(person);\nconsole.log(person.name); // 此处仍然打印 &quot;ObjectA&quot;，即引用本身不会被改变；\n</code></pre>\n<ol start=\"4\">\n<li><p>JavaScript 中的基本类型（Undefined, Null, Number, String, Boolean）变量在赋值给其他变量时会在栈上重新生成一个该变量对应值副本，而在将对象类型变量复制给其他变量时则仅仅复制该对象所对应的引用（指针），而不会复制存在于堆上的对象本身。</p>\n</li>\n<li><p>JavaScript 中有些语句不会产生块级作用域，比如在 <code>if</code> 语句内声明的变量可以在 <code>if</code> 语句之外使用，即 <code>if</code> 语句并不会产生新的块级作用域。同样的， <code>for</code> 语句和 <code>if</code> 语句均不会产生新的块级作用域。</p>\n</li>\n<li><p>JavaScript 垃圾收集机制有<strong>标记清除</strong>和<strong>引用计数</strong>两种方式：</p>\n</li>\n</ol>\n<ul>\n<li><p><strong>标记清除：</strong>即当变量进入环境时就为该变量标记为“进入环境”。而当变量离开环境时，同理会被标记为“离开环境”。“进入环境”的变量永远不会被释放。被标记为“离开环境”的变量将被视为准备被释放的变量，因为环境中所有的变量都已经无法访问到这些变量了。最后，垃圾收集器将会完成垃圾清理工作。</p>\n</li>\n<li><p><strong>引用计数：</strong>该方法的基本思路是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型的值赋给该变量时，则这个值的引用次数便加一。相反，如果包含对这个值引用的变量又取得另外一个值，则这个值的引用次数便减一。如果引用次数变为0，则垃圾收集器将回收该值所占用的内存空间。</p>\n</li>\n</ul>\n<p>通常大部分浏览器均会采用标记清除的方式来作为基本的垃圾回收方式，而早期的 “Netscape Navigator3.0” 浏览器则使用了引用计数的方式。但这个方式很快便暴露出了一个严重的问题，即“<strong>循环引用</strong>”。</p>\n<pre><code class=\"javascript\">function myFunction() {\n  var objectA = new Object();\n  var objectB = new Object();\n\n  objectA.instanceB = objectB;\n  objectB.instanceA = objectA;\n}\n</code></pre>\n<p><strong>循环引用</strong>：是指对象 A 中包含一个指向对象 B 的引用（指针），而对象 B 中也包含一个指向对象 A 的引用（指针）。如上所示代码中，对象 A 和对象 B 通过各自的属性互相引用，在引用计数的方式中，对象 A 和对象 B 由于其引用次数永远不会变成0，因此对象 A 和对象 B 占用的内存永远不会被释放，而如果这些对象被大量生产和使用，则会有大量的内存被占用而得不到释放。因此后期 Netscape 放弃了引用计数的方式。这个问题在早期 IE9 之前的浏览器中的 DOM 对象和 BOM 对象中也曾存在，其根本原因是由于当时 IE 对 “COM” 对象的垃圾收集机制采用了引用计数方式。</p>\n<ol start=\"7\">\n<li>函数声明与函数表达式：</li>\n</ol>\n<p>在 JavaScript 代码被解释运行时，代码解释器会率先读取函数声明，并使其在执行任何代码之前可用；至于函数表达式，则必须等到解释器执行到它所在的代码行，才会真正被解释执行。</p>\n<pre><code class=\"javascript\">// sum 为函数声明，此段代码可以执行；\nalert(sum(10, 20));\nfunction sum(arg1, arg2) {\n  return arg1 + arg2;\n}\n</code></pre>\n<p>下面给出的代码中声明的函数 sum 为函数表达式，因此如果想要调用 sum 函数，只能够将调用过程放在 sum 函数的函数表达式之后再进行。</p>\n<pre><code class=\"javascript\">// sum 为函数表达式，此段代码无法执行；\nalert(sum(10, 20));\nvar sum = function(arg1, arg2) {\n  return arg1 + arg2;\n}\n</code></pre>\n"},{"title":"JavaScript 核心特性揭秘（二）","intro":"本文是《JavaScript 核心特性揭秘》系列的第二篇，这一系列的文章并没有按照由浅入深的顺序来写，旨在记录与分享，将碎片化的 JS 知识集中起来。囊括所有你需要知道的 Javascript 核心特性与技巧。文章内容如有错误，欢迎大家积极指正与交流。","comments":1,"date":"2016-03-29T15:41:39.000Z","_content":"\n本文是《JavaScript 核心特性揭秘》系列的第二篇，这一系列的文章并没有按照由浅入深的顺序来写，旨在记录与分享，将碎片化的 JS 知识集中起来。囊括所有你需要知道的 Javascript 核心特性与技巧。文章内容如有错误，欢迎大家积极指正与交流。\n\n1. 从一个函数中返回另一个函数，这是一个常用的技巧。参考《Javascript高级程序设计》给出的示例代码：\n\n```javascript\nfunction createComparisonFunction(propertyName) {\n  return function(obj1, obj2) {\n    var val1 = obj1[propertyName];\n    var val2 = obj2[propertyName];\n    if (val1 < val2) {\n      return -1;\n    } else if (val1 > val2) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n}\n\n// 调用函数，并传递参数；\nvar data = [{ name: \"Zachary\", age:28 }, { name: \"Nicholas\", age: 29 }];\n\ndata.sort(createComparisonFunction(\"name\"));\nconsole.log(data);\n```\n\nJavaScript 的 `sort` 函数接受一个带有两个参数的函数用来自定义排序顺序。通过该函数返回的不同值来排列给定数组中的元素。上述代码中 `createComparisonFunction` 方法返回一个带有两个参数的函数供 `sort` 函数使用，在 `createComparisonFunction` 方法中按照用户指定的键来返回不同的排列函数。因此，每一个返回的匿名函数都是根据该方法和用户指定的键属性来动态生成的。\n\n2. `arguments` 对象：该对象除了可以获得传入函数的所有参数之外，它还有一个名为 `callee` 的属性，该属性是一个指针类型，指向拥有这个 `arguments` 对象的函数本身。一般我们可以在递归函数中使用此属性，示例代码如下。\n\n```javascript\nfunction factorial(num) {\n  if (num <= 1) {\n    return 1;\n  } else {\n    // 此处的 arguments.callee 跟直接调用 factorial 函数效果相同；\n    return num * arguments.callee(num - 1);  \n  }\n}\n```\n\n3.  `caller` 属性：在 ECMAScript5 中终于规范化了该属性，`caller` 属性中保存着调用当前函数的函数引用，该引用即指向调用当前函数的函数体。如果当前函数是在 `window` 作用域被调用，则该属性返回 `null`。一般为了实现松耦合，我们采用 `arguments.callee.caller` 的方式来代替 `object.caller` 方式调用该属性（此处 `object` 指代具体的函数对象）。\n\n4. 使用 `call()` 和 `apply()` 来扩大作用域：这两个函数的基本作用都是在特定的作用域环境内调用其它函数，简单的说就是在其他环境下传递不同的参数，但它们的真正作用并非如此。我们可以用这两个函数来扩大函数运行的作用域，并保持对象与函数本身之间没有任何耦合，示例代码如下。\n\n```javascript\nwindow.color = \"red\";\nvar o = { color: \"blue\" };\n\nfunction sayColor() {\n  console.log(this.color);\n}\n\nsayColor.call(this);\nsayColor.call(window);\nsayColor.call(o);  // 在对象 o 的 this 环境内调用方法 sayColor；\n\n// 使用 ECMAScript5 中定义的新函数 bind 来绑定 sayColor 内的 this 环境到对象 o 上；\nvar objSayColor = sayColor.bind(o);\nobjSayColor();\n```\n\n5. 不要使用 `Boolean` 对象：JavaScript 中提供很多基本类型的包装类，即对应基本类型的引用类型，使用时需要用 `new` 关键字来创建包装类型。而 `Boolean` 类型在 ECMAScript 中的用处不大。如下代码所示，使用 `Boolean` 对象常常会出现奇怪的现象给程序调试和扩展带来困难，所以不推荐使用。\n\n```javascript\nvar falseObject = new Boolean(false);\nvar result = falseObject && true;\nconsole.log(result);  // 输出 true；\n\nvar falseObject = false;\nvar result = falseObject && true;\nconsole.log(result);  // 输出 false；\n```\n\n6. 不要使用 `Number` 对象：`Number` 对象和普通的整数变量在 `instanceof` 和 `typeof` 函数中会出现不一致的现象（一个为 Number 类型，一个为 Object 类型），所以同样不推荐使用。\n","source":"_posts/JavaScript-核心特性揭秘（二）.md","raw":"---\ntitle: JavaScript 核心特性揭秘（二）\nintro: 本文是《JavaScript 核心特性揭秘》系列的第二篇，这一系列的文章并没有按照由浅入深的顺序来写，旨在记录与分享，将碎片化的 JS 知识集中起来。囊括所有你需要知道的 Javascript 核心特性与技巧。文章内容如有错误，欢迎大家积极指正与交流。\ncomments: true\ndate: 2016-03-29 23:41:39\ntags:\n- JavaScript\n---\n\n本文是《JavaScript 核心特性揭秘》系列的第二篇，这一系列的文章并没有按照由浅入深的顺序来写，旨在记录与分享，将碎片化的 JS 知识集中起来。囊括所有你需要知道的 Javascript 核心特性与技巧。文章内容如有错误，欢迎大家积极指正与交流。\n\n1. 从一个函数中返回另一个函数，这是一个常用的技巧。参考《Javascript高级程序设计》给出的示例代码：\n\n```javascript\nfunction createComparisonFunction(propertyName) {\n  return function(obj1, obj2) {\n    var val1 = obj1[propertyName];\n    var val2 = obj2[propertyName];\n    if (val1 < val2) {\n      return -1;\n    } else if (val1 > val2) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n}\n\n// 调用函数，并传递参数；\nvar data = [{ name: \"Zachary\", age:28 }, { name: \"Nicholas\", age: 29 }];\n\ndata.sort(createComparisonFunction(\"name\"));\nconsole.log(data);\n```\n\nJavaScript 的 `sort` 函数接受一个带有两个参数的函数用来自定义排序顺序。通过该函数返回的不同值来排列给定数组中的元素。上述代码中 `createComparisonFunction` 方法返回一个带有两个参数的函数供 `sort` 函数使用，在 `createComparisonFunction` 方法中按照用户指定的键来返回不同的排列函数。因此，每一个返回的匿名函数都是根据该方法和用户指定的键属性来动态生成的。\n\n2. `arguments` 对象：该对象除了可以获得传入函数的所有参数之外，它还有一个名为 `callee` 的属性，该属性是一个指针类型，指向拥有这个 `arguments` 对象的函数本身。一般我们可以在递归函数中使用此属性，示例代码如下。\n\n```javascript\nfunction factorial(num) {\n  if (num <= 1) {\n    return 1;\n  } else {\n    // 此处的 arguments.callee 跟直接调用 factorial 函数效果相同；\n    return num * arguments.callee(num - 1);  \n  }\n}\n```\n\n3.  `caller` 属性：在 ECMAScript5 中终于规范化了该属性，`caller` 属性中保存着调用当前函数的函数引用，该引用即指向调用当前函数的函数体。如果当前函数是在 `window` 作用域被调用，则该属性返回 `null`。一般为了实现松耦合，我们采用 `arguments.callee.caller` 的方式来代替 `object.caller` 方式调用该属性（此处 `object` 指代具体的函数对象）。\n\n4. 使用 `call()` 和 `apply()` 来扩大作用域：这两个函数的基本作用都是在特定的作用域环境内调用其它函数，简单的说就是在其他环境下传递不同的参数，但它们的真正作用并非如此。我们可以用这两个函数来扩大函数运行的作用域，并保持对象与函数本身之间没有任何耦合，示例代码如下。\n\n```javascript\nwindow.color = \"red\";\nvar o = { color: \"blue\" };\n\nfunction sayColor() {\n  console.log(this.color);\n}\n\nsayColor.call(this);\nsayColor.call(window);\nsayColor.call(o);  // 在对象 o 的 this 环境内调用方法 sayColor；\n\n// 使用 ECMAScript5 中定义的新函数 bind 来绑定 sayColor 内的 this 环境到对象 o 上；\nvar objSayColor = sayColor.bind(o);\nobjSayColor();\n```\n\n5. 不要使用 `Boolean` 对象：JavaScript 中提供很多基本类型的包装类，即对应基本类型的引用类型，使用时需要用 `new` 关键字来创建包装类型。而 `Boolean` 类型在 ECMAScript 中的用处不大。如下代码所示，使用 `Boolean` 对象常常会出现奇怪的现象给程序调试和扩展带来困难，所以不推荐使用。\n\n```javascript\nvar falseObject = new Boolean(false);\nvar result = falseObject && true;\nconsole.log(result);  // 输出 true；\n\nvar falseObject = false;\nvar result = falseObject && true;\nconsole.log(result);  // 输出 false；\n```\n\n6. 不要使用 `Number` 对象：`Number` 对象和普通的整数变量在 `instanceof` 和 `typeof` 函数中会出现不一致的现象（一个为 Number 类型，一个为 Object 类型），所以同样不推荐使用。\n","slug":"JavaScript-核心特性揭秘（二）","published":1,"updated":"2019-02-05T10:39:56.723Z","layout":"post","photos":[],"link":"","_id":"cjsqwht88001fknp2lydoyl7l","content":"<p>本文是《JavaScript 核心特性揭秘》系列的第二篇，这一系列的文章并没有按照由浅入深的顺序来写，旨在记录与分享，将碎片化的 JS 知识集中起来。囊括所有你需要知道的 Javascript 核心特性与技巧。文章内容如有错误，欢迎大家积极指正与交流。</p>\n<ol>\n<li>从一个函数中返回另一个函数，这是一个常用的技巧。参考《Javascript高级程序设计》给出的示例代码：</li>\n</ol>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">createComparisonFunction</span><span class=\"token punctuation\">(</span>propertyName<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>obj1<span class=\"token punctuation\">,</span> obj2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> val1 <span class=\"token operator\">=</span> obj1<span class=\"token punctuation\">[</span>propertyName<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> val2 <span class=\"token operator\">=</span> obj2<span class=\"token punctuation\">[</span>propertyName<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>val1 <span class=\"token operator\">&lt;</span> val2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>val1 <span class=\"token operator\">></span> val2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 调用函数，并传递参数；</span>\n<span class=\"token keyword\">var</span> data <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">{</span> name<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Zachary\"</span><span class=\"token punctuation\">,</span> age<span class=\"token punctuation\">:</span><span class=\"token number\">28</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> name<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Nicholas\"</span><span class=\"token punctuation\">,</span> age<span class=\"token punctuation\">:</span> <span class=\"token number\">29</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\ndata<span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span><span class=\"token function\">createComparisonFunction</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"name\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>JavaScript 的 <code>sort</code> 函数接受一个带有两个参数的函数用来自定义排序顺序。通过该函数返回的不同值来排列给定数组中的元素。上述代码中 <code>createComparisonFunction</code> 方法返回一个带有两个参数的函数供 <code>sort</code> 函数使用，在 <code>createComparisonFunction</code> 方法中按照用户指定的键来返回不同的排列函数。因此，每一个返回的匿名函数都是根据该方法和用户指定的键属性来动态生成的。</p>\n<ol start=\"2\">\n<li><code>arguments</code> 对象：该对象除了可以获得传入函数的所有参数之外，它还有一个名为 <code>callee</code> 的属性，该属性是一个指针类型，指向拥有这个 <code>arguments</code> 对象的函数本身。一般我们可以在递归函数中使用此属性，示例代码如下。</li>\n</ol>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">factorial</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>num <span class=\"token operator\">&lt;=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 此处的 arguments.callee 跟直接调用 factorial 函数效果相同；</span>\n    <span class=\"token keyword\">return</span> num <span class=\"token operator\">*</span> arguments<span class=\"token punctuation\">.</span><span class=\"token function\">callee</span><span class=\"token punctuation\">(</span>num <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ol start=\"3\">\n<li><p><code>caller</code> 属性：在 ECMAScript5 中终于规范化了该属性，<code>caller</code> 属性中保存着调用当前函数的函数引用，该引用即指向调用当前函数的函数体。如果当前函数是在 <code>window</code> 作用域被调用，则该属性返回 <code>null</code>。一般为了实现松耦合，我们采用 <code>arguments.callee.caller</code> 的方式来代替 <code>object.caller</code> 方式调用该属性（此处 <code>object</code> 指代具体的函数对象）。</p>\n</li>\n<li><p>使用 <code>call()</code> 和 <code>apply()</code> 来扩大作用域：这两个函数的基本作用都是在特定的作用域环境内调用其它函数，简单的说就是在其他环境下传递不同的参数，但它们的真正作用并非如此。我们可以用这两个函数来扩大函数运行的作用域，并保持对象与函数本身之间没有任何耦合，示例代码如下。</p>\n</li>\n</ol>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\">window<span class=\"token punctuation\">.</span>color <span class=\"token operator\">=</span> <span class=\"token string\">\"red\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> o <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> color<span class=\"token punctuation\">:</span> <span class=\"token string\">\"blue\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">sayColor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>color<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nsayColor<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nsayColor<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nsayColor<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>o<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 在对象 o 的 this 环境内调用方法 sayColor；</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 使用 ECMAScript5 中定义的新函数 bind 来绑定 sayColor 内的 this 环境到对象 o 上；</span>\n<span class=\"token keyword\">var</span> objSayColor <span class=\"token operator\">=</span> sayColor<span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span>o<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">objSayColor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ol start=\"5\">\n<li>不要使用 <code>Boolean</code> 对象：JavaScript 中提供很多基本类型的包装类，即对应基本类型的引用类型，使用时需要用 <code>new</code> 关键字来创建包装类型。而 <code>Boolean</code> 类型在 ECMAScript 中的用处不大。如下代码所示，使用 <code>Boolean</code> 对象常常会出现奇怪的现象给程序调试和扩展带来困难，所以不推荐使用。</li>\n</ol>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> falseObject <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Boolean</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> result <span class=\"token operator\">=</span> falseObject <span class=\"token operator\">&amp;&amp;</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 输出 true；</span>\n\n<span class=\"token keyword\">var</span> falseObject <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> result <span class=\"token operator\">=</span> falseObject <span class=\"token operator\">&amp;&amp;</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 输出 false；</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ol start=\"6\">\n<li>不要使用 <code>Number</code> 对象：<code>Number</code> 对象和普通的整数变量在 <code>instanceof</code> 和 <code>typeof</code> 函数中会出现不一致的现象（一个为 Number 类型，一个为 Object 类型），所以同样不推荐使用。</li>\n</ol>\n","site":{"data":{}},"id":"2bea56386b481eb8df2fe28a2f947e54","excerpt":"","more":"<p>本文是《JavaScript 核心特性揭秘》系列的第二篇，这一系列的文章并没有按照由浅入深的顺序来写，旨在记录与分享，将碎片化的 JS 知识集中起来。囊括所有你需要知道的 Javascript 核心特性与技巧。文章内容如有错误，欢迎大家积极指正与交流。</p>\n<ol>\n<li>从一个函数中返回另一个函数，这是一个常用的技巧。参考《Javascript高级程序设计》给出的示例代码：</li>\n</ol>\n<pre><code class=\"javascript\">function createComparisonFunction(propertyName) {\n  return function(obj1, obj2) {\n    var val1 = obj1[propertyName];\n    var val2 = obj2[propertyName];\n    if (val1 &lt; val2) {\n      return -1;\n    } else if (val1 &gt; val2) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n}\n\n// 调用函数，并传递参数；\nvar data = [{ name: &quot;Zachary&quot;, age:28 }, { name: &quot;Nicholas&quot;, age: 29 }];\n\ndata.sort(createComparisonFunction(&quot;name&quot;));\nconsole.log(data);\n</code></pre>\n<p>JavaScript 的 <code>sort</code> 函数接受一个带有两个参数的函数用来自定义排序顺序。通过该函数返回的不同值来排列给定数组中的元素。上述代码中 <code>createComparisonFunction</code> 方法返回一个带有两个参数的函数供 <code>sort</code> 函数使用，在 <code>createComparisonFunction</code> 方法中按照用户指定的键来返回不同的排列函数。因此，每一个返回的匿名函数都是根据该方法和用户指定的键属性来动态生成的。</p>\n<ol start=\"2\">\n<li><code>arguments</code> 对象：该对象除了可以获得传入函数的所有参数之外，它还有一个名为 <code>callee</code> 的属性，该属性是一个指针类型，指向拥有这个 <code>arguments</code> 对象的函数本身。一般我们可以在递归函数中使用此属性，示例代码如下。</li>\n</ol>\n<pre><code class=\"javascript\">function factorial(num) {\n  if (num &lt;= 1) {\n    return 1;\n  } else {\n    // 此处的 arguments.callee 跟直接调用 factorial 函数效果相同；\n    return num * arguments.callee(num - 1);  \n  }\n}\n</code></pre>\n<ol start=\"3\">\n<li><p><code>caller</code> 属性：在 ECMAScript5 中终于规范化了该属性，<code>caller</code> 属性中保存着调用当前函数的函数引用，该引用即指向调用当前函数的函数体。如果当前函数是在 <code>window</code> 作用域被调用，则该属性返回 <code>null</code>。一般为了实现松耦合，我们采用 <code>arguments.callee.caller</code> 的方式来代替 <code>object.caller</code> 方式调用该属性（此处 <code>object</code> 指代具体的函数对象）。</p>\n</li>\n<li><p>使用 <code>call()</code> 和 <code>apply()</code> 来扩大作用域：这两个函数的基本作用都是在特定的作用域环境内调用其它函数，简单的说就是在其他环境下传递不同的参数，但它们的真正作用并非如此。我们可以用这两个函数来扩大函数运行的作用域，并保持对象与函数本身之间没有任何耦合，示例代码如下。</p>\n</li>\n</ol>\n<pre><code class=\"javascript\">window.color = &quot;red&quot;;\nvar o = { color: &quot;blue&quot; };\n\nfunction sayColor() {\n  console.log(this.color);\n}\n\nsayColor.call(this);\nsayColor.call(window);\nsayColor.call(o);  // 在对象 o 的 this 环境内调用方法 sayColor；\n\n// 使用 ECMAScript5 中定义的新函数 bind 来绑定 sayColor 内的 this 环境到对象 o 上；\nvar objSayColor = sayColor.bind(o);\nobjSayColor();\n</code></pre>\n<ol start=\"5\">\n<li>不要使用 <code>Boolean</code> 对象：JavaScript 中提供很多基本类型的包装类，即对应基本类型的引用类型，使用时需要用 <code>new</code> 关键字来创建包装类型。而 <code>Boolean</code> 类型在 ECMAScript 中的用处不大。如下代码所示，使用 <code>Boolean</code> 对象常常会出现奇怪的现象给程序调试和扩展带来困难，所以不推荐使用。</li>\n</ol>\n<pre><code class=\"javascript\">var falseObject = new Boolean(false);\nvar result = falseObject &amp;&amp; true;\nconsole.log(result);  // 输出 true；\n\nvar falseObject = false;\nvar result = falseObject &amp;&amp; true;\nconsole.log(result);  // 输出 false；\n</code></pre>\n<ol start=\"6\">\n<li>不要使用 <code>Number</code> 对象：<code>Number</code> 对象和普通的整数变量在 <code>instanceof</code> 和 <code>typeof</code> 函数中会出现不一致的现象（一个为 Number 类型，一个为 Object 类型），所以同样不推荐使用。</li>\n</ol>\n"},{"title":"JavaScript 核心特性揭秘（三）","intro":"本文是《JavaScript 核心特性揭秘》系列的第三篇，我们将继续沿着 JavaScript 的核心特性向下探索。JS 天生并不具备诸如“类”，“继承”等一系列专用于面向对象开发（OOP）的特性，那么该如何在 JS 中尽量“完美”地进行面向对象开发呢？如何封装对象？本文将给出答案。","comments":1,"date":"2016-04-03T10:41:27.000Z","_content":"\n本文是《JavaScript 核心特性揭秘》系列的第三篇，我们将继续沿着 JavaScript 的核心特性向下探索。JS 天生并不具备诸如“**类**”，“**继承**”等一系列专用于面向对象开发（OOP）的特性，那么该如何在 JS 中尽量“完美”地进行面向对象开发呢？如何封装对象？本文将给出答案。\n\nJavaScript 本身并不支持**类**这种面向对象开发专有的数据结构，但是却存在**对象**这种数据类型。我们可以通过如下所示的两种方式代码来生成一个对象，并为对象添加相应的属性和方法：（第一种方式为使用 `new` 操作符和 `Object()` 构造函数来直接生成对象，第二种方式为使用对象字面量表示法来直接生成对象，两种方式没有任何区别）但更加推荐使用第二种方式。\n\n```javascript\nvar person = new Object();  // 通过 new 操作符生成一个 Object 对象实例，并将引用 person 指向此对象；\nperson.name = \"JASON\";  // 为 person 指向的对象添加属性；\nperson.age = 23;\nperson.job = \"Engineer\";\nperson.sayName = function() {  // 为 person 指向的对象添加方法；\n  console.log(this.name);\n}\n\n// 调用对象上的方法；\nperson.sayName();\n```\n\n使用字面量的方式生成对象：\n\n```javascript\nvar person = {\n  name: \"Jason\",\n  age: 23,\n  job: \"Engineer\",\n  sayName: function() {\n    console.log(this.name);        \n  }\n}\n\n// 调用对象上的方法；\nperson.sayName();\n```\n\n虽然 JS 本身提供了**对象**这种数据类型，但直接使用 `Object` 并不符合面向对象程序设计的基本准则即**继承**，**封装**和**多态**。从某种意义上来看，直接使用 `Object()` 构造函数生成对象仅仅符合了面向对象中“封装”的特性。不仅如此，这种方式在处理不同对象间的相同方法或逻辑时，需要写下两遍相同的逻辑代码，并没有符合“**复用**”的特性，只是仅仅从名字上符合了“对象”这一称号。这里顺便提一下，在 ECMAScpit5 中定义了可以设置对象中属性相关特性的方法 `Object.defineProperties`，使用方法如下：\n\n```javascript\nvar person = {};  // 声明一个空对象；\nObject.defineProperty(person, \"name\", {   // 为对象添加属性，第一个参数为对象名；第二个参数为添加的属性名；第三个参数为一个属性描述对象；\n  writable: false,   // 设置该参数是否可以被改变；\n  value: \"Anny\",    // 设置该参数的值；\n  enumerable: false,    // 设置该参数是否可以通过 for-in 遍历出来；\n  configurable: true    // 设置该参数是否可以通过 delete 操作符删除；\n});\n```\n\n为了符合“**复用**”的特性，我们可以使用“工厂模式”将上述构造对象的流程进行封装，每次返回一个封装好的对象进行使用，但这并没有从根本上解决问题 - 我们怎样才能够区分不同的对象？怎样知道他们的类型？上述所有的对象都是从直接使用 `Object()` 构造函数生成的，并且生成的对象之间不能够互相继承，两个对象之间也没有任何关系。为此，我们又提出了另一种封装模式：“**构造函数模式**”。我们将上述例子用“构造函数模式”重写如下：\n\n```javascript\nfunction Person(name, age, job) {\n  this.name = name;\n  this.age = age;\n  this.job = job;\n  this.sayName = function() {\n    console.log(this.name);        \n  }\n}\n\n// 生成对象，并调用对象上的方法；\nvar person1 = new Person(\"Anny\", 15, \"student\");\nvar person2 = new Person(\"Alice\", 29, \"teacher\");\n\nperson1.sayName();\nperson2.sayName();\n```\n\n我们此处用 `function` 关键字创建了自定义的构造函数和该构造函数所持有的方法和属性，不再直接使用 `Object()` 构造函数生成对象。（请注意在 JS 中构造函即函数，两者没有本质的区别，只是调用的方式不同而已）接下来通过 `new` 操作符创建该构造函数所对用的对象实例，并且调用对象所持有的方法。“**构造函数模式**”与文章开篇我们讲解的直接使用 `Object()` 创建对象的方法相比较有一个优点，即对于使用“**构造函数模式**”生成的每一个对象，我们都可以使用对象实例的 `instanceof` 方法或者 `constructor` 属性来判断该对象所对应的类型，如下代码所示：\n\n```javascript\n// 自定义构造函数；\nfunction Person(){}\nfunction Animal(){}\n\n// 生成对象；\nvar person = new Person();\nvar animal = new Animal();\n\n// 获得对象类型（constructor 属性会返回该实例所对应的构造函数本身）；\nconsole.log(person.constructor === Person);  // 输出 true；\nconsole.log(animal.constructor === Animal);  // 输出 true；\n\n// 获得对象类型（instanceof 方法判断该实例是否是从指定的构造函数生成的）；\nconsole.log(person instanceof Person);  // 输出 true；\nconsole.log(animal instanceof Animal);  // 输出 true；\n```\n\n事情到这里并没有结束，“**构造函数模式**” 也存在着自身的缺点与不足，比如从同一个构造函数生成的两个对象间并不能共享方法。也就是说，虽然两个对象是从同一个构造函数生成的，但是这两个对象内部的方法并不是只有一份拷贝，而是有两份拷贝（即两个函数对象）。同理，如果生成三个对象，则这三个对象内部的函数各有自己的一份拷贝。这样在生成大量对象实例时就会造成内存浪费的问题。（对象内部的方法逻辑都是同样的，但是却有多个拷贝）并且，这些不同对象实例上的同名同逻辑的函数也并不相等。为此，我们又提出了“**原型模式**”，代码如下所示：\n\n```javascript\n// 自定义构造函数；\nfunction Person(){}\nPerson.prototype.name = \"Jason\";\nPerson.prototype.age = 23;\nPerson.prototype.job = \"Engineer\";\nPerson.prototype.sayName = function() {\n  console.log(this.name);        \n}\n\n// 生成对象；\nvar person1 = new Person();\nvar person2 = new Person();\nconsole.log(person1.sayName === person2.sayName);  // 输出 true；\n```\n\n“**原型模式**”是利用了每一个函数所持有的 `prototype` 属性来达到共享属性和方法的目的的。`prototype` 属性是一个指向函数原型对象的指针，在函数的原型对象里包含着所有实例共享的属性和方法（所谓共享，即不会随着对象的实例化产生多个共享属性或方法的副本，而是多个对象共享同一个方法或属性实例）。在原型对象中不仅包含了所有共享的属性和方法，其中还有一个 `constructor` 属性指向了该原型对象所在函数。“**原型模式**”也可以采用如下写法，但需注意该写法会将原型对象中的 `constructor` 属性重置，因此需要手动将其修正，如下所示：\n\n```javascript\n// 自定义构造函数；\nfunction Person(){}\nPerson.prototype = {\n  constructor: Person,  // 修正 constructor 指向的值；\n  name: \"Jason\",\n  age: 23,\n  job: \"Engineer\",\n  sayName: function() {\n    console.log(this.name);        \n  }\n}\n\n// 生成对象；\nvar person1 = new Person();\n```\n\n“**原型模式**”可以解决多个对象实例之间共享属性和方法的问题，即多个对象间共享属性和方法时只产生一份属性和方法的实例。但一般我们并不单独使用“**原型模式**”，因为对于一般的对象实例来说，实例所持有的方法是共享的（所有实例的方法签名和逻辑都是相同的），但是属性却是可以进行自定义的。但是单独使用“**原型模式**”并不能实行对象属性的“本地化”。因此我们将“构造函数模式”和“原型模式”进行组合，产生了“混合模式”，即将对象的函数共享，属性本地化。示例代码如下：\n\n```javascript\n// 自定义构造函数，添加本地化属性，每个对象有自己的属性，并不共享；\nfunction Person(name, age, job){\n  this.name = name;\n  this.age = age;\n  this.job = job;\n}\n\n// 在原型对象中添加共享的方法，方法的签名和逻辑在所有对象中保持一致；\nPerson.prototype = {\n  constructor: Person,  // 修正 constructor 指向的值；\n  sayName: function() {\n    console.log(this.name);        \n  }\n}\n\n// 生成对象，并调用对象方法；\nvar person1 = new Person(\"Anny\", 15, \"student\");\nvar person2 = new Person(\"Alice\", 29, \"teacher\");\n\nconsole.log(person1.name === person2.name);  //输出 false；\nconsole.log(person1.sayName === person2.sayName);  // 输出 true；\n```\n\n这种“**混合模式**”是一种比较常用的构造对象的模式，它汲取了“构造函数模式”和“原型模式”各自的优点。下面给出完整的在Js中构建以及封装对象的实例代码，在代码中我们加入了定义静态变量及静态方法的部分。在 JS 中定义静态变量或静态属性可以理解为直接给函数本身添加属性或方法，即添加的属性或方法与函数的 `prototype` 属性处于同一层次，这与通过函数产生的对象没有任何关系。\n\n```javascript\n// 自定义构造函数，添加本地化属性，每个对象有自己的属性，并不共享；\nfunction Person(name, age, job) {\n  // 定义公有变量；\n  if (typeof(name) != \"undefined\")\n    this.name = name;\n  if (typeof(age) != \"undefined\")\n    this.age = age;\n  if (typeof(job) != \"undefined\")\n    this.job = job;\n}\n\n// 定义静态变量；\nPerson.staticVar = \"This is a static variable\";\n// 定义静态方法；\nPerson.staticFunc = function() {\n  console.log(\"This is a static function\");   \n}\n\n// 在原型对象中添加共享的（公有）方法和默认的属性值，方法的签名和逻辑在所有对象中保持一致；\nPerson.prototype = {\n  name: \"defaultName\",\n  age: \"defaultAge\",\n  job: \"defaultJob\",\n  constructor: Person,  // 修正 constructor 指向的值；\n  sayName: function() {\n    console.log(this.name);        \n  },\n  getFlag: function() {\n    console.log(this.flag);        \n  }\n};\n\n// 生成对象，传递参数；\nvar person1 = new Person(\"Anny\", 15, \"student\");\n// 生成对象，不传递参数，使用默认值；\nvar person2 = new Person();\n\nconsole.log(person1.name === person2.name);  //输出 false；\nconsole.log(person1.sayName === person2.sayName);  // 输出 true；\n\n// 调用静态方法；\nPerson.staticFunc();\n```\n\n","source":"_posts/JavaScript-核心特性揭秘（三）.md","raw":"---\ntitle: JavaScript 核心特性揭秘（三）\nintro: 本文是《JavaScript 核心特性揭秘》系列的第三篇，我们将继续沿着 JavaScript 的核心特性向下探索。JS 天生并不具备诸如“类”，“继承”等一系列专用于面向对象开发（OOP）的特性，那么该如何在 JS 中尽量“完美”地进行面向对象开发呢？如何封装对象？本文将给出答案。\ncomments: true\ndate: 2016-04-03 18:41:27\ntags:\n- JavaScript\n---\n\n本文是《JavaScript 核心特性揭秘》系列的第三篇，我们将继续沿着 JavaScript 的核心特性向下探索。JS 天生并不具备诸如“**类**”，“**继承**”等一系列专用于面向对象开发（OOP）的特性，那么该如何在 JS 中尽量“完美”地进行面向对象开发呢？如何封装对象？本文将给出答案。\n\nJavaScript 本身并不支持**类**这种面向对象开发专有的数据结构，但是却存在**对象**这种数据类型。我们可以通过如下所示的两种方式代码来生成一个对象，并为对象添加相应的属性和方法：（第一种方式为使用 `new` 操作符和 `Object()` 构造函数来直接生成对象，第二种方式为使用对象字面量表示法来直接生成对象，两种方式没有任何区别）但更加推荐使用第二种方式。\n\n```javascript\nvar person = new Object();  // 通过 new 操作符生成一个 Object 对象实例，并将引用 person 指向此对象；\nperson.name = \"JASON\";  // 为 person 指向的对象添加属性；\nperson.age = 23;\nperson.job = \"Engineer\";\nperson.sayName = function() {  // 为 person 指向的对象添加方法；\n  console.log(this.name);\n}\n\n// 调用对象上的方法；\nperson.sayName();\n```\n\n使用字面量的方式生成对象：\n\n```javascript\nvar person = {\n  name: \"Jason\",\n  age: 23,\n  job: \"Engineer\",\n  sayName: function() {\n    console.log(this.name);        \n  }\n}\n\n// 调用对象上的方法；\nperson.sayName();\n```\n\n虽然 JS 本身提供了**对象**这种数据类型，但直接使用 `Object` 并不符合面向对象程序设计的基本准则即**继承**，**封装**和**多态**。从某种意义上来看，直接使用 `Object()` 构造函数生成对象仅仅符合了面向对象中“封装”的特性。不仅如此，这种方式在处理不同对象间的相同方法或逻辑时，需要写下两遍相同的逻辑代码，并没有符合“**复用**”的特性，只是仅仅从名字上符合了“对象”这一称号。这里顺便提一下，在 ECMAScpit5 中定义了可以设置对象中属性相关特性的方法 `Object.defineProperties`，使用方法如下：\n\n```javascript\nvar person = {};  // 声明一个空对象；\nObject.defineProperty(person, \"name\", {   // 为对象添加属性，第一个参数为对象名；第二个参数为添加的属性名；第三个参数为一个属性描述对象；\n  writable: false,   // 设置该参数是否可以被改变；\n  value: \"Anny\",    // 设置该参数的值；\n  enumerable: false,    // 设置该参数是否可以通过 for-in 遍历出来；\n  configurable: true    // 设置该参数是否可以通过 delete 操作符删除；\n});\n```\n\n为了符合“**复用**”的特性，我们可以使用“工厂模式”将上述构造对象的流程进行封装，每次返回一个封装好的对象进行使用，但这并没有从根本上解决问题 - 我们怎样才能够区分不同的对象？怎样知道他们的类型？上述所有的对象都是从直接使用 `Object()` 构造函数生成的，并且生成的对象之间不能够互相继承，两个对象之间也没有任何关系。为此，我们又提出了另一种封装模式：“**构造函数模式**”。我们将上述例子用“构造函数模式”重写如下：\n\n```javascript\nfunction Person(name, age, job) {\n  this.name = name;\n  this.age = age;\n  this.job = job;\n  this.sayName = function() {\n    console.log(this.name);        \n  }\n}\n\n// 生成对象，并调用对象上的方法；\nvar person1 = new Person(\"Anny\", 15, \"student\");\nvar person2 = new Person(\"Alice\", 29, \"teacher\");\n\nperson1.sayName();\nperson2.sayName();\n```\n\n我们此处用 `function` 关键字创建了自定义的构造函数和该构造函数所持有的方法和属性，不再直接使用 `Object()` 构造函数生成对象。（请注意在 JS 中构造函即函数，两者没有本质的区别，只是调用的方式不同而已）接下来通过 `new` 操作符创建该构造函数所对用的对象实例，并且调用对象所持有的方法。“**构造函数模式**”与文章开篇我们讲解的直接使用 `Object()` 创建对象的方法相比较有一个优点，即对于使用“**构造函数模式**”生成的每一个对象，我们都可以使用对象实例的 `instanceof` 方法或者 `constructor` 属性来判断该对象所对应的类型，如下代码所示：\n\n```javascript\n// 自定义构造函数；\nfunction Person(){}\nfunction Animal(){}\n\n// 生成对象；\nvar person = new Person();\nvar animal = new Animal();\n\n// 获得对象类型（constructor 属性会返回该实例所对应的构造函数本身）；\nconsole.log(person.constructor === Person);  // 输出 true；\nconsole.log(animal.constructor === Animal);  // 输出 true；\n\n// 获得对象类型（instanceof 方法判断该实例是否是从指定的构造函数生成的）；\nconsole.log(person instanceof Person);  // 输出 true；\nconsole.log(animal instanceof Animal);  // 输出 true；\n```\n\n事情到这里并没有结束，“**构造函数模式**” 也存在着自身的缺点与不足，比如从同一个构造函数生成的两个对象间并不能共享方法。也就是说，虽然两个对象是从同一个构造函数生成的，但是这两个对象内部的方法并不是只有一份拷贝，而是有两份拷贝（即两个函数对象）。同理，如果生成三个对象，则这三个对象内部的函数各有自己的一份拷贝。这样在生成大量对象实例时就会造成内存浪费的问题。（对象内部的方法逻辑都是同样的，但是却有多个拷贝）并且，这些不同对象实例上的同名同逻辑的函数也并不相等。为此，我们又提出了“**原型模式**”，代码如下所示：\n\n```javascript\n// 自定义构造函数；\nfunction Person(){}\nPerson.prototype.name = \"Jason\";\nPerson.prototype.age = 23;\nPerson.prototype.job = \"Engineer\";\nPerson.prototype.sayName = function() {\n  console.log(this.name);        \n}\n\n// 生成对象；\nvar person1 = new Person();\nvar person2 = new Person();\nconsole.log(person1.sayName === person2.sayName);  // 输出 true；\n```\n\n“**原型模式**”是利用了每一个函数所持有的 `prototype` 属性来达到共享属性和方法的目的的。`prototype` 属性是一个指向函数原型对象的指针，在函数的原型对象里包含着所有实例共享的属性和方法（所谓共享，即不会随着对象的实例化产生多个共享属性或方法的副本，而是多个对象共享同一个方法或属性实例）。在原型对象中不仅包含了所有共享的属性和方法，其中还有一个 `constructor` 属性指向了该原型对象所在函数。“**原型模式**”也可以采用如下写法，但需注意该写法会将原型对象中的 `constructor` 属性重置，因此需要手动将其修正，如下所示：\n\n```javascript\n// 自定义构造函数；\nfunction Person(){}\nPerson.prototype = {\n  constructor: Person,  // 修正 constructor 指向的值；\n  name: \"Jason\",\n  age: 23,\n  job: \"Engineer\",\n  sayName: function() {\n    console.log(this.name);        \n  }\n}\n\n// 生成对象；\nvar person1 = new Person();\n```\n\n“**原型模式**”可以解决多个对象实例之间共享属性和方法的问题，即多个对象间共享属性和方法时只产生一份属性和方法的实例。但一般我们并不单独使用“**原型模式**”，因为对于一般的对象实例来说，实例所持有的方法是共享的（所有实例的方法签名和逻辑都是相同的），但是属性却是可以进行自定义的。但是单独使用“**原型模式**”并不能实行对象属性的“本地化”。因此我们将“构造函数模式”和“原型模式”进行组合，产生了“混合模式”，即将对象的函数共享，属性本地化。示例代码如下：\n\n```javascript\n// 自定义构造函数，添加本地化属性，每个对象有自己的属性，并不共享；\nfunction Person(name, age, job){\n  this.name = name;\n  this.age = age;\n  this.job = job;\n}\n\n// 在原型对象中添加共享的方法，方法的签名和逻辑在所有对象中保持一致；\nPerson.prototype = {\n  constructor: Person,  // 修正 constructor 指向的值；\n  sayName: function() {\n    console.log(this.name);        \n  }\n}\n\n// 生成对象，并调用对象方法；\nvar person1 = new Person(\"Anny\", 15, \"student\");\nvar person2 = new Person(\"Alice\", 29, \"teacher\");\n\nconsole.log(person1.name === person2.name);  //输出 false；\nconsole.log(person1.sayName === person2.sayName);  // 输出 true；\n```\n\n这种“**混合模式**”是一种比较常用的构造对象的模式，它汲取了“构造函数模式”和“原型模式”各自的优点。下面给出完整的在Js中构建以及封装对象的实例代码，在代码中我们加入了定义静态变量及静态方法的部分。在 JS 中定义静态变量或静态属性可以理解为直接给函数本身添加属性或方法，即添加的属性或方法与函数的 `prototype` 属性处于同一层次，这与通过函数产生的对象没有任何关系。\n\n```javascript\n// 自定义构造函数，添加本地化属性，每个对象有自己的属性，并不共享；\nfunction Person(name, age, job) {\n  // 定义公有变量；\n  if (typeof(name) != \"undefined\")\n    this.name = name;\n  if (typeof(age) != \"undefined\")\n    this.age = age;\n  if (typeof(job) != \"undefined\")\n    this.job = job;\n}\n\n// 定义静态变量；\nPerson.staticVar = \"This is a static variable\";\n// 定义静态方法；\nPerson.staticFunc = function() {\n  console.log(\"This is a static function\");   \n}\n\n// 在原型对象中添加共享的（公有）方法和默认的属性值，方法的签名和逻辑在所有对象中保持一致；\nPerson.prototype = {\n  name: \"defaultName\",\n  age: \"defaultAge\",\n  job: \"defaultJob\",\n  constructor: Person,  // 修正 constructor 指向的值；\n  sayName: function() {\n    console.log(this.name);        \n  },\n  getFlag: function() {\n    console.log(this.flag);        \n  }\n};\n\n// 生成对象，传递参数；\nvar person1 = new Person(\"Anny\", 15, \"student\");\n// 生成对象，不传递参数，使用默认值；\nvar person2 = new Person();\n\nconsole.log(person1.name === person2.name);  //输出 false；\nconsole.log(person1.sayName === person2.sayName);  // 输出 true；\n\n// 调用静态方法；\nPerson.staticFunc();\n```\n\n","slug":"JavaScript-核心特性揭秘（三）","published":1,"updated":"2019-02-05T11:04:43.135Z","layout":"post","photos":[],"link":"","_id":"cjsqwht8e001iknp2qi8qef23","content":"<p>本文是《JavaScript 核心特性揭秘》系列的第三篇，我们将继续沿着 JavaScript 的核心特性向下探索。JS 天生并不具备诸如“<strong>类</strong>”，“<strong>继承</strong>”等一系列专用于面向对象开发（OOP）的特性，那么该如何在 JS 中尽量“完美”地进行面向对象开发呢？如何封装对象？本文将给出答案。</p>\n<p>JavaScript 本身并不支持<strong>类</strong>这种面向对象开发专有的数据结构，但是却存在<strong>对象</strong>这种数据类型。我们可以通过如下所示的两种方式代码来生成一个对象，并为对象添加相应的属性和方法：（第一种方式为使用 <code>new</code> 操作符和 <code>Object()</code> 构造函数来直接生成对象，第二种方式为使用对象字面量表示法来直接生成对象，两种方式没有任何区别）但更加推荐使用第二种方式。</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> person <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 通过 new 操作符生成一个 Object 对象实例，并将引用 person 指向此对象；</span>\nperson<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">\"JASON\"</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 为 person 指向的对象添加属性；</span>\nperson<span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> <span class=\"token number\">23</span><span class=\"token punctuation\">;</span>\nperson<span class=\"token punctuation\">.</span>job <span class=\"token operator\">=</span> <span class=\"token string\">\"Engineer\"</span><span class=\"token punctuation\">;</span>\nperson<span class=\"token punctuation\">.</span>sayName <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  <span class=\"token comment\" spellcheck=\"true\">// 为 person 指向的对象添加方法；</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 调用对象上的方法；</span>\nperson<span class=\"token punctuation\">.</span><span class=\"token function\">sayName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>使用字面量的方式生成对象：</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> person <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Jason\"</span><span class=\"token punctuation\">,</span>\n  age<span class=\"token punctuation\">:</span> <span class=\"token number\">23</span><span class=\"token punctuation\">,</span>\n  job<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Engineer\"</span><span class=\"token punctuation\">,</span>\n  sayName<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>        \n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 调用对象上的方法；</span>\nperson<span class=\"token punctuation\">.</span><span class=\"token function\">sayName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>虽然 JS 本身提供了<strong>对象</strong>这种数据类型，但直接使用 <code>Object</code> 并不符合面向对象程序设计的基本准则即<strong>继承</strong>，<strong>封装</strong>和<strong>多态</strong>。从某种意义上来看，直接使用 <code>Object()</code> 构造函数生成对象仅仅符合了面向对象中“封装”的特性。不仅如此，这种方式在处理不同对象间的相同方法或逻辑时，需要写下两遍相同的逻辑代码，并没有符合“<strong>复用</strong>”的特性，只是仅仅从名字上符合了“对象”这一称号。这里顺便提一下，在 ECMAScpit5 中定义了可以设置对象中属性相关特性的方法 <code>Object.defineProperties</code>，使用方法如下：</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> person <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 声明一个空对象；</span>\nObject<span class=\"token punctuation\">.</span><span class=\"token function\">defineProperty</span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">,</span> <span class=\"token string\">\"name\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>   <span class=\"token comment\" spellcheck=\"true\">// 为对象添加属性，第一个参数为对象名；第二个参数为添加的属性名；第三个参数为一个属性描述对象；</span>\n  writable<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>   <span class=\"token comment\" spellcheck=\"true\">// 设置该参数是否可以被改变；</span>\n  value<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Anny\"</span><span class=\"token punctuation\">,</span>    <span class=\"token comment\" spellcheck=\"true\">// 设置该参数的值；</span>\n  enumerable<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>    <span class=\"token comment\" spellcheck=\"true\">// 设置该参数是否可以通过 for-in 遍历出来；</span>\n  configurable<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span>    <span class=\"token comment\" spellcheck=\"true\">// 设置该参数是否可以通过 delete 操作符删除；</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>为了符合“<strong>复用</strong>”的特性，我们可以使用“工厂模式”将上述构造对象的流程进行封装，每次返回一个封装好的对象进行使用，但这并没有从根本上解决问题 - 我们怎样才能够区分不同的对象？怎样知道他们的类型？上述所有的对象都是从直接使用 <code>Object()</code> 构造函数生成的，并且生成的对象之间不能够互相继承，两个对象之间也没有任何关系。为此，我们又提出了另一种封装模式：“<strong>构造函数模式</strong>”。我们将上述例子用“构造函数模式”重写如下：</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> age<span class=\"token punctuation\">,</span> job<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>job <span class=\"token operator\">=</span> job<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>sayName <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>        \n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 生成对象，并调用对象上的方法；</span>\n<span class=\"token keyword\">var</span> person1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Anny\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">15</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"student\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> person2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Alice\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">29</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"teacher\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nperson1<span class=\"token punctuation\">.</span><span class=\"token function\">sayName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nperson2<span class=\"token punctuation\">.</span><span class=\"token function\">sayName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>我们此处用 <code>function</code> 关键字创建了自定义的构造函数和该构造函数所持有的方法和属性，不再直接使用 <code>Object()</code> 构造函数生成对象。（请注意在 JS 中构造函即函数，两者没有本质的区别，只是调用的方式不同而已）接下来通过 <code>new</code> 操作符创建该构造函数所对用的对象实例，并且调用对象所持有的方法。“<strong>构造函数模式</strong>”与文章开篇我们讲解的直接使用 <code>Object()</code> 创建对象的方法相比较有一个优点，即对于使用“<strong>构造函数模式</strong>”生成的每一个对象，我们都可以使用对象实例的 <code>instanceof</code> 方法或者 <code>constructor</code> 属性来判断该对象所对应的类型，如下代码所示：</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">// 自定义构造函数；</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">Animal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 生成对象；</span>\n<span class=\"token keyword\">var</span> person <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> animal <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Animal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 获得对象类型（constructor 属性会返回该实例所对应的构造函数本身）；</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">.</span>constructor <span class=\"token operator\">===</span> Person<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 输出 true；</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>animal<span class=\"token punctuation\">.</span>constructor <span class=\"token operator\">===</span> Animal<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 输出 true；</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 获得对象类型（instanceof 方法判断该实例是否是从指定的构造函数生成的）；</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>person <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 输出 true；</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>animal <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Animal</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 输出 true；</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>事情到这里并没有结束，“<strong>构造函数模式</strong>” 也存在着自身的缺点与不足，比如从同一个构造函数生成的两个对象间并不能共享方法。也就是说，虽然两个对象是从同一个构造函数生成的，但是这两个对象内部的方法并不是只有一份拷贝，而是有两份拷贝（即两个函数对象）。同理，如果生成三个对象，则这三个对象内部的函数各有自己的一份拷贝。这样在生成大量对象实例时就会造成内存浪费的问题。（对象内部的方法逻辑都是同样的，但是却有多个拷贝）并且，这些不同对象实例上的同名同逻辑的函数也并不相等。为此，我们又提出了“<strong>原型模式</strong>”，代码如下所示：</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">// 自定义构造函数；</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\nPerson<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">\"Jason\"</span><span class=\"token punctuation\">;</span>\nPerson<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> <span class=\"token number\">23</span><span class=\"token punctuation\">;</span>\nPerson<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>job <span class=\"token operator\">=</span> <span class=\"token string\">\"Engineer\"</span><span class=\"token punctuation\">;</span>\nPerson<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>sayName <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>        \n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 生成对象；</span>\n<span class=\"token keyword\">var</span> person1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> person2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>person1<span class=\"token punctuation\">.</span>sayName <span class=\"token operator\">===</span> person2<span class=\"token punctuation\">.</span>sayName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 输出 true；</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>“<strong>原型模式</strong>”是利用了每一个函数所持有的 <code>prototype</code> 属性来达到共享属性和方法的目的的。<code>prototype</code> 属性是一个指向函数原型对象的指针，在函数的原型对象里包含着所有实例共享的属性和方法（所谓共享，即不会随着对象的实例化产生多个共享属性或方法的副本，而是多个对象共享同一个方法或属性实例）。在原型对象中不仅包含了所有共享的属性和方法，其中还有一个 <code>constructor</code> 属性指向了该原型对象所在函数。“<strong>原型模式</strong>”也可以采用如下写法，但需注意该写法会将原型对象中的 <code>constructor</code> 属性重置，因此需要手动将其修正，如下所示：</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">// 自定义构造函数；</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\nPerson<span class=\"token punctuation\">.</span>prototype <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  constructor<span class=\"token punctuation\">:</span> Person<span class=\"token punctuation\">,</span>  <span class=\"token comment\" spellcheck=\"true\">// 修正 constructor 指向的值；</span>\n  name<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Jason\"</span><span class=\"token punctuation\">,</span>\n  age<span class=\"token punctuation\">:</span> <span class=\"token number\">23</span><span class=\"token punctuation\">,</span>\n  job<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Engineer\"</span><span class=\"token punctuation\">,</span>\n  sayName<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>        \n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 生成对象；</span>\n<span class=\"token keyword\">var</span> person1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>“<strong>原型模式</strong>”可以解决多个对象实例之间共享属性和方法的问题，即多个对象间共享属性和方法时只产生一份属性和方法的实例。但一般我们并不单独使用“<strong>原型模式</strong>”，因为对于一般的对象实例来说，实例所持有的方法是共享的（所有实例的方法签名和逻辑都是相同的），但是属性却是可以进行自定义的。但是单独使用“<strong>原型模式</strong>”并不能实行对象属性的“本地化”。因此我们将“构造函数模式”和“原型模式”进行组合，产生了“混合模式”，即将对象的函数共享，属性本地化。示例代码如下：</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">// 自定义构造函数，添加本地化属性，每个对象有自己的属性，并不共享；</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> age<span class=\"token punctuation\">,</span> job<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>job <span class=\"token operator\">=</span> job<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 在原型对象中添加共享的方法，方法的签名和逻辑在所有对象中保持一致；</span>\nPerson<span class=\"token punctuation\">.</span>prototype <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  constructor<span class=\"token punctuation\">:</span> Person<span class=\"token punctuation\">,</span>  <span class=\"token comment\" spellcheck=\"true\">// 修正 constructor 指向的值；</span>\n  sayName<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>        \n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 生成对象，并调用对象方法；</span>\n<span class=\"token keyword\">var</span> person1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Anny\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">15</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"student\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> person2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Alice\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">29</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"teacher\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>person1<span class=\"token punctuation\">.</span>name <span class=\"token operator\">===</span> person2<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">//输出 false；</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>person1<span class=\"token punctuation\">.</span>sayName <span class=\"token operator\">===</span> person2<span class=\"token punctuation\">.</span>sayName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 输出 true；</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这种“<strong>混合模式</strong>”是一种比较常用的构造对象的模式，它汲取了“构造函数模式”和“原型模式”各自的优点。下面给出完整的在Js中构建以及封装对象的实例代码，在代码中我们加入了定义静态变量及静态方法的部分。在 JS 中定义静态变量或静态属性可以理解为直接给函数本身添加属性或方法，即添加的属性或方法与函数的 <code>prototype</code> 属性处于同一层次，这与通过函数产生的对象没有任何关系。</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">// 自定义构造函数，添加本地化属性，每个对象有自己的属性，并不共享；</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> age<span class=\"token punctuation\">,</span> job<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 定义公有变量；</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token string\">\"undefined\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span><span class=\"token punctuation\">(</span>age<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token string\">\"undefined\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span><span class=\"token punctuation\">(</span>job<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token string\">\"undefined\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>job <span class=\"token operator\">=</span> job<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 定义静态变量；</span>\nPerson<span class=\"token punctuation\">.</span>staticVar <span class=\"token operator\">=</span> <span class=\"token string\">\"This is a static variable\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// 定义静态方法；</span>\nPerson<span class=\"token punctuation\">.</span>staticFunc <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"This is a static function\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   \n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 在原型对象中添加共享的（公有）方法和默认的属性值，方法的签名和逻辑在所有对象中保持一致；</span>\nPerson<span class=\"token punctuation\">.</span>prototype <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token punctuation\">:</span> <span class=\"token string\">\"defaultName\"</span><span class=\"token punctuation\">,</span>\n  age<span class=\"token punctuation\">:</span> <span class=\"token string\">\"defaultAge\"</span><span class=\"token punctuation\">,</span>\n  job<span class=\"token punctuation\">:</span> <span class=\"token string\">\"defaultJob\"</span><span class=\"token punctuation\">,</span>\n  constructor<span class=\"token punctuation\">:</span> Person<span class=\"token punctuation\">,</span>  <span class=\"token comment\" spellcheck=\"true\">// 修正 constructor 指向的值；</span>\n  sayName<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>        \n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  getFlag<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>flag<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>        \n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 生成对象，传递参数；</span>\n<span class=\"token keyword\">var</span> person1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Anny\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">15</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"student\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// 生成对象，不传递参数，使用默认值；</span>\n<span class=\"token keyword\">var</span> person2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>person1<span class=\"token punctuation\">.</span>name <span class=\"token operator\">===</span> person2<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">//输出 false；</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>person1<span class=\"token punctuation\">.</span>sayName <span class=\"token operator\">===</span> person2<span class=\"token punctuation\">.</span>sayName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 输出 true；</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 调用静态方法；</span>\nPerson<span class=\"token punctuation\">.</span><span class=\"token function\">staticFunc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"id":"27c56e75e05c02e56d9c990ab27c41a0","excerpt":"","more":"<p>本文是《JavaScript 核心特性揭秘》系列的第三篇，我们将继续沿着 JavaScript 的核心特性向下探索。JS 天生并不具备诸如“<strong>类</strong>”，“<strong>继承</strong>”等一系列专用于面向对象开发（OOP）的特性，那么该如何在 JS 中尽量“完美”地进行面向对象开发呢？如何封装对象？本文将给出答案。</p>\n<p>JavaScript 本身并不支持<strong>类</strong>这种面向对象开发专有的数据结构，但是却存在<strong>对象</strong>这种数据类型。我们可以通过如下所示的两种方式代码来生成一个对象，并为对象添加相应的属性和方法：（第一种方式为使用 <code>new</code> 操作符和 <code>Object()</code> 构造函数来直接生成对象，第二种方式为使用对象字面量表示法来直接生成对象，两种方式没有任何区别）但更加推荐使用第二种方式。</p>\n<pre><code class=\"javascript\">var person = new Object();  // 通过 new 操作符生成一个 Object 对象实例，并将引用 person 指向此对象；\nperson.name = &quot;JASON&quot;;  // 为 person 指向的对象添加属性；\nperson.age = 23;\nperson.job = &quot;Engineer&quot;;\nperson.sayName = function() {  // 为 person 指向的对象添加方法；\n  console.log(this.name);\n}\n\n// 调用对象上的方法；\nperson.sayName();\n</code></pre>\n<p>使用字面量的方式生成对象：</p>\n<pre><code class=\"javascript\">var person = {\n  name: &quot;Jason&quot;,\n  age: 23,\n  job: &quot;Engineer&quot;,\n  sayName: function() {\n    console.log(this.name);        \n  }\n}\n\n// 调用对象上的方法；\nperson.sayName();\n</code></pre>\n<p>虽然 JS 本身提供了<strong>对象</strong>这种数据类型，但直接使用 <code>Object</code> 并不符合面向对象程序设计的基本准则即<strong>继承</strong>，<strong>封装</strong>和<strong>多态</strong>。从某种意义上来看，直接使用 <code>Object()</code> 构造函数生成对象仅仅符合了面向对象中“封装”的特性。不仅如此，这种方式在处理不同对象间的相同方法或逻辑时，需要写下两遍相同的逻辑代码，并没有符合“<strong>复用</strong>”的特性，只是仅仅从名字上符合了“对象”这一称号。这里顺便提一下，在 ECMAScpit5 中定义了可以设置对象中属性相关特性的方法 <code>Object.defineProperties</code>，使用方法如下：</p>\n<pre><code class=\"javascript\">var person = {};  // 声明一个空对象；\nObject.defineProperty(person, &quot;name&quot;, {   // 为对象添加属性，第一个参数为对象名；第二个参数为添加的属性名；第三个参数为一个属性描述对象；\n  writable: false,   // 设置该参数是否可以被改变；\n  value: &quot;Anny&quot;,    // 设置该参数的值；\n  enumerable: false,    // 设置该参数是否可以通过 for-in 遍历出来；\n  configurable: true    // 设置该参数是否可以通过 delete 操作符删除；\n});\n</code></pre>\n<p>为了符合“<strong>复用</strong>”的特性，我们可以使用“工厂模式”将上述构造对象的流程进行封装，每次返回一个封装好的对象进行使用，但这并没有从根本上解决问题 - 我们怎样才能够区分不同的对象？怎样知道他们的类型？上述所有的对象都是从直接使用 <code>Object()</code> 构造函数生成的，并且生成的对象之间不能够互相继承，两个对象之间也没有任何关系。为此，我们又提出了另一种封装模式：“<strong>构造函数模式</strong>”。我们将上述例子用“构造函数模式”重写如下：</p>\n<pre><code class=\"javascript\">function Person(name, age, job) {\n  this.name = name;\n  this.age = age;\n  this.job = job;\n  this.sayName = function() {\n    console.log(this.name);        \n  }\n}\n\n// 生成对象，并调用对象上的方法；\nvar person1 = new Person(&quot;Anny&quot;, 15, &quot;student&quot;);\nvar person2 = new Person(&quot;Alice&quot;, 29, &quot;teacher&quot;);\n\nperson1.sayName();\nperson2.sayName();\n</code></pre>\n<p>我们此处用 <code>function</code> 关键字创建了自定义的构造函数和该构造函数所持有的方法和属性，不再直接使用 <code>Object()</code> 构造函数生成对象。（请注意在 JS 中构造函即函数，两者没有本质的区别，只是调用的方式不同而已）接下来通过 <code>new</code> 操作符创建该构造函数所对用的对象实例，并且调用对象所持有的方法。“<strong>构造函数模式</strong>”与文章开篇我们讲解的直接使用 <code>Object()</code> 创建对象的方法相比较有一个优点，即对于使用“<strong>构造函数模式</strong>”生成的每一个对象，我们都可以使用对象实例的 <code>instanceof</code> 方法或者 <code>constructor</code> 属性来判断该对象所对应的类型，如下代码所示：</p>\n<pre><code class=\"javascript\">// 自定义构造函数；\nfunction Person(){}\nfunction Animal(){}\n\n// 生成对象；\nvar person = new Person();\nvar animal = new Animal();\n\n// 获得对象类型（constructor 属性会返回该实例所对应的构造函数本身）；\nconsole.log(person.constructor === Person);  // 输出 true；\nconsole.log(animal.constructor === Animal);  // 输出 true；\n\n// 获得对象类型（instanceof 方法判断该实例是否是从指定的构造函数生成的）；\nconsole.log(person instanceof Person);  // 输出 true；\nconsole.log(animal instanceof Animal);  // 输出 true；\n</code></pre>\n<p>事情到这里并没有结束，“<strong>构造函数模式</strong>” 也存在着自身的缺点与不足，比如从同一个构造函数生成的两个对象间并不能共享方法。也就是说，虽然两个对象是从同一个构造函数生成的，但是这两个对象内部的方法并不是只有一份拷贝，而是有两份拷贝（即两个函数对象）。同理，如果生成三个对象，则这三个对象内部的函数各有自己的一份拷贝。这样在生成大量对象实例时就会造成内存浪费的问题。（对象内部的方法逻辑都是同样的，但是却有多个拷贝）并且，这些不同对象实例上的同名同逻辑的函数也并不相等。为此，我们又提出了“<strong>原型模式</strong>”，代码如下所示：</p>\n<pre><code class=\"javascript\">// 自定义构造函数；\nfunction Person(){}\nPerson.prototype.name = &quot;Jason&quot;;\nPerson.prototype.age = 23;\nPerson.prototype.job = &quot;Engineer&quot;;\nPerson.prototype.sayName = function() {\n  console.log(this.name);        \n}\n\n// 生成对象；\nvar person1 = new Person();\nvar person2 = new Person();\nconsole.log(person1.sayName === person2.sayName);  // 输出 true；\n</code></pre>\n<p>“<strong>原型模式</strong>”是利用了每一个函数所持有的 <code>prototype</code> 属性来达到共享属性和方法的目的的。<code>prototype</code> 属性是一个指向函数原型对象的指针，在函数的原型对象里包含着所有实例共享的属性和方法（所谓共享，即不会随着对象的实例化产生多个共享属性或方法的副本，而是多个对象共享同一个方法或属性实例）。在原型对象中不仅包含了所有共享的属性和方法，其中还有一个 <code>constructor</code> 属性指向了该原型对象所在函数。“<strong>原型模式</strong>”也可以采用如下写法，但需注意该写法会将原型对象中的 <code>constructor</code> 属性重置，因此需要手动将其修正，如下所示：</p>\n<pre><code class=\"javascript\">// 自定义构造函数；\nfunction Person(){}\nPerson.prototype = {\n  constructor: Person,  // 修正 constructor 指向的值；\n  name: &quot;Jason&quot;,\n  age: 23,\n  job: &quot;Engineer&quot;,\n  sayName: function() {\n    console.log(this.name);        \n  }\n}\n\n// 生成对象；\nvar person1 = new Person();\n</code></pre>\n<p>“<strong>原型模式</strong>”可以解决多个对象实例之间共享属性和方法的问题，即多个对象间共享属性和方法时只产生一份属性和方法的实例。但一般我们并不单独使用“<strong>原型模式</strong>”，因为对于一般的对象实例来说，实例所持有的方法是共享的（所有实例的方法签名和逻辑都是相同的），但是属性却是可以进行自定义的。但是单独使用“<strong>原型模式</strong>”并不能实行对象属性的“本地化”。因此我们将“构造函数模式”和“原型模式”进行组合，产生了“混合模式”，即将对象的函数共享，属性本地化。示例代码如下：</p>\n<pre><code class=\"javascript\">// 自定义构造函数，添加本地化属性，每个对象有自己的属性，并不共享；\nfunction Person(name, age, job){\n  this.name = name;\n  this.age = age;\n  this.job = job;\n}\n\n// 在原型对象中添加共享的方法，方法的签名和逻辑在所有对象中保持一致；\nPerson.prototype = {\n  constructor: Person,  // 修正 constructor 指向的值；\n  sayName: function() {\n    console.log(this.name);        \n  }\n}\n\n// 生成对象，并调用对象方法；\nvar person1 = new Person(&quot;Anny&quot;, 15, &quot;student&quot;);\nvar person2 = new Person(&quot;Alice&quot;, 29, &quot;teacher&quot;);\n\nconsole.log(person1.name === person2.name);  //输出 false；\nconsole.log(person1.sayName === person2.sayName);  // 输出 true；\n</code></pre>\n<p>这种“<strong>混合模式</strong>”是一种比较常用的构造对象的模式，它汲取了“构造函数模式”和“原型模式”各自的优点。下面给出完整的在Js中构建以及封装对象的实例代码，在代码中我们加入了定义静态变量及静态方法的部分。在 JS 中定义静态变量或静态属性可以理解为直接给函数本身添加属性或方法，即添加的属性或方法与函数的 <code>prototype</code> 属性处于同一层次，这与通过函数产生的对象没有任何关系。</p>\n<pre><code class=\"javascript\">// 自定义构造函数，添加本地化属性，每个对象有自己的属性，并不共享；\nfunction Person(name, age, job) {\n  // 定义公有变量；\n  if (typeof(name) != &quot;undefined&quot;)\n    this.name = name;\n  if (typeof(age) != &quot;undefined&quot;)\n    this.age = age;\n  if (typeof(job) != &quot;undefined&quot;)\n    this.job = job;\n}\n\n// 定义静态变量；\nPerson.staticVar = &quot;This is a static variable&quot;;\n// 定义静态方法；\nPerson.staticFunc = function() {\n  console.log(&quot;This is a static function&quot;);   \n}\n\n// 在原型对象中添加共享的（公有）方法和默认的属性值，方法的签名和逻辑在所有对象中保持一致；\nPerson.prototype = {\n  name: &quot;defaultName&quot;,\n  age: &quot;defaultAge&quot;,\n  job: &quot;defaultJob&quot;,\n  constructor: Person,  // 修正 constructor 指向的值；\n  sayName: function() {\n    console.log(this.name);        \n  },\n  getFlag: function() {\n    console.log(this.flag);        \n  }\n};\n\n// 生成对象，传递参数；\nvar person1 = new Person(&quot;Anny&quot;, 15, &quot;student&quot;);\n// 生成对象，不传递参数，使用默认值；\nvar person2 = new Person();\n\nconsole.log(person1.name === person2.name);  //输出 false；\nconsole.log(person1.sayName === person2.sayName);  // 输出 true；\n\n// 调用静态方法；\nPerson.staticFunc();\n</code></pre>\n"},{"title":"LAMP 架构之升级 PHP 版本","intro":"当你看到这篇文章的时候 YHSPY.COM 服务器上的 PHP 版本已经从 5.4.27 升级到了 7.0.4，这是一个重大的飞跃。一路升级遇到了很多问题。官方声称 PHP7 最大的升级就是在语言性能上的提升，最大到达了30%。同时也去掉了很多老版本中被标记为 Deprecated 的函数方法，语言整体变得更加稳定。","comments":1,"date":"2016-03-16T01:12:07.000Z","_content":"\n当你看到这篇文章的时候 YHSPY.COM 服务器上的 PHP 版本已经从 5.4.27 升级到了 7.0.4，这是一个重大的飞跃。一路升级遇到了很多问题。官方声称 PHP7 最大的升级就是在语言性能上的提升，最大到达了30%。同时也去掉了很多老版本中被标记为 Deprecated 的函数方法，语言整体变得更加稳定。\n\n首先声明，此文不适用于使用 `yum` 方式安装的 PHP 环境进行的升级，**只适用于通过 PHP 源代码编译安装的 PHP 版本**。升级之前首先需要判断服务器上的 Apache 版本，根据不同的 Apache 版本来参考不同的官方编译文档。用以下命令来查看当前已安装 Apache 的版本：\n\n```bash\n[root@iZ23ki8vt8tZ /]# httpd -v\nServer version: Apache/2.2.27 (Unix)\nServer built:   Jun 12 2014 21:19:24\n```\n\n由上述命令返回的结果可知，当前 Apache 服务器为“2.X”版本，所以此处应该参考官方给出的 PHP 在 Apache 版本2.X上的编译参考文档：[Apache2.X 版本 PHP 编译文档](http://php.net/manual/en/install.unix.apache2.php)。对于其他版本的 Aapche 或者 Nginx 服务器，可以参考此处：[针对其他版本服务器的 PHP 编译文档](http://php.net/manual/en/install.php)。\n\n接下来我们从 PHP 官方给出的镜像地址来获取 PHP 源代码，这些源代码将会最后被编译并安装在我们的服务器上。这里按照官方文档的说明，我们使用 `wget` 命令来获取源代码的压缩包，并逐层解压，直到生成最后的源代码文件夹。\n\n```bash\nwget http://bg2.php.net/get/php-7.0.4.tar.gz/from/this/mirror  #从镜像获取 PHP 源代码；\ngzip -d php-7.0.4.tar.gz  #解压缩；\ntar -xf php-7.0.4.tar\n```\n\n由于我们这里为 PHP 的版本进行升级操作，所以需要保持新版本 PHP 源代码的预编译参数和旧版本 PHP 源码的预编译参数一致。进入到旧版本（当前版本）PHP 源码文件夹内，使用 `vi/vim` 命令打开文件夹内的 Makefile 文件，复制其中的 “CONFIGURE_COMMAND” 参数部分并整理（去掉单引号等）成如下格式：\n\n```bash\nCONFIGURE_COMMAND = ./configure --prefix=/alidata/server/php --with-config-file-path=/alidata/server/php/etc --with-apxs2=/alidata/server/httpd/bin/apxs --with-mysql=mysqlnd --with-mysqli=mysqlnd --with-pdo-mysql=mysqlnd --enable-static --enable-maintainer-zts --enable-zend-multibyte --enable-inline-optimization --enable-sockets --enable-wddx --enable-zip --enable-calendar --enable-bcmath --enable-soap --with-zlib --with-iconv-dir=/usr/local/libiconv --with-gd --with-xmlrpc --enable-mbstring --without-sqlite --with-curl --enable-ftp --with-mcrypt --with-freetype-dir=/usr/local/freetype.2.1.10 --with-jpeg-dir=/usr/local/jpeg.6 --with-png-dir=/usr/local/libpng.1.2.50 --disable-ipv6 --disable-fileinfo --with-openssl --with-pcntl\n```\n\n\n这里 CONFIGURE_COMMAND 参数的值就是对应于我们上一次 PHP 源码预编译过程的全部编译命令（和子参数），这里顺便说一下其中几个子参数的作用。 `--prefix` 参数用来指定 PHP 安装的主要目录位置，`--with-config-file-path` 参数主要用来指定 “php.ini” 文件的生成路径，对于其他子参数的具体用法和说明，可以在 PHP 源代码文件夹内使用 `./configure --help` 命令来进行查看。\n\n接下来便通过已经整理好的预编译参数来对源码进行预编译（即编译前的配置操作）操作，命令如下：\n\n\n```bash\n./configure --prefix=/alidata/server/php --with-config-file-path=/alidata/server/php/etc --with-apxs2=/alidata/server/httpd/bin/apxs --with-mysql=mysqlnd --with-mysqli=mysqlnd --with-pdo-mysql=mysqlnd --enable-static --enable-maintainer-zts --enable-zend-multibyte --enable-inline-optimization --enable-sockets --enable-wddx --enable-zip --enable-calendar --enable-bcmath --enable-soap --with-zlib --with-iconv-dir=/usr/local/libiconv --with-gd --with-xmlrpc --enable-mbstring --without-sqlite --with-curl --enable-ftp --with-mcrypt --with-freetype-dir=/usr/local/freetype.2.1.10 --with-jpeg-dir=/usr/local/jpeg.6 --with-png-dir=/usr/local/libpng.1.2.50 --disable-ipv6 --disable-fileinfo --with-openssl --with-pcntl\n```\n\n在这里为了防止出现错误，我们需要分开执行 `make` 编译和 `make install` 安装两个操作命令，首先执行 `make` 命令来编译源代码。\n\n```bash\nmake\n```\n\n如果在执行过程中遇到 “undefined reference to \"libiconv\"”错误，请尝试为 `make` 命令加入 “ZEND_EXTRA_LIBS” 参数，如下所示：\n\n```bash\nmake ZEND_EXTRA_LIBS='-liconv'\n```\n\n\n最后再执行 `make install` 命令来安装 PHP 环境：\n\n```bash\nmake install\n```\n\n当源代码全部编译完成并安装后，便可以用以下命令来重新启动 Apache 服务器：\n\n```bash\nservice httpd restart\n```\n\n至此，PHP7 的升级就全部结束了，你可以通过 `phpinfo()` 函数来查看新版本 PHP 的相关配置，包括扩展配置和错误日志等常用设置是否配置正确。从 PHP5.X 升级至 PHP7.X 后，一些 PHP 在早期版本不推荐使用的函数比如 `split()` 等都已经从 PHP7 中被移除了，所以在升级时务必请参考官方的升级文档。并且，PHP7 也移除了 `mysql` 相关的函数，因此只能够使用 PDO 或其他方式来连接数据库。\n\n写在最后，其实所谓的预编译步骤是对源代码编译之前进行一些环境配置，比如指定编译是否携带某一模块，编译生成的文件夹等。同时在执行 `./configure` 时也会同时生成 Makefile 文件。\n","source":"_posts/LAMP-架构之升级-PHP-版本.md","raw":"---\ntitle: LAMP 架构之升级 PHP 版本\nintro: 当你看到这篇文章的时候 YHSPY.COM 服务器上的 PHP 版本已经从 5.4.27 升级到了 7.0.4，这是一个重大的飞跃。一路升级遇到了很多问题。官方声称 PHP7 最大的升级就是在语言性能上的提升，最大到达了30%。同时也去掉了很多老版本中被标记为 Deprecated 的函数方法，语言整体变得更加稳定。\ncomments: true\ndate: 2016-03-16 09:12:07\ntags:\n- PHP\n---\n\n当你看到这篇文章的时候 YHSPY.COM 服务器上的 PHP 版本已经从 5.4.27 升级到了 7.0.4，这是一个重大的飞跃。一路升级遇到了很多问题。官方声称 PHP7 最大的升级就是在语言性能上的提升，最大到达了30%。同时也去掉了很多老版本中被标记为 Deprecated 的函数方法，语言整体变得更加稳定。\n\n首先声明，此文不适用于使用 `yum` 方式安装的 PHP 环境进行的升级，**只适用于通过 PHP 源代码编译安装的 PHP 版本**。升级之前首先需要判断服务器上的 Apache 版本，根据不同的 Apache 版本来参考不同的官方编译文档。用以下命令来查看当前已安装 Apache 的版本：\n\n```bash\n[root@iZ23ki8vt8tZ /]# httpd -v\nServer version: Apache/2.2.27 (Unix)\nServer built:   Jun 12 2014 21:19:24\n```\n\n由上述命令返回的结果可知，当前 Apache 服务器为“2.X”版本，所以此处应该参考官方给出的 PHP 在 Apache 版本2.X上的编译参考文档：[Apache2.X 版本 PHP 编译文档](http://php.net/manual/en/install.unix.apache2.php)。对于其他版本的 Aapche 或者 Nginx 服务器，可以参考此处：[针对其他版本服务器的 PHP 编译文档](http://php.net/manual/en/install.php)。\n\n接下来我们从 PHP 官方给出的镜像地址来获取 PHP 源代码，这些源代码将会最后被编译并安装在我们的服务器上。这里按照官方文档的说明，我们使用 `wget` 命令来获取源代码的压缩包，并逐层解压，直到生成最后的源代码文件夹。\n\n```bash\nwget http://bg2.php.net/get/php-7.0.4.tar.gz/from/this/mirror  #从镜像获取 PHP 源代码；\ngzip -d php-7.0.4.tar.gz  #解压缩；\ntar -xf php-7.0.4.tar\n```\n\n由于我们这里为 PHP 的版本进行升级操作，所以需要保持新版本 PHP 源代码的预编译参数和旧版本 PHP 源码的预编译参数一致。进入到旧版本（当前版本）PHP 源码文件夹内，使用 `vi/vim` 命令打开文件夹内的 Makefile 文件，复制其中的 “CONFIGURE_COMMAND” 参数部分并整理（去掉单引号等）成如下格式：\n\n```bash\nCONFIGURE_COMMAND = ./configure --prefix=/alidata/server/php --with-config-file-path=/alidata/server/php/etc --with-apxs2=/alidata/server/httpd/bin/apxs --with-mysql=mysqlnd --with-mysqli=mysqlnd --with-pdo-mysql=mysqlnd --enable-static --enable-maintainer-zts --enable-zend-multibyte --enable-inline-optimization --enable-sockets --enable-wddx --enable-zip --enable-calendar --enable-bcmath --enable-soap --with-zlib --with-iconv-dir=/usr/local/libiconv --with-gd --with-xmlrpc --enable-mbstring --without-sqlite --with-curl --enable-ftp --with-mcrypt --with-freetype-dir=/usr/local/freetype.2.1.10 --with-jpeg-dir=/usr/local/jpeg.6 --with-png-dir=/usr/local/libpng.1.2.50 --disable-ipv6 --disable-fileinfo --with-openssl --with-pcntl\n```\n\n\n这里 CONFIGURE_COMMAND 参数的值就是对应于我们上一次 PHP 源码预编译过程的全部编译命令（和子参数），这里顺便说一下其中几个子参数的作用。 `--prefix` 参数用来指定 PHP 安装的主要目录位置，`--with-config-file-path` 参数主要用来指定 “php.ini” 文件的生成路径，对于其他子参数的具体用法和说明，可以在 PHP 源代码文件夹内使用 `./configure --help` 命令来进行查看。\n\n接下来便通过已经整理好的预编译参数来对源码进行预编译（即编译前的配置操作）操作，命令如下：\n\n\n```bash\n./configure --prefix=/alidata/server/php --with-config-file-path=/alidata/server/php/etc --with-apxs2=/alidata/server/httpd/bin/apxs --with-mysql=mysqlnd --with-mysqli=mysqlnd --with-pdo-mysql=mysqlnd --enable-static --enable-maintainer-zts --enable-zend-multibyte --enable-inline-optimization --enable-sockets --enable-wddx --enable-zip --enable-calendar --enable-bcmath --enable-soap --with-zlib --with-iconv-dir=/usr/local/libiconv --with-gd --with-xmlrpc --enable-mbstring --without-sqlite --with-curl --enable-ftp --with-mcrypt --with-freetype-dir=/usr/local/freetype.2.1.10 --with-jpeg-dir=/usr/local/jpeg.6 --with-png-dir=/usr/local/libpng.1.2.50 --disable-ipv6 --disable-fileinfo --with-openssl --with-pcntl\n```\n\n在这里为了防止出现错误，我们需要分开执行 `make` 编译和 `make install` 安装两个操作命令，首先执行 `make` 命令来编译源代码。\n\n```bash\nmake\n```\n\n如果在执行过程中遇到 “undefined reference to \"libiconv\"”错误，请尝试为 `make` 命令加入 “ZEND_EXTRA_LIBS” 参数，如下所示：\n\n```bash\nmake ZEND_EXTRA_LIBS='-liconv'\n```\n\n\n最后再执行 `make install` 命令来安装 PHP 环境：\n\n```bash\nmake install\n```\n\n当源代码全部编译完成并安装后，便可以用以下命令来重新启动 Apache 服务器：\n\n```bash\nservice httpd restart\n```\n\n至此，PHP7 的升级就全部结束了，你可以通过 `phpinfo()` 函数来查看新版本 PHP 的相关配置，包括扩展配置和错误日志等常用设置是否配置正确。从 PHP5.X 升级至 PHP7.X 后，一些 PHP 在早期版本不推荐使用的函数比如 `split()` 等都已经从 PHP7 中被移除了，所以在升级时务必请参考官方的升级文档。并且，PHP7 也移除了 `mysql` 相关的函数，因此只能够使用 PDO 或其他方式来连接数据库。\n\n写在最后，其实所谓的预编译步骤是对源代码编译之前进行一些环境配置，比如指定编译是否携带某一模块，编译生成的文件夹等。同时在执行 `./configure` 时也会同时生成 Makefile 文件。\n","slug":"LAMP-架构之升级-PHP-版本","published":1,"updated":"2019-02-05T09:33:26.178Z","layout":"post","photos":[],"link":"","_id":"cjsqwht8i001kknp2g2gr673g","content":"<p>当你看到这篇文章的时候 YHSPY.COM 服务器上的 PHP 版本已经从 5.4.27 升级到了 7.0.4，这是一个重大的飞跃。一路升级遇到了很多问题。官方声称 PHP7 最大的升级就是在语言性能上的提升，最大到达了30%。同时也去掉了很多老版本中被标记为 Deprecated 的函数方法，语言整体变得更加稳定。</p>\n<p>首先声明，此文不适用于使用 <code>yum</code> 方式安装的 PHP 环境进行的升级，<strong>只适用于通过 PHP 源代码编译安装的 PHP 版本</strong>。升级之前首先需要判断服务器上的 Apache 版本，根据不同的 Apache 版本来参考不同的官方编译文档。用以下命令来查看当前已安装 Apache 的版本：</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@iZ23ki8vt8tZ /<span class=\"token punctuation\">]</span><span class=\"token comment\" spellcheck=\"true\"># httpd -v</span>\nServer version: Apache/2.2.27 <span class=\"token punctuation\">(</span>Unix<span class=\"token punctuation\">)</span>\nServer built:   Jun 12 2014 21:19:24\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>由上述命令返回的结果可知，当前 Apache 服务器为“2.X”版本，所以此处应该参考官方给出的 PHP 在 Apache 版本2.X上的编译参考文档：<a href=\"http://php.net/manual/en/install.unix.apache2.php\" target=\"_blank\" rel=\"noopener\">Apache2.X 版本 PHP 编译文档</a>。对于其他版本的 Aapche 或者 Nginx 服务器，可以参考此处：<a href=\"http://php.net/manual/en/install.php\" target=\"_blank\" rel=\"noopener\">针对其他版本服务器的 PHP 编译文档</a>。</p>\n<p>接下来我们从 PHP 官方给出的镜像地址来获取 PHP 源代码，这些源代码将会最后被编译并安装在我们的服务器上。这里按照官方文档的说明，我们使用 <code>wget</code> 命令来获取源代码的压缩包，并逐层解压，直到生成最后的源代码文件夹。</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token function\">wget</span> http://bg2.php.net/get/php-7.0.4.tar.gz/from/this/mirror  <span class=\"token comment\" spellcheck=\"true\">#从镜像获取 PHP 源代码；</span>\n<span class=\"token function\">gzip</span> -d php-7.0.4.tar.gz  <span class=\"token comment\" spellcheck=\"true\">#解压缩；</span>\n<span class=\"token function\">tar</span> -xf php-7.0.4.tar\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>由于我们这里为 PHP 的版本进行升级操作，所以需要保持新版本 PHP 源代码的预编译参数和旧版本 PHP 源码的预编译参数一致。进入到旧版本（当前版本）PHP 源码文件夹内，使用 <code>vi/vim</code> 命令打开文件夹内的 Makefile 文件，复制其中的 “CONFIGURE_COMMAND” 参数部分并整理（去掉单引号等）成如下格式：</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\">CONFIGURE_COMMAND <span class=\"token operator\">=</span> ./configure --prefix<span class=\"token operator\">=</span>/alidata/server/php --with-config-file-path<span class=\"token operator\">=</span>/alidata/server/php/etc --with-apxs2<span class=\"token operator\">=</span>/alidata/server/httpd/bin/apxs --with-mysql<span class=\"token operator\">=</span>mysqlnd --with-mysqli<span class=\"token operator\">=</span>mysqlnd --with-pdo-mysql<span class=\"token operator\">=</span>mysqlnd --enable-static --enable-maintainer-zts --enable-zend-multibyte --enable-inline-optimization --enable-sockets --enable-wddx --enable-zip --enable-calendar --enable-bcmath --enable-soap --with-zlib --with-iconv-dir<span class=\"token operator\">=</span>/usr/local/libiconv --with-gd --with-xmlrpc --enable-mbstring --without-sqlite --with-curl --enable-ftp --with-mcrypt --with-freetype-dir<span class=\"token operator\">=</span>/usr/local/freetype.2.1.10 --with-jpeg-dir<span class=\"token operator\">=</span>/usr/local/jpeg.6 --with-png-dir<span class=\"token operator\">=</span>/usr/local/libpng.1.2.50 --disable-ipv6 --disable-fileinfo --with-openssl --with-pcntl\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>这里 CONFIGURE_COMMAND 参数的值就是对应于我们上一次 PHP 源码预编译过程的全部编译命令（和子参数），这里顺便说一下其中几个子参数的作用。 <code>--prefix</code> 参数用来指定 PHP 安装的主要目录位置，<code>--with-config-file-path</code> 参数主要用来指定 “php.ini” 文件的生成路径，对于其他子参数的具体用法和说明，可以在 PHP 源代码文件夹内使用 <code>./configure --help</code> 命令来进行查看。</p>\n<p>接下来便通过已经整理好的预编译参数来对源码进行预编译（即编译前的配置操作）操作，命令如下：</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\">./configure --prefix<span class=\"token operator\">=</span>/alidata/server/php --with-config-file-path<span class=\"token operator\">=</span>/alidata/server/php/etc --with-apxs2<span class=\"token operator\">=</span>/alidata/server/httpd/bin/apxs --with-mysql<span class=\"token operator\">=</span>mysqlnd --with-mysqli<span class=\"token operator\">=</span>mysqlnd --with-pdo-mysql<span class=\"token operator\">=</span>mysqlnd --enable-static --enable-maintainer-zts --enable-zend-multibyte --enable-inline-optimization --enable-sockets --enable-wddx --enable-zip --enable-calendar --enable-bcmath --enable-soap --with-zlib --with-iconv-dir<span class=\"token operator\">=</span>/usr/local/libiconv --with-gd --with-xmlrpc --enable-mbstring --without-sqlite --with-curl --enable-ftp --with-mcrypt --with-freetype-dir<span class=\"token operator\">=</span>/usr/local/freetype.2.1.10 --with-jpeg-dir<span class=\"token operator\">=</span>/usr/local/jpeg.6 --with-png-dir<span class=\"token operator\">=</span>/usr/local/libpng.1.2.50 --disable-ipv6 --disable-fileinfo --with-openssl --with-pcntl\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>在这里为了防止出现错误，我们需要分开执行 <code>make</code> 编译和 <code>make install</code> 安装两个操作命令，首先执行 <code>make</code> 命令来编译源代码。</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token function\">make</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>如果在执行过程中遇到 “undefined reference to “libiconv””错误，请尝试为 <code>make</code> 命令加入 “ZEND_EXTRA_LIBS” 参数，如下所示：</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token function\">make</span> ZEND_EXTRA_LIBS<span class=\"token operator\">=</span><span class=\"token string\">'-liconv'</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>最后再执行 <code>make install</code> 命令来安装 PHP 环境：</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token function\">make</span> <span class=\"token function\">install</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>当源代码全部编译完成并安装后，便可以用以下命令来重新启动 Apache 服务器：</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token function\">service</span> httpd restart\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>至此，PHP7 的升级就全部结束了，你可以通过 <code>phpinfo()</code> 函数来查看新版本 PHP 的相关配置，包括扩展配置和错误日志等常用设置是否配置正确。从 PHP5.X 升级至 PHP7.X 后，一些 PHP 在早期版本不推荐使用的函数比如 <code>split()</code> 等都已经从 PHP7 中被移除了，所以在升级时务必请参考官方的升级文档。并且，PHP7 也移除了 <code>mysql</code> 相关的函数，因此只能够使用 PDO 或其他方式来连接数据库。</p>\n<p>写在最后，其实所谓的预编译步骤是对源代码编译之前进行一些环境配置，比如指定编译是否携带某一模块，编译生成的文件夹等。同时在执行 <code>./configure</code> 时也会同时生成 Makefile 文件。</p>\n","site":{"data":{}},"id":"a9558592da8a57005ff420bc286a908c","excerpt":"","more":"<p>当你看到这篇文章的时候 YHSPY.COM 服务器上的 PHP 版本已经从 5.4.27 升级到了 7.0.4，这是一个重大的飞跃。一路升级遇到了很多问题。官方声称 PHP7 最大的升级就是在语言性能上的提升，最大到达了30%。同时也去掉了很多老版本中被标记为 Deprecated 的函数方法，语言整体变得更加稳定。</p>\n<p>首先声明，此文不适用于使用 <code>yum</code> 方式安装的 PHP 环境进行的升级，<strong>只适用于通过 PHP 源代码编译安装的 PHP 版本</strong>。升级之前首先需要判断服务器上的 Apache 版本，根据不同的 Apache 版本来参考不同的官方编译文档。用以下命令来查看当前已安装 Apache 的版本：</p>\n<pre><code class=\"bash\">[root@iZ23ki8vt8tZ /]# httpd -v\nServer version: Apache/2.2.27 (Unix)\nServer built:   Jun 12 2014 21:19:24\n</code></pre>\n<p>由上述命令返回的结果可知，当前 Apache 服务器为“2.X”版本，所以此处应该参考官方给出的 PHP 在 Apache 版本2.X上的编译参考文档：<a href=\"http://php.net/manual/en/install.unix.apache2.php\" target=\"_blank\" rel=\"noopener\">Apache2.X 版本 PHP 编译文档</a>。对于其他版本的 Aapche 或者 Nginx 服务器，可以参考此处：<a href=\"http://php.net/manual/en/install.php\" target=\"_blank\" rel=\"noopener\">针对其他版本服务器的 PHP 编译文档</a>。</p>\n<p>接下来我们从 PHP 官方给出的镜像地址来获取 PHP 源代码，这些源代码将会最后被编译并安装在我们的服务器上。这里按照官方文档的说明，我们使用 <code>wget</code> 命令来获取源代码的压缩包，并逐层解压，直到生成最后的源代码文件夹。</p>\n<pre><code class=\"bash\">wget http://bg2.php.net/get/php-7.0.4.tar.gz/from/this/mirror  #从镜像获取 PHP 源代码；\ngzip -d php-7.0.4.tar.gz  #解压缩；\ntar -xf php-7.0.4.tar\n</code></pre>\n<p>由于我们这里为 PHP 的版本进行升级操作，所以需要保持新版本 PHP 源代码的预编译参数和旧版本 PHP 源码的预编译参数一致。进入到旧版本（当前版本）PHP 源码文件夹内，使用 <code>vi/vim</code> 命令打开文件夹内的 Makefile 文件，复制其中的 “CONFIGURE_COMMAND” 参数部分并整理（去掉单引号等）成如下格式：</p>\n<pre><code class=\"bash\">CONFIGURE_COMMAND = ./configure --prefix=/alidata/server/php --with-config-file-path=/alidata/server/php/etc --with-apxs2=/alidata/server/httpd/bin/apxs --with-mysql=mysqlnd --with-mysqli=mysqlnd --with-pdo-mysql=mysqlnd --enable-static --enable-maintainer-zts --enable-zend-multibyte --enable-inline-optimization --enable-sockets --enable-wddx --enable-zip --enable-calendar --enable-bcmath --enable-soap --with-zlib --with-iconv-dir=/usr/local/libiconv --with-gd --with-xmlrpc --enable-mbstring --without-sqlite --with-curl --enable-ftp --with-mcrypt --with-freetype-dir=/usr/local/freetype.2.1.10 --with-jpeg-dir=/usr/local/jpeg.6 --with-png-dir=/usr/local/libpng.1.2.50 --disable-ipv6 --disable-fileinfo --with-openssl --with-pcntl\n</code></pre>\n<p>这里 CONFIGURE_COMMAND 参数的值就是对应于我们上一次 PHP 源码预编译过程的全部编译命令（和子参数），这里顺便说一下其中几个子参数的作用。 <code>--prefix</code> 参数用来指定 PHP 安装的主要目录位置，<code>--with-config-file-path</code> 参数主要用来指定 “php.ini” 文件的生成路径，对于其他子参数的具体用法和说明，可以在 PHP 源代码文件夹内使用 <code>./configure --help</code> 命令来进行查看。</p>\n<p>接下来便通过已经整理好的预编译参数来对源码进行预编译（即编译前的配置操作）操作，命令如下：</p>\n<pre><code class=\"bash\">./configure --prefix=/alidata/server/php --with-config-file-path=/alidata/server/php/etc --with-apxs2=/alidata/server/httpd/bin/apxs --with-mysql=mysqlnd --with-mysqli=mysqlnd --with-pdo-mysql=mysqlnd --enable-static --enable-maintainer-zts --enable-zend-multibyte --enable-inline-optimization --enable-sockets --enable-wddx --enable-zip --enable-calendar --enable-bcmath --enable-soap --with-zlib --with-iconv-dir=/usr/local/libiconv --with-gd --with-xmlrpc --enable-mbstring --without-sqlite --with-curl --enable-ftp --with-mcrypt --with-freetype-dir=/usr/local/freetype.2.1.10 --with-jpeg-dir=/usr/local/jpeg.6 --with-png-dir=/usr/local/libpng.1.2.50 --disable-ipv6 --disable-fileinfo --with-openssl --with-pcntl\n</code></pre>\n<p>在这里为了防止出现错误，我们需要分开执行 <code>make</code> 编译和 <code>make install</code> 安装两个操作命令，首先执行 <code>make</code> 命令来编译源代码。</p>\n<pre><code class=\"bash\">make\n</code></pre>\n<p>如果在执行过程中遇到 “undefined reference to “libiconv””错误，请尝试为 <code>make</code> 命令加入 “ZEND_EXTRA_LIBS” 参数，如下所示：</p>\n<pre><code class=\"bash\">make ZEND_EXTRA_LIBS=&#39;-liconv&#39;\n</code></pre>\n<p>最后再执行 <code>make install</code> 命令来安装 PHP 环境：</p>\n<pre><code class=\"bash\">make install\n</code></pre>\n<p>当源代码全部编译完成并安装后，便可以用以下命令来重新启动 Apache 服务器：</p>\n<pre><code class=\"bash\">service httpd restart\n</code></pre>\n<p>至此，PHP7 的升级就全部结束了，你可以通过 <code>phpinfo()</code> 函数来查看新版本 PHP 的相关配置，包括扩展配置和错误日志等常用设置是否配置正确。从 PHP5.X 升级至 PHP7.X 后，一些 PHP 在早期版本不推荐使用的函数比如 <code>split()</code> 等都已经从 PHP7 中被移除了，所以在升级时务必请参考官方的升级文档。并且，PHP7 也移除了 <code>mysql</code> 相关的函数，因此只能够使用 PDO 或其他方式来连接数据库。</p>\n<p>写在最后，其实所谓的预编译步骤是对源代码编译之前进行一些环境配置，比如指定编译是否携带某一模块，编译生成的文件夹等。同时在执行 <code>./configure</code> 时也会同时生成 Makefile 文件。</p>\n"},{"title":"JavaScript 浏览器自动化","intro":"今天突然想到能不能利用 JavaScript（后面简称 “JS”） 来让本来重复性乏味的网页操作变得自动化。有一个网站有这样一项功能，注册登录的用户可以通过每天搜索50个关键词（关键词随意不能重复）来获得积分，一定积分即可获得相应的奖金。但每天手动输入50个词语再点击搜索按钮就显得很枯燥乏味，那么能否通过 JS 脚本来让其可以自动进行搜索呢？","comments":1,"date":"2015-02-18T15:39:00.000Z","_content":"\n今天突然想到能不能利用 JavaScript（后面简称 “JS”） 来让本来重复性乏味的网页操作变得自动化。有一个网站有这样一项功能，注册登录的用户可以通过每天搜索50个关键词（关键词随意不能重复）来获得积分，一定积分即可获得相应的奖金。但每天手动输入50个词语再点击搜索按钮就显得很枯燥乏味，那么能否通过 JS 脚本来让其可以自动进行搜索呢？\n\n![](1.jpg)\n\n随即我便开始了对网站的检查，经过查看每次搜素时执行的源码，我发现网站每次搜索都会从服务器端产生一个随机的 Token 令牌，并将其存放在本地 HTML 的一个`hidden` 域标签中。这个 Token 将会随下一次的搜索提交到服务器进行对比验证，如果令牌不一致将不会触发搜索。不过网站提交搜索请求时的 URL 链接并没有进行伪静态处理，所以不用抓包便可以简单获得提交时传入的参数，并且整个后端服务是用 PHP 语言进行编写的。\n\n![](2.jpg)\n\n接下来需要对网站做进一步的检查，因为每一次搜索的内容都会出现在搜索结果页上，所以这里首先可以进行“反射型 XSS”漏洞的检查。但检测结果令人失望，所有提交后的数据使用了 `htmlspecialchars` 函数转义为 HTML 实体了。接下来再进行“SQL 注入”漏洞的检测，用 Safe3 进行检测，仍然没有发现任何结果。\n\n利用漏洞的方式看了是不行了，接下来把目光从漏洞转移到“JS 跨域”，不过现在大多数的跨域方式都没有什么作用，`iframe` 跨域由于浏览器为了安全性的考虑，现在纯正的“JS 跨域”也已经基本无法使用。既然跨域也不行，那再把目光从外部执行的 JS 脚本转移到浏览器上。\n\n因为整个网络的访问是基于 BS 模式的，浏览器作为客户端是完全可以模拟用户的行为的，所以从浏览器进行突破应该会有所收获。直接 F12 打开浏览器的调试模式。在 Console 控制台中尝试用 `document` 对象获得网页某一元素的值，没有任何问题。接着构造 XHR 对象，进行 AJAX 模拟提交数据请求，并打印返回的内容，发现网页是将整个 HTML 的内容返回过来，并不是单独返回 Token 的值，接下来一切顺利。因为目标网站加载了 JQuery 库，所以可以直接利用其封装好的 `$.ajax` 方法来发送和接受请求。将请求返回来的源代码进行过滤，过滤出 Token 值并用于下一次请求，然后编写一个包含递归调用 `$.ajax` 函数不断获取 Token 值的请求，最后的结果跟预想的一样，一切顺利。\n\n![](3.png)\n\n此处的 `setTimeout` 因为需要传递参数所以写成了 `setTimeout(function() { ... }, [time])` 的形式。测试的代码就不提供下载了，没有什么难度，只是整个优化或者说渗透过程的思路是要有条理并且具有针对性的。\n","source":"_posts/JavaScript-浏览器自动化.md","raw":"---\ntitle: JavaScript 浏览器自动化\nintro: 今天突然想到能不能利用 JavaScript（后面简称 “JS”） 来让本来重复性乏味的网页操作变得自动化。有一个网站有这样一项功能，注册登录的用户可以通过每天搜索50个关键词（关键词随意不能重复）来获得积分，一定积分即可获得相应的奖金。但每天手动输入50个词语再点击搜索按钮就显得很枯燥乏味，那么能否通过 JS 脚本来让其可以自动进行搜索呢？\ncomments: true\ndate: 2015-02-18 23:39:00\ntags:\n- JavaScript\n---\n\n今天突然想到能不能利用 JavaScript（后面简称 “JS”） 来让本来重复性乏味的网页操作变得自动化。有一个网站有这样一项功能，注册登录的用户可以通过每天搜索50个关键词（关键词随意不能重复）来获得积分，一定积分即可获得相应的奖金。但每天手动输入50个词语再点击搜索按钮就显得很枯燥乏味，那么能否通过 JS 脚本来让其可以自动进行搜索呢？\n\n![](1.jpg)\n\n随即我便开始了对网站的检查，经过查看每次搜素时执行的源码，我发现网站每次搜索都会从服务器端产生一个随机的 Token 令牌，并将其存放在本地 HTML 的一个`hidden` 域标签中。这个 Token 将会随下一次的搜索提交到服务器进行对比验证，如果令牌不一致将不会触发搜索。不过网站提交搜索请求时的 URL 链接并没有进行伪静态处理，所以不用抓包便可以简单获得提交时传入的参数，并且整个后端服务是用 PHP 语言进行编写的。\n\n![](2.jpg)\n\n接下来需要对网站做进一步的检查，因为每一次搜索的内容都会出现在搜索结果页上，所以这里首先可以进行“反射型 XSS”漏洞的检查。但检测结果令人失望，所有提交后的数据使用了 `htmlspecialchars` 函数转义为 HTML 实体了。接下来再进行“SQL 注入”漏洞的检测，用 Safe3 进行检测，仍然没有发现任何结果。\n\n利用漏洞的方式看了是不行了，接下来把目光从漏洞转移到“JS 跨域”，不过现在大多数的跨域方式都没有什么作用，`iframe` 跨域由于浏览器为了安全性的考虑，现在纯正的“JS 跨域”也已经基本无法使用。既然跨域也不行，那再把目光从外部执行的 JS 脚本转移到浏览器上。\n\n因为整个网络的访问是基于 BS 模式的，浏览器作为客户端是完全可以模拟用户的行为的，所以从浏览器进行突破应该会有所收获。直接 F12 打开浏览器的调试模式。在 Console 控制台中尝试用 `document` 对象获得网页某一元素的值，没有任何问题。接着构造 XHR 对象，进行 AJAX 模拟提交数据请求，并打印返回的内容，发现网页是将整个 HTML 的内容返回过来，并不是单独返回 Token 的值，接下来一切顺利。因为目标网站加载了 JQuery 库，所以可以直接利用其封装好的 `$.ajax` 方法来发送和接受请求。将请求返回来的源代码进行过滤，过滤出 Token 值并用于下一次请求，然后编写一个包含递归调用 `$.ajax` 函数不断获取 Token 值的请求，最后的结果跟预想的一样，一切顺利。\n\n![](3.png)\n\n此处的 `setTimeout` 因为需要传递参数所以写成了 `setTimeout(function() { ... }, [time])` 的形式。测试的代码就不提供下载了，没有什么难度，只是整个优化或者说渗透过程的思路是要有条理并且具有针对性的。\n","slug":"JavaScript-浏览器自动化","published":1,"updated":"2019-02-26T09:33:43.210Z","layout":"post","photos":[],"link":"","_id":"cjsqwht8r001nknp275qrcpki","content":"<p>今天突然想到能不能利用 JavaScript（后面简称 “JS”） 来让本来重复性乏味的网页操作变得自动化。有一个网站有这样一项功能，注册登录的用户可以通过每天搜索50个关键词（关键词随意不能重复）来获得积分，一定积分即可获得相应的奖金。但每天手动输入50个词语再点击搜索按钮就显得很枯燥乏味，那么能否通过 JS 脚本来让其可以自动进行搜索呢？</p>\n<p><img src=\"1.jpg\" alt></p>\n<p>随即我便开始了对网站的检查，经过查看每次搜素时执行的源码，我发现网站每次搜索都会从服务器端产生一个随机的 Token 令牌，并将其存放在本地 HTML 的一个<code>hidden</code> 域标签中。这个 Token 将会随下一次的搜索提交到服务器进行对比验证，如果令牌不一致将不会触发搜索。不过网站提交搜索请求时的 URL 链接并没有进行伪静态处理，所以不用抓包便可以简单获得提交时传入的参数，并且整个后端服务是用 PHP 语言进行编写的。</p>\n<p><img src=\"2.jpg\" alt></p>\n<p>接下来需要对网站做进一步的检查，因为每一次搜索的内容都会出现在搜索结果页上，所以这里首先可以进行“反射型 XSS”漏洞的检查。但检测结果令人失望，所有提交后的数据使用了 <code>htmlspecialchars</code> 函数转义为 HTML 实体了。接下来再进行“SQL 注入”漏洞的检测，用 Safe3 进行检测，仍然没有发现任何结果。</p>\n<p>利用漏洞的方式看了是不行了，接下来把目光从漏洞转移到“JS 跨域”，不过现在大多数的跨域方式都没有什么作用，<code>iframe</code> 跨域由于浏览器为了安全性的考虑，现在纯正的“JS 跨域”也已经基本无法使用。既然跨域也不行，那再把目光从外部执行的 JS 脚本转移到浏览器上。</p>\n<p>因为整个网络的访问是基于 BS 模式的，浏览器作为客户端是完全可以模拟用户的行为的，所以从浏览器进行突破应该会有所收获。直接 F12 打开浏览器的调试模式。在 Console 控制台中尝试用 <code>document</code> 对象获得网页某一元素的值，没有任何问题。接着构造 XHR 对象，进行 AJAX 模拟提交数据请求，并打印返回的内容，发现网页是将整个 HTML 的内容返回过来，并不是单独返回 Token 的值，接下来一切顺利。因为目标网站加载了 JQuery 库，所以可以直接利用其封装好的 <code>$.ajax</code> 方法来发送和接受请求。将请求返回来的源代码进行过滤，过滤出 Token 值并用于下一次请求，然后编写一个包含递归调用 <code>$.ajax</code> 函数不断获取 Token 值的请求，最后的结果跟预想的一样，一切顺利。</p>\n<p><img src=\"3.png\" alt></p>\n<p>此处的 <code>setTimeout</code> 因为需要传递参数所以写成了 <code>setTimeout(function() { ... }, [time])</code> 的形式。测试的代码就不提供下载了，没有什么难度，只是整个优化或者说渗透过程的思路是要有条理并且具有针对性的。</p>\n","site":{"data":{}},"id":"b3c5a4bc96e60dd4811dbc949b96568e","excerpt":"","more":"<p>今天突然想到能不能利用 JavaScript（后面简称 “JS”） 来让本来重复性乏味的网页操作变得自动化。有一个网站有这样一项功能，注册登录的用户可以通过每天搜索50个关键词（关键词随意不能重复）来获得积分，一定积分即可获得相应的奖金。但每天手动输入50个词语再点击搜索按钮就显得很枯燥乏味，那么能否通过 JS 脚本来让其可以自动进行搜索呢？</p>\n<p><img src=\"1.jpg\" alt></p>\n<p>随即我便开始了对网站的检查，经过查看每次搜素时执行的源码，我发现网站每次搜索都会从服务器端产生一个随机的 Token 令牌，并将其存放在本地 HTML 的一个<code>hidden</code> 域标签中。这个 Token 将会随下一次的搜索提交到服务器进行对比验证，如果令牌不一致将不会触发搜索。不过网站提交搜索请求时的 URL 链接并没有进行伪静态处理，所以不用抓包便可以简单获得提交时传入的参数，并且整个后端服务是用 PHP 语言进行编写的。</p>\n<p><img src=\"2.jpg\" alt></p>\n<p>接下来需要对网站做进一步的检查，因为每一次搜索的内容都会出现在搜索结果页上，所以这里首先可以进行“反射型 XSS”漏洞的检查。但检测结果令人失望，所有提交后的数据使用了 <code>htmlspecialchars</code> 函数转义为 HTML 实体了。接下来再进行“SQL 注入”漏洞的检测，用 Safe3 进行检测，仍然没有发现任何结果。</p>\n<p>利用漏洞的方式看了是不行了，接下来把目光从漏洞转移到“JS 跨域”，不过现在大多数的跨域方式都没有什么作用，<code>iframe</code> 跨域由于浏览器为了安全性的考虑，现在纯正的“JS 跨域”也已经基本无法使用。既然跨域也不行，那再把目光从外部执行的 JS 脚本转移到浏览器上。</p>\n<p>因为整个网络的访问是基于 BS 模式的，浏览器作为客户端是完全可以模拟用户的行为的，所以从浏览器进行突破应该会有所收获。直接 F12 打开浏览器的调试模式。在 Console 控制台中尝试用 <code>document</code> 对象获得网页某一元素的值，没有任何问题。接着构造 XHR 对象，进行 AJAX 模拟提交数据请求，并打印返回的内容，发现网页是将整个 HTML 的内容返回过来，并不是单独返回 Token 的值，接下来一切顺利。因为目标网站加载了 JQuery 库，所以可以直接利用其封装好的 <code>$.ajax</code> 方法来发送和接受请求。将请求返回来的源代码进行过滤，过滤出 Token 值并用于下一次请求，然后编写一个包含递归调用 <code>$.ajax</code> 函数不断获取 Token 值的请求，最后的结果跟预想的一样，一切顺利。</p>\n<p><img src=\"3.png\" alt></p>\n<p>此处的 <code>setTimeout</code> 因为需要传递参数所以写成了 <code>setTimeout(function() { ... }, [time])</code> 的形式。测试的代码就不提供下载了，没有什么难度，只是整个优化或者说渗透过程的思路是要有条理并且具有针对性的。</p>\n"},{"title":"LeetCode 每日一题 - 100. Same Tree","intro":"LeetCode 每日一题系列，今天第十九题。又是一段时间没有更新了，今天换换思路，不再是 Array 和 String，来玩转一下简单的二叉树吧。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Tree】 【Depth-first-search】","comments":1,"date":"2016-07-07T10:45:22.000Z","_content":"\nLeetCode 每日一题系列，今天第十九题。又是一段时间没有更新了，今天换换思路，不再是 Array 和 String，来玩转一下简单的二叉树吧。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Tree】 【Depth-first-search】\n\n#### 100. [Same Tree](https://leetcode.com/problems/same-tree/)：\n\n> Given two binary trees, write a function to check if they are equal or not.\n\n> Two binary trees are considered equal if they are structurally identical and the nodes have the same value.\n\n**0. 题目大意：**\n\n给定两个二叉树的头节点，判断这两个二叉树的结构以及各个节点的值是否相同。即判断这两个二叉树是否完全相等（结构和每个节点的值）。\n\n**1. 基本方法，DFS：**\n\n基本的思路就是基于二叉树的 DFS 算法，即“深度优先搜索”算法。通过对二叉树进行 “DFS” 运算，我们可以得到一个遍历序列，这个序列中包括了该二叉树所有节点的值，通过判断这两个二叉树分别得到的遍历序列是否完全相同即可以判断两个二叉树是否完全相等。\n\n实现 “DFS” 的基本思路即使用“栈”来模拟对二叉树的“先序遍历”，代码如下所示：\n\n```java\npublic class Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        ArrayList a1 = Solution.depthOrderTraversal(p);\n        ArrayList a2 = Solution.depthOrderTraversal(q);\n\t\t\t\n        return a1.equals(a2);\n    }\n\n    public static ArrayList depthOrderTraversal(TreeNode t) {\n        if (t == null) \n            return new ArrayList();\n\t\t\n        Stack <TreeNode> nodeStack = new Stack <TreeNode>();\n        TreeNode node;\n        ArrayList result = new ArrayList();\n\t\t\n        nodeStack.push(t);\n\t\t\n        while (!nodeStack.isEmpty()) {\n            node = nodeStack.pop();\n\t\t\t\n            if (node == null) {\n                result.add(null);\n            } else {\n                result.add(node.val);\n\t\t\t\t\n                nodeStack.push(node.right);\n                nodeStack.push(node.left);\n            }\n        }\n        // 返回遍历后的序列；\n        return result;\t\n    }\n}\n```\n\n```text\n54 / 54 test cases passed.\nStatus: Accepted\nRuntime: 3 ms\n```\n","source":"_posts/LeetCode-每日一题-100-Same-Tree.md","raw":"---\ntitle: LeetCode 每日一题 - 100. Same Tree\nintro: LeetCode 每日一题系列，今天第十九题。又是一段时间没有更新了，今天换换思路，不再是 Array 和 String，来玩转一下简单的二叉树吧。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Tree】 【Depth-first-search】\ncomments: true\ndate: 2016-07-07 18:45:22\ntags:\n- 算法\n- LeetCode\n---\n\nLeetCode 每日一题系列，今天第十九题。又是一段时间没有更新了，今天换换思路，不再是 Array 和 String，来玩转一下简单的二叉树吧。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Tree】 【Depth-first-search】\n\n#### 100. [Same Tree](https://leetcode.com/problems/same-tree/)：\n\n> Given two binary trees, write a function to check if they are equal or not.\n\n> Two binary trees are considered equal if they are structurally identical and the nodes have the same value.\n\n**0. 题目大意：**\n\n给定两个二叉树的头节点，判断这两个二叉树的结构以及各个节点的值是否相同。即判断这两个二叉树是否完全相等（结构和每个节点的值）。\n\n**1. 基本方法，DFS：**\n\n基本的思路就是基于二叉树的 DFS 算法，即“深度优先搜索”算法。通过对二叉树进行 “DFS” 运算，我们可以得到一个遍历序列，这个序列中包括了该二叉树所有节点的值，通过判断这两个二叉树分别得到的遍历序列是否完全相同即可以判断两个二叉树是否完全相等。\n\n实现 “DFS” 的基本思路即使用“栈”来模拟对二叉树的“先序遍历”，代码如下所示：\n\n```java\npublic class Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        ArrayList a1 = Solution.depthOrderTraversal(p);\n        ArrayList a2 = Solution.depthOrderTraversal(q);\n\t\t\t\n        return a1.equals(a2);\n    }\n\n    public static ArrayList depthOrderTraversal(TreeNode t) {\n        if (t == null) \n            return new ArrayList();\n\t\t\n        Stack <TreeNode> nodeStack = new Stack <TreeNode>();\n        TreeNode node;\n        ArrayList result = new ArrayList();\n\t\t\n        nodeStack.push(t);\n\t\t\n        while (!nodeStack.isEmpty()) {\n            node = nodeStack.pop();\n\t\t\t\n            if (node == null) {\n                result.add(null);\n            } else {\n                result.add(node.val);\n\t\t\t\t\n                nodeStack.push(node.right);\n                nodeStack.push(node.left);\n            }\n        }\n        // 返回遍历后的序列；\n        return result;\t\n    }\n}\n```\n\n```text\n54 / 54 test cases passed.\nStatus: Accepted\nRuntime: 3 ms\n```\n","slug":"LeetCode-每日一题-100-Same-Tree","published":1,"updated":"2019-02-10T02:50:02.270Z","layout":"post","photos":[],"link":"","_id":"cjsqwht8w001pknp2efblsozr","content":"<p>LeetCode 每日一题系列，今天第十九题。又是一段时间没有更新了，今天换换思路，不再是 Array 和 String，来玩转一下简单的二叉树吧。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Tree】 【Depth-first-search】</p>\n<h4 id=\"100-Same-Tree：\"><a href=\"#100-Same-Tree：\" class=\"headerlink\" title=\"100. Same Tree：\"></a>100. <a href=\"https://leetcode.com/problems/same-tree/\" target=\"_blank\" rel=\"noopener\">Same Tree</a>：</h4><blockquote>\n<p>Given two binary trees, write a function to check if they are equal or not.</p>\n</blockquote>\n<blockquote>\n<p>Two binary trees are considered equal if they are structurally identical and the nodes have the same value.</p>\n</blockquote>\n<p><strong>0. 题目大意：</strong></p>\n<p>给定两个二叉树的头节点，判断这两个二叉树的结构以及各个节点的值是否相同。即判断这两个二叉树是否完全相等（结构和每个节点的值）。</p>\n<p><strong>1. 基本方法，DFS：</strong></p>\n<p>基本的思路就是基于二叉树的 DFS 算法，即“深度优先搜索”算法。通过对二叉树进行 “DFS” 运算，我们可以得到一个遍历序列，这个序列中包括了该二叉树所有节点的值，通过判断这两个二叉树分别得到的遍历序列是否完全相同即可以判断两个二叉树是否完全相等。</p>\n<p>实现 “DFS” 的基本思路即使用“栈”来模拟对二叉树的“先序遍历”，代码如下所示：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">isSameTree</span><span class=\"token punctuation\">(</span>TreeNode p<span class=\"token punctuation\">,</span> TreeNode q<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        ArrayList a1 <span class=\"token operator\">=</span> Solution<span class=\"token punctuation\">.</span><span class=\"token function\">depthOrderTraversal</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        ArrayList a2 <span class=\"token operator\">=</span> Solution<span class=\"token punctuation\">.</span><span class=\"token function\">depthOrderTraversal</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">return</span> a1<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>a2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> ArrayList <span class=\"token function\">depthOrderTraversal</span><span class=\"token punctuation\">(</span>TreeNode t<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>t <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> \n            <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        Stack <span class=\"token operator\">&lt;</span>TreeNode<span class=\"token operator\">></span> nodeStack <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Stack</span> <span class=\"token operator\">&lt;</span>TreeNode<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        TreeNode node<span class=\"token punctuation\">;</span>\n        ArrayList result <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        nodeStack<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>nodeStack<span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            node <span class=\"token operator\">=</span> nodeStack<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>node <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                result<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                result<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n                nodeStack<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                nodeStack<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 返回遍历后的序列；</span>\n        <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>    \n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">54 / 54 test cases passed.\nStatus: Accepted\nRuntime: 3 ms\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"id":"bde9921fa019befb457ca3cd2f18f362","excerpt":"","more":"<p>LeetCode 每日一题系列，今天第十九题。又是一段时间没有更新了，今天换换思路，不再是 Array 和 String，来玩转一下简单的二叉树吧。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Tree】 【Depth-first-search】</p>\n<h4 id=\"100-Same-Tree：\"><a href=\"#100-Same-Tree：\" class=\"headerlink\" title=\"100. Same Tree：\"></a>100. <a href=\"https://leetcode.com/problems/same-tree/\" target=\"_blank\" rel=\"noopener\">Same Tree</a>：</h4><blockquote>\n<p>Given two binary trees, write a function to check if they are equal or not.</p>\n</blockquote>\n<blockquote>\n<p>Two binary trees are considered equal if they are structurally identical and the nodes have the same value.</p>\n</blockquote>\n<p><strong>0. 题目大意：</strong></p>\n<p>给定两个二叉树的头节点，判断这两个二叉树的结构以及各个节点的值是否相同。即判断这两个二叉树是否完全相等（结构和每个节点的值）。</p>\n<p><strong>1. 基本方法，DFS：</strong></p>\n<p>基本的思路就是基于二叉树的 DFS 算法，即“深度优先搜索”算法。通过对二叉树进行 “DFS” 运算，我们可以得到一个遍历序列，这个序列中包括了该二叉树所有节点的值，通过判断这两个二叉树分别得到的遍历序列是否完全相同即可以判断两个二叉树是否完全相等。</p>\n<p>实现 “DFS” 的基本思路即使用“栈”来模拟对二叉树的“先序遍历”，代码如下所示：</p>\n<pre><code class=\"java\">public class Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        ArrayList a1 = Solution.depthOrderTraversal(p);\n        ArrayList a2 = Solution.depthOrderTraversal(q);\n\n        return a1.equals(a2);\n    }\n\n    public static ArrayList depthOrderTraversal(TreeNode t) {\n        if (t == null) \n            return new ArrayList();\n\n        Stack &lt;TreeNode&gt; nodeStack = new Stack &lt;TreeNode&gt;();\n        TreeNode node;\n        ArrayList result = new ArrayList();\n\n        nodeStack.push(t);\n\n        while (!nodeStack.isEmpty()) {\n            node = nodeStack.pop();\n\n            if (node == null) {\n                result.add(null);\n            } else {\n                result.add(node.val);\n\n                nodeStack.push(node.right);\n                nodeStack.push(node.left);\n            }\n        }\n        // 返回遍历后的序列；\n        return result;    \n    }\n}\n</code></pre>\n<pre><code class=\"text\">54 / 54 test cases passed.\nStatus: Accepted\nRuntime: 3 ms\n</code></pre>\n"},{"title":"LeetCode 每日一题 - 104. Maximum Depth of Binary Tree","intro":"LeetCode 每日一题系列。本文算法题目：给出一个二叉树和其根节点，给出该二叉树的最大深度（指树中最长路径所经过的所有节点数量）。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Tree】 【Depth-first Search】","comments":1,"date":"2016-09-17T14:32:01.000Z","_content":"\nLeetCode 每日一题系列。本文算法题目：给出一个二叉树和其根节点，给出该二叉树的最大深度（指树中最长路径所经过的所有节点数量）。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Tree】 【Depth-first Search】\n\n#### 104. [Maximum Depth of Binary Tree ](https://leetcode.com/problems/maximum-depth-of-binary-tree/)：\n\n> Given a binary tree, find its maximum depth.\n\n> The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n\n**0. 题目大意：**\n\n给出一个二叉树和其根节点，给出该二叉树的最大深度（指树中最长路径所经过的所有节点数量）。\n\n**1. 基础解法：**\n\n直接使用 DFS 来计算树的最大深度。代码如下所示：\n\n\n```java\npublic class Solution {\n    public int maxDepth(TreeNode root) {  \n        if (root == null) {  \n            return 0;  \n        }  \n        int res = 1;  \n        int left = maxDepth(root.left);  \n        int right = maxDepth(root.right);  \n        return left > right ? left + 1 : right + 1;  \n    }  \n}\n```\n\n```text\n38 / 38 test cases passed.\nStatus: Accepted\nRuntime: 0 ms\n```\n","source":"_posts/LeetCode-每日一题-104-Maximum-Depth-of-Binary-Tree.md","raw":"---\ntitle: LeetCode 每日一题 - 104. Maximum Depth of Binary Tree\nintro: LeetCode 每日一题系列。本文算法题目：给出一个二叉树和其根节点，给出该二叉树的最大深度（指树中最长路径所经过的所有节点数量）。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Tree】 【Depth-first Search】\ncomments: true\ndate: 2016-09-17 22:32:01\ntags:\n- 算法\n- LeetCode\n---\n\nLeetCode 每日一题系列。本文算法题目：给出一个二叉树和其根节点，给出该二叉树的最大深度（指树中最长路径所经过的所有节点数量）。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Tree】 【Depth-first Search】\n\n#### 104. [Maximum Depth of Binary Tree ](https://leetcode.com/problems/maximum-depth-of-binary-tree/)：\n\n> Given a binary tree, find its maximum depth.\n\n> The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n\n**0. 题目大意：**\n\n给出一个二叉树和其根节点，给出该二叉树的最大深度（指树中最长路径所经过的所有节点数量）。\n\n**1. 基础解法：**\n\n直接使用 DFS 来计算树的最大深度。代码如下所示：\n\n\n```java\npublic class Solution {\n    public int maxDepth(TreeNode root) {  \n        if (root == null) {  \n            return 0;  \n        }  \n        int res = 1;  \n        int left = maxDepth(root.left);  \n        int right = maxDepth(root.right);  \n        return left > right ? left + 1 : right + 1;  \n    }  \n}\n```\n\n```text\n38 / 38 test cases passed.\nStatus: Accepted\nRuntime: 0 ms\n```\n","slug":"LeetCode-每日一题-104-Maximum-Depth-of-Binary-Tree","published":1,"updated":"2019-02-10T02:50:06.969Z","layout":"post","photos":[],"link":"","_id":"cjsqwht91001sknp2ngxsorzt","content":"<p>LeetCode 每日一题系列。本文算法题目：给出一个二叉树和其根节点，给出该二叉树的最大深度（指树中最长路径所经过的所有节点数量）。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Tree】 【Depth-first Search】</p>\n<h4 id=\"104-Maximum-Depth-of-Binary-Tree-：\"><a href=\"#104-Maximum-Depth-of-Binary-Tree-：\" class=\"headerlink\" title=\"104. Maximum Depth of Binary Tree ：\"></a>104. <a href=\"https://leetcode.com/problems/maximum-depth-of-binary-tree/\" target=\"_blank\" rel=\"noopener\">Maximum Depth of Binary Tree </a>：</h4><blockquote>\n<p>Given a binary tree, find its maximum depth.</p>\n</blockquote>\n<blockquote>\n<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>\n</blockquote>\n<p><strong>0. 题目大意：</strong></p>\n<p>给出一个二叉树和其根节点，给出该二叉树的最大深度（指树中最长路径所经过的所有节点数量）。</p>\n<p><strong>1. 基础解法：</strong></p>\n<p>直接使用 DFS 来计算树的最大深度。代码如下所示：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">maxDepth</span><span class=\"token punctuation\">(</span>TreeNode root<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>root <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n            <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>  \n        <span class=\"token punctuation\">}</span>  \n        <span class=\"token keyword\">int</span> res <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>  \n        <span class=\"token keyword\">int</span> left <span class=\"token operator\">=</span> <span class=\"token function\">maxDepth</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n        <span class=\"token keyword\">int</span> right <span class=\"token operator\">=</span> <span class=\"token function\">maxDepth</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n        <span class=\"token keyword\">return</span> left <span class=\"token operator\">></span> right <span class=\"token operator\">?</span> left <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token operator\">:</span> right <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>  \n    <span class=\"token punctuation\">}</span>  \n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">38 / 38 test cases passed.\nStatus: Accepted\nRuntime: 0 ms\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"id":"eac91d47b581b68aca86a02ab73a17d5","excerpt":"","more":"<p>LeetCode 每日一题系列。本文算法题目：给出一个二叉树和其根节点，给出该二叉树的最大深度（指树中最长路径所经过的所有节点数量）。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Tree】 【Depth-first Search】</p>\n<h4 id=\"104-Maximum-Depth-of-Binary-Tree-：\"><a href=\"#104-Maximum-Depth-of-Binary-Tree-：\" class=\"headerlink\" title=\"104. Maximum Depth of Binary Tree ：\"></a>104. <a href=\"https://leetcode.com/problems/maximum-depth-of-binary-tree/\" target=\"_blank\" rel=\"noopener\">Maximum Depth of Binary Tree </a>：</h4><blockquote>\n<p>Given a binary tree, find its maximum depth.</p>\n</blockquote>\n<blockquote>\n<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>\n</blockquote>\n<p><strong>0. 题目大意：</strong></p>\n<p>给出一个二叉树和其根节点，给出该二叉树的最大深度（指树中最长路径所经过的所有节点数量）。</p>\n<p><strong>1. 基础解法：</strong></p>\n<p>直接使用 DFS 来计算树的最大深度。代码如下所示：</p>\n<pre><code class=\"java\">public class Solution {\n    public int maxDepth(TreeNode root) {  \n        if (root == null) {  \n            return 0;  \n        }  \n        int res = 1;  \n        int left = maxDepth(root.left);  \n        int right = maxDepth(root.right);  \n        return left &gt; right ? left + 1 : right + 1;  \n    }  \n}\n</code></pre>\n<pre><code class=\"text\">38 / 38 test cases passed.\nStatus: Accepted\nRuntime: 0 ms\n</code></pre>\n"},{"title":"LeetCode 每日一题 - 1. Two Sum","intro":"LeetCode 每日一题系列，今天第一题。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。提高算法能力，势在必行。【Array】【HashMap】","comments":1,"date":"2016-04-11T14:40:19.000Z","_content":"\nLeetCode 每日一题系列，今天第一题。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。提高算法能力，势在必行。【Array】【HashMap】\n\n#### 1. [Two Sum](https://leetcode.com/problems/two-sum/)：\n\n> Given an array of integers, return **indices** of the two numbers such that they add up to a specific target. You may assume that each input would have **exactly** one solution.\n\n**Example：**\n\n```text\nGiven nums = [2, 7, 11, 15], target = 9,\n\nBecause nums[<strong>0</strong>] + nums[<strong>1</strong>] = 2 + 7 = 9,\nreturn [<strong>0</strong>, <strong>1</strong>].\n```\n\n**1. 最基本的方法，遍历寻找所有可能：**\n\n大部分人解答本题时的第一想法都会是采用遍历所有可能性的方法，遍历出所有可能得到的值，然后再在这些值中查找与 target 目标相等的值。将 start 和 end 作为任意两个数的指针，依次移动两个指针，遍历所有值。如果 start 和 end 指针指向的两个值与 target 相等则返回 start 和 end 两者组成的位置索引数组。该算法的时间复杂度为 “O(n2)”。实现代码如下：\n\n```java\npublic static int[] twoSum(int[] nums, int target) {\n    int numsLength = nums.length;\n    int start = 0, end = 0;\n    \n    int[] resultArr = new int[] {};\n    while (start < numsLength - 1) {  // 最外层循环移动 start 指针；\n    \tend = start + 1;  // end 永远位于 start 后面；\n    \t\n    \tint stepLength = numsLength - end;  // 每一次循环 end 指针需要走的步长；\n    \t\n    \tfor (int i = 0; i< stepLength; i ++) {  // 最内层循环移动 end 指针；\n    \t\tif ((nums[start] + nums[end]) == target) {  // 判断每一次遇到的值是否与 target 相等；\n    \t\t\treturn new int[] {start, end};\n    \t\t} else {\n    \t\t\tend++;\n    \t\t}\n    \t}\n    \tstart++;\n    }   \n    return resultArr;\n}\n```\n\n**2. 优化的算法，利用 HashMap：**\n\n利用 HashMap，将给定数组的值作为 HashMap 的 Key，每个值对应的索引位置作为 Value。接下来通过一次循环查询 target 值减去当前 HashMap 指向的值所得到的值是否在 HashMap 中即可，如果存在则直接返回该元素和当前 HashMap 指向元素的位置。该算法的时间复杂度为 “O(n)”，实现代码如下：\n\n```java\npublic static int[] twoSumOptimize(int[] nums, int target) {\n    int numsLength = nums.length;\n    Map<Integer, Integer> map = new HashMap<>();\n\t\n    for (int i = 0; i < numsLength; i++) {  // 为 HashMap 赋值，重复值只会取最后一次出现的，重复值无用；\n        map.put(nums[i], i);\n    }\n    \n    for (int i = 0; i < numsLength; i++) {  // 开始遍历查询；\n        int search = target - nums[i];  // 得到与当前值的匹配值；\n        if (map.containsKey(search) && map.get(search) != i) {  // 查询匹配值是否存在于 HashMap 中，并且匹配值不能是自己； \n            return new int[] {i, map.get(search)};\n        }\n    }\n    return new int[] {};\n}\n```\n\n**3. 更加优化的算法，优化 HushMap 的执行流程：**\n\n此处的大致思路与第二种方法相同，即也是通过利用 HashMap 来实现快速查询的。优化的地方在于不再单独创建循环为 HashSet 赋值，而是利用每次在 HashSet 中查找时同时在 HashSet 中加入新的值，这种方法可以减少一次赋值循环，但对于所查找的两个值的位置，只有在搜索靠后的值时，整个过程才会返回结果。（因为搜索到第一个匹配值时，第二个匹配值还没有被放到 HashSet 中）。该算法的时间复杂度同样为 “O(n)”，实现代码如下：\n\n```java\npublic static int[] twoSumFurtherOptimize(int[] nums, int target) {\n    int numsLength = nums.length;\n    int[] resultArr = new int[] {};\n    Map<Integer, Integer> map = new HashMap<>();\n\t\n    for (int i = 0; i < numsLength; i++) {\n        int search = target - nums[i];\n        if (map.containsKey(search) && map.get(search) != i) {\n            return new int[] {map.get(search), i};\n        }\n        map.put(nums[i], i);  // 向 HashSet 中插入值；\n    }\n    return resultArr;\n}\n```\n","source":"_posts/LeetCode-每日一题-1-Two-Sum.md","raw":"---\ntitle: LeetCode 每日一题 - 1. Two Sum\nintro: LeetCode 每日一题系列，今天第一题。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。提高算法能力，势在必行。【Array】【HashMap】\ncomments: true\ndate: 2016-04-11 22:40:19\ntags:\n- 算法\n- LeetCode\n---\n\nLeetCode 每日一题系列，今天第一题。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。提高算法能力，势在必行。【Array】【HashMap】\n\n#### 1. [Two Sum](https://leetcode.com/problems/two-sum/)：\n\n> Given an array of integers, return **indices** of the two numbers such that they add up to a specific target. You may assume that each input would have **exactly** one solution.\n\n**Example：**\n\n```text\nGiven nums = [2, 7, 11, 15], target = 9,\n\nBecause nums[<strong>0</strong>] + nums[<strong>1</strong>] = 2 + 7 = 9,\nreturn [<strong>0</strong>, <strong>1</strong>].\n```\n\n**1. 最基本的方法，遍历寻找所有可能：**\n\n大部分人解答本题时的第一想法都会是采用遍历所有可能性的方法，遍历出所有可能得到的值，然后再在这些值中查找与 target 目标相等的值。将 start 和 end 作为任意两个数的指针，依次移动两个指针，遍历所有值。如果 start 和 end 指针指向的两个值与 target 相等则返回 start 和 end 两者组成的位置索引数组。该算法的时间复杂度为 “O(n2)”。实现代码如下：\n\n```java\npublic static int[] twoSum(int[] nums, int target) {\n    int numsLength = nums.length;\n    int start = 0, end = 0;\n    \n    int[] resultArr = new int[] {};\n    while (start < numsLength - 1) {  // 最外层循环移动 start 指针；\n    \tend = start + 1;  // end 永远位于 start 后面；\n    \t\n    \tint stepLength = numsLength - end;  // 每一次循环 end 指针需要走的步长；\n    \t\n    \tfor (int i = 0; i< stepLength; i ++) {  // 最内层循环移动 end 指针；\n    \t\tif ((nums[start] + nums[end]) == target) {  // 判断每一次遇到的值是否与 target 相等；\n    \t\t\treturn new int[] {start, end};\n    \t\t} else {\n    \t\t\tend++;\n    \t\t}\n    \t}\n    \tstart++;\n    }   \n    return resultArr;\n}\n```\n\n**2. 优化的算法，利用 HashMap：**\n\n利用 HashMap，将给定数组的值作为 HashMap 的 Key，每个值对应的索引位置作为 Value。接下来通过一次循环查询 target 值减去当前 HashMap 指向的值所得到的值是否在 HashMap 中即可，如果存在则直接返回该元素和当前 HashMap 指向元素的位置。该算法的时间复杂度为 “O(n)”，实现代码如下：\n\n```java\npublic static int[] twoSumOptimize(int[] nums, int target) {\n    int numsLength = nums.length;\n    Map<Integer, Integer> map = new HashMap<>();\n\t\n    for (int i = 0; i < numsLength; i++) {  // 为 HashMap 赋值，重复值只会取最后一次出现的，重复值无用；\n        map.put(nums[i], i);\n    }\n    \n    for (int i = 0; i < numsLength; i++) {  // 开始遍历查询；\n        int search = target - nums[i];  // 得到与当前值的匹配值；\n        if (map.containsKey(search) && map.get(search) != i) {  // 查询匹配值是否存在于 HashMap 中，并且匹配值不能是自己； \n            return new int[] {i, map.get(search)};\n        }\n    }\n    return new int[] {};\n}\n```\n\n**3. 更加优化的算法，优化 HushMap 的执行流程：**\n\n此处的大致思路与第二种方法相同，即也是通过利用 HashMap 来实现快速查询的。优化的地方在于不再单独创建循环为 HashSet 赋值，而是利用每次在 HashSet 中查找时同时在 HashSet 中加入新的值，这种方法可以减少一次赋值循环，但对于所查找的两个值的位置，只有在搜索靠后的值时，整个过程才会返回结果。（因为搜索到第一个匹配值时，第二个匹配值还没有被放到 HashSet 中）。该算法的时间复杂度同样为 “O(n)”，实现代码如下：\n\n```java\npublic static int[] twoSumFurtherOptimize(int[] nums, int target) {\n    int numsLength = nums.length;\n    int[] resultArr = new int[] {};\n    Map<Integer, Integer> map = new HashMap<>();\n\t\n    for (int i = 0; i < numsLength; i++) {\n        int search = target - nums[i];\n        if (map.containsKey(search) && map.get(search) != i) {\n            return new int[] {map.get(search), i};\n        }\n        map.put(nums[i], i);  // 向 HashSet 中插入值；\n    }\n    return resultArr;\n}\n```\n","slug":"LeetCode-每日一题-1-Two-Sum","published":1,"updated":"2019-02-10T02:49:39.935Z","layout":"post","photos":[],"link":"","_id":"cjsqwht95001uknp2h8n6bpq7","content":"<p>LeetCode 每日一题系列，今天第一题。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。提高算法能力，势在必行。【Array】【HashMap】</p>\n<h4 id=\"1-Two-Sum：\"><a href=\"#1-Two-Sum：\" class=\"headerlink\" title=\"1. Two Sum：\"></a>1. <a href=\"https://leetcode.com/problems/two-sum/\" target=\"_blank\" rel=\"noopener\">Two Sum</a>：</h4><blockquote>\n<p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target. You may assume that each input would have <strong>exactly</strong> one solution.</p>\n</blockquote>\n<p><strong>Example：</strong></p>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">Given nums = [2, 7, 11, 15], target = 9,\n\nBecause nums[<strong>0</strong>] + nums[<strong>1</strong>] = 2 + 7 = 9,\nreturn [<strong>0</strong>, <strong>1</strong>].\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>1. 最基本的方法，遍历寻找所有可能：</strong></p>\n<p>大部分人解答本题时的第一想法都会是采用遍历所有可能性的方法，遍历出所有可能得到的值，然后再在这些值中查找与 target 目标相等的值。将 start 和 end 作为任意两个数的指针，依次移动两个指针，遍历所有值。如果 start 和 end 指针指向的两个值与 target 相等则返回 start 和 end 两者组成的位置索引数组。该算法的时间复杂度为 “O(n2)”。实现代码如下：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">twoSum</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> target<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> numsLength <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> start <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> end <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> resultArr <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>start <span class=\"token operator\">&lt;</span> numsLength <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  <span class=\"token comment\" spellcheck=\"true\">// 最外层循环移动 start 指针；</span>\n        end <span class=\"token operator\">=</span> start <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// end 永远位于 start 后面；</span>\n\n        <span class=\"token keyword\">int</span> stepLength <span class=\"token operator\">=</span> numsLength <span class=\"token operator\">-</span> end<span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 每一次循环 end 指针需要走的步长；</span>\n\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;</span> stepLength<span class=\"token punctuation\">;</span> i <span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  <span class=\"token comment\" spellcheck=\"true\">// 最内层循环移动 end 指针；</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>start<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> nums<span class=\"token punctuation\">[</span>end<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> target<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  <span class=\"token comment\" spellcheck=\"true\">// 判断每一次遇到的值是否与 target 相等；</span>\n                <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>start<span class=\"token punctuation\">,</span> end<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                end<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        start<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>   \n    <span class=\"token keyword\">return</span> resultArr<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>2. 优化的算法，利用 HashMap：</strong></p>\n<p>利用 HashMap，将给定数组的值作为 HashMap 的 Key，每个值对应的索引位置作为 Value。接下来通过一次循环查询 target 值减去当前 HashMap 指向的值所得到的值是否在 HashMap 中即可，如果存在则直接返回该元素和当前 HashMap 指向元素的位置。该算法的时间复杂度为 “O(n)”，实现代码如下：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">twoSumOptimize</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> target<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> numsLength <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    Map<span class=\"token operator\">&lt;</span>Integer<span class=\"token punctuation\">,</span> Integer<span class=\"token operator\">></span> map <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> numsLength<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  <span class=\"token comment\" spellcheck=\"true\">// 为 HashMap 赋值，重复值只会取最后一次出现的，重复值无用；</span>\n        map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> numsLength<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  <span class=\"token comment\" spellcheck=\"true\">// 开始遍历查询；</span>\n        <span class=\"token keyword\">int</span> search <span class=\"token operator\">=</span> target <span class=\"token operator\">-</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 得到与当前值的匹配值；</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">.</span><span class=\"token function\">containsKey</span><span class=\"token punctuation\">(</span>search<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> map<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>search<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  <span class=\"token comment\" spellcheck=\"true\">// 查询匹配值是否存在于 HashMap 中，并且匹配值不能是自己； </span>\n            <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>i<span class=\"token punctuation\">,</span> map<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>search<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>3. 更加优化的算法，优化 HushMap 的执行流程：</strong></p>\n<p>此处的大致思路与第二种方法相同，即也是通过利用 HashMap 来实现快速查询的。优化的地方在于不再单独创建循环为 HashSet 赋值，而是利用每次在 HashSet 中查找时同时在 HashSet 中加入新的值，这种方法可以减少一次赋值循环，但对于所查找的两个值的位置，只有在搜索靠后的值时，整个过程才会返回结果。（因为搜索到第一个匹配值时，第二个匹配值还没有被放到 HashSet 中）。该算法的时间复杂度同样为 “O(n)”，实现代码如下：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">twoSumFurtherOptimize</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> target<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> numsLength <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> resultArr <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    Map<span class=\"token operator\">&lt;</span>Integer<span class=\"token punctuation\">,</span> Integer<span class=\"token operator\">></span> map <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> numsLength<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> search <span class=\"token operator\">=</span> target <span class=\"token operator\">-</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">.</span><span class=\"token function\">containsKey</span><span class=\"token punctuation\">(</span>search<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> map<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>search<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>map<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>search<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 向 HashSet 中插入值；</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> resultArr<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"id":"e4a2e9a2b08accb20c5348f481588274","excerpt":"","more":"<p>LeetCode 每日一题系列，今天第一题。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。提高算法能力，势在必行。【Array】【HashMap】</p>\n<h4 id=\"1-Two-Sum：\"><a href=\"#1-Two-Sum：\" class=\"headerlink\" title=\"1. Two Sum：\"></a>1. <a href=\"https://leetcode.com/problems/two-sum/\" target=\"_blank\" rel=\"noopener\">Two Sum</a>：</h4><blockquote>\n<p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target. You may assume that each input would have <strong>exactly</strong> one solution.</p>\n</blockquote>\n<p><strong>Example：</strong></p>\n<pre><code class=\"text\">Given nums = [2, 7, 11, 15], target = 9,\n\nBecause nums[&lt;strong&gt;0&lt;/strong&gt;] + nums[&lt;strong&gt;1&lt;/strong&gt;] = 2 + 7 = 9,\nreturn [&lt;strong&gt;0&lt;/strong&gt;, &lt;strong&gt;1&lt;/strong&gt;].\n</code></pre>\n<p><strong>1. 最基本的方法，遍历寻找所有可能：</strong></p>\n<p>大部分人解答本题时的第一想法都会是采用遍历所有可能性的方法，遍历出所有可能得到的值，然后再在这些值中查找与 target 目标相等的值。将 start 和 end 作为任意两个数的指针，依次移动两个指针，遍历所有值。如果 start 和 end 指针指向的两个值与 target 相等则返回 start 和 end 两者组成的位置索引数组。该算法的时间复杂度为 “O(n2)”。实现代码如下：</p>\n<pre><code class=\"java\">public static int[] twoSum(int[] nums, int target) {\n    int numsLength = nums.length;\n    int start = 0, end = 0;\n\n    int[] resultArr = new int[] {};\n    while (start &lt; numsLength - 1) {  // 最外层循环移动 start 指针；\n        end = start + 1;  // end 永远位于 start 后面；\n\n        int stepLength = numsLength - end;  // 每一次循环 end 指针需要走的步长；\n\n        for (int i = 0; i&lt; stepLength; i ++) {  // 最内层循环移动 end 指针；\n            if ((nums[start] + nums[end]) == target) {  // 判断每一次遇到的值是否与 target 相等；\n                return new int[] {start, end};\n            } else {\n                end++;\n            }\n        }\n        start++;\n    }   \n    return resultArr;\n}\n</code></pre>\n<p><strong>2. 优化的算法，利用 HashMap：</strong></p>\n<p>利用 HashMap，将给定数组的值作为 HashMap 的 Key，每个值对应的索引位置作为 Value。接下来通过一次循环查询 target 值减去当前 HashMap 指向的值所得到的值是否在 HashMap 中即可，如果存在则直接返回该元素和当前 HashMap 指向元素的位置。该算法的时间复杂度为 “O(n)”，实现代码如下：</p>\n<pre><code class=\"java\">public static int[] twoSumOptimize(int[] nums, int target) {\n    int numsLength = nums.length;\n    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();\n\n    for (int i = 0; i &lt; numsLength; i++) {  // 为 HashMap 赋值，重复值只会取最后一次出现的，重复值无用；\n        map.put(nums[i], i);\n    }\n\n    for (int i = 0; i &lt; numsLength; i++) {  // 开始遍历查询；\n        int search = target - nums[i];  // 得到与当前值的匹配值；\n        if (map.containsKey(search) &amp;&amp; map.get(search) != i) {  // 查询匹配值是否存在于 HashMap 中，并且匹配值不能是自己； \n            return new int[] {i, map.get(search)};\n        }\n    }\n    return new int[] {};\n}\n</code></pre>\n<p><strong>3. 更加优化的算法，优化 HushMap 的执行流程：</strong></p>\n<p>此处的大致思路与第二种方法相同，即也是通过利用 HashMap 来实现快速查询的。优化的地方在于不再单独创建循环为 HashSet 赋值，而是利用每次在 HashSet 中查找时同时在 HashSet 中加入新的值，这种方法可以减少一次赋值循环，但对于所查找的两个值的位置，只有在搜索靠后的值时，整个过程才会返回结果。（因为搜索到第一个匹配值时，第二个匹配值还没有被放到 HashSet 中）。该算法的时间复杂度同样为 “O(n)”，实现代码如下：</p>\n<pre><code class=\"java\">public static int[] twoSumFurtherOptimize(int[] nums, int target) {\n    int numsLength = nums.length;\n    int[] resultArr = new int[] {};\n    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();\n\n    for (int i = 0; i &lt; numsLength; i++) {\n        int search = target - nums[i];\n        if (map.containsKey(search) &amp;&amp; map.get(search) != i) {\n            return new int[] {map.get(search), i};\n        }\n        map.put(nums[i], i);  // 向 HashSet 中插入值；\n    }\n    return resultArr;\n}\n</code></pre>\n"},{"title":"LeetCode 每日一题 - 168. Excel Sheet Column Title","intro":"LeetCode 每日一题系列，今天第九题。这是一道与数学“进制”相关的题目，从零开始的进位和从一开始的进位处理起来并不相同。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Math】","comments":1,"date":"2016-04-21T14:45:22.000Z","_content":"\nLeetCode 每日一题系列，今天第九题。这是一道与数学“进制”相关的题目，从零开始的进位和从一开始的进位处理起来并不相同。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Math】\n\n#### 168. [Excel Sheet Column Title](https://leetcode.com/problems/excel-sheet-column-title/)：\n\n\n> Given a positive integer, return its corresponding column title as appear in an Excel sheet.\n\n**Example：**\n\n```text\n1 -> A\n2 -> B\n3 -> C\n...\n26 -> Z\n27 -> AA\n28 -> AB\n...\n52 -> AZ \n```\n\n**0. 题目大意：**\n\n根据题目给出的示例，通过观察可以发现这是一道与数学“进制”相关的题目。从 A 到 Z 一共26个字母分别对应着数字从1到26，而字母组合 AA 则对应着数字27，可见组合中的第一个字母 A 为进位，表示26乘以（A 所代表的数字1）即 “26 x 1\"，再加上最后一位字母（A 代表的数字1）结果即为 “26 x 1 + 1 = 27”。\n\n**1. 最基本的方法，找寻进制的规律：**\n\n进制的规律大家应该都很熟悉，该题可以看作是26进制来进行处理，但需要要注意的是题目中并没有出现数字0，一切进位都是从数字1开始计数，一直到数字26。整个字母串的每一位都是一直到出现数字27才会开始进位的，所以在处理需要进位的地方时要多加小心。遇到进位的地方时可以手动强制使其少进一位，而该位的0用 Z 来替换，以下简称“去0换 Z”。代码如下所示：\n\n```java\npublic static String convertToTitle(int n) {\n    String[] alphabet = {\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"};\n    String result = \"\";\n    \n    if (n <= 26) { \n    \treturn alphabet[n - 1];  // n 小于26直接返回对应数组的字母；\n    }\n    \n    int i = n, j = 0;\n    while (i > 26){\n    \ti = n / 26;\n        j = n % 26;\n        \n        if (j != 0) {  // 获得余数；\n        \tresult = alphabet[j - 1] + result;\n        } else {  // 没有余数则将i减一，防止出现数字26而进位；\n        \ti = i - 1;\n        \tresult = &#39;Z&#39; + result;  // 去0换 Z；\n        }\n        \n        if (i > 26) {\n        \tn = i;\n        } else {\n        \tresult = alphabet[i - 1] + result;\n        }\n    }\n    \n    return result;\n}\n```\n\n\n**2. 优化的方法，优化运算流程：**\n\n第二种方法优化了代码的运算流程，但主体思路并没有变。代码如下所示：\n\n```java\npublic static String convertToTitleOptimize(int n) {\n    String[] alphabet = {\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"};\n    String result = \"\", j = \"\";\n    \n    while (n > 0) { \n        int i = n % 26;  \n        if (i == 0) i = 26;  // 没有余数则表明进位了，手动去0换 Z；\n        j = alphabet[i - 1];  \n        result = j + result;  \n        n = (n - 1) / 26;  // 两种情况：1、有余数时并没有影响；2、没有余数时强制少进一位，去0换 Z； \n    }  \n    \n    return result;\n}\n```\n","source":"_posts/LeetCode-每日一题-168-Excel-Sheet-Column-Title.md","raw":"---\ntitle: LeetCode 每日一题 - 168. Excel Sheet Column Title\nintro: LeetCode 每日一题系列，今天第九题。这是一道与数学“进制”相关的题目，从零开始的进位和从一开始的进位处理起来并不相同。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Math】\ncomments: true\ndate: 2016-04-21 22:45:22\ntags:\n- 算法\n- LeetCode\n---\n\nLeetCode 每日一题系列，今天第九题。这是一道与数学“进制”相关的题目，从零开始的进位和从一开始的进位处理起来并不相同。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Math】\n\n#### 168. [Excel Sheet Column Title](https://leetcode.com/problems/excel-sheet-column-title/)：\n\n\n> Given a positive integer, return its corresponding column title as appear in an Excel sheet.\n\n**Example：**\n\n```text\n1 -> A\n2 -> B\n3 -> C\n...\n26 -> Z\n27 -> AA\n28 -> AB\n...\n52 -> AZ \n```\n\n**0. 题目大意：**\n\n根据题目给出的示例，通过观察可以发现这是一道与数学“进制”相关的题目。从 A 到 Z 一共26个字母分别对应着数字从1到26，而字母组合 AA 则对应着数字27，可见组合中的第一个字母 A 为进位，表示26乘以（A 所代表的数字1）即 “26 x 1\"，再加上最后一位字母（A 代表的数字1）结果即为 “26 x 1 + 1 = 27”。\n\n**1. 最基本的方法，找寻进制的规律：**\n\n进制的规律大家应该都很熟悉，该题可以看作是26进制来进行处理，但需要要注意的是题目中并没有出现数字0，一切进位都是从数字1开始计数，一直到数字26。整个字母串的每一位都是一直到出现数字27才会开始进位的，所以在处理需要进位的地方时要多加小心。遇到进位的地方时可以手动强制使其少进一位，而该位的0用 Z 来替换，以下简称“去0换 Z”。代码如下所示：\n\n```java\npublic static String convertToTitle(int n) {\n    String[] alphabet = {\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"};\n    String result = \"\";\n    \n    if (n <= 26) { \n    \treturn alphabet[n - 1];  // n 小于26直接返回对应数组的字母；\n    }\n    \n    int i = n, j = 0;\n    while (i > 26){\n    \ti = n / 26;\n        j = n % 26;\n        \n        if (j != 0) {  // 获得余数；\n        \tresult = alphabet[j - 1] + result;\n        } else {  // 没有余数则将i减一，防止出现数字26而进位；\n        \ti = i - 1;\n        \tresult = &#39;Z&#39; + result;  // 去0换 Z；\n        }\n        \n        if (i > 26) {\n        \tn = i;\n        } else {\n        \tresult = alphabet[i - 1] + result;\n        }\n    }\n    \n    return result;\n}\n```\n\n\n**2. 优化的方法，优化运算流程：**\n\n第二种方法优化了代码的运算流程，但主体思路并没有变。代码如下所示：\n\n```java\npublic static String convertToTitleOptimize(int n) {\n    String[] alphabet = {\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"};\n    String result = \"\", j = \"\";\n    \n    while (n > 0) { \n        int i = n % 26;  \n        if (i == 0) i = 26;  // 没有余数则表明进位了，手动去0换 Z；\n        j = alphabet[i - 1];  \n        result = j + result;  \n        n = (n - 1) / 26;  // 两种情况：1、有余数时并没有影响；2、没有余数时强制少进一位，去0换 Z； \n    }  \n    \n    return result;\n}\n```\n","slug":"LeetCode-每日一题-168-Excel-Sheet-Column-Title","published":1,"updated":"2019-02-10T02:50:18.169Z","layout":"post","photos":[],"link":"","_id":"cjsqwht9a001xknp2kqb7wkjg","content":"<p>LeetCode 每日一题系列，今天第九题。这是一道与数学“进制”相关的题目，从零开始的进位和从一开始的进位处理起来并不相同。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Math】</p>\n<h4 id=\"168-Excel-Sheet-Column-Title：\"><a href=\"#168-Excel-Sheet-Column-Title：\" class=\"headerlink\" title=\"168. Excel Sheet Column Title：\"></a>168. <a href=\"https://leetcode.com/problems/excel-sheet-column-title/\" target=\"_blank\" rel=\"noopener\">Excel Sheet Column Title</a>：</h4><blockquote>\n<p>Given a positive integer, return its corresponding column title as appear in an Excel sheet.</p>\n</blockquote>\n<p><strong>Example：</strong></p>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">1 -> A\n2 -> B\n3 -> C\n...\n26 -> Z\n27 -> AA\n28 -> AB\n...\n52 -> AZ \n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>0. 题目大意：</strong></p>\n<p>根据题目给出的示例，通过观察可以发现这是一道与数学“进制”相关的题目。从 A 到 Z 一共26个字母分别对应着数字从1到26，而字母组合 AA 则对应着数字27，可见组合中的第一个字母 A 为进位，表示26乘以（A 所代表的数字1）即 “26 x 1”，再加上最后一位字母（A 代表的数字1）结果即为 “26 x 1 + 1 = 27”。</p>\n<p><strong>1. 最基本的方法，找寻进制的规律：</strong></p>\n<p>进制的规律大家应该都很熟悉，该题可以看作是26进制来进行处理，但需要要注意的是题目中并没有出现数字0，一切进位都是从数字1开始计数，一直到数字26。整个字母串的每一位都是一直到出现数字27才会开始进位的，所以在处理需要进位的地方时要多加小心。遇到进位的地方时可以手动强制使其少进一位，而该位的0用 Z 来替换，以下简称“去0换 Z”。代码如下所示：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> String <span class=\"token function\">convertToTitle</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> alphabet <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token string\">\"A\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"B\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"C\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"D\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"E\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"F\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"G\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"H\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"I\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"J\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"K\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"L\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"M\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"N\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"O\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"P\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Q\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"R\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"S\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"T\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"U\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"V\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"W\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"X\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Y\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Z\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    String result <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">&lt;=</span> <span class=\"token number\">26</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n        <span class=\"token keyword\">return</span> alphabet<span class=\"token punctuation\">[</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// n 小于26直接返回对应数组的字母；</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> n<span class=\"token punctuation\">,</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">></span> <span class=\"token number\">26</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        i <span class=\"token operator\">=</span> n <span class=\"token operator\">/</span> <span class=\"token number\">26</span><span class=\"token punctuation\">;</span>\n        j <span class=\"token operator\">=</span> n <span class=\"token operator\">%</span> <span class=\"token number\">26</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>j <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  <span class=\"token comment\" spellcheck=\"true\">// 获得余数；</span>\n            result <span class=\"token operator\">=</span> alphabet<span class=\"token punctuation\">[</span>j <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> result<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>  <span class=\"token comment\" spellcheck=\"true\">// 没有余数则将i减一，防止出现数字26而进位；</span>\n            i <span class=\"token operator\">=</span> i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n            result <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>#<span class=\"token number\">39</span><span class=\"token punctuation\">;</span>Z<span class=\"token operator\">&amp;</span>#<span class=\"token number\">39</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">+</span> result<span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 去0换 Z；</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">></span> <span class=\"token number\">26</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            n <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            result <span class=\"token operator\">=</span> alphabet<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> result<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>2. 优化的方法，优化运算流程：</strong></p>\n<p>第二种方法优化了代码的运算流程，但主体思路并没有变。代码如下所示：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> String <span class=\"token function\">convertToTitleOptimize</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> alphabet <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token string\">\"A\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"B\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"C\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"D\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"E\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"F\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"G\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"H\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"I\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"J\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"K\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"L\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"M\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"N\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"O\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"P\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Q\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"R\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"S\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"T\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"U\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"V\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"W\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"X\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Y\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Z\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    String result <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span> j <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n        <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> n <span class=\"token operator\">%</span> <span class=\"token number\">26</span><span class=\"token punctuation\">;</span>  \n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> i <span class=\"token operator\">=</span> <span class=\"token number\">26</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 没有余数则表明进位了，手动去0换 Z；</span>\n        j <span class=\"token operator\">=</span> alphabet<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  \n        result <span class=\"token operator\">=</span> j <span class=\"token operator\">+</span> result<span class=\"token punctuation\">;</span>  \n        n <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">26</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 两种情况：1、有余数时并没有影响；2、没有余数时强制少进一位，去0换 Z； </span>\n    <span class=\"token punctuation\">}</span>  \n\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"id":"04f1b4a4ccb5babc7e9bd8cfedb1425e","excerpt":"","more":"<p>LeetCode 每日一题系列，今天第九题。这是一道与数学“进制”相关的题目，从零开始的进位和从一开始的进位处理起来并不相同。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Math】</p>\n<h4 id=\"168-Excel-Sheet-Column-Title：\"><a href=\"#168-Excel-Sheet-Column-Title：\" class=\"headerlink\" title=\"168. Excel Sheet Column Title：\"></a>168. <a href=\"https://leetcode.com/problems/excel-sheet-column-title/\" target=\"_blank\" rel=\"noopener\">Excel Sheet Column Title</a>：</h4><blockquote>\n<p>Given a positive integer, return its corresponding column title as appear in an Excel sheet.</p>\n</blockquote>\n<p><strong>Example：</strong></p>\n<pre><code class=\"text\">1 -&gt; A\n2 -&gt; B\n3 -&gt; C\n...\n26 -&gt; Z\n27 -&gt; AA\n28 -&gt; AB\n...\n52 -&gt; AZ \n</code></pre>\n<p><strong>0. 题目大意：</strong></p>\n<p>根据题目给出的示例，通过观察可以发现这是一道与数学“进制”相关的题目。从 A 到 Z 一共26个字母分别对应着数字从1到26，而字母组合 AA 则对应着数字27，可见组合中的第一个字母 A 为进位，表示26乘以（A 所代表的数字1）即 “26 x 1”，再加上最后一位字母（A 代表的数字1）结果即为 “26 x 1 + 1 = 27”。</p>\n<p><strong>1. 最基本的方法，找寻进制的规律：</strong></p>\n<p>进制的规律大家应该都很熟悉，该题可以看作是26进制来进行处理，但需要要注意的是题目中并没有出现数字0，一切进位都是从数字1开始计数，一直到数字26。整个字母串的每一位都是一直到出现数字27才会开始进位的，所以在处理需要进位的地方时要多加小心。遇到进位的地方时可以手动强制使其少进一位，而该位的0用 Z 来替换，以下简称“去0换 Z”。代码如下所示：</p>\n<pre><code class=\"java\">public static String convertToTitle(int n) {\n    String[] alphabet = {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, &quot;N&quot;, &quot;O&quot;, &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;};\n    String result = &quot;&quot;;\n\n    if (n &lt;= 26) { \n        return alphabet[n - 1];  // n 小于26直接返回对应数组的字母；\n    }\n\n    int i = n, j = 0;\n    while (i &gt; 26){\n        i = n / 26;\n        j = n % 26;\n\n        if (j != 0) {  // 获得余数；\n            result = alphabet[j - 1] + result;\n        } else {  // 没有余数则将i减一，防止出现数字26而进位；\n            i = i - 1;\n            result = &amp;#39;Z&amp;#39; + result;  // 去0换 Z；\n        }\n\n        if (i &gt; 26) {\n            n = i;\n        } else {\n            result = alphabet[i - 1] + result;\n        }\n    }\n\n    return result;\n}\n</code></pre>\n<p><strong>2. 优化的方法，优化运算流程：</strong></p>\n<p>第二种方法优化了代码的运算流程，但主体思路并没有变。代码如下所示：</p>\n<pre><code class=\"java\">public static String convertToTitleOptimize(int n) {\n    String[] alphabet = {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, &quot;N&quot;, &quot;O&quot;, &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;};\n    String result = &quot;&quot;, j = &quot;&quot;;\n\n    while (n &gt; 0) { \n        int i = n % 26;  \n        if (i == 0) i = 26;  // 没有余数则表明进位了，手动去0换 Z；\n        j = alphabet[i - 1];  \n        result = j + result;  \n        n = (n - 1) / 26;  // 两种情况：1、有余数时并没有影响；2、没有余数时强制少进一位，去0换 Z； \n    }  \n\n    return result;\n}\n</code></pre>\n"},{"title":"LeetCode 每日一题 - 136. Single Number","intro":"LeetCode 每日一题系列，今天第十八题。今天的题目其解法有非常多种，在本篇文章中我们给出了其中三种，但这些答案并非是最优解，期待你心里的最优答案。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Hash Table】","comments":1,"date":"2016-06-16T07:07:05.000Z","_content":"\n\nLeetCode 每日一题系列，今天第十八题。今天的题目其解法有非常多种，在本篇文章中我们给出了其中三种，但这些答案并非是最优解，期待你心里的最优答案。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Hash Table】\n\n#### 136. [Single Number](https://leetcode.com/problems/single-number/)：\n\n> Given an array of integers, every element appears twice except for one. Find that single one.\n\n> Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\n\n**0. 题目大意：**\n\n给定一个只含有整数的数组，该数组中除了其中某一个元素以外的所有其他元素均出现过两次，但该元素只出现过一次，请找出这个在数组中只出现了一次的元素。\n\n**1. 第一种方法，HashMap 计算各个元素出现的次数：**\n\n用一个 HashMap 来遍历给定的数组，并统计其中每个元素出现的次数。最后再遍历 Map，找出次数为“1”的元素并返回。代码如下所示：\n\n```java\npublic static int singleNumber(int[] nums) {\n    int arrLen = nums.length;\n    HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n        \n    for (int i = 0; i < arrLen; i++) {\n        if (map.containsKey(nums[i])) {\n            int currentTime = map.get(nums[i]);\n            map.put(nums[i], ++currentTime);\n        } else {\n            map.put(nums[i], 1);\n        }\n    }\n    // 遍历 Map；\n    for (Map.Entry<Integer, Integer> entry : map.entrySet()) {    \n        if (entry.getValue() == 1)\n            return entry.getKey();\n    }  \n         \n    return 0;\n}\n```\n\n```text\n15 / 15 test cases passed.\nStatus: Accepted\nRuntime: 27 ms\n```\n\n**2. 第二种方法，Set 排除法：**\n\n用一个 Set 来遍历给定数组，第一次遍历时如果元素不存在与 Set 中，则将该元素加入到 Set 中。当第二次遍历到该元素时如果该元素已经存在 Set 中，则从 Set 移除该元素。直到遍历结束后，Set 中只存在一个元素，即为所求元素值。代码如下所示：\n\n```java\npublic static int singleNumberOptimize(int[] nums) {\n    int arrLen = nums.length;\n    HashSet<Integer> set = new HashSet<Integer>();\n        \n    for (int i = 0; i < arrLen; i++) {\n        if (set.contains(nums[i])) {\n            set.remove(nums[i]);\n        } else {\n            set.add(nums[i]);\n        }\n    }\n         \n    return set.iterator().next();\n}\n```\n\n```text\n15 / 15 test cases passed.\nStatus: Accepted\nRuntime: 21 ms\n```\n\n\n\n**3. 第三种方法，数组双指针法：**\n\n先将给定数组排序，然后利用双指针遍历数组，步长为2。遍历时如果两个指针对应的元素值相等则跳过该次循环（进行下一次），如果不相等则返回第一个指针指向的元素（索引较小的指针）。使用这种方法时需要注意处理**目标元素在最后一个位置**和**数组只有一个元素**两种特殊情况。代码如下所示：\n\n```java\npublic static int singleNumberOptimizeFuther(int[] nums) {\n    int arrLen = nums.length;\n    if(arrLen == 1)\n        return nums[0];\n\t// 排序数组；\n    Arrays.sort(nums);\n\t\t\n    for (int i = 0; i < arrLen; i += 2) {\n        int j = i + 1;\n\t\t\t\n        if (j == arrLen)\n            return nums[i];\n\t\t\t\t\t\t\n        if (nums[i] == nums[j])\n            continue;\n        else \n            return nums[i];\n    }\n\t\t\n    return 0;       \n}\t\n```\n\n```text\n15 / 15 test cases passed.\nStatus: Accepted\nRuntime: 9 ms\n```\n\n**4. 第四种方法，最优解法：**\n\n将数组内的元素依次异或最后得到的结果即为所求。所有出现过两次的元素之间进行异或的结果为0，而0与我们要寻找的元素异或之后结果不变。代码如下所示：\n\n```java\npublic class Solution {\n    public int singleNumber(int[] nums) {\n        int arrLen = nums.length;\n        int result = 0;\n        for (int i = 0; i < arrLen; i++) {\n            result = result ^ nums[i];\n        }\n        \n        return result;\n    }\n}\n```\n\n```text\n15 / 15 test cases passed.\nStatus: Accepted\nRuntime: 1 ms\n```\n","source":"_posts/LeetCode-每日一题-136-Single-Number.md","raw":"---\ntitle: LeetCode 每日一题 - 136. Single Number\nintro: LeetCode 每日一题系列，今天第十八题。今天的题目其解法有非常多种，在本篇文章中我们给出了其中三种，但这些答案并非是最优解，期待你心里的最优答案。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Hash Table】\ncomments: true\ndate: 2016-06-16 15:07:05\ntags:\n- 算法\n- LeetCode\n---\n\n\nLeetCode 每日一题系列，今天第十八题。今天的题目其解法有非常多种，在本篇文章中我们给出了其中三种，但这些答案并非是最优解，期待你心里的最优答案。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Hash Table】\n\n#### 136. [Single Number](https://leetcode.com/problems/single-number/)：\n\n> Given an array of integers, every element appears twice except for one. Find that single one.\n\n> Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\n\n**0. 题目大意：**\n\n给定一个只含有整数的数组，该数组中除了其中某一个元素以外的所有其他元素均出现过两次，但该元素只出现过一次，请找出这个在数组中只出现了一次的元素。\n\n**1. 第一种方法，HashMap 计算各个元素出现的次数：**\n\n用一个 HashMap 来遍历给定的数组，并统计其中每个元素出现的次数。最后再遍历 Map，找出次数为“1”的元素并返回。代码如下所示：\n\n```java\npublic static int singleNumber(int[] nums) {\n    int arrLen = nums.length;\n    HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n        \n    for (int i = 0; i < arrLen; i++) {\n        if (map.containsKey(nums[i])) {\n            int currentTime = map.get(nums[i]);\n            map.put(nums[i], ++currentTime);\n        } else {\n            map.put(nums[i], 1);\n        }\n    }\n    // 遍历 Map；\n    for (Map.Entry<Integer, Integer> entry : map.entrySet()) {    \n        if (entry.getValue() == 1)\n            return entry.getKey();\n    }  \n         \n    return 0;\n}\n```\n\n```text\n15 / 15 test cases passed.\nStatus: Accepted\nRuntime: 27 ms\n```\n\n**2. 第二种方法，Set 排除法：**\n\n用一个 Set 来遍历给定数组，第一次遍历时如果元素不存在与 Set 中，则将该元素加入到 Set 中。当第二次遍历到该元素时如果该元素已经存在 Set 中，则从 Set 移除该元素。直到遍历结束后，Set 中只存在一个元素，即为所求元素值。代码如下所示：\n\n```java\npublic static int singleNumberOptimize(int[] nums) {\n    int arrLen = nums.length;\n    HashSet<Integer> set = new HashSet<Integer>();\n        \n    for (int i = 0; i < arrLen; i++) {\n        if (set.contains(nums[i])) {\n            set.remove(nums[i]);\n        } else {\n            set.add(nums[i]);\n        }\n    }\n         \n    return set.iterator().next();\n}\n```\n\n```text\n15 / 15 test cases passed.\nStatus: Accepted\nRuntime: 21 ms\n```\n\n\n\n**3. 第三种方法，数组双指针法：**\n\n先将给定数组排序，然后利用双指针遍历数组，步长为2。遍历时如果两个指针对应的元素值相等则跳过该次循环（进行下一次），如果不相等则返回第一个指针指向的元素（索引较小的指针）。使用这种方法时需要注意处理**目标元素在最后一个位置**和**数组只有一个元素**两种特殊情况。代码如下所示：\n\n```java\npublic static int singleNumberOptimizeFuther(int[] nums) {\n    int arrLen = nums.length;\n    if(arrLen == 1)\n        return nums[0];\n\t// 排序数组；\n    Arrays.sort(nums);\n\t\t\n    for (int i = 0; i < arrLen; i += 2) {\n        int j = i + 1;\n\t\t\t\n        if (j == arrLen)\n            return nums[i];\n\t\t\t\t\t\t\n        if (nums[i] == nums[j])\n            continue;\n        else \n            return nums[i];\n    }\n\t\t\n    return 0;       \n}\t\n```\n\n```text\n15 / 15 test cases passed.\nStatus: Accepted\nRuntime: 9 ms\n```\n\n**4. 第四种方法，最优解法：**\n\n将数组内的元素依次异或最后得到的结果即为所求。所有出现过两次的元素之间进行异或的结果为0，而0与我们要寻找的元素异或之后结果不变。代码如下所示：\n\n```java\npublic class Solution {\n    public int singleNumber(int[] nums) {\n        int arrLen = nums.length;\n        int result = 0;\n        for (int i = 0; i < arrLen; i++) {\n            result = result ^ nums[i];\n        }\n        \n        return result;\n    }\n}\n```\n\n```text\n15 / 15 test cases passed.\nStatus: Accepted\nRuntime: 1 ms\n```\n","slug":"LeetCode-每日一题-136-Single-Number","published":1,"updated":"2019-02-10T02:50:14.276Z","layout":"post","photos":[],"link":"","_id":"cjsqwht9a001zknp2namufh7z","content":"<p>LeetCode 每日一题系列，今天第十八题。今天的题目其解法有非常多种，在本篇文章中我们给出了其中三种，但这些答案并非是最优解，期待你心里的最优答案。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Hash Table】</p>\n<h4 id=\"136-Single-Number：\"><a href=\"#136-Single-Number：\" class=\"headerlink\" title=\"136. Single Number：\"></a>136. <a href=\"https://leetcode.com/problems/single-number/\" target=\"_blank\" rel=\"noopener\">Single Number</a>：</h4><blockquote>\n<p>Given an array of integers, every element appears twice except for one. Find that single one.</p>\n</blockquote>\n<blockquote>\n<p>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>\n</blockquote>\n<p><strong>0. 题目大意：</strong></p>\n<p>给定一个只含有整数的数组，该数组中除了其中某一个元素以外的所有其他元素均出现过两次，但该元素只出现过一次，请找出这个在数组中只出现了一次的元素。</p>\n<p><strong>1. 第一种方法，HashMap 计算各个元素出现的次数：</strong></p>\n<p>用一个 HashMap 来遍历给定的数组，并统计其中每个元素出现的次数。最后再遍历 Map，找出次数为“1”的元素并返回。代码如下所示：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">singleNumber</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> arrLen <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    HashMap<span class=\"token operator\">&lt;</span>Integer<span class=\"token punctuation\">,</span> Integer<span class=\"token operator\">></span> map <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token operator\">&lt;</span>Integer<span class=\"token punctuation\">,</span> Integer<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> arrLen<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">.</span><span class=\"token function\">containsKey</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> currentTime <span class=\"token operator\">=</span> map<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">++</span>currentTime<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 遍历 Map；</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>Map<span class=\"token punctuation\">.</span>Entry<span class=\"token operator\">&lt;</span>Integer<span class=\"token punctuation\">,</span> Integer<span class=\"token operator\">></span> entry <span class=\"token operator\">:</span> map<span class=\"token punctuation\">.</span><span class=\"token function\">entrySet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>    \n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>entry<span class=\"token punctuation\">.</span><span class=\"token function\">getValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> entry<span class=\"token punctuation\">.</span><span class=\"token function\">getKey</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>  \n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">15 / 15 test cases passed.\nStatus: Accepted\nRuntime: 27 ms\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p><strong>2. 第二种方法，Set 排除法：</strong></p>\n<p>用一个 Set 来遍历给定数组，第一次遍历时如果元素不存在与 Set 中，则将该元素加入到 Set 中。当第二次遍历到该元素时如果该元素已经存在 Set 中，则从 Set 移除该元素。直到遍历结束后，Set 中只存在一个元素，即为所求元素值。代码如下所示：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">singleNumberOptimize</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> arrLen <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    HashSet<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span> set <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashSet</span><span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> arrLen<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>set<span class=\"token punctuation\">.</span><span class=\"token function\">contains</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            set<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            set<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> set<span class=\"token punctuation\">.</span><span class=\"token function\">iterator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">15 / 15 test cases passed.\nStatus: Accepted\nRuntime: 21 ms\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p><strong>3. 第三种方法，数组双指针法：</strong></p>\n<p>先将给定数组排序，然后利用双指针遍历数组，步长为2。遍历时如果两个指针对应的元素值相等则跳过该次循环（进行下一次），如果不相等则返回第一个指针指向的元素（索引较小的指针）。使用这种方法时需要注意处理<strong>目标元素在最后一个位置</strong>和<strong>数组只有一个元素</strong>两种特殊情况。代码如下所示：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">singleNumberOptimizeFuther</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> arrLen <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>arrLen <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> nums<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 排序数组；</span>\n    Arrays<span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> arrLen<span class=\"token punctuation\">;</span> i <span class=\"token operator\">+=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>j <span class=\"token operator\">==</span> arrLen<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> nums<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span> \n            <span class=\"token keyword\">return</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>       \n<span class=\"token punctuation\">}</span>    \n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">15 / 15 test cases passed.\nStatus: Accepted\nRuntime: 9 ms\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p><strong>4. 第四种方法，最优解法：</strong></p>\n<p>将数组内的元素依次异或最后得到的结果即为所求。所有出现过两次的元素之间进行异或的结果为0，而0与我们要寻找的元素异或之后结果不变。代码如下所示：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">singleNumber</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> arrLen <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> result <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> arrLen<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            result <span class=\"token operator\">=</span> result <span class=\"token operator\">^</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">15 / 15 test cases passed.\nStatus: Accepted\nRuntime: 1 ms\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"id":"e314a55cd13838ebe131a9d5ec4731fb","excerpt":"","more":"<p>LeetCode 每日一题系列，今天第十八题。今天的题目其解法有非常多种，在本篇文章中我们给出了其中三种，但这些答案并非是最优解，期待你心里的最优答案。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Hash Table】</p>\n<h4 id=\"136-Single-Number：\"><a href=\"#136-Single-Number：\" class=\"headerlink\" title=\"136. Single Number：\"></a>136. <a href=\"https://leetcode.com/problems/single-number/\" target=\"_blank\" rel=\"noopener\">Single Number</a>：</h4><blockquote>\n<p>Given an array of integers, every element appears twice except for one. Find that single one.</p>\n</blockquote>\n<blockquote>\n<p>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>\n</blockquote>\n<p><strong>0. 题目大意：</strong></p>\n<p>给定一个只含有整数的数组，该数组中除了其中某一个元素以外的所有其他元素均出现过两次，但该元素只出现过一次，请找出这个在数组中只出现了一次的元素。</p>\n<p><strong>1. 第一种方法，HashMap 计算各个元素出现的次数：</strong></p>\n<p>用一个 HashMap 来遍历给定的数组，并统计其中每个元素出现的次数。最后再遍历 Map，找出次数为“1”的元素并返回。代码如下所示：</p>\n<pre><code class=\"java\">public static int singleNumber(int[] nums) {\n    int arrLen = nums.length;\n    HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();\n\n    for (int i = 0; i &lt; arrLen; i++) {\n        if (map.containsKey(nums[i])) {\n            int currentTime = map.get(nums[i]);\n            map.put(nums[i], ++currentTime);\n        } else {\n            map.put(nums[i], 1);\n        }\n    }\n    // 遍历 Map；\n    for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) {    \n        if (entry.getValue() == 1)\n            return entry.getKey();\n    }  \n\n    return 0;\n}\n</code></pre>\n<pre><code class=\"text\">15 / 15 test cases passed.\nStatus: Accepted\nRuntime: 27 ms\n</code></pre>\n<p><strong>2. 第二种方法，Set 排除法：</strong></p>\n<p>用一个 Set 来遍历给定数组，第一次遍历时如果元素不存在与 Set 中，则将该元素加入到 Set 中。当第二次遍历到该元素时如果该元素已经存在 Set 中，则从 Set 移除该元素。直到遍历结束后，Set 中只存在一个元素，即为所求元素值。代码如下所示：</p>\n<pre><code class=\"java\">public static int singleNumberOptimize(int[] nums) {\n    int arrLen = nums.length;\n    HashSet&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();\n\n    for (int i = 0; i &lt; arrLen; i++) {\n        if (set.contains(nums[i])) {\n            set.remove(nums[i]);\n        } else {\n            set.add(nums[i]);\n        }\n    }\n\n    return set.iterator().next();\n}\n</code></pre>\n<pre><code class=\"text\">15 / 15 test cases passed.\nStatus: Accepted\nRuntime: 21 ms\n</code></pre>\n<p><strong>3. 第三种方法，数组双指针法：</strong></p>\n<p>先将给定数组排序，然后利用双指针遍历数组，步长为2。遍历时如果两个指针对应的元素值相等则跳过该次循环（进行下一次），如果不相等则返回第一个指针指向的元素（索引较小的指针）。使用这种方法时需要注意处理<strong>目标元素在最后一个位置</strong>和<strong>数组只有一个元素</strong>两种特殊情况。代码如下所示：</p>\n<pre><code class=\"java\">public static int singleNumberOptimizeFuther(int[] nums) {\n    int arrLen = nums.length;\n    if(arrLen == 1)\n        return nums[0];\n    // 排序数组；\n    Arrays.sort(nums);\n\n    for (int i = 0; i &lt; arrLen; i += 2) {\n        int j = i + 1;\n\n        if (j == arrLen)\n            return nums[i];\n\n        if (nums[i] == nums[j])\n            continue;\n        else \n            return nums[i];\n    }\n\n    return 0;       \n}    \n</code></pre>\n<pre><code class=\"text\">15 / 15 test cases passed.\nStatus: Accepted\nRuntime: 9 ms\n</code></pre>\n<p><strong>4. 第四种方法，最优解法：</strong></p>\n<p>将数组内的元素依次异或最后得到的结果即为所求。所有出现过两次的元素之间进行异或的结果为0，而0与我们要寻找的元素异或之后结果不变。代码如下所示：</p>\n<pre><code class=\"java\">public class Solution {\n    public int singleNumber(int[] nums) {\n        int arrLen = nums.length;\n        int result = 0;\n        for (int i = 0; i &lt; arrLen; i++) {\n            result = result ^ nums[i];\n        }\n\n        return result;\n    }\n}\n</code></pre>\n<pre><code class=\"text\">15 / 15 test cases passed.\nStatus: Accepted\nRuntime: 1 ms\n</code></pre>\n"},{"title":"LeetCode 每日一题 - 121. Best Time to Buy and Sell Stock","intro":"LeetCode 每日一题系列，今天第六题，今天的题目是一道算法描述问题，需要先读懂题目，然后“翻译”成算法需求，再按照算法需求来解决问题。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Array】","comments":1,"date":"2016-04-17T11:28:26.000Z","_content":"\nLeetCode 每日一题系列，今天第六题，今天的题目是一道算法描述问题，需要先读懂题目，然后“翻译”成算法需求，再按照算法需求来解决问题。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Array】\n\n#### 121. [Best Time to Buy and Sell Stock](https://leetcode.com/problems/majority-element/)：\n\n\n> Say you have an array for which the ith element is the price of a given stock on day i.\n\n> If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.\n\n**Example：**\n\n```text\nGiven prices = [2, 7, 11, 15],\n\nBecause you can get the maximum profit if you buy at the first day and sell at the forth day. \nReturn the maximum profit by one transaction is 13.\n```\n\n**0. 题目大意：**\n\n假设有一个数组，其中第 n 个元素的值为第 n 天股票的价格。如果你只有一次买入和卖出的机会，请设计一个算法来寻找你卖出一股的最大收益。例如给出数组 [1, 3, 9, 4, 5, 1, 4]，即第一天的股票价格为1（买入和卖出相同），第二天的股票价格为3，其他以此类推。若只有一次买入和卖出的机会，则在第一天买入，第3天卖出时会获利最大为8。\n\n**1. 最基本的方法，列出所有可能的收益值：**\n\n这里我们能想到的第一种最基本的解决方案就是采用遍历所有可能性的方法来找到最大收益值。请注意题目中的**卖出过程只能在买入之后进行**，因此选取的卖出价格对应的元素一定位于买入元素的后边，即“卖出”价格对应元素的索引一定大于“买入”价格元素的索引，这一点要十分注意。我们这里选择用 HashSet 来存储所有可能出现的收益值。该算法时间复杂度 “O(n2)”。代码如下所示：\n\n```java\npublic static int maxProfit(int[] prices) {\n    int arrLen = prices.length;\n    Set<Integer> set = new HashSet<>();\n    \n    if (arrLen == 0)\n        return 0;\n        \n    for (int i = 0; i < arrLen - 1; i++) {  // i 指针对应元素值为买入价；\n        for (int j = i + 1; j < arrLen; j++) {  // j 指针对应元素值为卖出价；\n            int maxVal = prices[j] - prices[i];  // 获得所有可能的收益值；\n            if (maxVal >= 0)\n                set.add(maxVal);  // 将正收益值存入 Set；\n        }\n    }\n    \n    if (set.isEmpty())\n        return 0;\n    \n    Integer[] array = (Integer[]) set.toArray(new Integer[set.size()]);  // 将 Set 转换为 Array；\n    Arrays.sort(array);  // 对 Array 进行排序；\n    return array[array.length - 1];  // 返回最大值，即最大收益值；\n}\n```\n\n\n**2. 优化的方法，动态规划：**\n\n此处采用动态规划的方法，两个变量分别保存着当前出现过的最低价格和最大收益，每一次出现比当前最低价格低的元素时便更新当前最低价格变量所存储的值，同时并按照当前最低价格来计算后续出现的最大利益。算法时间复杂度 “O(n)”。代码如下所示：\n\n```java\npublic static int maxProfitOptimize(int[] prices) {\n    int arrLen = prices.length;\n    \n    if (arrLen == 0)\n        return 0;\n    \n    int maxProfit = 0;\n    int curMin = prices[0];\n    \n    for (int i = 1; i < arrLen; i++) {\n        curMin = Math.min(curMin, prices[i]);  // 更新最低价格；\n        maxProfit = Math.max(maxProfit, prices[i] - curMin);  // 更新最大收益；\n    }\n    \n    return maxProfit;   \n}\n```\n\n\n**3. 效率更高的方法：**你的想法。\n","source":"_posts/LeetCode-每日一题-121-Best-Time-to-Buy-and-Sell-Stock.md","raw":"---\ntitle: LeetCode 每日一题 - 121. Best Time to Buy and Sell Stock\nintro: LeetCode 每日一题系列，今天第六题，今天的题目是一道算法描述问题，需要先读懂题目，然后“翻译”成算法需求，再按照算法需求来解决问题。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Array】\ncomments: true\ndate: 2016-04-17 19:28:26\ntags:\n- 算法\n- LeetCode\n---\n\nLeetCode 每日一题系列，今天第六题，今天的题目是一道算法描述问题，需要先读懂题目，然后“翻译”成算法需求，再按照算法需求来解决问题。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Array】\n\n#### 121. [Best Time to Buy and Sell Stock](https://leetcode.com/problems/majority-element/)：\n\n\n> Say you have an array for which the ith element is the price of a given stock on day i.\n\n> If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.\n\n**Example：**\n\n```text\nGiven prices = [2, 7, 11, 15],\n\nBecause you can get the maximum profit if you buy at the first day and sell at the forth day. \nReturn the maximum profit by one transaction is 13.\n```\n\n**0. 题目大意：**\n\n假设有一个数组，其中第 n 个元素的值为第 n 天股票的价格。如果你只有一次买入和卖出的机会，请设计一个算法来寻找你卖出一股的最大收益。例如给出数组 [1, 3, 9, 4, 5, 1, 4]，即第一天的股票价格为1（买入和卖出相同），第二天的股票价格为3，其他以此类推。若只有一次买入和卖出的机会，则在第一天买入，第3天卖出时会获利最大为8。\n\n**1. 最基本的方法，列出所有可能的收益值：**\n\n这里我们能想到的第一种最基本的解决方案就是采用遍历所有可能性的方法来找到最大收益值。请注意题目中的**卖出过程只能在买入之后进行**，因此选取的卖出价格对应的元素一定位于买入元素的后边，即“卖出”价格对应元素的索引一定大于“买入”价格元素的索引，这一点要十分注意。我们这里选择用 HashSet 来存储所有可能出现的收益值。该算法时间复杂度 “O(n2)”。代码如下所示：\n\n```java\npublic static int maxProfit(int[] prices) {\n    int arrLen = prices.length;\n    Set<Integer> set = new HashSet<>();\n    \n    if (arrLen == 0)\n        return 0;\n        \n    for (int i = 0; i < arrLen - 1; i++) {  // i 指针对应元素值为买入价；\n        for (int j = i + 1; j < arrLen; j++) {  // j 指针对应元素值为卖出价；\n            int maxVal = prices[j] - prices[i];  // 获得所有可能的收益值；\n            if (maxVal >= 0)\n                set.add(maxVal);  // 将正收益值存入 Set；\n        }\n    }\n    \n    if (set.isEmpty())\n        return 0;\n    \n    Integer[] array = (Integer[]) set.toArray(new Integer[set.size()]);  // 将 Set 转换为 Array；\n    Arrays.sort(array);  // 对 Array 进行排序；\n    return array[array.length - 1];  // 返回最大值，即最大收益值；\n}\n```\n\n\n**2. 优化的方法，动态规划：**\n\n此处采用动态规划的方法，两个变量分别保存着当前出现过的最低价格和最大收益，每一次出现比当前最低价格低的元素时便更新当前最低价格变量所存储的值，同时并按照当前最低价格来计算后续出现的最大利益。算法时间复杂度 “O(n)”。代码如下所示：\n\n```java\npublic static int maxProfitOptimize(int[] prices) {\n    int arrLen = prices.length;\n    \n    if (arrLen == 0)\n        return 0;\n    \n    int maxProfit = 0;\n    int curMin = prices[0];\n    \n    for (int i = 1; i < arrLen; i++) {\n        curMin = Math.min(curMin, prices[i]);  // 更新最低价格；\n        maxProfit = Math.max(maxProfit, prices[i] - curMin);  // 更新最大收益；\n    }\n    \n    return maxProfit;   \n}\n```\n\n\n**3. 效率更高的方法：**你的想法。\n","slug":"LeetCode-每日一题-121-Best-Time-to-Buy-and-Sell-Stock","published":1,"updated":"2019-02-10T02:50:10.087Z","layout":"post","photos":[],"link":"","_id":"cjsqwht9b0022knp2ukt5asbf","content":"<p>LeetCode 每日一题系列，今天第六题，今天的题目是一道算法描述问题，需要先读懂题目，然后“翻译”成算法需求，再按照算法需求来解决问题。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Array】</p>\n<h4 id=\"121-Best-Time-to-Buy-and-Sell-Stock：\"><a href=\"#121-Best-Time-to-Buy-and-Sell-Stock：\" class=\"headerlink\" title=\"121. Best Time to Buy and Sell Stock：\"></a>121. <a href=\"https://leetcode.com/problems/majority-element/\" target=\"_blank\" rel=\"noopener\">Best Time to Buy and Sell Stock</a>：</h4><blockquote>\n<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>\n</blockquote>\n<blockquote>\n<p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>\n</blockquote>\n<p><strong>Example：</strong></p>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">Given prices = [2, 7, 11, 15],\n\nBecause you can get the maximum profit if you buy at the first day and sell at the forth day. \nReturn the maximum profit by one transaction is 13.\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>0. 题目大意：</strong></p>\n<p>假设有一个数组，其中第 n 个元素的值为第 n 天股票的价格。如果你只有一次买入和卖出的机会，请设计一个算法来寻找你卖出一股的最大收益。例如给出数组 [1, 3, 9, 4, 5, 1, 4]，即第一天的股票价格为1（买入和卖出相同），第二天的股票价格为3，其他以此类推。若只有一次买入和卖出的机会，则在第一天买入，第3天卖出时会获利最大为8。</p>\n<p><strong>1. 最基本的方法，列出所有可能的收益值：</strong></p>\n<p>这里我们能想到的第一种最基本的解决方案就是采用遍历所有可能性的方法来找到最大收益值。请注意题目中的<strong>卖出过程只能在买入之后进行</strong>，因此选取的卖出价格对应的元素一定位于买入元素的后边，即“卖出”价格对应元素的索引一定大于“买入”价格元素的索引，这一点要十分注意。我们这里选择用 HashSet 来存储所有可能出现的收益值。该算法时间复杂度 “O(n2)”。代码如下所示：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">maxProfit</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> prices<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> arrLen <span class=\"token operator\">=</span> prices<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    Set<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span> set <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashSet</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>arrLen <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> arrLen <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  <span class=\"token comment\" spellcheck=\"true\">// i 指针对应元素值为买入价；</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> arrLen<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  <span class=\"token comment\" spellcheck=\"true\">// j 指针对应元素值为卖出价；</span>\n            <span class=\"token keyword\">int</span> maxVal <span class=\"token operator\">=</span> prices<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> prices<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 获得所有可能的收益值；</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>maxVal <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n                set<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>maxVal<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 将正收益值存入 Set；</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>set<span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    Integer<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> array <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>Integer<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> set<span class=\"token punctuation\">.</span><span class=\"token function\">toArray</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">[</span>set<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 将 Set 转换为 Array；</span>\n    Arrays<span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 对 Array 进行排序；</span>\n    <span class=\"token keyword\">return</span> array<span class=\"token punctuation\">[</span>array<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 返回最大值，即最大收益值；</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>2. 优化的方法，动态规划：</strong></p>\n<p>此处采用动态规划的方法，两个变量分别保存着当前出现过的最低价格和最大收益，每一次出现比当前最低价格低的元素时便更新当前最低价格变量所存储的值，同时并按照当前最低价格来计算后续出现的最大利益。算法时间复杂度 “O(n)”。代码如下所示：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">maxProfitOptimize</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> prices<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> arrLen <span class=\"token operator\">=</span> prices<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>arrLen <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> maxProfit <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> curMin <span class=\"token operator\">=</span> prices<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> arrLen<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        curMin <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">min</span><span class=\"token punctuation\">(</span>curMin<span class=\"token punctuation\">,</span> prices<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 更新最低价格；</span>\n        maxProfit <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>maxProfit<span class=\"token punctuation\">,</span> prices<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> curMin<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 更新最大收益；</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> maxProfit<span class=\"token punctuation\">;</span>   \n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>3. 效率更高的方法：</strong>你的想法。</p>\n","site":{"data":{}},"id":"2713809aaa34ff465c0583980ff32c1b","excerpt":"","more":"<p>LeetCode 每日一题系列，今天第六题，今天的题目是一道算法描述问题，需要先读懂题目，然后“翻译”成算法需求，再按照算法需求来解决问题。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Array】</p>\n<h4 id=\"121-Best-Time-to-Buy-and-Sell-Stock：\"><a href=\"#121-Best-Time-to-Buy-and-Sell-Stock：\" class=\"headerlink\" title=\"121. Best Time to Buy and Sell Stock：\"></a>121. <a href=\"https://leetcode.com/problems/majority-element/\" target=\"_blank\" rel=\"noopener\">Best Time to Buy and Sell Stock</a>：</h4><blockquote>\n<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>\n</blockquote>\n<blockquote>\n<p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>\n</blockquote>\n<p><strong>Example：</strong></p>\n<pre><code class=\"text\">Given prices = [2, 7, 11, 15],\n\nBecause you can get the maximum profit if you buy at the first day and sell at the forth day. \nReturn the maximum profit by one transaction is 13.\n</code></pre>\n<p><strong>0. 题目大意：</strong></p>\n<p>假设有一个数组，其中第 n 个元素的值为第 n 天股票的价格。如果你只有一次买入和卖出的机会，请设计一个算法来寻找你卖出一股的最大收益。例如给出数组 [1, 3, 9, 4, 5, 1, 4]，即第一天的股票价格为1（买入和卖出相同），第二天的股票价格为3，其他以此类推。若只有一次买入和卖出的机会，则在第一天买入，第3天卖出时会获利最大为8。</p>\n<p><strong>1. 最基本的方法，列出所有可能的收益值：</strong></p>\n<p>这里我们能想到的第一种最基本的解决方案就是采用遍历所有可能性的方法来找到最大收益值。请注意题目中的<strong>卖出过程只能在买入之后进行</strong>，因此选取的卖出价格对应的元素一定位于买入元素的后边，即“卖出”价格对应元素的索引一定大于“买入”价格元素的索引，这一点要十分注意。我们这里选择用 HashSet 来存储所有可能出现的收益值。该算法时间复杂度 “O(n2)”。代码如下所示：</p>\n<pre><code class=\"java\">public static int maxProfit(int[] prices) {\n    int arrLen = prices.length;\n    Set&lt;Integer&gt; set = new HashSet&lt;&gt;();\n\n    if (arrLen == 0)\n        return 0;\n\n    for (int i = 0; i &lt; arrLen - 1; i++) {  // i 指针对应元素值为买入价；\n        for (int j = i + 1; j &lt; arrLen; j++) {  // j 指针对应元素值为卖出价；\n            int maxVal = prices[j] - prices[i];  // 获得所有可能的收益值；\n            if (maxVal &gt;= 0)\n                set.add(maxVal);  // 将正收益值存入 Set；\n        }\n    }\n\n    if (set.isEmpty())\n        return 0;\n\n    Integer[] array = (Integer[]) set.toArray(new Integer[set.size()]);  // 将 Set 转换为 Array；\n    Arrays.sort(array);  // 对 Array 进行排序；\n    return array[array.length - 1];  // 返回最大值，即最大收益值；\n}\n</code></pre>\n<p><strong>2. 优化的方法，动态规划：</strong></p>\n<p>此处采用动态规划的方法，两个变量分别保存着当前出现过的最低价格和最大收益，每一次出现比当前最低价格低的元素时便更新当前最低价格变量所存储的值，同时并按照当前最低价格来计算后续出现的最大利益。算法时间复杂度 “O(n)”。代码如下所示：</p>\n<pre><code class=\"java\">public static int maxProfitOptimize(int[] prices) {\n    int arrLen = prices.length;\n\n    if (arrLen == 0)\n        return 0;\n\n    int maxProfit = 0;\n    int curMin = prices[0];\n\n    for (int i = 1; i &lt; arrLen; i++) {\n        curMin = Math.min(curMin, prices[i]);  // 更新最低价格；\n        maxProfit = Math.max(maxProfit, prices[i] - curMin);  // 更新最大收益；\n    }\n\n    return maxProfit;   \n}\n</code></pre>\n<p><strong>3. 效率更高的方法：</strong>你的想法。</p>\n"},{"title":"LeetCode 每日一题 - 169. Majority Element","intro":"LeetCode 每日一题系列，今天第五题。昨天由于事情比较多所以没有抽出时间更新文章，今天来一道简单的题，在星期六的日子里轻松一下。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Divide and Conquer】【Array】【Bit Manipulation】","comments":1,"date":"2016-04-16T12:09:00.000Z","_content":"\nLeetCode 每日一题系列，今天第五题。昨天由于事情比较多所以没有抽出时间更新文章，今天来一道简单的题，在星期六的日子里轻松一下。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Divide and Conquer】【Array】【Bit Manipulation】\n\n#### 169. [Majority Element](https://leetcode.com/problems/majority-element/)：\n\n\n> Given an array of size n, find the majority element. The majority element is the element that appears **more than ⌊ n/2 ⌋** times.\n\n> You may assume that the array is non-empty and the majority element always exist in the array.\n\n<strong>Example:</strong>\n\n```text\nGiven nums = [2, 7, 2, 15, 2, 7, 2],\n\nBecause integer 2 appears more than 3.5 times, so after your function it should return integer 2.\n```\n\n**1. 利用HashMap：**\n\n相信经过前面几道题目的经验加成，这里大家第一个想到的就是利用 HashMap 来存储每个元素出现的次数。并且使用优化过的 HashMap 流程，即不需要将所有元素的个数全部统计出来后再判断，而是每次循环时先检查 HashMap 里是否含有当前元素，如果有则判断当前元素出现的次数（即 HashMap 中该元素所对应的 Value）是否超过数组长度的一半，如果超过则返回，否则 HashMap 里该元素的 Value 值加一。代码时间复杂度 “O(n)”。代码如下所示：\n\n```java\npublic static int majorityElement(int[] nums) {\n    if (nums.length == 0)  // 如果数组长度为0则返回-1；\n    \treturn -1;\n    \n    int arrLen = nums.length;\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0;i < arrLen; i++) {\n    \tint currentVal = 0;\n    \tif (map.containsKey(nums[i]))  // 如果 HashMap 中存在该值对应的元素则使用该值；\n    \t\tcurrentVal = map.get(nums[i]);\n\n    \tif (currentVal > arrLen / 2) {  // 如果满足条件则返回该元素；\n    \t\treturn nums[i];\n    \t} else {\n    \t\tmap.put(nums[i], currentVal + 1);  // 否则对应元素值加一；\n    \t}\n    }\n    \n    return -1;\n}\n```\n\n\n\n**2. 优化的方法，堆排序：**\n\n如果仔细阅读题目可以发现题目中已经假定数组一定为非空数组，并且一定含有一系列元素的值满足所给条件，即该值对应元素在数组中出现的次数大于数组长度的一半。这里我们便可以采用先排序后取值的方法，如果一个元素满足上述所给条件，则排序后的数组的**中间（Middle）元素**一定为所求元素。这里我们直接使用 Java 自带的堆排序方法进行排序。代码如下所示：\n\n```java\npublic static boolean majorityElementOptimize(int[] nums) {\n    if (nums.length == 0)\n        return -1;\n    \n    int arrLen = nums.length;\n    Arrays.sort(nums);  // 对数组进行堆排序；\n    return nums[arrLen / 2];  // 返回中间元素；\n}\n```\n\n\n3、**另一种思路**：\n\n网友 “**JD**” 给出的另一种思路，Majority 的元素总量会占到数组一半以上，所以不同数字两两相抵之后 Majority 元素的剩余数量一定大于0。代码如下所示：\n\n```java\npublic static int majorityElementOptimize(int[] nums) {\n    if (nums.length == 0)\n        return -1;\n    \n    int arrLen = nums.length;\n    int mark = nums[0], count = 1;\n    for (int i = 1; i < arrLen; i++) {\n        if (count == 0) {\n            mark = nums[i];\n            count = 1;\n            continue;\n        }\n\n        if (nums[i] != mark) {\n            count--;\n        }\n        \n        if (nums[i] == mark) {\n            count++;\n        }\n    }\n    \n    return mark;\n}\n```\n","source":"_posts/LeetCode-每日一题-169-Majority-Element.md","raw":"---\ntitle: LeetCode 每日一题 - 169. Majority Element\nintro: LeetCode 每日一题系列，今天第五题。昨天由于事情比较多所以没有抽出时间更新文章，今天来一道简单的题，在星期六的日子里轻松一下。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Divide and Conquer】【Array】【Bit Manipulation】\ncomments: true\ndate: 2016-04-16 20:09:00\ntags:\n- 算法\n- LeetCode\n---\n\nLeetCode 每日一题系列，今天第五题。昨天由于事情比较多所以没有抽出时间更新文章，今天来一道简单的题，在星期六的日子里轻松一下。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Divide and Conquer】【Array】【Bit Manipulation】\n\n#### 169. [Majority Element](https://leetcode.com/problems/majority-element/)：\n\n\n> Given an array of size n, find the majority element. The majority element is the element that appears **more than ⌊ n/2 ⌋** times.\n\n> You may assume that the array is non-empty and the majority element always exist in the array.\n\n<strong>Example:</strong>\n\n```text\nGiven nums = [2, 7, 2, 15, 2, 7, 2],\n\nBecause integer 2 appears more than 3.5 times, so after your function it should return integer 2.\n```\n\n**1. 利用HashMap：**\n\n相信经过前面几道题目的经验加成，这里大家第一个想到的就是利用 HashMap 来存储每个元素出现的次数。并且使用优化过的 HashMap 流程，即不需要将所有元素的个数全部统计出来后再判断，而是每次循环时先检查 HashMap 里是否含有当前元素，如果有则判断当前元素出现的次数（即 HashMap 中该元素所对应的 Value）是否超过数组长度的一半，如果超过则返回，否则 HashMap 里该元素的 Value 值加一。代码时间复杂度 “O(n)”。代码如下所示：\n\n```java\npublic static int majorityElement(int[] nums) {\n    if (nums.length == 0)  // 如果数组长度为0则返回-1；\n    \treturn -1;\n    \n    int arrLen = nums.length;\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0;i < arrLen; i++) {\n    \tint currentVal = 0;\n    \tif (map.containsKey(nums[i]))  // 如果 HashMap 中存在该值对应的元素则使用该值；\n    \t\tcurrentVal = map.get(nums[i]);\n\n    \tif (currentVal > arrLen / 2) {  // 如果满足条件则返回该元素；\n    \t\treturn nums[i];\n    \t} else {\n    \t\tmap.put(nums[i], currentVal + 1);  // 否则对应元素值加一；\n    \t}\n    }\n    \n    return -1;\n}\n```\n\n\n\n**2. 优化的方法，堆排序：**\n\n如果仔细阅读题目可以发现题目中已经假定数组一定为非空数组，并且一定含有一系列元素的值满足所给条件，即该值对应元素在数组中出现的次数大于数组长度的一半。这里我们便可以采用先排序后取值的方法，如果一个元素满足上述所给条件，则排序后的数组的**中间（Middle）元素**一定为所求元素。这里我们直接使用 Java 自带的堆排序方法进行排序。代码如下所示：\n\n```java\npublic static boolean majorityElementOptimize(int[] nums) {\n    if (nums.length == 0)\n        return -1;\n    \n    int arrLen = nums.length;\n    Arrays.sort(nums);  // 对数组进行堆排序；\n    return nums[arrLen / 2];  // 返回中间元素；\n}\n```\n\n\n3、**另一种思路**：\n\n网友 “**JD**” 给出的另一种思路，Majority 的元素总量会占到数组一半以上，所以不同数字两两相抵之后 Majority 元素的剩余数量一定大于0。代码如下所示：\n\n```java\npublic static int majorityElementOptimize(int[] nums) {\n    if (nums.length == 0)\n        return -1;\n    \n    int arrLen = nums.length;\n    int mark = nums[0], count = 1;\n    for (int i = 1; i < arrLen; i++) {\n        if (count == 0) {\n            mark = nums[i];\n            count = 1;\n            continue;\n        }\n\n        if (nums[i] != mark) {\n            count--;\n        }\n        \n        if (nums[i] == mark) {\n            count++;\n        }\n    }\n    \n    return mark;\n}\n```\n","slug":"LeetCode-每日一题-169-Majority-Element","published":1,"updated":"2019-02-10T02:50:20.763Z","layout":"post","photos":[],"link":"","_id":"cjsqwht9c0024knp2gdmqoojl","content":"<p>LeetCode 每日一题系列，今天第五题。昨天由于事情比较多所以没有抽出时间更新文章，今天来一道简单的题，在星期六的日子里轻松一下。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Divide and Conquer】【Array】【Bit Manipulation】</p>\n<h4 id=\"169-Majority-Element：\"><a href=\"#169-Majority-Element：\" class=\"headerlink\" title=\"169. Majority Element：\"></a>169. <a href=\"https://leetcode.com/problems/majority-element/\" target=\"_blank\" rel=\"noopener\">Majority Element</a>：</h4><blockquote>\n<p>Given an array of size n, find the majority element. The majority element is the element that appears <strong>more than ⌊ n/2 ⌋</strong> times.</p>\n</blockquote>\n<blockquote>\n<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>\n</blockquote>\n<p><strong>Example:</strong></p>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">Given nums = [2, 7, 2, 15, 2, 7, 2],\n\nBecause integer 2 appears more than 3.5 times, so after your function it should return integer 2.\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p><strong>1. 利用HashMap：</strong></p>\n<p>相信经过前面几道题目的经验加成，这里大家第一个想到的就是利用 HashMap 来存储每个元素出现的次数。并且使用优化过的 HashMap 流程，即不需要将所有元素的个数全部统计出来后再判断，而是每次循环时先检查 HashMap 里是否含有当前元素，如果有则判断当前元素出现的次数（即 HashMap 中该元素所对应的 Value）是否超过数组长度的一半，如果超过则返回，否则 HashMap 里该元素的 Value 值加一。代码时间复杂度 “O(n)”。代码如下所示：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">majorityElement</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">.</span>length <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\" spellcheck=\"true\">// 如果数组长度为0则返回-1；</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> arrLen <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    Map<span class=\"token operator\">&lt;</span>Integer<span class=\"token punctuation\">,</span> Integer<span class=\"token operator\">></span> map <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i <span class=\"token operator\">&lt;</span> arrLen<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> currentVal <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">.</span><span class=\"token function\">containsKey</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\" spellcheck=\"true\">// 如果 HashMap 中存在该值对应的元素则使用该值；</span>\n            currentVal <span class=\"token operator\">=</span> map<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>currentVal <span class=\"token operator\">></span> arrLen <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  <span class=\"token comment\" spellcheck=\"true\">// 如果满足条件则返回该元素；</span>\n            <span class=\"token keyword\">return</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> currentVal <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 否则对应元素值加一；</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>2. 优化的方法，堆排序：</strong></p>\n<p>如果仔细阅读题目可以发现题目中已经假定数组一定为非空数组，并且一定含有一系列元素的值满足所给条件，即该值对应元素在数组中出现的次数大于数组长度的一半。这里我们便可以采用先排序后取值的方法，如果一个元素满足上述所给条件，则排序后的数组的<strong>中间（Middle）元素</strong>一定为所求元素。这里我们直接使用 Java 自带的堆排序方法进行排序。代码如下所示：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">majorityElementOptimize</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">.</span>length <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> arrLen <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    Arrays<span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 对数组进行堆排序；</span>\n    <span class=\"token keyword\">return</span> nums<span class=\"token punctuation\">[</span>arrLen <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 返回中间元素；</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>3、<strong>另一种思路</strong>：</p>\n<p>网友 “<strong>JD</strong>” 给出的另一种思路，Majority 的元素总量会占到数组一半以上，所以不同数字两两相抵之后 Majority 元素的剩余数量一定大于0。代码如下所示：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">majorityElementOptimize</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">.</span>length <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> arrLen <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> mark <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> count <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> arrLen<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>count <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            mark <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            count <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> mark<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            count<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> mark<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            count<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> mark<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"id":"1c3b171483c5b68f83fba61f2590a00b","excerpt":"","more":"<p>LeetCode 每日一题系列，今天第五题。昨天由于事情比较多所以没有抽出时间更新文章，今天来一道简单的题，在星期六的日子里轻松一下。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Divide and Conquer】【Array】【Bit Manipulation】</p>\n<h4 id=\"169-Majority-Element：\"><a href=\"#169-Majority-Element：\" class=\"headerlink\" title=\"169. Majority Element：\"></a>169. <a href=\"https://leetcode.com/problems/majority-element/\" target=\"_blank\" rel=\"noopener\">Majority Element</a>：</h4><blockquote>\n<p>Given an array of size n, find the majority element. The majority element is the element that appears <strong>more than ⌊ n/2 ⌋</strong> times.</p>\n</blockquote>\n<blockquote>\n<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>\n</blockquote>\n<p><strong>Example:</strong></p>\n<pre><code class=\"text\">Given nums = [2, 7, 2, 15, 2, 7, 2],\n\nBecause integer 2 appears more than 3.5 times, so after your function it should return integer 2.\n</code></pre>\n<p><strong>1. 利用HashMap：</strong></p>\n<p>相信经过前面几道题目的经验加成，这里大家第一个想到的就是利用 HashMap 来存储每个元素出现的次数。并且使用优化过的 HashMap 流程，即不需要将所有元素的个数全部统计出来后再判断，而是每次循环时先检查 HashMap 里是否含有当前元素，如果有则判断当前元素出现的次数（即 HashMap 中该元素所对应的 Value）是否超过数组长度的一半，如果超过则返回，否则 HashMap 里该元素的 Value 值加一。代码时间复杂度 “O(n)”。代码如下所示：</p>\n<pre><code class=\"java\">public static int majorityElement(int[] nums) {\n    if (nums.length == 0)  // 如果数组长度为0则返回-1；\n        return -1;\n\n    int arrLen = nums.length;\n    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();\n    for (int i = 0;i &lt; arrLen; i++) {\n        int currentVal = 0;\n        if (map.containsKey(nums[i]))  // 如果 HashMap 中存在该值对应的元素则使用该值；\n            currentVal = map.get(nums[i]);\n\n        if (currentVal &gt; arrLen / 2) {  // 如果满足条件则返回该元素；\n            return nums[i];\n        } else {\n            map.put(nums[i], currentVal + 1);  // 否则对应元素值加一；\n        }\n    }\n\n    return -1;\n}\n</code></pre>\n<p><strong>2. 优化的方法，堆排序：</strong></p>\n<p>如果仔细阅读题目可以发现题目中已经假定数组一定为非空数组，并且一定含有一系列元素的值满足所给条件，即该值对应元素在数组中出现的次数大于数组长度的一半。这里我们便可以采用先排序后取值的方法，如果一个元素满足上述所给条件，则排序后的数组的<strong>中间（Middle）元素</strong>一定为所求元素。这里我们直接使用 Java 自带的堆排序方法进行排序。代码如下所示：</p>\n<pre><code class=\"java\">public static boolean majorityElementOptimize(int[] nums) {\n    if (nums.length == 0)\n        return -1;\n\n    int arrLen = nums.length;\n    Arrays.sort(nums);  // 对数组进行堆排序；\n    return nums[arrLen / 2];  // 返回中间元素；\n}\n</code></pre>\n<p>3、<strong>另一种思路</strong>：</p>\n<p>网友 “<strong>JD</strong>” 给出的另一种思路，Majority 的元素总量会占到数组一半以上，所以不同数字两两相抵之后 Majority 元素的剩余数量一定大于0。代码如下所示：</p>\n<pre><code class=\"java\">public static int majorityElementOptimize(int[] nums) {\n    if (nums.length == 0)\n        return -1;\n\n    int arrLen = nums.length;\n    int mark = nums[0], count = 1;\n    for (int i = 1; i &lt; arrLen; i++) {\n        if (count == 0) {\n            mark = nums[i];\n            count = 1;\n            continue;\n        }\n\n        if (nums[i] != mark) {\n            count--;\n        }\n\n        if (nums[i] == mark) {\n            count++;\n        }\n    }\n\n    return mark;\n}\n</code></pre>\n"},{"title":"LeetCode 每日一题 - 203. Remove Linked List Elements","intro":"LeetCode 每日一题系列，今天第十七题。好久不见，不管事情有多忙，算法还是要继续学习和研究下去，今天的是一道十分简单的链表题。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Linked List】","comments":1,"date":"2016-06-15T08:47:28.000Z","_content":"\n\nLeetCode 每日一题系列，今天第十七题。好久不见，不管事情有多忙，算法还是要继续学习和研究下去，今天的是一道十分简单的链表题。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Linked List】\n\n#### 203. [Remove Linked List Elements](https://leetcode.com/problems/remove-linked-list-elements/)：\n\n> Remove all elements from a linked list of integers that have value val.\n\n**Example：**\n\n```text\nGiven: 1 --> 2 --> 6 --> 3 --> 4 --> 5 --> 6, val = 6\n\nReturn: 1 --> 2 --> 3 --> 4 --> 5\n```\n\n**0. 题目大意：**\n\n给定一个链表的头（Head）节点，和一个数值 **val**，去除链表中所有数值等于 **val** 的节点。\n\n**1. 常规方法，链表删除特定节点：**\n\n最基本的思路无非是遍历整个链表的所有节点，只要该节点的 **val** 属性值等于给定的值，便在链表中去掉该节点。在去掉链表节点的过程中，应该遵循以下原则：\n\n* 先将该节点的上一个节点的 **next** 指针指向该节点的下一个节点；\n* 然后再删除该节点即可；\n\n这里的代码中还用到了另一个小的思路：在该链表的头节点前加入一个“伪节点”，这个“伪节点”的作用是为了保持删除头节点和删除其他节点的方式保持一致，即均遵循我们上述的步骤。代码如下所示：\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\n\npublic class Solution {\n    public ListNode removeElements(ListNode head, int val) {  \n        // 在头节点前加入“伪节点”；\n        ListNode fakeNode = new ListNode(0);  \n        fakeNode.next = head;  \n        // 两个节点指针分别指向“伪节点”和“首节点”；\n        ListNode p = fakeNode;  \n        ListNode q = head;  \n        // 当下一个节点存在时继续遍历；\n        while (q! = null) {  \n            if (q.val == val) {  \n                // 删除该节点；\n                p.next = q.next;  \n            } else {  \n                // p 指针后移；\n                p = p.next;  \n            }  \n            // q 指针后移；\n            q = q.next;  \n        }  \n        \n        // 返回“首节点”\n        return fakeNode.next;  \n    }  \n}\n```\n\n```text\n63 / 63 test cases passed.\nStatus: Accepted\nRuntime: 2 ms\n```\n","source":"_posts/LeetCode-每日一题-203-Remove-Linked-List-Elements.md","raw":"---\ntitle: LeetCode 每日一题 - 203. Remove Linked List Elements\nintro: LeetCode 每日一题系列，今天第十七题。好久不见，不管事情有多忙，算法还是要继续学习和研究下去，今天的是一道十分简单的链表题。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Linked List】\ncomments: true\ndate: 2016-06-15 16:47:28\ntags:\n- 算法\n- LeetCode\n---\n\n\nLeetCode 每日一题系列，今天第十七题。好久不见，不管事情有多忙，算法还是要继续学习和研究下去，今天的是一道十分简单的链表题。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Linked List】\n\n#### 203. [Remove Linked List Elements](https://leetcode.com/problems/remove-linked-list-elements/)：\n\n> Remove all elements from a linked list of integers that have value val.\n\n**Example：**\n\n```text\nGiven: 1 --> 2 --> 6 --> 3 --> 4 --> 5 --> 6, val = 6\n\nReturn: 1 --> 2 --> 3 --> 4 --> 5\n```\n\n**0. 题目大意：**\n\n给定一个链表的头（Head）节点，和一个数值 **val**，去除链表中所有数值等于 **val** 的节点。\n\n**1. 常规方法，链表删除特定节点：**\n\n最基本的思路无非是遍历整个链表的所有节点，只要该节点的 **val** 属性值等于给定的值，便在链表中去掉该节点。在去掉链表节点的过程中，应该遵循以下原则：\n\n* 先将该节点的上一个节点的 **next** 指针指向该节点的下一个节点；\n* 然后再删除该节点即可；\n\n这里的代码中还用到了另一个小的思路：在该链表的头节点前加入一个“伪节点”，这个“伪节点”的作用是为了保持删除头节点和删除其他节点的方式保持一致，即均遵循我们上述的步骤。代码如下所示：\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\n\npublic class Solution {\n    public ListNode removeElements(ListNode head, int val) {  \n        // 在头节点前加入“伪节点”；\n        ListNode fakeNode = new ListNode(0);  \n        fakeNode.next = head;  \n        // 两个节点指针分别指向“伪节点”和“首节点”；\n        ListNode p = fakeNode;  \n        ListNode q = head;  \n        // 当下一个节点存在时继续遍历；\n        while (q! = null) {  \n            if (q.val == val) {  \n                // 删除该节点；\n                p.next = q.next;  \n            } else {  \n                // p 指针后移；\n                p = p.next;  \n            }  \n            // q 指针后移；\n            q = q.next;  \n        }  \n        \n        // 返回“首节点”\n        return fakeNode.next;  \n    }  \n}\n```\n\n```text\n63 / 63 test cases passed.\nStatus: Accepted\nRuntime: 2 ms\n```\n","slug":"LeetCode-每日一题-203-Remove-Linked-List-Elements","published":1,"updated":"2019-02-10T02:50:27.327Z","layout":"post","photos":[],"link":"","_id":"cjsqwht9c0025knp2ozgfuo7k","content":"<p>LeetCode 每日一题系列，今天第十七题。好久不见，不管事情有多忙，算法还是要继续学习和研究下去，今天的是一道十分简单的链表题。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Linked List】</p>\n<h4 id=\"203-Remove-Linked-List-Elements：\"><a href=\"#203-Remove-Linked-List-Elements：\" class=\"headerlink\" title=\"203. Remove Linked List Elements：\"></a>203. <a href=\"https://leetcode.com/problems/remove-linked-list-elements/\" target=\"_blank\" rel=\"noopener\">Remove Linked List Elements</a>：</h4><blockquote>\n<p>Remove all elements from a linked list of integers that have value val.</p>\n</blockquote>\n<p><strong>Example：</strong></p>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">Given: 1 --> 2 --> 6 --> 3 --> 4 --> 5 --> 6, val = 6\n\nReturn: 1 --> 2 --> 3 --> 4 --> 5\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p><strong>0. 题目大意：</strong></p>\n<p>给定一个链表的头（Head）节点，和一个数值 <strong>val</strong>，去除链表中所有数值等于 <strong>val</strong> 的节点。</p>\n<p><strong>1. 常规方法，链表删除特定节点：</strong></p>\n<p>最基本的思路无非是遍历整个链表的所有节点，只要该节点的 <strong>val</strong> 属性值等于给定的值，便在链表中去掉该节点。在去掉链表节点的过程中，应该遵循以下原则：</p>\n<ul>\n<li>先将该节点的上一个节点的 <strong>next</strong> 指针指向该节点的下一个节点；</li>\n<li>然后再删除该节点即可；</li>\n</ul>\n<p>这里的代码中还用到了另一个小的思路：在该链表的头节点前加入一个“伪节点”，这个“伪节点”的作用是为了保持删除头节点和删除其他节点的方式保持一致，即均遵循我们上述的步骤。代码如下所示：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> ListNode <span class=\"token function\">removeElements</span><span class=\"token punctuation\">(</span>ListNode head<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> val<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n        <span class=\"token comment\" spellcheck=\"true\">// 在头节点前加入“伪节点”；</span>\n        ListNode fakeNode <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ListNode</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n        fakeNode<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> head<span class=\"token punctuation\">;</span>  \n        <span class=\"token comment\" spellcheck=\"true\">// 两个节点指针分别指向“伪节点”和“首节点”；</span>\n        ListNode p <span class=\"token operator\">=</span> fakeNode<span class=\"token punctuation\">;</span>  \n        ListNode q <span class=\"token operator\">=</span> head<span class=\"token punctuation\">;</span>  \n        <span class=\"token comment\" spellcheck=\"true\">// 当下一个节点存在时继续遍历；</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>q<span class=\"token operator\">!</span> <span class=\"token operator\">=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">.</span>val <span class=\"token operator\">==</span> val<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n                <span class=\"token comment\" spellcheck=\"true\">// 删除该节点；</span>\n                p<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> q<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>  \n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>  \n                <span class=\"token comment\" spellcheck=\"true\">// p 指针后移；</span>\n                p <span class=\"token operator\">=</span> p<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>  \n            <span class=\"token punctuation\">}</span>  \n            <span class=\"token comment\" spellcheck=\"true\">// q 指针后移；</span>\n            q <span class=\"token operator\">=</span> q<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>  \n        <span class=\"token punctuation\">}</span>  \n\n        <span class=\"token comment\" spellcheck=\"true\">// 返回“首节点”</span>\n        <span class=\"token keyword\">return</span> fakeNode<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>  \n    <span class=\"token punctuation\">}</span>  \n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">63 / 63 test cases passed.\nStatus: Accepted\nRuntime: 2 ms\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"id":"5993f9a6e02641dc230c67e3d0f1f876","excerpt":"","more":"<p>LeetCode 每日一题系列，今天第十七题。好久不见，不管事情有多忙，算法还是要继续学习和研究下去，今天的是一道十分简单的链表题。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Linked List】</p>\n<h4 id=\"203-Remove-Linked-List-Elements：\"><a href=\"#203-Remove-Linked-List-Elements：\" class=\"headerlink\" title=\"203. Remove Linked List Elements：\"></a>203. <a href=\"https://leetcode.com/problems/remove-linked-list-elements/\" target=\"_blank\" rel=\"noopener\">Remove Linked List Elements</a>：</h4><blockquote>\n<p>Remove all elements from a linked list of integers that have value val.</p>\n</blockquote>\n<p><strong>Example：</strong></p>\n<pre><code class=\"text\">Given: 1 --&gt; 2 --&gt; 6 --&gt; 3 --&gt; 4 --&gt; 5 --&gt; 6, val = 6\n\nReturn: 1 --&gt; 2 --&gt; 3 --&gt; 4 --&gt; 5\n</code></pre>\n<p><strong>0. 题目大意：</strong></p>\n<p>给定一个链表的头（Head）节点，和一个数值 <strong>val</strong>，去除链表中所有数值等于 <strong>val</strong> 的节点。</p>\n<p><strong>1. 常规方法，链表删除特定节点：</strong></p>\n<p>最基本的思路无非是遍历整个链表的所有节点，只要该节点的 <strong>val</strong> 属性值等于给定的值，便在链表中去掉该节点。在去掉链表节点的过程中，应该遵循以下原则：</p>\n<ul>\n<li>先将该节点的上一个节点的 <strong>next</strong> 指针指向该节点的下一个节点；</li>\n<li>然后再删除该节点即可；</li>\n</ul>\n<p>这里的代码中还用到了另一个小的思路：在该链表的头节点前加入一个“伪节点”，这个“伪节点”的作用是为了保持删除头节点和删除其他节点的方式保持一致，即均遵循我们上述的步骤。代码如下所示：</p>\n<pre><code class=\"java\">/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\n\npublic class Solution {\n    public ListNode removeElements(ListNode head, int val) {  \n        // 在头节点前加入“伪节点”；\n        ListNode fakeNode = new ListNode(0);  \n        fakeNode.next = head;  \n        // 两个节点指针分别指向“伪节点”和“首节点”；\n        ListNode p = fakeNode;  \n        ListNode q = head;  \n        // 当下一个节点存在时继续遍历；\n        while (q! = null) {  \n            if (q.val == val) {  \n                // 删除该节点；\n                p.next = q.next;  \n            } else {  \n                // p 指针后移；\n                p = p.next;  \n            }  \n            // q 指针后移；\n            q = q.next;  \n        }  \n\n        // 返回“首节点”\n        return fakeNode.next;  \n    }  \n}\n</code></pre>\n<pre><code class=\"text\">63 / 63 test cases passed.\nStatus: Accepted\nRuntime: 2 ms\n</code></pre>\n"},{"title":"LeetCode 每日一题 - 217. Contains Duplicate","intro":"LeetCode 每日一题系列，今天第三题。早上写了三种解题方法，前两种 “Time Limit Exceeded” 了，第三种通过了 Judge，不过三种方法都可以实现，只是效率不同。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Array】【HashTable】","comments":1,"date":"2016-04-13T01:45:09.000Z","_content":"\nLeetCode 每日一题系列，今天第三题。早上写了三种解题方法，前两种 “Time Limit Exceeded” 了，第三种通过了 Judge，不过三种方法都可以实现，只是效率不同。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Array】【HashTable】\n\n#### 217. [Contains Duplicate](https://leetcode.com/problems/contains-duplicate/)：\n\n> Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.\n\n**Example：**\n\n```text\nGiven nums = [2, 7, 11, 15],\n\nBecause nums contains not any duplicates, so after your function it should return false.\nElse return true.\n```\n\n**1. 最基本的方法，两个指针，依次比较对应元素值是否相同：**\n\n遍历所有可能性是解决算法问题最基本也是最暴力的方式。理论上来讲在实际工作遇到的“大部分”业务中，不用过多考虑算法的成本问题，因为对于现在的大多数 PC 或服务器来说，其性能已经足够强悍可以承担任何低效率算法所带来的负载了。两个指针，**指针 i** 指向当前元素，**指针 j** 指向 **i** 其后的任意元素。最内层循环依次比较**指针 i** 与**指针 j** 对应元素大小，外层循环将i指针向后移动，直到找到相等值或完成所有遍历。时间复杂度 “O(n2)”。代码如下所示：\n\n```java\npublic static boolean containsDuplicate(int[] nums) {\n    int arrLen = nums.length;\n\t\n    for (int i = 0; i < arrLen - 1; i++) {      \t\n    \tfor (int j = i + 1; j < arrLen; j++) {\n    \t    if (nums[i] == nums[j])\n    \t\treturn true;\n    \t}\n    }\n    return false;\n}\n```\n\n\n**2. 优化的方法，利用 HashMap：**\n\n们可以使用 HashMap 的 - **在 HashMap 中不能含有重复的 key** 这个特性，来实现数组查重。首先将数组元素作为 key，数组索引作为值依次放入 HashMap 中，此时如果数组中有重复元素，则会被 HashMap 最后一个相同元素覆盖掉。接下来比较 HashMap 的大小和数组的长度是否相等，如果相等则没有重复元素，否则数组含有重复元素。代码如下所示：\n\n```java\npublic static boolean containsDuplicateOptimize(int[] nums) {\n    Map<Integer,Integer< map = new HashMap<>();\n    int arrLen = nums.length;\n    \n    for (int i = 0; i < arrLen; i++) {\n        map.put(nums[i], i);  // 为HashMap赋值\n    }\n    \n    int result = map.size();\n    if (arrLen != result) {\n        return true;\n    }\n    return false;\n}\n```\n\n\n\n**3. 更加优化的方法，同样使用 HashMap：**\n\n这一次我们并不需要把所有元素都放入 HashMap，即不通过比较数组和 HashMap 的大小来判断是否含有重复元素。而是在每次从数组中取一个元素放入 HashMap时，先检查 HashMap 中是否含有此元素，如果没有则放入 HashMap，并继续从数组中取下一个元素，否则返回 `false` 。时间复杂度 “O(n)”。代码如下所示：\n\n```java\npublic static boolean containsDuplicateOptimizeFurther(int[] nums) {\n    Map<Integer,Integer< map = new HashMap<>();\n    int arrLen = nums.length;\n    \n    for (int i = 0; i < arrLen; i++) {\n        if (map.containsKey(nums[i])) {\n            return true;\n        } else {\n            map.put(nums[i], i);\n        }\n    }\n    return false;       \n}\n```\n\n\n**4. 效率更高的方法：**\n\n这里基于 “**Big-O notation**” 理论告诉我们：只有当 n 是一个比较大的数时，“O(n)” 的算法才会体现出其优势。那么这里我们可以采用先排序，再判断相邻元素是否相等来解决此题目。常用的排序算法比如**堆排序**，在最坏情况下会有 “O(nlogn)” 的时间复杂度。\n\n```java\npublic boolean containsDuplicateSort(int[] nums) {\n    Arrays.sort(nums);\n    for (int i = 0; i < nums.length - 1;++i) {\n        if (nums[i] == nums[i + 1]) return true;\n    }\n    return false;\n}\n```\n\n\n\n* **更正**：对于上述的第二种和第三种方法，我们完全可以只使用 Set 即可，并不需要使用 HashMap。示例更正代码如下：\n\n```java\npublic static boolean containsDuplicateSet(int[] nums) {\n    Set<Integer< set = new HashSet<>();\n\n    int arrLen = nums.length;\n\t\n    for (int i = 0; i < arrLen; i++) {\n        set.add(nums[i]);\n    }\n\t\n    int result = set.size();\n    if (arrLen != result) {\n        return true;\n    }\n    return false;\n}\n```\n","source":"_posts/LeetCode-每日一题-217-Contains-Duplicate.md","raw":"---\ntitle: LeetCode 每日一题 - 217. Contains Duplicate\nintro: LeetCode 每日一题系列，今天第三题。早上写了三种解题方法，前两种 “Time Limit Exceeded” 了，第三种通过了 Judge，不过三种方法都可以实现，只是效率不同。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Array】【HashTable】\ncomments: true\ndate: 2016-04-13 09:45:09\ntags:\n- 算法\n- LeetCode\n---\n\nLeetCode 每日一题系列，今天第三题。早上写了三种解题方法，前两种 “Time Limit Exceeded” 了，第三种通过了 Judge，不过三种方法都可以实现，只是效率不同。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Array】【HashTable】\n\n#### 217. [Contains Duplicate](https://leetcode.com/problems/contains-duplicate/)：\n\n> Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.\n\n**Example：**\n\n```text\nGiven nums = [2, 7, 11, 15],\n\nBecause nums contains not any duplicates, so after your function it should return false.\nElse return true.\n```\n\n**1. 最基本的方法，两个指针，依次比较对应元素值是否相同：**\n\n遍历所有可能性是解决算法问题最基本也是最暴力的方式。理论上来讲在实际工作遇到的“大部分”业务中，不用过多考虑算法的成本问题，因为对于现在的大多数 PC 或服务器来说，其性能已经足够强悍可以承担任何低效率算法所带来的负载了。两个指针，**指针 i** 指向当前元素，**指针 j** 指向 **i** 其后的任意元素。最内层循环依次比较**指针 i** 与**指针 j** 对应元素大小，外层循环将i指针向后移动，直到找到相等值或完成所有遍历。时间复杂度 “O(n2)”。代码如下所示：\n\n```java\npublic static boolean containsDuplicate(int[] nums) {\n    int arrLen = nums.length;\n\t\n    for (int i = 0; i < arrLen - 1; i++) {      \t\n    \tfor (int j = i + 1; j < arrLen; j++) {\n    \t    if (nums[i] == nums[j])\n    \t\treturn true;\n    \t}\n    }\n    return false;\n}\n```\n\n\n**2. 优化的方法，利用 HashMap：**\n\n们可以使用 HashMap 的 - **在 HashMap 中不能含有重复的 key** 这个特性，来实现数组查重。首先将数组元素作为 key，数组索引作为值依次放入 HashMap 中，此时如果数组中有重复元素，则会被 HashMap 最后一个相同元素覆盖掉。接下来比较 HashMap 的大小和数组的长度是否相等，如果相等则没有重复元素，否则数组含有重复元素。代码如下所示：\n\n```java\npublic static boolean containsDuplicateOptimize(int[] nums) {\n    Map<Integer,Integer< map = new HashMap<>();\n    int arrLen = nums.length;\n    \n    for (int i = 0; i < arrLen; i++) {\n        map.put(nums[i], i);  // 为HashMap赋值\n    }\n    \n    int result = map.size();\n    if (arrLen != result) {\n        return true;\n    }\n    return false;\n}\n```\n\n\n\n**3. 更加优化的方法，同样使用 HashMap：**\n\n这一次我们并不需要把所有元素都放入 HashMap，即不通过比较数组和 HashMap 的大小来判断是否含有重复元素。而是在每次从数组中取一个元素放入 HashMap时，先检查 HashMap 中是否含有此元素，如果没有则放入 HashMap，并继续从数组中取下一个元素，否则返回 `false` 。时间复杂度 “O(n)”。代码如下所示：\n\n```java\npublic static boolean containsDuplicateOptimizeFurther(int[] nums) {\n    Map<Integer,Integer< map = new HashMap<>();\n    int arrLen = nums.length;\n    \n    for (int i = 0; i < arrLen; i++) {\n        if (map.containsKey(nums[i])) {\n            return true;\n        } else {\n            map.put(nums[i], i);\n        }\n    }\n    return false;       \n}\n```\n\n\n**4. 效率更高的方法：**\n\n这里基于 “**Big-O notation**” 理论告诉我们：只有当 n 是一个比较大的数时，“O(n)” 的算法才会体现出其优势。那么这里我们可以采用先排序，再判断相邻元素是否相等来解决此题目。常用的排序算法比如**堆排序**，在最坏情况下会有 “O(nlogn)” 的时间复杂度。\n\n```java\npublic boolean containsDuplicateSort(int[] nums) {\n    Arrays.sort(nums);\n    for (int i = 0; i < nums.length - 1;++i) {\n        if (nums[i] == nums[i + 1]) return true;\n    }\n    return false;\n}\n```\n\n\n\n* **更正**：对于上述的第二种和第三种方法，我们完全可以只使用 Set 即可，并不需要使用 HashMap。示例更正代码如下：\n\n```java\npublic static boolean containsDuplicateSet(int[] nums) {\n    Set<Integer< set = new HashSet<>();\n\n    int arrLen = nums.length;\n\t\n    for (int i = 0; i < arrLen; i++) {\n        set.add(nums[i]);\n    }\n\t\n    int result = set.size();\n    if (arrLen != result) {\n        return true;\n    }\n    return false;\n}\n```\n","slug":"LeetCode-每日一题-217-Contains-Duplicate","published":1,"updated":"2019-02-10T02:50:30.396Z","layout":"post","photos":[],"link":"","_id":"cjsqwht9e0028knp2zqsv50wo","content":"<p>LeetCode 每日一题系列，今天第三题。早上写了三种解题方法，前两种 “Time Limit Exceeded” 了，第三种通过了 Judge，不过三种方法都可以实现，只是效率不同。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Array】【HashTable】</p>\n<h4 id=\"217-Contains-Duplicate：\"><a href=\"#217-Contains-Duplicate：\" class=\"headerlink\" title=\"217. Contains Duplicate：\"></a>217. <a href=\"https://leetcode.com/problems/contains-duplicate/\" target=\"_blank\" rel=\"noopener\">Contains Duplicate</a>：</h4><blockquote>\n<p>Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.</p>\n</blockquote>\n<p><strong>Example：</strong></p>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">Given nums = [2, 7, 11, 15],\n\nBecause nums contains not any duplicates, so after your function it should return false.\nElse return true.\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>1. 最基本的方法，两个指针，依次比较对应元素值是否相同：</strong></p>\n<p>遍历所有可能性是解决算法问题最基本也是最暴力的方式。理论上来讲在实际工作遇到的“大部分”业务中，不用过多考虑算法的成本问题，因为对于现在的大多数 PC 或服务器来说，其性能已经足够强悍可以承担任何低效率算法所带来的负载了。两个指针，<strong>指针 i</strong> 指向当前元素，<strong>指针 j</strong> 指向 <strong>i</strong> 其后的任意元素。最内层循环依次比较<strong>指针 i</strong> 与<strong>指针 j</strong> 对应元素大小，外层循环将i指针向后移动，直到找到相等值或完成所有遍历。时间复杂度 “O(n2)”。代码如下所示：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">containsDuplicate</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> arrLen <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> arrLen <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>          \n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> arrLen<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> nums<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>2. 优化的方法，利用 HashMap：</strong></p>\n<p>们可以使用 HashMap 的 - <strong>在 HashMap 中不能含有重复的 key</strong> 这个特性，来实现数组查重。首先将数组元素作为 key，数组索引作为值依次放入 HashMap 中，此时如果数组中有重复元素，则会被 HashMap 最后一个相同元素覆盖掉。接下来比较 HashMap 的大小和数组的长度是否相等，如果相等则没有重复元素，否则数组含有重复元素。代码如下所示：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">containsDuplicateOptimize</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    Map<span class=\"token operator\">&lt;</span>Integer<span class=\"token punctuation\">,</span>Integer<span class=\"token operator\">&lt;</span> map <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> arrLen <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> arrLen<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 为HashMap赋值</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">int</span> result <span class=\"token operator\">=</span> map<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>arrLen <span class=\"token operator\">!=</span> result<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>3. 更加优化的方法，同样使用 HashMap：</strong></p>\n<p>这一次我们并不需要把所有元素都放入 HashMap，即不通过比较数组和 HashMap 的大小来判断是否含有重复元素。而是在每次从数组中取一个元素放入 HashMap时，先检查 HashMap 中是否含有此元素，如果没有则放入 HashMap，并继续从数组中取下一个元素，否则返回 <code>false</code> 。时间复杂度 “O(n)”。代码如下所示：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">containsDuplicateOptimizeFurther</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    Map<span class=\"token operator\">&lt;</span>Integer<span class=\"token punctuation\">,</span>Integer<span class=\"token operator\">&lt;</span> map <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> arrLen <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> arrLen<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">.</span><span class=\"token function\">containsKey</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>       \n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>4. 效率更高的方法：</strong></p>\n<p>这里基于 “<strong>Big-O notation</strong>” 理论告诉我们：只有当 n 是一个比较大的数时，“O(n)” 的算法才会体现出其优势。那么这里我们可以采用先排序，再判断相邻元素是否相等来解决此题目。常用的排序算法比如<strong>堆排序</strong>，在最坏情况下会有 “O(nlogn)” 的时间复杂度。</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">containsDuplicateSort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    Arrays<span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> nums<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span><span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> nums<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li><strong>更正</strong>：对于上述的第二种和第三种方法，我们完全可以只使用 Set 即可，并不需要使用 HashMap。示例更正代码如下：</li>\n</ul>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">containsDuplicateSet</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    Set<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">&lt;</span> set <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashSet</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> arrLen <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> arrLen<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        set<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">int</span> result <span class=\"token operator\">=</span> set<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>arrLen <span class=\"token operator\">!=</span> result<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"id":"3a10ea4e184324d53a3cb97393e91016","excerpt":"","more":"<p>LeetCode 每日一题系列，今天第三题。早上写了三种解题方法，前两种 “Time Limit Exceeded” 了，第三种通过了 Judge，不过三种方法都可以实现，只是效率不同。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Array】【HashTable】</p>\n<h4 id=\"217-Contains-Duplicate：\"><a href=\"#217-Contains-Duplicate：\" class=\"headerlink\" title=\"217. Contains Duplicate：\"></a>217. <a href=\"https://leetcode.com/problems/contains-duplicate/\" target=\"_blank\" rel=\"noopener\">Contains Duplicate</a>：</h4><blockquote>\n<p>Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.</p>\n</blockquote>\n<p><strong>Example：</strong></p>\n<pre><code class=\"text\">Given nums = [2, 7, 11, 15],\n\nBecause nums contains not any duplicates, so after your function it should return false.\nElse return true.\n</code></pre>\n<p><strong>1. 最基本的方法，两个指针，依次比较对应元素值是否相同：</strong></p>\n<p>遍历所有可能性是解决算法问题最基本也是最暴力的方式。理论上来讲在实际工作遇到的“大部分”业务中，不用过多考虑算法的成本问题，因为对于现在的大多数 PC 或服务器来说，其性能已经足够强悍可以承担任何低效率算法所带来的负载了。两个指针，<strong>指针 i</strong> 指向当前元素，<strong>指针 j</strong> 指向 <strong>i</strong> 其后的任意元素。最内层循环依次比较<strong>指针 i</strong> 与<strong>指针 j</strong> 对应元素大小，外层循环将i指针向后移动，直到找到相等值或完成所有遍历。时间复杂度 “O(n2)”。代码如下所示：</p>\n<pre><code class=\"java\">public static boolean containsDuplicate(int[] nums) {\n    int arrLen = nums.length;\n\n    for (int i = 0; i &lt; arrLen - 1; i++) {          \n        for (int j = i + 1; j &lt; arrLen; j++) {\n            if (nums[i] == nums[j])\n            return true;\n        }\n    }\n    return false;\n}\n</code></pre>\n<p><strong>2. 优化的方法，利用 HashMap：</strong></p>\n<p>们可以使用 HashMap 的 - <strong>在 HashMap 中不能含有重复的 key</strong> 这个特性，来实现数组查重。首先将数组元素作为 key，数组索引作为值依次放入 HashMap 中，此时如果数组中有重复元素，则会被 HashMap 最后一个相同元素覆盖掉。接下来比较 HashMap 的大小和数组的长度是否相等，如果相等则没有重复元素，否则数组含有重复元素。代码如下所示：</p>\n<pre><code class=\"java\">public static boolean containsDuplicateOptimize(int[] nums) {\n    Map&lt;Integer,Integer&lt; map = new HashMap&lt;&gt;();\n    int arrLen = nums.length;\n\n    for (int i = 0; i &lt; arrLen; i++) {\n        map.put(nums[i], i);  // 为HashMap赋值\n    }\n\n    int result = map.size();\n    if (arrLen != result) {\n        return true;\n    }\n    return false;\n}\n</code></pre>\n<p><strong>3. 更加优化的方法，同样使用 HashMap：</strong></p>\n<p>这一次我们并不需要把所有元素都放入 HashMap，即不通过比较数组和 HashMap 的大小来判断是否含有重复元素。而是在每次从数组中取一个元素放入 HashMap时，先检查 HashMap 中是否含有此元素，如果没有则放入 HashMap，并继续从数组中取下一个元素，否则返回 <code>false</code> 。时间复杂度 “O(n)”。代码如下所示：</p>\n<pre><code class=\"java\">public static boolean containsDuplicateOptimizeFurther(int[] nums) {\n    Map&lt;Integer,Integer&lt; map = new HashMap&lt;&gt;();\n    int arrLen = nums.length;\n\n    for (int i = 0; i &lt; arrLen; i++) {\n        if (map.containsKey(nums[i])) {\n            return true;\n        } else {\n            map.put(nums[i], i);\n        }\n    }\n    return false;       \n}\n</code></pre>\n<p><strong>4. 效率更高的方法：</strong></p>\n<p>这里基于 “<strong>Big-O notation</strong>” 理论告诉我们：只有当 n 是一个比较大的数时，“O(n)” 的算法才会体现出其优势。那么这里我们可以采用先排序，再判断相邻元素是否相等来解决此题目。常用的排序算法比如<strong>堆排序</strong>，在最坏情况下会有 “O(nlogn)” 的时间复杂度。</p>\n<pre><code class=\"java\">public boolean containsDuplicateSort(int[] nums) {\n    Arrays.sort(nums);\n    for (int i = 0; i &lt; nums.length - 1;++i) {\n        if (nums[i] == nums[i + 1]) return true;\n    }\n    return false;\n}\n</code></pre>\n<ul>\n<li><strong>更正</strong>：对于上述的第二种和第三种方法，我们完全可以只使用 Set 即可，并不需要使用 HashMap。示例更正代码如下：</li>\n</ul>\n<pre><code class=\"java\">public static boolean containsDuplicateSet(int[] nums) {\n    Set&lt;Integer&lt; set = new HashSet&lt;&gt;();\n\n    int arrLen = nums.length;\n\n    for (int i = 0; i &lt; arrLen; i++) {\n        set.add(nums[i]);\n    }\n\n    int result = set.size();\n    if (arrLen != result) {\n        return true;\n    }\n    return false;\n}\n</code></pre>\n"},{"title":"LeetCode 每日一题 - 189. Rotate Array","intro":"LeetCode 每日一题系列，今天第七题。今天的题型还是基于数组的变换，观察题目不仅仅是要理解题目的意思，更要去发现题目中的规律，擅于归纳。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Array】","comments":1,"date":"2016-04-19T01:25:56.000Z","_content":"\nLeetCode 每日一题系列，今天第七题。今天的题型还是基于数组的变换，观察题目不仅仅是要理解题目的意思，更要去发现题目中的规律，擅于归纳。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Array】\n\n#### 189. [Rotate Array](https://leetcode.com/problems/rotate-array/)：\n\n\n> Rotate an array of n elements to the right by k steps.\n\n> For example, with **n = 7** and **k = 3**, the array **[1, 2, 3, 4, 5, 6, 7]** is rotated to **[5, 6, 7, 1, 2, 3, 4]**.\n\n**0. 题目大意：**循环地将一个含有 **n** 个元素数组的右边 **k** 个元素搬移到数组左边。举例，给定 **n** 等于7，**k** 等于3，数组 [1, 2, 3, 4, 5, 6, 7] 经过旋转后便得到 [5, 6, 7, 1, 2, 3, 4]。\n\n\n\n**1. 最基本的方法，循环移动**：题目的大意即每一次循环将数组最右的一个元素搬移到数组的最左边，然后将该循环执行 **k** 次，即可得到最后的结果。这里利用两层循环，每一次将最后一个元素搬移到最左边时，要先将最后一个元素存储到临时变量，然后依次将数组所有元素向后移动一个位置，再将临时变量的元素放到第一个位置，这里没有使用新的数组，所以该解法为 “In-Place” 的基础解法。时间复杂度 “O(n2)”。代码如下所示：\n\n```java\npublic static void rotate(int[] nums, int k) {\n    if (nums.length == 0)\n        return;\n        \n    int arrLen = nums.length;\n    for (int i = 0; i < k; i++){\n        int lastVal = nums[nums.length - 1];  // 最后一个值存储到临时变量；\n        for (int j = nums.length - 2; j >= 0 ; j--){  // 所有元素依次后移一位；\n            nums[j + 1] = nums[j]; \n        }\n        nums[0] = lastVal;  // 将临时变量的值赋给第一个元素；\n    }\n}\n```\n\n\n**2. 优化的方法，寻找规律，一步求解：**\n\n如果擅于归纳和寻找题目细节，你会发现该题在计算过程中含有的一些规律。当k的值等于数组长度时，数组不会发生任何改变，即此时循环搬移 **k** 次之后，数组又回到了初始时的顺序。利用此规律，无论 **k** 取何值，我们只需要搬移 “k % 数组长度” 次即可。这里同时利用了一个新的临时数组，整个过程只需先将数组的后 “k % 数组长度” 个元素搬移到新数组的“头部”，原数组剩下的部分搬移到新数组的“尾部”，最后再将新数组的内容拷贝给旧数组即可。算法时间复杂度 “O(n)”。代码如下所示：\n\n```java\npublic static void rotateOptimize(int[] nums, int k) {\n    if (nums.length == 0)\n        return;\n        \n    int arrLen = nums.length;\n    int temp[] = new int[arrLen];\n    k = k % arrLen;\n    \n    for (int i = 0; i < k; i++) {\n       temp[i] = nums[arrLen - k + i];\n    }\n    \n    for (int j = k; j < arrLen; j++){ \n        temp[j] = nums[j - k];\n    }\n    \n    System.arraycopy(temp, 0, nums, 0, nums.length);\n}\n```\n\n\n**3. 效率更高的方法，继续寻找规律，发现本质：**\n\n我们继续来寻找该题的规律，你会发现对于每次需要执行的 “k % 数组长度” 次搬移，我们只要按照下面的步骤都可以顺利完成。\n\n* ① 将数组按照从后往前数第（k % 数组长度）个元素分成前后两部分。如数组 [1, 2, 3, 4, 5, 6]，k 取值2，则分为 [1, 2, 3, 4] 和 [5, 6] 两部分；\n* ② 将前一部分元素全部翻转，得到 [4, 3, 2, 1]；\n* ③ 将后一部分元素全部翻转，得到 [6, 5]；\n* ④ 最后将两部分拼接到一起再进行一次翻转即可得到 [5, 6, 1, 2, 3, 4]；\n\n该算法时间复杂度为 “O(n)”。代码如下所示：\n\n```java\npublic static void rotateOptimizeFuther(int[] nums, int k) {\n    k = k % nums.length;\n \n    if (nums == null || k < 0) {\n        return;\n    }\n \n    int a = nums.length - k; \n \n    reverse(nums, 0, a-1);  // 翻转前一部分元素；\n    reverse(nums, a, nums.length-1);  // 翻转后一部分元素；\n    reverse(nums, 0, nums.length-1);  // 翻转整体元素；\n}\n \npublic static void reverse(int[] nums, int left, int right) {\n    if(nums == null || nums.length == 1) \n        return;\n \n    while(left < right) {\n        // 翻转的整体思路是利用双指针前后调换对应元素的值；\n        int temp = nums[left];\n        nums[left] = nums[right];\n        nums[right] = temp;\n        left++;\n        right--;\n    }   \n}\n```\n","source":"_posts/LeetCode-每日一题-189-Rotate-Array.md","raw":"---\ntitle: LeetCode 每日一题 - 189. Rotate Array\nintro: LeetCode 每日一题系列，今天第七题。今天的题型还是基于数组的变换，观察题目不仅仅是要理解题目的意思，更要去发现题目中的规律，擅于归纳。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Array】\ncomments: true\ndate: 2016-04-19 09:25:56\ntags:\n- 算法\n- LeetCode\n---\n\nLeetCode 每日一题系列，今天第七题。今天的题型还是基于数组的变换，观察题目不仅仅是要理解题目的意思，更要去发现题目中的规律，擅于归纳。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Array】\n\n#### 189. [Rotate Array](https://leetcode.com/problems/rotate-array/)：\n\n\n> Rotate an array of n elements to the right by k steps.\n\n> For example, with **n = 7** and **k = 3**, the array **[1, 2, 3, 4, 5, 6, 7]** is rotated to **[5, 6, 7, 1, 2, 3, 4]**.\n\n**0. 题目大意：**循环地将一个含有 **n** 个元素数组的右边 **k** 个元素搬移到数组左边。举例，给定 **n** 等于7，**k** 等于3，数组 [1, 2, 3, 4, 5, 6, 7] 经过旋转后便得到 [5, 6, 7, 1, 2, 3, 4]。\n\n\n\n**1. 最基本的方法，循环移动**：题目的大意即每一次循环将数组最右的一个元素搬移到数组的最左边，然后将该循环执行 **k** 次，即可得到最后的结果。这里利用两层循环，每一次将最后一个元素搬移到最左边时，要先将最后一个元素存储到临时变量，然后依次将数组所有元素向后移动一个位置，再将临时变量的元素放到第一个位置，这里没有使用新的数组，所以该解法为 “In-Place” 的基础解法。时间复杂度 “O(n2)”。代码如下所示：\n\n```java\npublic static void rotate(int[] nums, int k) {\n    if (nums.length == 0)\n        return;\n        \n    int arrLen = nums.length;\n    for (int i = 0; i < k; i++){\n        int lastVal = nums[nums.length - 1];  // 最后一个值存储到临时变量；\n        for (int j = nums.length - 2; j >= 0 ; j--){  // 所有元素依次后移一位；\n            nums[j + 1] = nums[j]; \n        }\n        nums[0] = lastVal;  // 将临时变量的值赋给第一个元素；\n    }\n}\n```\n\n\n**2. 优化的方法，寻找规律，一步求解：**\n\n如果擅于归纳和寻找题目细节，你会发现该题在计算过程中含有的一些规律。当k的值等于数组长度时，数组不会发生任何改变，即此时循环搬移 **k** 次之后，数组又回到了初始时的顺序。利用此规律，无论 **k** 取何值，我们只需要搬移 “k % 数组长度” 次即可。这里同时利用了一个新的临时数组，整个过程只需先将数组的后 “k % 数组长度” 个元素搬移到新数组的“头部”，原数组剩下的部分搬移到新数组的“尾部”，最后再将新数组的内容拷贝给旧数组即可。算法时间复杂度 “O(n)”。代码如下所示：\n\n```java\npublic static void rotateOptimize(int[] nums, int k) {\n    if (nums.length == 0)\n        return;\n        \n    int arrLen = nums.length;\n    int temp[] = new int[arrLen];\n    k = k % arrLen;\n    \n    for (int i = 0; i < k; i++) {\n       temp[i] = nums[arrLen - k + i];\n    }\n    \n    for (int j = k; j < arrLen; j++){ \n        temp[j] = nums[j - k];\n    }\n    \n    System.arraycopy(temp, 0, nums, 0, nums.length);\n}\n```\n\n\n**3. 效率更高的方法，继续寻找规律，发现本质：**\n\n我们继续来寻找该题的规律，你会发现对于每次需要执行的 “k % 数组长度” 次搬移，我们只要按照下面的步骤都可以顺利完成。\n\n* ① 将数组按照从后往前数第（k % 数组长度）个元素分成前后两部分。如数组 [1, 2, 3, 4, 5, 6]，k 取值2，则分为 [1, 2, 3, 4] 和 [5, 6] 两部分；\n* ② 将前一部分元素全部翻转，得到 [4, 3, 2, 1]；\n* ③ 将后一部分元素全部翻转，得到 [6, 5]；\n* ④ 最后将两部分拼接到一起再进行一次翻转即可得到 [5, 6, 1, 2, 3, 4]；\n\n该算法时间复杂度为 “O(n)”。代码如下所示：\n\n```java\npublic static void rotateOptimizeFuther(int[] nums, int k) {\n    k = k % nums.length;\n \n    if (nums == null || k < 0) {\n        return;\n    }\n \n    int a = nums.length - k; \n \n    reverse(nums, 0, a-1);  // 翻转前一部分元素；\n    reverse(nums, a, nums.length-1);  // 翻转后一部分元素；\n    reverse(nums, 0, nums.length-1);  // 翻转整体元素；\n}\n \npublic static void reverse(int[] nums, int left, int right) {\n    if(nums == null || nums.length == 1) \n        return;\n \n    while(left < right) {\n        // 翻转的整体思路是利用双指针前后调换对应元素的值；\n        int temp = nums[left];\n        nums[left] = nums[right];\n        nums[right] = temp;\n        left++;\n        right--;\n    }   \n}\n```\n","slug":"LeetCode-每日一题-189-Rotate-Array","published":1,"updated":"2019-02-10T02:50:23.571Z","layout":"post","photos":[],"link":"","_id":"cjsqwht9f0029knp2stpufl19","content":"<p>LeetCode 每日一题系列，今天第七题。今天的题型还是基于数组的变换，观察题目不仅仅是要理解题目的意思，更要去发现题目中的规律，擅于归纳。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Array】</p>\n<h4 id=\"189-Rotate-Array：\"><a href=\"#189-Rotate-Array：\" class=\"headerlink\" title=\"189. Rotate Array：\"></a>189. <a href=\"https://leetcode.com/problems/rotate-array/\" target=\"_blank\" rel=\"noopener\">Rotate Array</a>：</h4><blockquote>\n<p>Rotate an array of n elements to the right by k steps.</p>\n</blockquote>\n<blockquote>\n<p>For example, with <strong>n = 7</strong> and <strong>k = 3</strong>, the array <strong>[1, 2, 3, 4, 5, 6, 7]</strong> is rotated to <strong>[5, 6, 7, 1, 2, 3, 4]</strong>.</p>\n</blockquote>\n<p><strong>0. 题目大意：</strong>循环地将一个含有 <strong>n</strong> 个元素数组的右边 <strong>k</strong> 个元素搬移到数组左边。举例，给定 <strong>n</strong> 等于7，<strong>k</strong> 等于3，数组 [1, 2, 3, 4, 5, 6, 7] 经过旋转后便得到 [5, 6, 7, 1, 2, 3, 4]。</p>\n<p><strong>1. 最基本的方法，循环移动</strong>：题目的大意即每一次循环将数组最右的一个元素搬移到数组的最左边，然后将该循环执行 <strong>k</strong> 次，即可得到最后的结果。这里利用两层循环，每一次将最后一个元素搬移到最左边时，要先将最后一个元素存储到临时变量，然后依次将数组所有元素向后移动一个位置，再将临时变量的元素放到第一个位置，这里没有使用新的数组，所以该解法为 “In-Place” 的基础解法。时间复杂度 “O(n2)”。代码如下所示：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">rotate</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> k<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">.</span>length <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> arrLen <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> k<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> lastVal <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>nums<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 最后一个值存储到临时变量；</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">>=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">;</span> j<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>  <span class=\"token comment\" spellcheck=\"true\">// 所有元素依次后移一位；</span>\n            nums<span class=\"token punctuation\">[</span>j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> \n        <span class=\"token punctuation\">}</span>\n        nums<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> lastVal<span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 将临时变量的值赋给第一个元素；</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>2. 优化的方法，寻找规律，一步求解：</strong></p>\n<p>如果擅于归纳和寻找题目细节，你会发现该题在计算过程中含有的一些规律。当k的值等于数组长度时，数组不会发生任何改变，即此时循环搬移 <strong>k</strong> 次之后，数组又回到了初始时的顺序。利用此规律，无论 <strong>k</strong> 取何值，我们只需要搬移 “k % 数组长度” 次即可。这里同时利用了一个新的临时数组，整个过程只需先将数组的后 “k % 数组长度” 个元素搬移到新数组的“头部”，原数组剩下的部分搬移到新数组的“尾部”，最后再将新数组的内容拷贝给旧数组即可。算法时间复杂度 “O(n)”。代码如下所示：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">rotateOptimize</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> k<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">.</span>length <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> arrLen <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> temp<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">int</span><span class=\"token punctuation\">[</span>arrLen<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    k <span class=\"token operator\">=</span> k <span class=\"token operator\">%</span> arrLen<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> k<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n       temp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>arrLen <span class=\"token operator\">-</span> k <span class=\"token operator\">+</span> i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> k<span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> arrLen<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span> \n        temp<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>j <span class=\"token operator\">-</span> k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    System<span class=\"token punctuation\">.</span><span class=\"token function\">arraycopy</span><span class=\"token punctuation\">(</span>temp<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>3. 效率更高的方法，继续寻找规律，发现本质：</strong></p>\n<p>我们继续来寻找该题的规律，你会发现对于每次需要执行的 “k % 数组长度” 次搬移，我们只要按照下面的步骤都可以顺利完成。</p>\n<ul>\n<li>① 将数组按照从后往前数第（k % 数组长度）个元素分成前后两部分。如数组 [1, 2, 3, 4, 5, 6]，k 取值2，则分为 [1, 2, 3, 4] 和 [5, 6] 两部分；</li>\n<li>② 将前一部分元素全部翻转，得到 [4, 3, 2, 1]；</li>\n<li>③ 将后一部分元素全部翻转，得到 [6, 5]；</li>\n<li>④ 最后将两部分拼接到一起再进行一次翻转即可得到 [5, 6, 1, 2, 3, 4]；</li>\n</ul>\n<p>该算法时间复杂度为 “O(n)”。代码如下所示：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">rotateOptimizeFuther</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> k<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    k <span class=\"token operator\">=</span> k <span class=\"token operator\">%</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nums <span class=\"token operator\">==</span> null <span class=\"token operator\">||</span> k <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> k<span class=\"token punctuation\">;</span> \n\n    <span class=\"token function\">reverse</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> a<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 翻转前一部分元素；</span>\n    <span class=\"token function\">reverse</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 翻转后一部分元素；</span>\n    <span class=\"token function\">reverse</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 翻转整体元素；</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">reverse</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> left<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> right<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>nums <span class=\"token operator\">==</span> null <span class=\"token operator\">||</span> nums<span class=\"token punctuation\">.</span>length <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> \n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>left <span class=\"token operator\">&lt;</span> right<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 翻转的整体思路是利用双指针前后调换对应元素的值；</span>\n        <span class=\"token keyword\">int</span> temp <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        nums<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        nums<span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span>\n        left<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        right<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>   \n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"id":"993cf45d48b5d9659f5c6a78bc0d621b","excerpt":"","more":"<p>LeetCode 每日一题系列，今天第七题。今天的题型还是基于数组的变换，观察题目不仅仅是要理解题目的意思，更要去发现题目中的规律，擅于归纳。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Array】</p>\n<h4 id=\"189-Rotate-Array：\"><a href=\"#189-Rotate-Array：\" class=\"headerlink\" title=\"189. Rotate Array：\"></a>189. <a href=\"https://leetcode.com/problems/rotate-array/\" target=\"_blank\" rel=\"noopener\">Rotate Array</a>：</h4><blockquote>\n<p>Rotate an array of n elements to the right by k steps.</p>\n</blockquote>\n<blockquote>\n<p>For example, with <strong>n = 7</strong> and <strong>k = 3</strong>, the array <strong>[1, 2, 3, 4, 5, 6, 7]</strong> is rotated to <strong>[5, 6, 7, 1, 2, 3, 4]</strong>.</p>\n</blockquote>\n<p><strong>0. 题目大意：</strong>循环地将一个含有 <strong>n</strong> 个元素数组的右边 <strong>k</strong> 个元素搬移到数组左边。举例，给定 <strong>n</strong> 等于7，<strong>k</strong> 等于3，数组 [1, 2, 3, 4, 5, 6, 7] 经过旋转后便得到 [5, 6, 7, 1, 2, 3, 4]。</p>\n<p><strong>1. 最基本的方法，循环移动</strong>：题目的大意即每一次循环将数组最右的一个元素搬移到数组的最左边，然后将该循环执行 <strong>k</strong> 次，即可得到最后的结果。这里利用两层循环，每一次将最后一个元素搬移到最左边时，要先将最后一个元素存储到临时变量，然后依次将数组所有元素向后移动一个位置，再将临时变量的元素放到第一个位置，这里没有使用新的数组，所以该解法为 “In-Place” 的基础解法。时间复杂度 “O(n2)”。代码如下所示：</p>\n<pre><code class=\"java\">public static void rotate(int[] nums, int k) {\n    if (nums.length == 0)\n        return;\n\n    int arrLen = nums.length;\n    for (int i = 0; i &lt; k; i++){\n        int lastVal = nums[nums.length - 1];  // 最后一个值存储到临时变量；\n        for (int j = nums.length - 2; j &gt;= 0 ; j--){  // 所有元素依次后移一位；\n            nums[j + 1] = nums[j]; \n        }\n        nums[0] = lastVal;  // 将临时变量的值赋给第一个元素；\n    }\n}\n</code></pre>\n<p><strong>2. 优化的方法，寻找规律，一步求解：</strong></p>\n<p>如果擅于归纳和寻找题目细节，你会发现该题在计算过程中含有的一些规律。当k的值等于数组长度时，数组不会发生任何改变，即此时循环搬移 <strong>k</strong> 次之后，数组又回到了初始时的顺序。利用此规律，无论 <strong>k</strong> 取何值，我们只需要搬移 “k % 数组长度” 次即可。这里同时利用了一个新的临时数组，整个过程只需先将数组的后 “k % 数组长度” 个元素搬移到新数组的“头部”，原数组剩下的部分搬移到新数组的“尾部”，最后再将新数组的内容拷贝给旧数组即可。算法时间复杂度 “O(n)”。代码如下所示：</p>\n<pre><code class=\"java\">public static void rotateOptimize(int[] nums, int k) {\n    if (nums.length == 0)\n        return;\n\n    int arrLen = nums.length;\n    int temp[] = new int[arrLen];\n    k = k % arrLen;\n\n    for (int i = 0; i &lt; k; i++) {\n       temp[i] = nums[arrLen - k + i];\n    }\n\n    for (int j = k; j &lt; arrLen; j++){ \n        temp[j] = nums[j - k];\n    }\n\n    System.arraycopy(temp, 0, nums, 0, nums.length);\n}\n</code></pre>\n<p><strong>3. 效率更高的方法，继续寻找规律，发现本质：</strong></p>\n<p>我们继续来寻找该题的规律，你会发现对于每次需要执行的 “k % 数组长度” 次搬移，我们只要按照下面的步骤都可以顺利完成。</p>\n<ul>\n<li>① 将数组按照从后往前数第（k % 数组长度）个元素分成前后两部分。如数组 [1, 2, 3, 4, 5, 6]，k 取值2，则分为 [1, 2, 3, 4] 和 [5, 6] 两部分；</li>\n<li>② 将前一部分元素全部翻转，得到 [4, 3, 2, 1]；</li>\n<li>③ 将后一部分元素全部翻转，得到 [6, 5]；</li>\n<li>④ 最后将两部分拼接到一起再进行一次翻转即可得到 [5, 6, 1, 2, 3, 4]；</li>\n</ul>\n<p>该算法时间复杂度为 “O(n)”。代码如下所示：</p>\n<pre><code class=\"java\">public static void rotateOptimizeFuther(int[] nums, int k) {\n    k = k % nums.length;\n\n    if (nums == null || k &lt; 0) {\n        return;\n    }\n\n    int a = nums.length - k; \n\n    reverse(nums, 0, a-1);  // 翻转前一部分元素；\n    reverse(nums, a, nums.length-1);  // 翻转后一部分元素；\n    reverse(nums, 0, nums.length-1);  // 翻转整体元素；\n}\n\npublic static void reverse(int[] nums, int left, int right) {\n    if(nums == null || nums.length == 1) \n        return;\n\n    while(left &lt; right) {\n        // 翻转的整体思路是利用双指针前后调换对应元素的值；\n        int temp = nums[left];\n        nums[left] = nums[right];\n        nums[right] = temp;\n        left++;\n        right--;\n    }   \n}\n</code></pre>\n"},{"title":"LeetCode 每日一题 - 219. Contains Duplicate II","intro":"LeetCode 每日一题系列，今天第四题。这道题与之前的 “217.Contains Duplicate” 基础解法思路大体相似，不过在判断是否含有重复元素的同时，还需要保证元素的索引信息不能够丢失。【Array】【HashTable】","comments":1,"date":"2016-04-14T01:29:45.000Z","_content":"\nLeetCode 每日一题系列，今天第四题。这道题与之前的 “**217.Contains Duplicate**” 基础解法思路大体相似，不过在判断是否含有重复元素的同时，还需要保证元素的索引信息不能够丢失。【Array】【HashTable】\n\n#### 219. [Contains Duplicate II](https://leetcode.com/problems/contains-duplicate-ii/)：\n\n> Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the difference between i and j is at most k.\n\n**Example：**\n\n```text\nGiven nums = [2, 7, 11, 15, 11],\nGiven k = 2,\n\nBecause nums contains duplicate number 11, and the distance between two duplicates less or equal than k,\nSo after your function it should return true.\nElse return false.\n```\n\n**1. 最基本的方法，还是遍历：**\n\n两个指针，**指针 i** 指向当前元素，**指针 j** 指向 **i** 其后的任意元素。最内层循环依次比较**指针 i** 与**指针 j** 对应元素大小，外层循环将指针 i 向后移动，直到找到相等值并判断此时**指针 i** 和**指针 j** 的相对位置是否小于等于 **k**。时间复杂度 “O(n2)”。代码如下所示：\n\n```java\npublic static boolean containsDuplicate(int[] nums) {\n    int arrLen = nums.length;\n    for (int i = 0; i< arrLen; i++) {\n\t    for (int j = i + 1; j < arrLen; j++) {\n            if (nums[i] == nums[j] && j - i <= k)\n\t        return true;\n\t    }\n    }\n    return false;\n}\n```\n\n\n**2. 优化的方法，同样使用HashMap：**\n\n思路不变，先检查 HashMap 中是否含有此元素，如果有则检查当前元素与该元素的索引距离是否大于 **k**，如果没有则将该元素放入 HashMap，并继续从数组中取下一个元素，否则返回 `false` 。时间复杂度 “O(n)“。代码如下所示：\n```java\npublic static boolean containsDuplicateOptimize(int[] nums) {\n    int arrLen = nums.length;\n    Map<Integer, Integer> map = new HashMap<>();\n    int prevPos = 0;\n    \n    for (int i = 0; i< arrLen; i++) {\n        if (map.containsKey(nums[i])) {\n            prevPos = map.get(nums[i]);\n            if((i - prevPos) <= k)\n\t\t        return true;\n            else \n\t            return false;\n        } else {\n            map.put(nums[i], i);\n        }\n    }\n    return false;      \n}\n```\n\n**3. 更加优化的方法，使用 Set 集合来保持一个固定大小的检测窗口：**\n\n这里我们使用 Set 来保持一个大小为 **k** 的检测窗口，只要在这个窗口中含有重复的元素，则一定满足两个元素之间的距离小于 **k** 的条件。代码如下所示：\n\n```java\npublic static boolean containsDuplicateOptimizeFurther(int[] nums) {\n    Set<Integer> set = new HashSet<Integer>();  \n    // 定义窗口的首尾指针；\n    int start = 0, end = 0;\n    // 开始遍历；\n    for (int i = 0; i < nums.length; i++) {   \n        if (!set.contains(nums[i])) {    \n            set.add(nums[i]);   \n            end++;   // 如果 Set 中没有此元素则加入，尾指针后移；\n        } else { \n            return true;   // 有则返回 true；\n        }\n        \n        // 保持首尾指针距离不大于 k；\n        if(end - start > k) {  \n            set.remove(nums[start]);    //如果大于则移除首指针元素；\n            start++;   // 移除后首指针后移；\n        }  \n    }  \n    return false;\n}\n```\n","source":"_posts/LeetCode-每日一题-219-Contains-Duplicate-II.md","raw":"---\ntitle: LeetCode 每日一题 - 219. Contains Duplicate II\nintro: LeetCode 每日一题系列，今天第四题。这道题与之前的 “217.Contains Duplicate” 基础解法思路大体相似，不过在判断是否含有重复元素的同时，还需要保证元素的索引信息不能够丢失。【Array】【HashTable】\ncomments: true\ndate: 2016-04-14 09:29:45\ntags:\n- 算法\n- LeetCode\n---\n\nLeetCode 每日一题系列，今天第四题。这道题与之前的 “**217.Contains Duplicate**” 基础解法思路大体相似，不过在判断是否含有重复元素的同时，还需要保证元素的索引信息不能够丢失。【Array】【HashTable】\n\n#### 219. [Contains Duplicate II](https://leetcode.com/problems/contains-duplicate-ii/)：\n\n> Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the difference between i and j is at most k.\n\n**Example：**\n\n```text\nGiven nums = [2, 7, 11, 15, 11],\nGiven k = 2,\n\nBecause nums contains duplicate number 11, and the distance between two duplicates less or equal than k,\nSo after your function it should return true.\nElse return false.\n```\n\n**1. 最基本的方法，还是遍历：**\n\n两个指针，**指针 i** 指向当前元素，**指针 j** 指向 **i** 其后的任意元素。最内层循环依次比较**指针 i** 与**指针 j** 对应元素大小，外层循环将指针 i 向后移动，直到找到相等值并判断此时**指针 i** 和**指针 j** 的相对位置是否小于等于 **k**。时间复杂度 “O(n2)”。代码如下所示：\n\n```java\npublic static boolean containsDuplicate(int[] nums) {\n    int arrLen = nums.length;\n    for (int i = 0; i< arrLen; i++) {\n\t    for (int j = i + 1; j < arrLen; j++) {\n            if (nums[i] == nums[j] && j - i <= k)\n\t        return true;\n\t    }\n    }\n    return false;\n}\n```\n\n\n**2. 优化的方法，同样使用HashMap：**\n\n思路不变，先检查 HashMap 中是否含有此元素，如果有则检查当前元素与该元素的索引距离是否大于 **k**，如果没有则将该元素放入 HashMap，并继续从数组中取下一个元素，否则返回 `false` 。时间复杂度 “O(n)“。代码如下所示：\n```java\npublic static boolean containsDuplicateOptimize(int[] nums) {\n    int arrLen = nums.length;\n    Map<Integer, Integer> map = new HashMap<>();\n    int prevPos = 0;\n    \n    for (int i = 0; i< arrLen; i++) {\n        if (map.containsKey(nums[i])) {\n            prevPos = map.get(nums[i]);\n            if((i - prevPos) <= k)\n\t\t        return true;\n            else \n\t            return false;\n        } else {\n            map.put(nums[i], i);\n        }\n    }\n    return false;      \n}\n```\n\n**3. 更加优化的方法，使用 Set 集合来保持一个固定大小的检测窗口：**\n\n这里我们使用 Set 来保持一个大小为 **k** 的检测窗口，只要在这个窗口中含有重复的元素，则一定满足两个元素之间的距离小于 **k** 的条件。代码如下所示：\n\n```java\npublic static boolean containsDuplicateOptimizeFurther(int[] nums) {\n    Set<Integer> set = new HashSet<Integer>();  \n    // 定义窗口的首尾指针；\n    int start = 0, end = 0;\n    // 开始遍历；\n    for (int i = 0; i < nums.length; i++) {   \n        if (!set.contains(nums[i])) {    \n            set.add(nums[i]);   \n            end++;   // 如果 Set 中没有此元素则加入，尾指针后移；\n        } else { \n            return true;   // 有则返回 true；\n        }\n        \n        // 保持首尾指针距离不大于 k；\n        if(end - start > k) {  \n            set.remove(nums[start]);    //如果大于则移除首指针元素；\n            start++;   // 移除后首指针后移；\n        }  \n    }  \n    return false;\n}\n```\n","slug":"LeetCode-每日一题-219-Contains-Duplicate-II","published":1,"updated":"2019-02-10T02:50:33.888Z","layout":"post","photos":[],"link":"","_id":"cjsqwht9f002cknp20p09yqym","content":"<p>LeetCode 每日一题系列，今天第四题。这道题与之前的 “<strong>217.Contains Duplicate</strong>” 基础解法思路大体相似，不过在判断是否含有重复元素的同时，还需要保证元素的索引信息不能够丢失。【Array】【HashTable】</p>\n<h4 id=\"219-Contains-Duplicate-II：\"><a href=\"#219-Contains-Duplicate-II：\" class=\"headerlink\" title=\"219. Contains Duplicate II：\"></a>219. <a href=\"https://leetcode.com/problems/contains-duplicate-ii/\" target=\"_blank\" rel=\"noopener\">Contains Duplicate II</a>：</h4><blockquote>\n<p>Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the difference between i and j is at most k.</p>\n</blockquote>\n<p><strong>Example：</strong></p>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">Given nums = [2, 7, 11, 15, 11],\nGiven k = 2,\n\nBecause nums contains duplicate number 11, and the distance between two duplicates less or equal than k,\nSo after your function it should return true.\nElse return false.\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>1. 最基本的方法，还是遍历：</strong></p>\n<p>两个指针，<strong>指针 i</strong> 指向当前元素，<strong>指针 j</strong> 指向 <strong>i</strong> 其后的任意元素。最内层循环依次比较<strong>指针 i</strong> 与<strong>指针 j</strong> 对应元素大小，外层循环将指针 i 向后移动，直到找到相等值并判断此时<strong>指针 i</strong> 和<strong>指针 j</strong> 的相对位置是否小于等于 <strong>k</strong>。时间复杂度 “O(n2)”。代码如下所示：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">containsDuplicate</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> arrLen <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;</span> arrLen<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> arrLen<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> nums<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> j <span class=\"token operator\">-</span> i <span class=\"token operator\">&lt;=</span> k<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>2. 优化的方法，同样使用HashMap：</strong></p>\n<p>思路不变，先检查 HashMap 中是否含有此元素，如果有则检查当前元素与该元素的索引距离是否大于 <strong>k</strong>，如果没有则将该元素放入 HashMap，并继续从数组中取下一个元素，否则返回 <code>false</code> 。时间复杂度 “O(n)“。代码如下所示：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">containsDuplicateOptimize</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> arrLen <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    Map<span class=\"token operator\">&lt;</span>Integer<span class=\"token punctuation\">,</span> Integer<span class=\"token operator\">></span> map <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> prevPos <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;</span> arrLen<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">.</span><span class=\"token function\">containsKey</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            prevPos <span class=\"token operator\">=</span> map<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">-</span> prevPos<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;=</span> k<span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">else</span> \n                <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>      \n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>3. 更加优化的方法，使用 Set 集合来保持一个固定大小的检测窗口：</strong></p>\n<p>这里我们使用 Set 来保持一个大小为 <strong>k</strong> 的检测窗口，只要在这个窗口中含有重复的元素，则一定满足两个元素之间的距离小于 <strong>k</strong> 的条件。代码如下所示：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">containsDuplicateOptimizeFurther</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    Set<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span> set <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashSet</span><span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n    <span class=\"token comment\" spellcheck=\"true\">// 定义窗口的首尾指针；</span>\n    <span class=\"token keyword\">int</span> start <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> end <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 开始遍历；</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>   \n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>set<span class=\"token punctuation\">.</span><span class=\"token function\">contains</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>    \n            set<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   \n            end<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\" spellcheck=\"true\">// 如果 Set 中没有此元素则加入，尾指针后移；</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span> \n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\" spellcheck=\"true\">// 有则返回 true；</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 保持首尾指针距离不大于 k；</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>end <span class=\"token operator\">-</span> start <span class=\"token operator\">></span> k<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n            set<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>start<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">//如果大于则移除首指针元素；</span>\n            start<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\" spellcheck=\"true\">// 移除后首指针后移；</span>\n        <span class=\"token punctuation\">}</span>  \n    <span class=\"token punctuation\">}</span>  \n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"id":"ed727c736664478dbb2c869e5d387886","excerpt":"","more":"<p>LeetCode 每日一题系列，今天第四题。这道题与之前的 “<strong>217.Contains Duplicate</strong>” 基础解法思路大体相似，不过在判断是否含有重复元素的同时，还需要保证元素的索引信息不能够丢失。【Array】【HashTable】</p>\n<h4 id=\"219-Contains-Duplicate-II：\"><a href=\"#219-Contains-Duplicate-II：\" class=\"headerlink\" title=\"219. Contains Duplicate II：\"></a>219. <a href=\"https://leetcode.com/problems/contains-duplicate-ii/\" target=\"_blank\" rel=\"noopener\">Contains Duplicate II</a>：</h4><blockquote>\n<p>Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the difference between i and j is at most k.</p>\n</blockquote>\n<p><strong>Example：</strong></p>\n<pre><code class=\"text\">Given nums = [2, 7, 11, 15, 11],\nGiven k = 2,\n\nBecause nums contains duplicate number 11, and the distance between two duplicates less or equal than k,\nSo after your function it should return true.\nElse return false.\n</code></pre>\n<p><strong>1. 最基本的方法，还是遍历：</strong></p>\n<p>两个指针，<strong>指针 i</strong> 指向当前元素，<strong>指针 j</strong> 指向 <strong>i</strong> 其后的任意元素。最内层循环依次比较<strong>指针 i</strong> 与<strong>指针 j</strong> 对应元素大小，外层循环将指针 i 向后移动，直到找到相等值并判断此时<strong>指针 i</strong> 和<strong>指针 j</strong> 的相对位置是否小于等于 <strong>k</strong>。时间复杂度 “O(n2)”。代码如下所示：</p>\n<pre><code class=\"java\">public static boolean containsDuplicate(int[] nums) {\n    int arrLen = nums.length;\n    for (int i = 0; i&lt; arrLen; i++) {\n        for (int j = i + 1; j &lt; arrLen; j++) {\n            if (nums[i] == nums[j] &amp;&amp; j - i &lt;= k)\n            return true;\n        }\n    }\n    return false;\n}\n</code></pre>\n<p><strong>2. 优化的方法，同样使用HashMap：</strong></p>\n<p>思路不变，先检查 HashMap 中是否含有此元素，如果有则检查当前元素与该元素的索引距离是否大于 <strong>k</strong>，如果没有则将该元素放入 HashMap，并继续从数组中取下一个元素，否则返回 <code>false</code> 。时间复杂度 “O(n)“。代码如下所示：</p>\n<pre><code class=\"java\">public static boolean containsDuplicateOptimize(int[] nums) {\n    int arrLen = nums.length;\n    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();\n    int prevPos = 0;\n\n    for (int i = 0; i&lt; arrLen; i++) {\n        if (map.containsKey(nums[i])) {\n            prevPos = map.get(nums[i]);\n            if((i - prevPos) &lt;= k)\n                return true;\n            else \n                return false;\n        } else {\n            map.put(nums[i], i);\n        }\n    }\n    return false;      \n}\n</code></pre>\n<p><strong>3. 更加优化的方法，使用 Set 集合来保持一个固定大小的检测窗口：</strong></p>\n<p>这里我们使用 Set 来保持一个大小为 <strong>k</strong> 的检测窗口，只要在这个窗口中含有重复的元素，则一定满足两个元素之间的距离小于 <strong>k</strong> 的条件。代码如下所示：</p>\n<pre><code class=\"java\">public static boolean containsDuplicateOptimizeFurther(int[] nums) {\n    Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();  \n    // 定义窗口的首尾指针；\n    int start = 0, end = 0;\n    // 开始遍历；\n    for (int i = 0; i &lt; nums.length; i++) {   \n        if (!set.contains(nums[i])) {    \n            set.add(nums[i]);   \n            end++;   // 如果 Set 中没有此元素则加入，尾指针后移；\n        } else { \n            return true;   // 有则返回 true；\n        }\n\n        // 保持首尾指针距离不大于 k；\n        if(end - start &gt; k) {  \n            set.remove(nums[start]);    //如果大于则移除首指针元素；\n            start++;   // 移除后首指针后移；\n        }  \n    }  \n    return false;\n}\n</code></pre>\n"},{"title":"LeetCode 每日一题 - 258. Add Digits","intro":"LeetCode 每日一题系列，今天第十二题。“Digital Root” 又名数根 (又称位数根或数字根) 是自然数的一种性质，今天我们就来看一道跟“数根”有关的题目。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Math】","comments":1,"date":"2016-05-06T10:35:40.000Z","_content":"\nLeetCode 每日一题系列，今天第十二题。“Digital Root” 又名数根 (又称位数根或数字根) 是自然数的一种性质，今天我们就来看一道跟“数根”有关的题目。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Math】\n\n#### 258. [Add Digits](https://leetcode.com/problems/add-digits/)：\n\n> Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.\n\n**Example：**\n\n```text\nGiven num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it.\n```\n\n\n**0. 题目大意：**\n\n给定一个非负整数，将其各个分位的数字相加得到一个整数 N，若 N 为一个个位数则返回 N，否则继续将 N 的各个分位的数字继续相加循环上述过程，直到相加的结果为一个个位数为止。实际上，事实上，该算法即为计算给定整数的数根。\n\n\n**1. 基本方法，递归：**\n\n如果对 “Digital Root” 没有任何概念的话，第一个想到的方法就是利用递归来解决此问题。将给定数字拆分成字符数组，并将得到的字符数组所有项全部相加再转换成整数类型，若此时的整数不满足仅为一个个位数，则再次重复上述过程。代码如下所示：\n\n```java\npublic static int addDigits(int num) {\n    String temp = String.valueOf(num);\n    char [] tempCharArr = temp.toCharArray();\n    int amount = 0;\n    \n    if (tempCharArr.length <= 1){\n    \treturn num;\n    }\n    \n    for (int i = 0; i < tempCharArr.length; i++){\n    \tamount = amount + Integer.parseInt(String.valueOf(tempCharArr[i]));\n    }\n    \n    return Main.addDigits(amount);\n}\n```\n\n\n**2. 优化的方法，公式推导：**\n\n我们可以直接利用推导出的专门用来求给定数字“数根”的公式，下边会给出推导方法。时间复杂度 “O(1)”。代码如下所示：\n\n```java\npublic static int addDigitsOptimize(int num) {\n    // Use formula；\n    return num - 9 * ((num - 1) / 9);\n}\n```\n\n\n* **附：数根推导**：\n\n我们可以很容易的发现，任何一个正整数的数根都**不会超过数字9**，例如：11 的数根为 2，而 11 为 9 之后的第二个数字；2035 的数根为 1，而 (2035 - 1) 为 9 的倍数；因此我们可以通过 **floor 函数**（向下取整）来得出数根计算公式如下。\n\n```text\ndr(n) = 1 + ((n - 1) mod 9);\n```\n\n* **附：数根特性**：\n\n数根还有一些常用特性如下，大家可以适当了解一下：\n\n```text\ndr(a + b) = dr(dr(a) + dr(b));\n\ndr(n) = 0 => n = 0;\n\ndr(n) > 0 => n > 0;\n\ndr(n) = n => n ∈ {1, 9};\n```\n\n[维基百科：数根（Digital Root）。](https://en.wikipedia.org/wiki/Digital_root#Significance_and_formula_of_the_digital_root)\n\n\n\n\n","source":"_posts/LeetCode-每日一题-258-Add-Digits.md","raw":"---\ntitle: LeetCode 每日一题 - 258. Add Digits\nintro: LeetCode 每日一题系列，今天第十二题。“Digital Root” 又名数根 (又称位数根或数字根) 是自然数的一种性质，今天我们就来看一道跟“数根”有关的题目。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Math】\ncomments: true\ndate: 2016-05-06 18:35:40\ntags:\n- 算法\n- LeetCode\n---\n\nLeetCode 每日一题系列，今天第十二题。“Digital Root” 又名数根 (又称位数根或数字根) 是自然数的一种性质，今天我们就来看一道跟“数根”有关的题目。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Math】\n\n#### 258. [Add Digits](https://leetcode.com/problems/add-digits/)：\n\n> Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.\n\n**Example：**\n\n```text\nGiven num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it.\n```\n\n\n**0. 题目大意：**\n\n给定一个非负整数，将其各个分位的数字相加得到一个整数 N，若 N 为一个个位数则返回 N，否则继续将 N 的各个分位的数字继续相加循环上述过程，直到相加的结果为一个个位数为止。实际上，事实上，该算法即为计算给定整数的数根。\n\n\n**1. 基本方法，递归：**\n\n如果对 “Digital Root” 没有任何概念的话，第一个想到的方法就是利用递归来解决此问题。将给定数字拆分成字符数组，并将得到的字符数组所有项全部相加再转换成整数类型，若此时的整数不满足仅为一个个位数，则再次重复上述过程。代码如下所示：\n\n```java\npublic static int addDigits(int num) {\n    String temp = String.valueOf(num);\n    char [] tempCharArr = temp.toCharArray();\n    int amount = 0;\n    \n    if (tempCharArr.length <= 1){\n    \treturn num;\n    }\n    \n    for (int i = 0; i < tempCharArr.length; i++){\n    \tamount = amount + Integer.parseInt(String.valueOf(tempCharArr[i]));\n    }\n    \n    return Main.addDigits(amount);\n}\n```\n\n\n**2. 优化的方法，公式推导：**\n\n我们可以直接利用推导出的专门用来求给定数字“数根”的公式，下边会给出推导方法。时间复杂度 “O(1)”。代码如下所示：\n\n```java\npublic static int addDigitsOptimize(int num) {\n    // Use formula；\n    return num - 9 * ((num - 1) / 9);\n}\n```\n\n\n* **附：数根推导**：\n\n我们可以很容易的发现，任何一个正整数的数根都**不会超过数字9**，例如：11 的数根为 2，而 11 为 9 之后的第二个数字；2035 的数根为 1，而 (2035 - 1) 为 9 的倍数；因此我们可以通过 **floor 函数**（向下取整）来得出数根计算公式如下。\n\n```text\ndr(n) = 1 + ((n - 1) mod 9);\n```\n\n* **附：数根特性**：\n\n数根还有一些常用特性如下，大家可以适当了解一下：\n\n```text\ndr(a + b) = dr(dr(a) + dr(b));\n\ndr(n) = 0 => n = 0;\n\ndr(n) > 0 => n > 0;\n\ndr(n) = n => n ∈ {1, 9};\n```\n\n[维基百科：数根（Digital Root）。](https://en.wikipedia.org/wiki/Digital_root#Significance_and_formula_of_the_digital_root)\n\n\n\n\n","slug":"LeetCode-每日一题-258-Add-Digits","published":1,"updated":"2019-02-10T02:50:36.668Z","layout":"post","photos":[],"link":"","_id":"cjsqwht9g002dknp2nn2us3wy","content":"<p>LeetCode 每日一题系列，今天第十二题。“Digital Root” 又名数根 (又称位数根或数字根) 是自然数的一种性质，今天我们就来看一道跟“数根”有关的题目。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Math】</p>\n<h4 id=\"258-Add-Digits：\"><a href=\"#258-Add-Digits：\" class=\"headerlink\" title=\"258. Add Digits：\"></a>258. <a href=\"https://leetcode.com/problems/add-digits/\" target=\"_blank\" rel=\"noopener\">Add Digits</a>：</h4><blockquote>\n<p>Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.</p>\n</blockquote>\n<p><strong>Example：</strong></p>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it.\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><strong>0. 题目大意：</strong></p>\n<p>给定一个非负整数，将其各个分位的数字相加得到一个整数 N，若 N 为一个个位数则返回 N，否则继续将 N 的各个分位的数字继续相加循环上述过程，直到相加的结果为一个个位数为止。实际上，事实上，该算法即为计算给定整数的数根。</p>\n<p><strong>1. 基本方法，递归：</strong></p>\n<p>如果对 “Digital Root” 没有任何概念的话，第一个想到的方法就是利用递归来解决此问题。将给定数字拆分成字符数组，并将得到的字符数组所有项全部相加再转换成整数类型，若此时的整数不满足仅为一个个位数，则再次重复上述过程。代码如下所示：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">addDigits</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> num<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    String temp <span class=\"token operator\">=</span> String<span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">char</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> tempCharArr <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">.</span><span class=\"token function\">toCharArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> amount <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>tempCharArr<span class=\"token punctuation\">.</span>length <span class=\"token operator\">&lt;=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> num<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> tempCharArr<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        amount <span class=\"token operator\">=</span> amount <span class=\"token operator\">+</span> Integer<span class=\"token punctuation\">.</span><span class=\"token function\">parseInt</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>tempCharArr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> Main<span class=\"token punctuation\">.</span><span class=\"token function\">addDigits</span><span class=\"token punctuation\">(</span>amount<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>2. 优化的方法，公式推导：</strong></p>\n<p>我们可以直接利用推导出的专门用来求给定数字“数根”的公式，下边会给出推导方法。时间复杂度 “O(1)”。代码如下所示：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">addDigitsOptimize</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> num<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Use formula；</span>\n    <span class=\"token keyword\">return</span> num <span class=\"token operator\">-</span> <span class=\"token number\">9</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>num <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">9</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li><strong>附：数根推导</strong>：</li>\n</ul>\n<p>我们可以很容易的发现，任何一个正整数的数根都<strong>不会超过数字9</strong>，例如：11 的数根为 2，而 11 为 9 之后的第二个数字；2035 的数根为 1，而 (2035 - 1) 为 9 的倍数；因此我们可以通过 <strong>floor 函数</strong>（向下取整）来得出数根计算公式如下。</p>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">dr(n) = 1 + ((n - 1) mod 9);\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<ul>\n<li><strong>附：数根特性</strong>：</li>\n</ul>\n<p>数根还有一些常用特性如下，大家可以适当了解一下：</p>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">dr(a + b) = dr(dr(a) + dr(b));\n\ndr(n) = 0 => n = 0;\n\ndr(n) > 0 => n > 0;\n\ndr(n) = n => n ∈ {1, 9};\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><a href=\"https://en.wikipedia.org/wiki/Digital_root#Significance_and_formula_of_the_digital_root\" target=\"_blank\" rel=\"noopener\">维基百科：数根（Digital Root）。</a></p>\n","site":{"data":{}},"id":"f975f13196d075cebe5bdc3c202baff7","excerpt":"","more":"<p>LeetCode 每日一题系列，今天第十二题。“Digital Root” 又名数根 (又称位数根或数字根) 是自然数的一种性质，今天我们就来看一道跟“数根”有关的题目。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Math】</p>\n<h4 id=\"258-Add-Digits：\"><a href=\"#258-Add-Digits：\" class=\"headerlink\" title=\"258. Add Digits：\"></a>258. <a href=\"https://leetcode.com/problems/add-digits/\" target=\"_blank\" rel=\"noopener\">Add Digits</a>：</h4><blockquote>\n<p>Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.</p>\n</blockquote>\n<p><strong>Example：</strong></p>\n<pre><code class=\"text\">Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it.\n</code></pre>\n<p><strong>0. 题目大意：</strong></p>\n<p>给定一个非负整数，将其各个分位的数字相加得到一个整数 N，若 N 为一个个位数则返回 N，否则继续将 N 的各个分位的数字继续相加循环上述过程，直到相加的结果为一个个位数为止。实际上，事实上，该算法即为计算给定整数的数根。</p>\n<p><strong>1. 基本方法，递归：</strong></p>\n<p>如果对 “Digital Root” 没有任何概念的话，第一个想到的方法就是利用递归来解决此问题。将给定数字拆分成字符数组，并将得到的字符数组所有项全部相加再转换成整数类型，若此时的整数不满足仅为一个个位数，则再次重复上述过程。代码如下所示：</p>\n<pre><code class=\"java\">public static int addDigits(int num) {\n    String temp = String.valueOf(num);\n    char [] tempCharArr = temp.toCharArray();\n    int amount = 0;\n\n    if (tempCharArr.length &lt;= 1){\n        return num;\n    }\n\n    for (int i = 0; i &lt; tempCharArr.length; i++){\n        amount = amount + Integer.parseInt(String.valueOf(tempCharArr[i]));\n    }\n\n    return Main.addDigits(amount);\n}\n</code></pre>\n<p><strong>2. 优化的方法，公式推导：</strong></p>\n<p>我们可以直接利用推导出的专门用来求给定数字“数根”的公式，下边会给出推导方法。时间复杂度 “O(1)”。代码如下所示：</p>\n<pre><code class=\"java\">public static int addDigitsOptimize(int num) {\n    // Use formula；\n    return num - 9 * ((num - 1) / 9);\n}\n</code></pre>\n<ul>\n<li><strong>附：数根推导</strong>：</li>\n</ul>\n<p>我们可以很容易的发现，任何一个正整数的数根都<strong>不会超过数字9</strong>，例如：11 的数根为 2，而 11 为 9 之后的第二个数字；2035 的数根为 1，而 (2035 - 1) 为 9 的倍数；因此我们可以通过 <strong>floor 函数</strong>（向下取整）来得出数根计算公式如下。</p>\n<pre><code class=\"text\">dr(n) = 1 + ((n - 1) mod 9);\n</code></pre>\n<ul>\n<li><strong>附：数根特性</strong>：</li>\n</ul>\n<p>数根还有一些常用特性如下，大家可以适当了解一下：</p>\n<pre><code class=\"text\">dr(a + b) = dr(dr(a) + dr(b));\n\ndr(n) = 0 =&gt; n = 0;\n\ndr(n) &gt; 0 =&gt; n &gt; 0;\n\ndr(n) = n =&gt; n ∈ {1, 9};\n</code></pre>\n<p><a href=\"https://en.wikipedia.org/wiki/Digital_root#Significance_and_formula_of_the_digital_root\" target=\"_blank\" rel=\"noopener\">维基百科：数根（Digital Root）。</a></p>\n"},{"title":"LeetCode 每日一题 - 27. Remove Element","intro":"LeetCode 每日一题系列，今天第十六题。今天还是一道关于数组的简单题目，闲暇时间可以用来练练手。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Array】【Two-Pointer】","comments":1,"date":"2016-05-24T12:49:26.000Z","_content":"\nLeetCode 每日一题系列，今天第十六题。今天还是一道关于数组的简单题目，闲暇时间可以用来练练手。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Array】【Two-Pointer】\n\n#### 27. [Remove Element](https://leetcode.com/problems/remove-element/)：\n\n> Given an array and a value, remove all instances of that value in place and return the new length.\n\n> Do not allocate extra space for another array, you must do this in place with constant memory.\n\n> The order of elements can be changed. It doesn''t matter what you leave beyond the new length.\n\n**Example：**\n\n```text\nGiven input array nums = [3,2,2,3], val = 3.\n\nYour function should return length = 2, with the first two elements of nums being 2.\n```\n\n**0. 题目大意：**\n\n给定一个数组和一个数字，将数组内和所给定数字不相等的值排列到数组的头部，相等的值排列到尾部（头部的值顺序可以被打乱）。\n\n**1. 第一种方法，双指针：**\n\n思路很简单也很容易想到，还是我们惯用的双指针，一个指针负责遍历，另一个指针负责锁定待更新值的位置。代码如下所示：\n\n```java\npublic static int removeElement(int[] nums, int val) {\n    int arrLen = nums.length;\n    int j = 0;\n    \n    for (int i = 0; i < arrLen; i ++) {\n        if (nums[i] != val) {\n            int temp = nums[j];\n            nums[j] = nums[i];\n            nums[i] = temp;\n            j ++;\n        }\n    }\n\n    return j;\n}\n```\n\n```text\n113 / 113 test cases passed.\nStatus: Accepted\nRuntime: 0 ms\n```","source":"_posts/LeetCode-每日一题-27-Remove-Element.md","raw":"---\ntitle: LeetCode 每日一题 - 27. Remove Element\nintro: LeetCode 每日一题系列，今天第十六题。今天还是一道关于数组的简单题目，闲暇时间可以用来练练手。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Array】【Two-Pointer】\ncomments: true\ndate: 2016-05-24 20:49:26\ntags:\n- 算法\n- LeetCode\n---\n\nLeetCode 每日一题系列，今天第十六题。今天还是一道关于数组的简单题目，闲暇时间可以用来练练手。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Array】【Two-Pointer】\n\n#### 27. [Remove Element](https://leetcode.com/problems/remove-element/)：\n\n> Given an array and a value, remove all instances of that value in place and return the new length.\n\n> Do not allocate extra space for another array, you must do this in place with constant memory.\n\n> The order of elements can be changed. It doesn''t matter what you leave beyond the new length.\n\n**Example：**\n\n```text\nGiven input array nums = [3,2,2,3], val = 3.\n\nYour function should return length = 2, with the first two elements of nums being 2.\n```\n\n**0. 题目大意：**\n\n给定一个数组和一个数字，将数组内和所给定数字不相等的值排列到数组的头部，相等的值排列到尾部（头部的值顺序可以被打乱）。\n\n**1. 第一种方法，双指针：**\n\n思路很简单也很容易想到，还是我们惯用的双指针，一个指针负责遍历，另一个指针负责锁定待更新值的位置。代码如下所示：\n\n```java\npublic static int removeElement(int[] nums, int val) {\n    int arrLen = nums.length;\n    int j = 0;\n    \n    for (int i = 0; i < arrLen; i ++) {\n        if (nums[i] != val) {\n            int temp = nums[j];\n            nums[j] = nums[i];\n            nums[i] = temp;\n            j ++;\n        }\n    }\n\n    return j;\n}\n```\n\n```text\n113 / 113 test cases passed.\nStatus: Accepted\nRuntime: 0 ms\n```","slug":"LeetCode-每日一题-27-Remove-Element","published":1,"updated":"2019-02-10T02:49:52.789Z","layout":"post","photos":[],"link":"","_id":"cjsqwht9h002fknp240f3lp7v","content":"<p>LeetCode 每日一题系列，今天第十六题。今天还是一道关于数组的简单题目，闲暇时间可以用来练练手。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Array】【Two-Pointer】</p>\n<h4 id=\"27-Remove-Element：\"><a href=\"#27-Remove-Element：\" class=\"headerlink\" title=\"27. Remove Element：\"></a>27. <a href=\"https://leetcode.com/problems/remove-element/\" target=\"_blank\" rel=\"noopener\">Remove Element</a>：</h4><blockquote>\n<p>Given an array and a value, remove all instances of that value in place and return the new length.</p>\n</blockquote>\n<blockquote>\n<p>Do not allocate extra space for another array, you must do this in place with constant memory.</p>\n</blockquote>\n<blockquote>\n<p>The order of elements can be changed. It doesn’’t matter what you leave beyond the new length.</p>\n</blockquote>\n<p><strong>Example：</strong></p>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">Given input array nums = [3,2,2,3], val = 3.\n\nYour function should return length = 2, with the first two elements of nums being 2.\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p><strong>0. 题目大意：</strong></p>\n<p>给定一个数组和一个数字，将数组内和所给定数字不相等的值排列到数组的头部，相等的值排列到尾部（头部的值顺序可以被打乱）。</p>\n<p><strong>1. 第一种方法，双指针：</strong></p>\n<p>思路很简单也很容易想到，还是我们惯用的双指针，一个指针负责遍历，另一个指针负责锁定待更新值的位置。代码如下所示：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">removeElement</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> val<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> arrLen <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> arrLen<span class=\"token punctuation\">;</span> i <span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> val<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> temp <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            nums<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span>\n            j <span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> j<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">113 / 113 test cases passed.\nStatus: Accepted\nRuntime: 0 ms\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"id":"a025125cebc1b064963a240e889ec5e3","excerpt":"","more":"<p>LeetCode 每日一题系列，今天第十六题。今天还是一道关于数组的简单题目，闲暇时间可以用来练练手。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Array】【Two-Pointer】</p>\n<h4 id=\"27-Remove-Element：\"><a href=\"#27-Remove-Element：\" class=\"headerlink\" title=\"27. Remove Element：\"></a>27. <a href=\"https://leetcode.com/problems/remove-element/\" target=\"_blank\" rel=\"noopener\">Remove Element</a>：</h4><blockquote>\n<p>Given an array and a value, remove all instances of that value in place and return the new length.</p>\n</blockquote>\n<blockquote>\n<p>Do not allocate extra space for another array, you must do this in place with constant memory.</p>\n</blockquote>\n<blockquote>\n<p>The order of elements can be changed. It doesn’’t matter what you leave beyond the new length.</p>\n</blockquote>\n<p><strong>Example：</strong></p>\n<pre><code class=\"text\">Given input array nums = [3,2,2,3], val = 3.\n\nYour function should return length = 2, with the first two elements of nums being 2.\n</code></pre>\n<p><strong>0. 题目大意：</strong></p>\n<p>给定一个数组和一个数字，将数组内和所给定数字不相等的值排列到数组的头部，相等的值排列到尾部（头部的值顺序可以被打乱）。</p>\n<p><strong>1. 第一种方法，双指针：</strong></p>\n<p>思路很简单也很容易想到，还是我们惯用的双指针，一个指针负责遍历，另一个指针负责锁定待更新值的位置。代码如下所示：</p>\n<pre><code class=\"java\">public static int removeElement(int[] nums, int val) {\n    int arrLen = nums.length;\n    int j = 0;\n\n    for (int i = 0; i &lt; arrLen; i ++) {\n        if (nums[i] != val) {\n            int temp = nums[j];\n            nums[j] = nums[i];\n            nums[i] = temp;\n            j ++;\n        }\n    }\n\n    return j;\n}\n</code></pre>\n<pre><code class=\"text\">113 / 113 test cases passed.\nStatus: Accepted\nRuntime: 0 ms\n</code></pre>\n"},{"title":"LeetCode 每日一题 - 283. Move Zeroes","intro":"LeetCode 每日一题系列，今天第二题。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。这道题是今天早上做的，整理成本篇文章。因笔者水平有限，如果有更好的想法欢迎留言。【Array】【TwoPointers】","comments":1,"date":"2016-04-12T02:16:00.000Z","_content":"\nLeetCode 每日一题系列，今天第二题。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。这道题是今天早上做的，整理成本篇文章。因笔者水平有限，如果有更好的想法欢迎留言。【Array】【TwoPointers】\n\n#### 283. [Move Zeroes](https://leetcode.com/problems/move-zeroes/)：\n\n> Given an array nums, write a function to move all 0''s to the end of it while maintaining the relative order of the non-zero elements.\n\n> For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].\n1. You must do this in-place without making a copy of the array.\n2. Minimize the total number of operations.\n\n\n**Example：**\n\n```text\nGiven nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].\n```\n\n**1. 最基本的方法，依次查找值为0的元素：**\n\n无论如何，对于一道题我们要先有一个基础的解题思路，然后在这个基础的思路上再进行优化。那么对于这道题来说，最暴力和直接方法就是依次寻找数组中值为“0”的元素，每当寻找到一个值为0的元素时，便将该元素从数组删除，将此元素所在位置后边的所有元素均向前移动一个位置，然后再将数组的最后一个元素设置为0。由于题目要求 “in-place”，因此我们不能创建另外的数组或者 ArrayList 等数据类型，只能在原有的数组上进行操作。此方法的实现代码如下。时间复杂度为 “O(n2)”。\n\n```java\npublic static void moveZeroes(int[] nums) {\n    int arrLen = nums.length;\n    int zeroCount = 0, flag = 0;  // 声明两个变量，一个用来保存数组中0的个数，一个用来标志移动的0的个数，用于控制循环；\n    \n    for (int i = 0; i < arrLen; i++) {  // 获取数组中0的个数；\n    \tif (nums[i] == 0) {\n    \t\tzeroCount++;\n    \t}\n    }\n    \n    for (int i = 0; i < arrLen; i++) {  // 循环遍历数组；\n    \twhile (nums[i] == 0) {  // 防止连续的0，只有当移动之后当前位置不为0，才向下移动；\n    \t    for (int k = i; k < arrLen - 1; k++) {  // 注意此处的k是代表索引位置，并不是循环次数；\n    \t        nums[k] = nums[k + 1];  // 移除找到的0，并依次将元素向前移动（填补移除的0的位置）；\n    \t    }\n    \t\t\n    \t    nums[arrLen - 1] = 0;  // 数组末尾值置0；\n    \t    flag++;  \n            if (zeroCount == flag) {  // 当移除0的次数与0的个数相等时结束循环；\n    \t\t    return;\n    \t    }\n    \t}\n    }\n}\n```\n\n\n**2. 更好的方法：**\n\n网友“**咸鱼**”给出的另一种思路，我们采用双指针（Two Pointers）的方法来实现。顾名思义，双指针就是指采用两个指针指向数组不同的位置来进行运算。针对本题的算法中定义两个指针，一个名为 currentPointer 指针，即指向数组中当前遍历到的元素；另一个指针为 zeroPointer 一直指向数组中第一值为0的元素。算法的思路是：依次遍历数组元素，首先将 zeroPointer 指针指向数组中第一个值为0的元素，然后 currentPointer 指针随着遍历位置逐渐后移，若发现 currentPointer 指针指向的元素值不为0则将该位置的值与 zeroPointer 指针指向的元素进行交换。直到全部遍历完成。时间复杂度 “O(n)”。相比上一种算法，效率要提高不少。\n\n该方法的重点在于如何保持 zeroPointer 指针能够一直指向数组中的第一个值为0的元素，这里一般分为两种情况：\n\n1. 若 currentPointer 指针指向的元素的前一个元素不为0，则替换后 zeroPointer 指针指向 currentPointer 指针指向的元素；\n2. 若 currentPointer 指针指向的元素的前一个元素为0，则替换后 zeroPointer 指针位置加一；\n\n```java\npublic static void moveZeroesOptimize(int[] nums) {\n    int arrLen = nums.length;\n    int zeroPointer = -1;\n    \n    for (int i = 0; i < arrLen; i++) {\n\t    // 处理两种情况：\n        // 1、数组中第一个元素值即为0；\n        // 2、若该元素的前一个元素不为0，而该元素为0，则将 zeroPointer 指针指向该元素；\n    \tif((i == 0 && nums[i] == 0) || (i != 0 && nums[i] == 0 && nums[i - 1] != 0)) {\n\t        zeroPointer = i;\n    \t}\n    \t\n\t    // 找到 zeroPointer 指针后面位置中不为0的元素；\n    \tif(zeroPointer != -1 && nums[i] != 0) {\n            // 交换两个指针对应元素的值；\n            nums[zeroPointer] = nums[i];\n            nums[i] = 0;\n            // 重点：若当前元素前一个元素不为0，则将 zeroPointer 指针指向该元素，否则 zeroPointer 指针后移一个位置；\n            if(i - 1 >= 0 && nums[i - 1] != 0)\n                zeroPointer = i;\n            else\n                zeroPointer ++;\n    \t}\n    }\n}\n```\n\n\n","source":"_posts/LeetCode-每日一题-283-Move-Zeroes.md","raw":"---\ntitle: LeetCode 每日一题 - 283. Move Zeroes\nintro: LeetCode 每日一题系列，今天第二题。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。这道题是今天早上做的，整理成本篇文章。因笔者水平有限，如果有更好的想法欢迎留言。【Array】【TwoPointers】\ncomments: true\ndate: 2016-04-12 10:16:00\ntags:\n- 算法\n- LeetCode\n---\n\nLeetCode 每日一题系列，今天第二题。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。这道题是今天早上做的，整理成本篇文章。因笔者水平有限，如果有更好的想法欢迎留言。【Array】【TwoPointers】\n\n#### 283. [Move Zeroes](https://leetcode.com/problems/move-zeroes/)：\n\n> Given an array nums, write a function to move all 0''s to the end of it while maintaining the relative order of the non-zero elements.\n\n> For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].\n1. You must do this in-place without making a copy of the array.\n2. Minimize the total number of operations.\n\n\n**Example：**\n\n```text\nGiven nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].\n```\n\n**1. 最基本的方法，依次查找值为0的元素：**\n\n无论如何，对于一道题我们要先有一个基础的解题思路，然后在这个基础的思路上再进行优化。那么对于这道题来说，最暴力和直接方法就是依次寻找数组中值为“0”的元素，每当寻找到一个值为0的元素时，便将该元素从数组删除，将此元素所在位置后边的所有元素均向前移动一个位置，然后再将数组的最后一个元素设置为0。由于题目要求 “in-place”，因此我们不能创建另外的数组或者 ArrayList 等数据类型，只能在原有的数组上进行操作。此方法的实现代码如下。时间复杂度为 “O(n2)”。\n\n```java\npublic static void moveZeroes(int[] nums) {\n    int arrLen = nums.length;\n    int zeroCount = 0, flag = 0;  // 声明两个变量，一个用来保存数组中0的个数，一个用来标志移动的0的个数，用于控制循环；\n    \n    for (int i = 0; i < arrLen; i++) {  // 获取数组中0的个数；\n    \tif (nums[i] == 0) {\n    \t\tzeroCount++;\n    \t}\n    }\n    \n    for (int i = 0; i < arrLen; i++) {  // 循环遍历数组；\n    \twhile (nums[i] == 0) {  // 防止连续的0，只有当移动之后当前位置不为0，才向下移动；\n    \t    for (int k = i; k < arrLen - 1; k++) {  // 注意此处的k是代表索引位置，并不是循环次数；\n    \t        nums[k] = nums[k + 1];  // 移除找到的0，并依次将元素向前移动（填补移除的0的位置）；\n    \t    }\n    \t\t\n    \t    nums[arrLen - 1] = 0;  // 数组末尾值置0；\n    \t    flag++;  \n            if (zeroCount == flag) {  // 当移除0的次数与0的个数相等时结束循环；\n    \t\t    return;\n    \t    }\n    \t}\n    }\n}\n```\n\n\n**2. 更好的方法：**\n\n网友“**咸鱼**”给出的另一种思路，我们采用双指针（Two Pointers）的方法来实现。顾名思义，双指针就是指采用两个指针指向数组不同的位置来进行运算。针对本题的算法中定义两个指针，一个名为 currentPointer 指针，即指向数组中当前遍历到的元素；另一个指针为 zeroPointer 一直指向数组中第一值为0的元素。算法的思路是：依次遍历数组元素，首先将 zeroPointer 指针指向数组中第一个值为0的元素，然后 currentPointer 指针随着遍历位置逐渐后移，若发现 currentPointer 指针指向的元素值不为0则将该位置的值与 zeroPointer 指针指向的元素进行交换。直到全部遍历完成。时间复杂度 “O(n)”。相比上一种算法，效率要提高不少。\n\n该方法的重点在于如何保持 zeroPointer 指针能够一直指向数组中的第一个值为0的元素，这里一般分为两种情况：\n\n1. 若 currentPointer 指针指向的元素的前一个元素不为0，则替换后 zeroPointer 指针指向 currentPointer 指针指向的元素；\n2. 若 currentPointer 指针指向的元素的前一个元素为0，则替换后 zeroPointer 指针位置加一；\n\n```java\npublic static void moveZeroesOptimize(int[] nums) {\n    int arrLen = nums.length;\n    int zeroPointer = -1;\n    \n    for (int i = 0; i < arrLen; i++) {\n\t    // 处理两种情况：\n        // 1、数组中第一个元素值即为0；\n        // 2、若该元素的前一个元素不为0，而该元素为0，则将 zeroPointer 指针指向该元素；\n    \tif((i == 0 && nums[i] == 0) || (i != 0 && nums[i] == 0 && nums[i - 1] != 0)) {\n\t        zeroPointer = i;\n    \t}\n    \t\n\t    // 找到 zeroPointer 指针后面位置中不为0的元素；\n    \tif(zeroPointer != -1 && nums[i] != 0) {\n            // 交换两个指针对应元素的值；\n            nums[zeroPointer] = nums[i];\n            nums[i] = 0;\n            // 重点：若当前元素前一个元素不为0，则将 zeroPointer 指针指向该元素，否则 zeroPointer 指针后移一个位置；\n            if(i - 1 >= 0 && nums[i - 1] != 0)\n                zeroPointer = i;\n            else\n                zeroPointer ++;\n    \t}\n    }\n}\n```\n\n\n","slug":"LeetCode-每日一题-283-Move-Zeroes","published":1,"updated":"2019-02-10T02:50:39.048Z","layout":"post","photos":[],"link":"","_id":"cjsqwht9i002hknp26w0jyksm","content":"<p>LeetCode 每日一题系列，今天第二题。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。这道题是今天早上做的，整理成本篇文章。因笔者水平有限，如果有更好的想法欢迎留言。【Array】【TwoPointers】</p>\n<h4 id=\"283-Move-Zeroes：\"><a href=\"#283-Move-Zeroes：\" class=\"headerlink\" title=\"283. Move Zeroes：\"></a>283. <a href=\"https://leetcode.com/problems/move-zeroes/\" target=\"_blank\" rel=\"noopener\">Move Zeroes</a>：</h4><blockquote>\n<p>Given an array nums, write a function to move all 0’’s to the end of it while maintaining the relative order of the non-zero elements.</p>\n</blockquote>\n<blockquote>\n<p>For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].</p>\n<ol>\n<li>You must do this in-place without making a copy of the array.</li>\n<li>Minimize the total number of operations.</li>\n</ol>\n</blockquote>\n<p><strong>Example：</strong></p>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">Given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><strong>1. 最基本的方法，依次查找值为0的元素：</strong></p>\n<p>无论如何，对于一道题我们要先有一个基础的解题思路，然后在这个基础的思路上再进行优化。那么对于这道题来说，最暴力和直接方法就是依次寻找数组中值为“0”的元素，每当寻找到一个值为0的元素时，便将该元素从数组删除，将此元素所在位置后边的所有元素均向前移动一个位置，然后再将数组的最后一个元素设置为0。由于题目要求 “in-place”，因此我们不能创建另外的数组或者 ArrayList 等数据类型，只能在原有的数组上进行操作。此方法的实现代码如下。时间复杂度为 “O(n2)”。</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">moveZeroes</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> arrLen <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> zeroCount <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> flag <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 声明两个变量，一个用来保存数组中0的个数，一个用来标志移动的0的个数，用于控制循环；</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> arrLen<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  <span class=\"token comment\" spellcheck=\"true\">// 获取数组中0的个数；</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            zeroCount<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> arrLen<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  <span class=\"token comment\" spellcheck=\"true\">// 循环遍历数组；</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  <span class=\"token comment\" spellcheck=\"true\">// 防止连续的0，只有当移动之后当前位置不为0，才向下移动；</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> k <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span> k <span class=\"token operator\">&lt;</span> arrLen <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> k<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  <span class=\"token comment\" spellcheck=\"true\">// 注意此处的k是代表索引位置，并不是循环次数；</span>\n                nums<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>k <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 移除找到的0，并依次将元素向前移动（填补移除的0的位置）；</span>\n            <span class=\"token punctuation\">}</span>\n\n            nums<span class=\"token punctuation\">[</span>arrLen <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 数组末尾值置0；</span>\n            flag<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>  \n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>zeroCount <span class=\"token operator\">==</span> flag<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  <span class=\"token comment\" spellcheck=\"true\">// 当移除0的次数与0的个数相等时结束循环；</span>\n                <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>2. 更好的方法：</strong></p>\n<p>网友“<strong>咸鱼</strong>”给出的另一种思路，我们采用双指针（Two Pointers）的方法来实现。顾名思义，双指针就是指采用两个指针指向数组不同的位置来进行运算。针对本题的算法中定义两个指针，一个名为 currentPointer 指针，即指向数组中当前遍历到的元素；另一个指针为 zeroPointer 一直指向数组中第一值为0的元素。算法的思路是：依次遍历数组元素，首先将 zeroPointer 指针指向数组中第一个值为0的元素，然后 currentPointer 指针随着遍历位置逐渐后移，若发现 currentPointer 指针指向的元素值不为0则将该位置的值与 zeroPointer 指针指向的元素进行交换。直到全部遍历完成。时间复杂度 “O(n)”。相比上一种算法，效率要提高不少。</p>\n<p>该方法的重点在于如何保持 zeroPointer 指针能够一直指向数组中的第一个值为0的元素，这里一般分为两种情况：</p>\n<ol>\n<li>若 currentPointer 指针指向的元素的前一个元素不为0，则替换后 zeroPointer 指针指向 currentPointer 指针指向的元素；</li>\n<li>若 currentPointer 指针指向的元素的前一个元素为0，则替换后 zeroPointer 指针位置加一；</li>\n</ol>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">moveZeroesOptimize</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> arrLen <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> zeroPointer <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> arrLen<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 处理两种情况：</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 1、数组中第一个元素值即为0；</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 2、若该元素的前一个元素不为0，而该元素为0，则将 zeroPointer 指针指向该元素；</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> nums<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            zeroPointer <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 找到 zeroPointer 指针后面位置中不为0的元素；</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>zeroPointer <span class=\"token operator\">!=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 交换两个指针对应元素的值；</span>\n            nums<span class=\"token punctuation\">[</span>zeroPointer<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 重点：若当前元素前一个元素不为0，则将 zeroPointer 指针指向该元素，否则 zeroPointer 指针后移一个位置；</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span> <span class=\"token operator\">>=</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> nums<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n                zeroPointer <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">else</span>\n                zeroPointer <span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"id":"a88b494f41882406a29684827af72d1a","excerpt":"","more":"<p>LeetCode 每日一题系列，今天第二题。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。这道题是今天早上做的，整理成本篇文章。因笔者水平有限，如果有更好的想法欢迎留言。【Array】【TwoPointers】</p>\n<h4 id=\"283-Move-Zeroes：\"><a href=\"#283-Move-Zeroes：\" class=\"headerlink\" title=\"283. Move Zeroes：\"></a>283. <a href=\"https://leetcode.com/problems/move-zeroes/\" target=\"_blank\" rel=\"noopener\">Move Zeroes</a>：</h4><blockquote>\n<p>Given an array nums, write a function to move all 0’’s to the end of it while maintaining the relative order of the non-zero elements.</p>\n</blockquote>\n<blockquote>\n<p>For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].</p>\n<ol>\n<li>You must do this in-place without making a copy of the array.</li>\n<li>Minimize the total number of operations.</li>\n</ol>\n</blockquote>\n<p><strong>Example：</strong></p>\n<pre><code class=\"text\">Given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].\n</code></pre>\n<p><strong>1. 最基本的方法，依次查找值为0的元素：</strong></p>\n<p>无论如何，对于一道题我们要先有一个基础的解题思路，然后在这个基础的思路上再进行优化。那么对于这道题来说，最暴力和直接方法就是依次寻找数组中值为“0”的元素，每当寻找到一个值为0的元素时，便将该元素从数组删除，将此元素所在位置后边的所有元素均向前移动一个位置，然后再将数组的最后一个元素设置为0。由于题目要求 “in-place”，因此我们不能创建另外的数组或者 ArrayList 等数据类型，只能在原有的数组上进行操作。此方法的实现代码如下。时间复杂度为 “O(n2)”。</p>\n<pre><code class=\"java\">public static void moveZeroes(int[] nums) {\n    int arrLen = nums.length;\n    int zeroCount = 0, flag = 0;  // 声明两个变量，一个用来保存数组中0的个数，一个用来标志移动的0的个数，用于控制循环；\n\n    for (int i = 0; i &lt; arrLen; i++) {  // 获取数组中0的个数；\n        if (nums[i] == 0) {\n            zeroCount++;\n        }\n    }\n\n    for (int i = 0; i &lt; arrLen; i++) {  // 循环遍历数组；\n        while (nums[i] == 0) {  // 防止连续的0，只有当移动之后当前位置不为0，才向下移动；\n            for (int k = i; k &lt; arrLen - 1; k++) {  // 注意此处的k是代表索引位置，并不是循环次数；\n                nums[k] = nums[k + 1];  // 移除找到的0，并依次将元素向前移动（填补移除的0的位置）；\n            }\n\n            nums[arrLen - 1] = 0;  // 数组末尾值置0；\n            flag++;  \n            if (zeroCount == flag) {  // 当移除0的次数与0的个数相等时结束循环；\n                return;\n            }\n        }\n    }\n}\n</code></pre>\n<p><strong>2. 更好的方法：</strong></p>\n<p>网友“<strong>咸鱼</strong>”给出的另一种思路，我们采用双指针（Two Pointers）的方法来实现。顾名思义，双指针就是指采用两个指针指向数组不同的位置来进行运算。针对本题的算法中定义两个指针，一个名为 currentPointer 指针，即指向数组中当前遍历到的元素；另一个指针为 zeroPointer 一直指向数组中第一值为0的元素。算法的思路是：依次遍历数组元素，首先将 zeroPointer 指针指向数组中第一个值为0的元素，然后 currentPointer 指针随着遍历位置逐渐后移，若发现 currentPointer 指针指向的元素值不为0则将该位置的值与 zeroPointer 指针指向的元素进行交换。直到全部遍历完成。时间复杂度 “O(n)”。相比上一种算法，效率要提高不少。</p>\n<p>该方法的重点在于如何保持 zeroPointer 指针能够一直指向数组中的第一个值为0的元素，这里一般分为两种情况：</p>\n<ol>\n<li>若 currentPointer 指针指向的元素的前一个元素不为0，则替换后 zeroPointer 指针指向 currentPointer 指针指向的元素；</li>\n<li>若 currentPointer 指针指向的元素的前一个元素为0，则替换后 zeroPointer 指针位置加一；</li>\n</ol>\n<pre><code class=\"java\">public static void moveZeroesOptimize(int[] nums) {\n    int arrLen = nums.length;\n    int zeroPointer = -1;\n\n    for (int i = 0; i &lt; arrLen; i++) {\n        // 处理两种情况：\n        // 1、数组中第一个元素值即为0；\n        // 2、若该元素的前一个元素不为0，而该元素为0，则将 zeroPointer 指针指向该元素；\n        if((i == 0 &amp;&amp; nums[i] == 0) || (i != 0 &amp;&amp; nums[i] == 0 &amp;&amp; nums[i - 1] != 0)) {\n            zeroPointer = i;\n        }\n\n        // 找到 zeroPointer 指针后面位置中不为0的元素；\n        if(zeroPointer != -1 &amp;&amp; nums[i] != 0) {\n            // 交换两个指针对应元素的值；\n            nums[zeroPointer] = nums[i];\n            nums[i] = 0;\n            // 重点：若当前元素前一个元素不为0，则将 zeroPointer 指针指向该元素，否则 zeroPointer 指针后移一个位置；\n            if(i - 1 &gt;= 0 &amp;&amp; nums[i - 1] != 0)\n                zeroPointer = i;\n            else\n                zeroPointer ++;\n        }\n    }\n}\n</code></pre>\n"},{"title":"LeetCode 每日一题 - 342. Power of Four","intro":"LeetCode 每日一题系列，今天第十题。双休日因为事情繁多，所以没有来得及更新，感到十分愧疚。今天的题目是一道关于“二进制”的题目，也是 LeetCode 上的新题。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Bit Manipulation】","comments":1,"date":"2016-04-25T02:00:00.000Z","_content":"\nLeetCode 每日一题系列，今天第十题。双休日因为事情繁多，所以没有来得及更新，感到十分愧疚。今天的题目是一道关于“二进制”的题目，也是 LeetCode 上的新题。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Bit Manipulation】\n\n#### 342. [Power of Four](https://leetcode.com/problems/power-of-four/)：\n\n\n> Given an integer (signed 32 bits), write a function to check whether it is a power of 4.\n\n**Example:**\n\n```text\nGiven num = 16, return true. \n\nGiven num = 5, return false.\n```\n\n**0. 题目大意：**\n\n给出一个长度为32位的整数，判断该整数是否为4的幂指数。\n\n**1. 最基本的方法，循环相除：**\n\n我们知道，一个数 P 的 N 次幂指数即 N 个该数（P）相乘。那么相反的，想要判断一个数是否为该数(P)的幂指数，可以通过将此数与 P 相除，如果通过 N 次相除后得到的值为1（除尽），并且每次相除时的余数均为0，我们即可判断该数为 P 的幂指数。另外还要考虑两种情况，即数字1为任意数的0次幂指数，数字0不是任何数的幂指数。代码如下所示：\n\n```java\npublic static boolean isPowerOfFour(int num) {\n    if (num == 1)  // 单独处理数字1；\n        return true;\n\t\n    while (num % 4 == 0 && num != 0) {\n\tnum = num / 4;\n\tif (num == 1)\n\t    return true;\n    }\n\t\n    return false;\n}\n```\n\n\n**2. 优化的方法，利用二进制的规律：**\n\n另一种方法，我们可以参考如下规律：\n\n```text\n4    ---> ‭0100‬\n16   ---> ‭0001 0000‬\n64   ---> ‭0100 0000‬\n256  ---> ‭0001 0000 0000‬\n1024 ---> ‭0100 0000 0000\n4096 ---> ‬‭0001 0000 0000 0000‬\n...\n```\n\n从上述列出的几个连续的4的幂指数可以发现，这些数的二进制形式符合以下规律：除前四位剩余位数均为0，前四位只有两种形式即：“0001”和 “0100”，即数字1后出现的0的个数为0个或2个，利用此规律，我们可以得到如下解题方法。代码如下所示：\n\n```java\npublic static boolean isPowerOfFourOptimize(int num) {\n    if (num == 1)  // 单独处理数字1；\n\t    return true;\n\t\n    if (num == 0)  // 单独处理数字0；\n\t    return false;\n\t\n    String binaryCode = Integer.toBinaryString(num);  // 获取给定数字的二进制形式（没有前置0补全，即以1开头）；\n\t\n    String lastPos = binaryCode.substring(1);  // 获取二进制数除第一位之后的所有位数字；\n    int lastPosVal = Integer.valueOf(lastPos, 2);  // 除第一位数之后所有位数组成的二进制数字的值；\n\t\n    if (lastPosVal == 0 && (lastPos.length() % 4 == 0 || lastPos.length() % 4 == 2))  // 满足条件则返回 true；\n\t    return true;\n    else\n\t    return false;\n}\n```","source":"_posts/LeetCode-每日一题-342-Power-of-Four.md","raw":"---\ntitle: LeetCode 每日一题 - 342. Power of Four\nintro: LeetCode 每日一题系列，今天第十题。双休日因为事情繁多，所以没有来得及更新，感到十分愧疚。今天的题目是一道关于“二进制”的题目，也是 LeetCode 上的新题。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Bit Manipulation】\ncomments: true\ndate: 2016-04-25 10:00:00\ntags:\n- 算法\n- LeetCode\n---\n\nLeetCode 每日一题系列，今天第十题。双休日因为事情繁多，所以没有来得及更新，感到十分愧疚。今天的题目是一道关于“二进制”的题目，也是 LeetCode 上的新题。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Bit Manipulation】\n\n#### 342. [Power of Four](https://leetcode.com/problems/power-of-four/)：\n\n\n> Given an integer (signed 32 bits), write a function to check whether it is a power of 4.\n\n**Example:**\n\n```text\nGiven num = 16, return true. \n\nGiven num = 5, return false.\n```\n\n**0. 题目大意：**\n\n给出一个长度为32位的整数，判断该整数是否为4的幂指数。\n\n**1. 最基本的方法，循环相除：**\n\n我们知道，一个数 P 的 N 次幂指数即 N 个该数（P）相乘。那么相反的，想要判断一个数是否为该数(P)的幂指数，可以通过将此数与 P 相除，如果通过 N 次相除后得到的值为1（除尽），并且每次相除时的余数均为0，我们即可判断该数为 P 的幂指数。另外还要考虑两种情况，即数字1为任意数的0次幂指数，数字0不是任何数的幂指数。代码如下所示：\n\n```java\npublic static boolean isPowerOfFour(int num) {\n    if (num == 1)  // 单独处理数字1；\n        return true;\n\t\n    while (num % 4 == 0 && num != 0) {\n\tnum = num / 4;\n\tif (num == 1)\n\t    return true;\n    }\n\t\n    return false;\n}\n```\n\n\n**2. 优化的方法，利用二进制的规律：**\n\n另一种方法，我们可以参考如下规律：\n\n```text\n4    ---> ‭0100‬\n16   ---> ‭0001 0000‬\n64   ---> ‭0100 0000‬\n256  ---> ‭0001 0000 0000‬\n1024 ---> ‭0100 0000 0000\n4096 ---> ‬‭0001 0000 0000 0000‬\n...\n```\n\n从上述列出的几个连续的4的幂指数可以发现，这些数的二进制形式符合以下规律：除前四位剩余位数均为0，前四位只有两种形式即：“0001”和 “0100”，即数字1后出现的0的个数为0个或2个，利用此规律，我们可以得到如下解题方法。代码如下所示：\n\n```java\npublic static boolean isPowerOfFourOptimize(int num) {\n    if (num == 1)  // 单独处理数字1；\n\t    return true;\n\t\n    if (num == 0)  // 单独处理数字0；\n\t    return false;\n\t\n    String binaryCode = Integer.toBinaryString(num);  // 获取给定数字的二进制形式（没有前置0补全，即以1开头）；\n\t\n    String lastPos = binaryCode.substring(1);  // 获取二进制数除第一位之后的所有位数字；\n    int lastPosVal = Integer.valueOf(lastPos, 2);  // 除第一位数之后所有位数组成的二进制数字的值；\n\t\n    if (lastPosVal == 0 && (lastPos.length() % 4 == 0 || lastPos.length() % 4 == 2))  // 满足条件则返回 true；\n\t    return true;\n    else\n\t    return false;\n}\n```","slug":"LeetCode-每日一题-342-Power-of-Four","published":1,"updated":"2019-02-10T02:50:42.179Z","layout":"post","photos":[],"link":"","_id":"cjsqwht9i002jknp2f7t3qtvi","content":"<p>LeetCode 每日一题系列，今天第十题。双休日因为事情繁多，所以没有来得及更新，感到十分愧疚。今天的题目是一道关于“二进制”的题目，也是 LeetCode 上的新题。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Bit Manipulation】</p>\n<h4 id=\"342-Power-of-Four：\"><a href=\"#342-Power-of-Four：\" class=\"headerlink\" title=\"342. Power of Four：\"></a>342. <a href=\"https://leetcode.com/problems/power-of-four/\" target=\"_blank\" rel=\"noopener\">Power of Four</a>：</h4><blockquote>\n<p>Given an integer (signed 32 bits), write a function to check whether it is a power of 4.</p>\n</blockquote>\n<p><strong>Example:</strong></p>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">Given num = 16, return true. \n\nGiven num = 5, return false.\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p><strong>0. 题目大意：</strong></p>\n<p>给出一个长度为32位的整数，判断该整数是否为4的幂指数。</p>\n<p><strong>1. 最基本的方法，循环相除：</strong></p>\n<p>我们知道，一个数 P 的 N 次幂指数即 N 个该数（P）相乘。那么相反的，想要判断一个数是否为该数(P)的幂指数，可以通过将此数与 P 相除，如果通过 N 次相除后得到的值为1（除尽），并且每次相除时的余数均为0，我们即可判断该数为 P 的幂指数。另外还要考虑两种情况，即数字1为任意数的0次幂指数，数字0不是任何数的幂指数。代码如下所示：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">isPowerOfFour</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> num<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>num <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\" spellcheck=\"true\">// 单独处理数字1；</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>num <span class=\"token operator\">%</span> <span class=\"token number\">4</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> num <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    num <span class=\"token operator\">=</span> num <span class=\"token operator\">/</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>num <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>2. 优化的方法，利用二进制的规律：</strong></p>\n<p>另一种方法，我们可以参考如下规律：</p>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">4    ---> ‭0100‬\n16   ---> ‭0001 0000‬\n64   ---> ‭0100 0000‬\n256  ---> ‭0001 0000 0000‬\n1024 ---> ‭0100 0000 0000\n4096 ---> ‬‭0001 0000 0000 0000‬\n...\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>从上述列出的几个连续的4的幂指数可以发现，这些数的二进制形式符合以下规律：除前四位剩余位数均为0，前四位只有两种形式即：“0001”和 “0100”，即数字1后出现的0的个数为0个或2个，利用此规律，我们可以得到如下解题方法。代码如下所示：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">isPowerOfFourOptimize</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> num<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>num <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\" spellcheck=\"true\">// 单独处理数字1；</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>num <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\" spellcheck=\"true\">// 单独处理数字0；</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n\n    String binaryCode <span class=\"token operator\">=</span> Integer<span class=\"token punctuation\">.</span><span class=\"token function\">toBinaryString</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 获取给定数字的二进制形式（没有前置0补全，即以1开头）；</span>\n\n    String lastPos <span class=\"token operator\">=</span> binaryCode<span class=\"token punctuation\">.</span><span class=\"token function\">substring</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 获取二进制数除第一位之后的所有位数字；</span>\n    <span class=\"token keyword\">int</span> lastPosVal <span class=\"token operator\">=</span> Integer<span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>lastPos<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 除第一位数之后所有位数组成的二进制数字的值；</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>lastPosVal <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>lastPos<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> <span class=\"token number\">4</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token operator\">||</span> lastPos<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> <span class=\"token number\">4</span> <span class=\"token operator\">==</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\" spellcheck=\"true\">// 满足条件则返回 true；</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"id":"6f8a1a23d48932c1b1a7ec1fc4985b3b","excerpt":"","more":"<p>LeetCode 每日一题系列，今天第十题。双休日因为事情繁多，所以没有来得及更新，感到十分愧疚。今天的题目是一道关于“二进制”的题目，也是 LeetCode 上的新题。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Bit Manipulation】</p>\n<h4 id=\"342-Power-of-Four：\"><a href=\"#342-Power-of-Four：\" class=\"headerlink\" title=\"342. Power of Four：\"></a>342. <a href=\"https://leetcode.com/problems/power-of-four/\" target=\"_blank\" rel=\"noopener\">Power of Four</a>：</h4><blockquote>\n<p>Given an integer (signed 32 bits), write a function to check whether it is a power of 4.</p>\n</blockquote>\n<p><strong>Example:</strong></p>\n<pre><code class=\"text\">Given num = 16, return true. \n\nGiven num = 5, return false.\n</code></pre>\n<p><strong>0. 题目大意：</strong></p>\n<p>给出一个长度为32位的整数，判断该整数是否为4的幂指数。</p>\n<p><strong>1. 最基本的方法，循环相除：</strong></p>\n<p>我们知道，一个数 P 的 N 次幂指数即 N 个该数（P）相乘。那么相反的，想要判断一个数是否为该数(P)的幂指数，可以通过将此数与 P 相除，如果通过 N 次相除后得到的值为1（除尽），并且每次相除时的余数均为0，我们即可判断该数为 P 的幂指数。另外还要考虑两种情况，即数字1为任意数的0次幂指数，数字0不是任何数的幂指数。代码如下所示：</p>\n<pre><code class=\"java\">public static boolean isPowerOfFour(int num) {\n    if (num == 1)  // 单独处理数字1；\n        return true;\n\n    while (num % 4 == 0 &amp;&amp; num != 0) {\n    num = num / 4;\n    if (num == 1)\n        return true;\n    }\n\n    return false;\n}\n</code></pre>\n<p><strong>2. 优化的方法，利用二进制的规律：</strong></p>\n<p>另一种方法，我们可以参考如下规律：</p>\n<pre><code class=\"text\">4    ---&gt; ‭0100‬\n16   ---&gt; ‭0001 0000‬\n64   ---&gt; ‭0100 0000‬\n256  ---&gt; ‭0001 0000 0000‬\n1024 ---&gt; ‭0100 0000 0000\n4096 ---&gt; ‬‭0001 0000 0000 0000‬\n...\n</code></pre>\n<p>从上述列出的几个连续的4的幂指数可以发现，这些数的二进制形式符合以下规律：除前四位剩余位数均为0，前四位只有两种形式即：“0001”和 “0100”，即数字1后出现的0的个数为0个或2个，利用此规律，我们可以得到如下解题方法。代码如下所示：</p>\n<pre><code class=\"java\">public static boolean isPowerOfFourOptimize(int num) {\n    if (num == 1)  // 单独处理数字1；\n        return true;\n\n    if (num == 0)  // 单独处理数字0；\n        return false;\n\n    String binaryCode = Integer.toBinaryString(num);  // 获取给定数字的二进制形式（没有前置0补全，即以1开头）；\n\n    String lastPos = binaryCode.substring(1);  // 获取二进制数除第一位之后的所有位数字；\n    int lastPosVal = Integer.valueOf(lastPos, 2);  // 除第一位数之后所有位数组成的二进制数字的值；\n\n    if (lastPosVal == 0 &amp;&amp; (lastPos.length() % 4 == 0 || lastPos.length() % 4 == 2))  // 满足条件则返回 true；\n        return true;\n    else\n        return false;\n}\n</code></pre>\n"},{"title":"LeetCode 每日一题 - 344. Reverse String","intro":"LeetCode 每日一题系列，今天第十一题。由于最近较忙，一段时间没有更新该系列文章了，今天继续。还是一道简单的题目，但是类似的题目也经常出现在各类互联网企业的面试中。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【String】","comments":1,"date":"2016-05-05T13:59:13.000Z","_content":"\nLeetCode 每日一题系列，今天第十一题。由于最近较忙，一段时间没有更新该系列文章了，今天继续。还是一道简单的题目，但是类似的题目也经常出现在各类互联网企业的面试中。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【String】\n\n#### 344. [Reverse String](https://leetcode.com/problems/reverse-string/)：\n\n> Write a function that takes a string as input and returns the string reversed.\n\n**Example：**\n\n```text\nGiven s = \"hello\", return \"olleh\".\n```\n\n**0. 题目大意：**\n\n给定一个字符串，给出它的逆序字符串。比如给定字符串 “hello”，经过算法返回其逆序字符串 “olleh”。\n\n\n**1. 基本方法：**\n\n先将字符串拆分成字符数组，利用另外一个相同长度的字符数组将原数组的各个位置的值从后往前依次赋值给新创建的数组。最后将这个新创建的数组转换成字符串返回即可。时间复杂度 “O(n)”。代码如下所示：\n\n```java\npublic static String reverseString(String s) {\n    int strLength = s.length();\n    char [] tempCharArr = s.toCharArray();\n    char [] resultArr = new char[strLength];\n    \n    for (int i = 0; i< strLength; i++) {\n    \tresultArr[i] = tempCharArr[strLength - i - 1];\n    }\n    \n    return String.valueOf(resultArr);\n}\n```\n\n\n**2. 优化的方法，双指针：**\n\n这个方法也很好想到，我们在之前的题目中也有用到过类似的“双指针”方法。该方法不需要另外创建数组。首先将字符串转换成字符数组，声明两个指针分别指向该字符数组的首尾元素，并且依次交换首尾元素的值。每交换一次后首指针加一，尾指针减一，直到首指针的位置大于等于尾指针时，循环结束。此时返回原数组对应转换成的字符串即可。该方法为 “In-Place” 方法，相较上一种方法更加节省内存。时间复杂度 “O(n)”。代码如下所示：\n\n```java\n// In-Place；\npublic static String reverseStringOptimize(String s) {\n    int strLength = s.length();\n    char [] tempCharArr = s.toCharArray();\n    \n    for (int i = 0; i< strLength; i++) {\n    \tint j = strLength - i - 1;  // 尾指针；\n    \tif (i >= j) {  // 首指针大于等于尾指针时循环结束；\n    \t\tbreak;\n    \t}\n    \t\n        // 以此交换收尾指针对应元素的值；\n    \tchar tempVal = tempCharArr[i]; \n    \ttempCharArr[i] = tempCharArr[j];\n    \ttempCharArr[j] = tempVal;\n    }\n    \n    return String.valueOf(tempCharArr);\n}\n```\n","source":"_posts/LeetCode-每日一题-344-Reverse-String.md","raw":"---\ntitle: LeetCode 每日一题 - 344. Reverse String\nintro: LeetCode 每日一题系列，今天第十一题。由于最近较忙，一段时间没有更新该系列文章了，今天继续。还是一道简单的题目，但是类似的题目也经常出现在各类互联网企业的面试中。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【String】\ncomments: true\ndate: 2016-05-05 21:59:13\ntags:\n- 算法\n- LeetCode\n---\n\nLeetCode 每日一题系列，今天第十一题。由于最近较忙，一段时间没有更新该系列文章了，今天继续。还是一道简单的题目，但是类似的题目也经常出现在各类互联网企业的面试中。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【String】\n\n#### 344. [Reverse String](https://leetcode.com/problems/reverse-string/)：\n\n> Write a function that takes a string as input and returns the string reversed.\n\n**Example：**\n\n```text\nGiven s = \"hello\", return \"olleh\".\n```\n\n**0. 题目大意：**\n\n给定一个字符串，给出它的逆序字符串。比如给定字符串 “hello”，经过算法返回其逆序字符串 “olleh”。\n\n\n**1. 基本方法：**\n\n先将字符串拆分成字符数组，利用另外一个相同长度的字符数组将原数组的各个位置的值从后往前依次赋值给新创建的数组。最后将这个新创建的数组转换成字符串返回即可。时间复杂度 “O(n)”。代码如下所示：\n\n```java\npublic static String reverseString(String s) {\n    int strLength = s.length();\n    char [] tempCharArr = s.toCharArray();\n    char [] resultArr = new char[strLength];\n    \n    for (int i = 0; i< strLength; i++) {\n    \tresultArr[i] = tempCharArr[strLength - i - 1];\n    }\n    \n    return String.valueOf(resultArr);\n}\n```\n\n\n**2. 优化的方法，双指针：**\n\n这个方法也很好想到，我们在之前的题目中也有用到过类似的“双指针”方法。该方法不需要另外创建数组。首先将字符串转换成字符数组，声明两个指针分别指向该字符数组的首尾元素，并且依次交换首尾元素的值。每交换一次后首指针加一，尾指针减一，直到首指针的位置大于等于尾指针时，循环结束。此时返回原数组对应转换成的字符串即可。该方法为 “In-Place” 方法，相较上一种方法更加节省内存。时间复杂度 “O(n)”。代码如下所示：\n\n```java\n// In-Place；\npublic static String reverseStringOptimize(String s) {\n    int strLength = s.length();\n    char [] tempCharArr = s.toCharArray();\n    \n    for (int i = 0; i< strLength; i++) {\n    \tint j = strLength - i - 1;  // 尾指针；\n    \tif (i >= j) {  // 首指针大于等于尾指针时循环结束；\n    \t\tbreak;\n    \t}\n    \t\n        // 以此交换收尾指针对应元素的值；\n    \tchar tempVal = tempCharArr[i]; \n    \ttempCharArr[i] = tempCharArr[j];\n    \ttempCharArr[j] = tempVal;\n    }\n    \n    return String.valueOf(tempCharArr);\n}\n```\n","slug":"LeetCode-每日一题-344-Reverse-String","published":1,"updated":"2019-02-10T02:50:45.487Z","layout":"post","photos":[],"link":"","_id":"cjsqwht9j002lknp2cmtr1pxd","content":"<p>LeetCode 每日一题系列，今天第十一题。由于最近较忙，一段时间没有更新该系列文章了，今天继续。还是一道简单的题目，但是类似的题目也经常出现在各类互联网企业的面试中。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【String】</p>\n<h4 id=\"344-Reverse-String：\"><a href=\"#344-Reverse-String：\" class=\"headerlink\" title=\"344. Reverse String：\"></a>344. <a href=\"https://leetcode.com/problems/reverse-string/\" target=\"_blank\" rel=\"noopener\">Reverse String</a>：</h4><blockquote>\n<p>Write a function that takes a string as input and returns the string reversed.</p>\n</blockquote>\n<p><strong>Example：</strong></p>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">Given s = \"hello\", return \"olleh\".\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><strong>0. 题目大意：</strong></p>\n<p>给定一个字符串，给出它的逆序字符串。比如给定字符串 “hello”，经过算法返回其逆序字符串 “olleh”。</p>\n<p><strong>1. 基本方法：</strong></p>\n<p>先将字符串拆分成字符数组，利用另外一个相同长度的字符数组将原数组的各个位置的值从后往前依次赋值给新创建的数组。最后将这个新创建的数组转换成字符串返回即可。时间复杂度 “O(n)”。代码如下所示：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> String <span class=\"token function\">reverseString</span><span class=\"token punctuation\">(</span>String s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> strLength <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">char</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> tempCharArr <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">toCharArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">char</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> resultArr <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">char</span><span class=\"token punctuation\">[</span>strLength<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;</span> strLength<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        resultArr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> tempCharArr<span class=\"token punctuation\">[</span>strLength <span class=\"token operator\">-</span> i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> String<span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>resultArr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>2. 优化的方法，双指针：</strong></p>\n<p>这个方法也很好想到，我们在之前的题目中也有用到过类似的“双指针”方法。该方法不需要另外创建数组。首先将字符串转换成字符数组，声明两个指针分别指向该字符数组的首尾元素，并且依次交换首尾元素的值。每交换一次后首指针加一，尾指针减一，直到首指针的位置大于等于尾指针时，循环结束。此时返回原数组对应转换成的字符串即可。该方法为 “In-Place” 方法，相较上一种方法更加节省内存。时间复杂度 “O(n)”。代码如下所示：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// In-Place；</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> String <span class=\"token function\">reverseStringOptimize</span><span class=\"token punctuation\">(</span>String s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> strLength <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">char</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> tempCharArr <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">toCharArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;</span> strLength<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> strLength <span class=\"token operator\">-</span> i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 尾指针；</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">>=</span> j<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  <span class=\"token comment\" spellcheck=\"true\">// 首指针大于等于尾指针时循环结束；</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 以此交换收尾指针对应元素的值；</span>\n        <span class=\"token keyword\">char</span> tempVal <span class=\"token operator\">=</span> tempCharArr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> \n        tempCharArr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> tempCharArr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        tempCharArr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> tempVal<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> String<span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>tempCharArr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"id":"f1eec912eceb9d2070eabde3088c661d","excerpt":"","more":"<p>LeetCode 每日一题系列，今天第十一题。由于最近较忙，一段时间没有更新该系列文章了，今天继续。还是一道简单的题目，但是类似的题目也经常出现在各类互联网企业的面试中。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【String】</p>\n<h4 id=\"344-Reverse-String：\"><a href=\"#344-Reverse-String：\" class=\"headerlink\" title=\"344. Reverse String：\"></a>344. <a href=\"https://leetcode.com/problems/reverse-string/\" target=\"_blank\" rel=\"noopener\">Reverse String</a>：</h4><blockquote>\n<p>Write a function that takes a string as input and returns the string reversed.</p>\n</blockquote>\n<p><strong>Example：</strong></p>\n<pre><code class=\"text\">Given s = &quot;hello&quot;, return &quot;olleh&quot;.\n</code></pre>\n<p><strong>0. 题目大意：</strong></p>\n<p>给定一个字符串，给出它的逆序字符串。比如给定字符串 “hello”，经过算法返回其逆序字符串 “olleh”。</p>\n<p><strong>1. 基本方法：</strong></p>\n<p>先将字符串拆分成字符数组，利用另外一个相同长度的字符数组将原数组的各个位置的值从后往前依次赋值给新创建的数组。最后将这个新创建的数组转换成字符串返回即可。时间复杂度 “O(n)”。代码如下所示：</p>\n<pre><code class=\"java\">public static String reverseString(String s) {\n    int strLength = s.length();\n    char [] tempCharArr = s.toCharArray();\n    char [] resultArr = new char[strLength];\n\n    for (int i = 0; i&lt; strLength; i++) {\n        resultArr[i] = tempCharArr[strLength - i - 1];\n    }\n\n    return String.valueOf(resultArr);\n}\n</code></pre>\n<p><strong>2. 优化的方法，双指针：</strong></p>\n<p>这个方法也很好想到，我们在之前的题目中也有用到过类似的“双指针”方法。该方法不需要另外创建数组。首先将字符串转换成字符数组，声明两个指针分别指向该字符数组的首尾元素，并且依次交换首尾元素的值。每交换一次后首指针加一，尾指针减一，直到首指针的位置大于等于尾指针时，循环结束。此时返回原数组对应转换成的字符串即可。该方法为 “In-Place” 方法，相较上一种方法更加节省内存。时间复杂度 “O(n)”。代码如下所示：</p>\n<pre><code class=\"java\">// In-Place；\npublic static String reverseStringOptimize(String s) {\n    int strLength = s.length();\n    char [] tempCharArr = s.toCharArray();\n\n    for (int i = 0; i&lt; strLength; i++) {\n        int j = strLength - i - 1;  // 尾指针；\n        if (i &gt;= j) {  // 首指针大于等于尾指针时循环结束；\n            break;\n        }\n\n        // 以此交换收尾指针对应元素的值；\n        char tempVal = tempCharArr[i]; \n        tempCharArr[i] = tempCharArr[j];\n        tempCharArr[j] = tempVal;\n    }\n\n    return String.valueOf(tempCharArr);\n}\n</code></pre>\n"},{"title":"LeetCode 每日一题 - 58. Length of Last Word","intro":"LeetCode 每日一题系列。本文算法题目：给出一个字符串，该字符串包含大写字母，小写字母和空格，请编写程序给出最后一个单词（不包含空格，只包含字母）的长度。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【String】","comments":1,"date":"2016-09-17T09:57:53.000Z","_content":"\nLeetCode 每日一题系列。本文算法题目：给出一个字符串，该字符串包含大写字母，小写字母以及空格，请编写程序给出最后一个单词（不包含空格，只包含字母）的长度。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【String】\n\n#### 27. [Length of Last Word](https://leetcode.com/problems/length-of-last-word/)：\n\n\n> Given a string s consists of upper/lower-case alphabets and empty space characters \" \", return the length of last word in the string.\n\n> If the last word does not exist, return 0.\n\n**Note：**\n\n> A word is defined as a character sequence consists of non-space characters only.\n\n**Example：**\n\n```text\nGiven s = \"Hello World\", return 5.\n```\n\n**0. 题目大意：**\n\n给出一个字符串，该字符串包含大写字母，小写字母以及空格，请编写程序给出该字符串最后一个单词（不包含空格，只包含字母）的长度。\n\n**1. 基础解法：**\n\n基本的思路就是从后往前处理字符串。首先初始化一个长度变量值为0，接下来从后往前寻找整个字符串中第一个不为零的位置，那么这个位置应该就是整个字符串中最后一个 Word 的最后一个字符的位置。接下来继续从后向前寻找，只要当前所处的字符不是 “Space” 符即可将长度变量的值加一，否则直接退出循环，返回现在的长度。代码如下所示：\n\n\n```java\npublic static int lengthOfLastWord(String s) {\n    if (s.length() == 0) {\n        return 0;\n    }\n\t\t\n    int strLen = s.length();\n    int lastWordIndex = 0;\n    int lastWordLen = 0;\n\t\t\n    for (int i = strLen - 1; i > 0; i--) {\n        if (s.charAt(i) != \" \") {\n            lastWordIndex = i;\n            break;\n        }\n    }\n\n    for (int i = lastWordIndex; i >= 0; i--) {\n        if (s.charAt(i) != \" \") {\n            lastWordLen ++;\n        } else {\n            break;\n        }\n    }\n    return lastWordLen;\n}\n```\n\n```text\n59 / 59 test cases passed.\nStatus: Accepted\nRuntime: 5 ms\n```\n","source":"_posts/LeetCode-每日一题-58-Length-of-Last-Word.md","raw":"---\ntitle: LeetCode 每日一题 - 58. Length of Last Word\nintro: LeetCode 每日一题系列。本文算法题目：给出一个字符串，该字符串包含大写字母，小写字母和空格，请编写程序给出最后一个单词（不包含空格，只包含字母）的长度。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【String】\ncomments: true\ndate: 2016-09-17 17:57:53\ntags:\n- 算法\n- LeetCode\n---\n\nLeetCode 每日一题系列。本文算法题目：给出一个字符串，该字符串包含大写字母，小写字母以及空格，请编写程序给出最后一个单词（不包含空格，只包含字母）的长度。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【String】\n\n#### 27. [Length of Last Word](https://leetcode.com/problems/length-of-last-word/)：\n\n\n> Given a string s consists of upper/lower-case alphabets and empty space characters \" \", return the length of last word in the string.\n\n> If the last word does not exist, return 0.\n\n**Note：**\n\n> A word is defined as a character sequence consists of non-space characters only.\n\n**Example：**\n\n```text\nGiven s = \"Hello World\", return 5.\n```\n\n**0. 题目大意：**\n\n给出一个字符串，该字符串包含大写字母，小写字母以及空格，请编写程序给出该字符串最后一个单词（不包含空格，只包含字母）的长度。\n\n**1. 基础解法：**\n\n基本的思路就是从后往前处理字符串。首先初始化一个长度变量值为0，接下来从后往前寻找整个字符串中第一个不为零的位置，那么这个位置应该就是整个字符串中最后一个 Word 的最后一个字符的位置。接下来继续从后向前寻找，只要当前所处的字符不是 “Space” 符即可将长度变量的值加一，否则直接退出循环，返回现在的长度。代码如下所示：\n\n\n```java\npublic static int lengthOfLastWord(String s) {\n    if (s.length() == 0) {\n        return 0;\n    }\n\t\t\n    int strLen = s.length();\n    int lastWordIndex = 0;\n    int lastWordLen = 0;\n\t\t\n    for (int i = strLen - 1; i > 0; i--) {\n        if (s.charAt(i) != \" \") {\n            lastWordIndex = i;\n            break;\n        }\n    }\n\n    for (int i = lastWordIndex; i >= 0; i--) {\n        if (s.charAt(i) != \" \") {\n            lastWordLen ++;\n        } else {\n            break;\n        }\n    }\n    return lastWordLen;\n}\n```\n\n```text\n59 / 59 test cases passed.\nStatus: Accepted\nRuntime: 5 ms\n```\n","slug":"LeetCode-每日一题-58-Length-of-Last-Word","published":1,"updated":"2019-02-10T02:49:55.613Z","layout":"post","photos":[],"link":"","_id":"cjsqwht9k002nknp2m0bwj2o8","content":"<p>LeetCode 每日一题系列。本文算法题目：给出一个字符串，该字符串包含大写字母，小写字母以及空格，请编写程序给出最后一个单词（不包含空格，只包含字母）的长度。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【String】</p>\n<h4 id=\"27-Length-of-Last-Word：\"><a href=\"#27-Length-of-Last-Word：\" class=\"headerlink\" title=\"27. Length of Last Word：\"></a>27. <a href=\"https://leetcode.com/problems/length-of-last-word/\" target=\"_blank\" rel=\"noopener\">Length of Last Word</a>：</h4><blockquote>\n<p>Given a string s consists of upper/lower-case alphabets and empty space characters “ “, return the length of last word in the string.</p>\n</blockquote>\n<blockquote>\n<p>If the last word does not exist, return 0.</p>\n</blockquote>\n<p><strong>Note：</strong></p>\n<blockquote>\n<p>A word is defined as a character sequence consists of non-space characters only.</p>\n</blockquote>\n<p><strong>Example：</strong></p>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">Given s = \"Hello World\", return 5.\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><strong>0. 题目大意：</strong></p>\n<p>给出一个字符串，该字符串包含大写字母，小写字母以及空格，请编写程序给出该字符串最后一个单词（不包含空格，只包含字母）的长度。</p>\n<p><strong>1. 基础解法：</strong></p>\n<p>基本的思路就是从后往前处理字符串。首先初始化一个长度变量值为0，接下来从后往前寻找整个字符串中第一个不为零的位置，那么这个位置应该就是整个字符串中最后一个 Word 的最后一个字符的位置。接下来继续从后向前寻找，只要当前所处的字符不是 “Space” 符即可将长度变量的值加一，否则直接退出循环，返回现在的长度。代码如下所示：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">lengthOfLastWord</span><span class=\"token punctuation\">(</span>String s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">int</span> strLen <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> lastWordIndex <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> lastWordLen <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> strLen <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            lastWordIndex <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> lastWordIndex<span class=\"token punctuation\">;</span> i <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            lastWordLen <span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> lastWordLen<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">59 / 59 test cases passed.\nStatus: Accepted\nRuntime: 5 ms\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"id":"e7df648c1c4aa9db50e81850f75329a7","excerpt":"","more":"<p>LeetCode 每日一题系列。本文算法题目：给出一个字符串，该字符串包含大写字母，小写字母以及空格，请编写程序给出最后一个单词（不包含空格，只包含字母）的长度。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【String】</p>\n<h4 id=\"27-Length-of-Last-Word：\"><a href=\"#27-Length-of-Last-Word：\" class=\"headerlink\" title=\"27. Length of Last Word：\"></a>27. <a href=\"https://leetcode.com/problems/length-of-last-word/\" target=\"_blank\" rel=\"noopener\">Length of Last Word</a>：</h4><blockquote>\n<p>Given a string s consists of upper/lower-case alphabets and empty space characters “ “, return the length of last word in the string.</p>\n</blockquote>\n<blockquote>\n<p>If the last word does not exist, return 0.</p>\n</blockquote>\n<p><strong>Note：</strong></p>\n<blockquote>\n<p>A word is defined as a character sequence consists of non-space characters only.</p>\n</blockquote>\n<p><strong>Example：</strong></p>\n<pre><code class=\"text\">Given s = &quot;Hello World&quot;, return 5.\n</code></pre>\n<p><strong>0. 题目大意：</strong></p>\n<p>给出一个字符串，该字符串包含大写字母，小写字母以及空格，请编写程序给出该字符串最后一个单词（不包含空格，只包含字母）的长度。</p>\n<p><strong>1. 基础解法：</strong></p>\n<p>基本的思路就是从后往前处理字符串。首先初始化一个长度变量值为0，接下来从后往前寻找整个字符串中第一个不为零的位置，那么这个位置应该就是整个字符串中最后一个 Word 的最后一个字符的位置。接下来继续从后向前寻找，只要当前所处的字符不是 “Space” 符即可将长度变量的值加一，否则直接退出循环，返回现在的长度。代码如下所示：</p>\n<pre><code class=\"java\">public static int lengthOfLastWord(String s) {\n    if (s.length() == 0) {\n        return 0;\n    }\n\n    int strLen = s.length();\n    int lastWordIndex = 0;\n    int lastWordLen = 0;\n\n    for (int i = strLen - 1; i &gt; 0; i--) {\n        if (s.charAt(i) != &quot; &quot;) {\n            lastWordIndex = i;\n            break;\n        }\n    }\n\n    for (int i = lastWordIndex; i &gt;= 0; i--) {\n        if (s.charAt(i) != &quot; &quot;) {\n            lastWordLen ++;\n        } else {\n            break;\n        }\n    }\n    return lastWordLen;\n}\n</code></pre>\n<pre><code class=\"text\">59 / 59 test cases passed.\nStatus: Accepted\nRuntime: 5 ms\n</code></pre>\n"},{"title":"LeetCode 每日一题 - 6. ZigZag Conversion","intro":"LeetCode 每日一题系列，今天第十三题。“ZigZag” 一词的意思是 “Z 字形，锯齿形”，如果把数字按照 “ZigZag” 的方式进行排列，这会是一道怎样的题目呢？我们一起来看看。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【String】","comments":1,"date":"2016-05-08T15:06:08.000Z","_content":"\nLeetCode 每日一题系列，今天第十三题。“ZigZag” 一词的意思是 “Z 字形，锯齿形”，如果把数字按照 “ZigZag” 的方式进行排列，这会是一道怎样的题目呢？我们一起来看看。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【String】\n\n#### 258. [ZigZag Conversion](https://leetcode.com/problems/zigzag-conversion/)：\n\n\n> The string **\"PAYPALISHIRING\"** is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility).\n\n**Example：**\n\n```text\nP   A   H   N\nA P L S I I G\nY   I   R\n```\n\n> And then read line by line: \"**PAHNAPLSIIGYIR**\".\n\n> Write the code that will take a string and make this conversion given a number of rows:\n\n```text\nstring convert(string text, int nRows);\n```\n\n> Here **convert(\"PAYPALISHIRING\", 3)** should return \"**PAHNAPLSIIGYIR**\".\n\n**0. 题目大意：**\n\n给定一组字符串，将该字符串的所有字符按照 “ZigZag” 的方式（Z形的方式，如上图，先从上至下排列然后继续向斜上方排列再继续向下排列依次循环）排列成 numRows 行，然后逐行水平方向从左到右读取这些字符并返回由这些字符组成的新字符串。\n\n**1. 基本方法，分析基本规律：**\n\n使用二维数组来模拟 “ZigZag” 的存储方式，行 (x) 和列 (y) 的规律分开进行处理。行 (x) 标一直在**0**和 **numRows** 之间循环变换，列 (y) 标在行 (x) 标增加的过程中值不变，在 (x) 标减少的时候值每次加一。总体来说有两个变化的地方，即**行 (x) 标为0的时候**和**行 (x) 标为 numRows - 1**的时候。同时不要忘记还要处理一种特殊情况，即 **numRows 为1**的情况，当然也可以整理到上述情况中，但思路不变，即行列的规律要分开处理。代码如下所示：\n\n```java\npublic static String convert(String s, int numRows) {\n    char[] tempCharArr = s.toCharArray();\n    int tempCharArrLen = tempCharArr.length;\n    // 计算列数；\n    int columeNum = tempCharArrLen * numRows / (2 * numRows - 1) + \n    \t\t(tempCharArrLen % (2 * numRows - 1) <= numRows ? 1 : tempCharArrLen % (2 * numRows - 1) - numRows + 1);\n    char[][] charMap = new char[numRows][columeNum];\n    \n    int x = 0, y = 0, k = 1, h = 1;\n    for (int i = 0; i < tempCharArrLen; i++){\n    \tchar thisChar = tempCharArr[i];\n     \tcharMap[x][y] = thisChar;\n    \t\n    \tif (x == 0) {\n    \t\tk = 1;\n    \t\th = 0;\n    \t} else if (x == numRows - 1) {\n    \t\tk = -1;\n    \t\th = 1;\n    \t}\n    \t\n    \t// 特殊情况；\n    \tif (numRows == 1) {\n    \t\tk = 0;\n    \t\th = 1;\n    \t}\n    \t\t\n    \tx = x + k;\n    \ty = y + h;\n    }\t\t\n    \n    StringBuffer sb = new StringBuffer();\n    \n    // Output string；\n    for (int i = 0; i < charMap.length; i++){\n    \tfor (int j = 0; j < charMap[i].length; j++){\n            char c = charMap[i][j];\n    \t    if (c == ''\\0'')\n    \t\t    continue;\n    \t    else\n    \t\t    sb.append(c);\n    \t}\n    }\n    \n    return sb.toString();\n}\n```\n\n```text\n1158 / 1158 test cases passed.\nStatus: Accepted\nRuntime: 51 ms\n```\n\n**2. 优化方法，进一步规律：**\n\n更加友好和规律化的方法就是直接按照一定规律去读取字符串某一位置的字符，然后组合在一起，而不是先按照Z字来排列之后再读取。这个规律就是：所有“直线列”水平读取时的重复周期都是 “2 x numRows - 2”；对于首行和末行之间的行，还会额外多读取一个位置的字符，而这一位置距离本周期起始字符的距离是 “2 x numRows - 2 - 2 x i”。代码如下所示：\n\n```java\npublic static String convertOptimize(String s, int numRows) {\n    int len = s.length();  \n    if (len == 0 || numRows < 2) return s;  \n      \n    String ret = \"\";   \n    int period = 2 * numRows - 2; // “直线列”水平读取时的循环周期；\n    for (int i = 0; i < numRows; i++) {  \n        for (int j = i; j < len; j += period) {  \n            ret += s.charAt(j);  \n              \n            // 非首行和末行时还要多读取一个字符；\n            if (i > 0 && i < numRows - 1) {  \n                int t = j + period - 2 * i;  \n                if (t < len) {  \n                    ret += s.charAt(t);  \n                }  \n            }  \n        }  \n    }  \n    return ret;  \n}\n```\n```text\n1158 / 1158 test cases passed.\nStatus: Accepted\nRuntime: 65 ms\n```\n\n\n\n\n\n\n\n","source":"_posts/LeetCode-每日一题-6-ZigZag-Conversion.md","raw":"---\ntitle: LeetCode 每日一题 - 6. ZigZag Conversion\nintro: LeetCode 每日一题系列，今天第十三题。“ZigZag” 一词的意思是 “Z 字形，锯齿形”，如果把数字按照 “ZigZag” 的方式进行排列，这会是一道怎样的题目呢？我们一起来看看。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【String】\ncomments: true\ndate: 2016-05-08 23:06:08\ntags:\n- 算法\n- LeetCode\n---\n\nLeetCode 每日一题系列，今天第十三题。“ZigZag” 一词的意思是 “Z 字形，锯齿形”，如果把数字按照 “ZigZag” 的方式进行排列，这会是一道怎样的题目呢？我们一起来看看。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【String】\n\n#### 258. [ZigZag Conversion](https://leetcode.com/problems/zigzag-conversion/)：\n\n\n> The string **\"PAYPALISHIRING\"** is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility).\n\n**Example：**\n\n```text\nP   A   H   N\nA P L S I I G\nY   I   R\n```\n\n> And then read line by line: \"**PAHNAPLSIIGYIR**\".\n\n> Write the code that will take a string and make this conversion given a number of rows:\n\n```text\nstring convert(string text, int nRows);\n```\n\n> Here **convert(\"PAYPALISHIRING\", 3)** should return \"**PAHNAPLSIIGYIR**\".\n\n**0. 题目大意：**\n\n给定一组字符串，将该字符串的所有字符按照 “ZigZag” 的方式（Z形的方式，如上图，先从上至下排列然后继续向斜上方排列再继续向下排列依次循环）排列成 numRows 行，然后逐行水平方向从左到右读取这些字符并返回由这些字符组成的新字符串。\n\n**1. 基本方法，分析基本规律：**\n\n使用二维数组来模拟 “ZigZag” 的存储方式，行 (x) 和列 (y) 的规律分开进行处理。行 (x) 标一直在**0**和 **numRows** 之间循环变换，列 (y) 标在行 (x) 标增加的过程中值不变，在 (x) 标减少的时候值每次加一。总体来说有两个变化的地方，即**行 (x) 标为0的时候**和**行 (x) 标为 numRows - 1**的时候。同时不要忘记还要处理一种特殊情况，即 **numRows 为1**的情况，当然也可以整理到上述情况中，但思路不变，即行列的规律要分开处理。代码如下所示：\n\n```java\npublic static String convert(String s, int numRows) {\n    char[] tempCharArr = s.toCharArray();\n    int tempCharArrLen = tempCharArr.length;\n    // 计算列数；\n    int columeNum = tempCharArrLen * numRows / (2 * numRows - 1) + \n    \t\t(tempCharArrLen % (2 * numRows - 1) <= numRows ? 1 : tempCharArrLen % (2 * numRows - 1) - numRows + 1);\n    char[][] charMap = new char[numRows][columeNum];\n    \n    int x = 0, y = 0, k = 1, h = 1;\n    for (int i = 0; i < tempCharArrLen; i++){\n    \tchar thisChar = tempCharArr[i];\n     \tcharMap[x][y] = thisChar;\n    \t\n    \tif (x == 0) {\n    \t\tk = 1;\n    \t\th = 0;\n    \t} else if (x == numRows - 1) {\n    \t\tk = -1;\n    \t\th = 1;\n    \t}\n    \t\n    \t// 特殊情况；\n    \tif (numRows == 1) {\n    \t\tk = 0;\n    \t\th = 1;\n    \t}\n    \t\t\n    \tx = x + k;\n    \ty = y + h;\n    }\t\t\n    \n    StringBuffer sb = new StringBuffer();\n    \n    // Output string；\n    for (int i = 0; i < charMap.length; i++){\n    \tfor (int j = 0; j < charMap[i].length; j++){\n            char c = charMap[i][j];\n    \t    if (c == ''\\0'')\n    \t\t    continue;\n    \t    else\n    \t\t    sb.append(c);\n    \t}\n    }\n    \n    return sb.toString();\n}\n```\n\n```text\n1158 / 1158 test cases passed.\nStatus: Accepted\nRuntime: 51 ms\n```\n\n**2. 优化方法，进一步规律：**\n\n更加友好和规律化的方法就是直接按照一定规律去读取字符串某一位置的字符，然后组合在一起，而不是先按照Z字来排列之后再读取。这个规律就是：所有“直线列”水平读取时的重复周期都是 “2 x numRows - 2”；对于首行和末行之间的行，还会额外多读取一个位置的字符，而这一位置距离本周期起始字符的距离是 “2 x numRows - 2 - 2 x i”。代码如下所示：\n\n```java\npublic static String convertOptimize(String s, int numRows) {\n    int len = s.length();  \n    if (len == 0 || numRows < 2) return s;  \n      \n    String ret = \"\";   \n    int period = 2 * numRows - 2; // “直线列”水平读取时的循环周期；\n    for (int i = 0; i < numRows; i++) {  \n        for (int j = i; j < len; j += period) {  \n            ret += s.charAt(j);  \n              \n            // 非首行和末行时还要多读取一个字符；\n            if (i > 0 && i < numRows - 1) {  \n                int t = j + period - 2 * i;  \n                if (t < len) {  \n                    ret += s.charAt(t);  \n                }  \n            }  \n        }  \n    }  \n    return ret;  \n}\n```\n```text\n1158 / 1158 test cases passed.\nStatus: Accepted\nRuntime: 65 ms\n```\n\n\n\n\n\n\n\n","slug":"LeetCode-每日一题-6-ZigZag-Conversion","published":1,"updated":"2019-02-10T02:49:44.941Z","layout":"post","photos":[],"link":"","_id":"cjsqwht9k002pknp2sr2skd8g","content":"<p>LeetCode 每日一题系列，今天第十三题。“ZigZag” 一词的意思是 “Z 字形，锯齿形”，如果把数字按照 “ZigZag” 的方式进行排列，这会是一道怎样的题目呢？我们一起来看看。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【String】</p>\n<h4 id=\"258-ZigZag-Conversion：\"><a href=\"#258-ZigZag-Conversion：\" class=\"headerlink\" title=\"258. ZigZag Conversion：\"></a>258. <a href=\"https://leetcode.com/problems/zigzag-conversion/\" target=\"_blank\" rel=\"noopener\">ZigZag Conversion</a>：</h4><blockquote>\n<p>The string <strong>“PAYPALISHIRING”</strong> is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility).</p>\n</blockquote>\n<p><strong>Example：</strong></p>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">P   A   H   N\nA P L S I I G\nY   I   R\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<p>And then read line by line: “<strong>PAHNAPLSIIGYIR</strong>“.</p>\n</blockquote>\n<blockquote>\n<p>Write the code that will take a string and make this conversion given a number of rows:</p>\n</blockquote>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">string convert(string text, int nRows);\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<blockquote>\n<p>Here <strong>convert(“PAYPALISHIRING”, 3)</strong> should return “<strong>PAHNAPLSIIGYIR</strong>“.</p>\n</blockquote>\n<p><strong>0. 题目大意：</strong></p>\n<p>给定一组字符串，将该字符串的所有字符按照 “ZigZag” 的方式（Z形的方式，如上图，先从上至下排列然后继续向斜上方排列再继续向下排列依次循环）排列成 numRows 行，然后逐行水平方向从左到右读取这些字符并返回由这些字符组成的新字符串。</p>\n<p><strong>1. 基本方法，分析基本规律：</strong></p>\n<p>使用二维数组来模拟 “ZigZag” 的存储方式，行 (x) 和列 (y) 的规律分开进行处理。行 (x) 标一直在<strong>0</strong>和 <strong>numRows</strong> 之间循环变换，列 (y) 标在行 (x) 标增加的过程中值不变，在 (x) 标减少的时候值每次加一。总体来说有两个变化的地方，即<strong>行 (x) 标为0的时候</strong>和<strong>行 (x) 标为 numRows - 1</strong>的时候。同时不要忘记还要处理一种特殊情况，即 <strong>numRows 为1</strong>的情况，当然也可以整理到上述情况中，但思路不变，即行列的规律要分开处理。代码如下所示：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> String <span class=\"token function\">convert</span><span class=\"token punctuation\">(</span>String s<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> numRows<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">char</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> tempCharArr <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">toCharArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> tempCharArrLen <span class=\"token operator\">=</span> tempCharArr<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 计算列数；</span>\n    <span class=\"token keyword\">int</span> columeNum <span class=\"token operator\">=</span> tempCharArrLen <span class=\"token operator\">*</span> numRows <span class=\"token operator\">/</span> <span class=\"token punctuation\">(</span><span class=\"token number\">2</span> <span class=\"token operator\">*</span> numRows <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> \n            <span class=\"token punctuation\">(</span>tempCharArrLen <span class=\"token operator\">%</span> <span class=\"token punctuation\">(</span><span class=\"token number\">2</span> <span class=\"token operator\">*</span> numRows <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;=</span> numRows <span class=\"token operator\">?</span> <span class=\"token number\">1</span> <span class=\"token operator\">:</span> tempCharArrLen <span class=\"token operator\">%</span> <span class=\"token punctuation\">(</span><span class=\"token number\">2</span> <span class=\"token operator\">*</span> numRows <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> numRows <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">char</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> charMap <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">char</span><span class=\"token punctuation\">[</span>numRows<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>columeNum<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> x <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> y <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> k <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> h <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> tempCharArrLen<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">char</span> thisChar <span class=\"token operator\">=</span> tempCharArr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n         charMap<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>y<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> thisChar<span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>x <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            k <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n            h <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>x <span class=\"token operator\">==</span> numRows <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            k <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n            h <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 特殊情况；</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>numRows <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            k <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n            h <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        x <span class=\"token operator\">=</span> x <span class=\"token operator\">+</span> k<span class=\"token punctuation\">;</span>\n        y <span class=\"token operator\">=</span> y <span class=\"token operator\">+</span> h<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>        \n\n    StringBuffer sb <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">StringBuffer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Output string；</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> charMap<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> charMap<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">char</span> c <span class=\"token operator\">=</span> charMap<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>c <span class=\"token operator\">==</span> <span class=\"token string\">''</span>\\<span class=\"token number\">0</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">else</span>\n                sb<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> sb<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">1158 / 1158 test cases passed.\nStatus: Accepted\nRuntime: 51 ms\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p><strong>2. 优化方法，进一步规律：</strong></p>\n<p>更加友好和规律化的方法就是直接按照一定规律去读取字符串某一位置的字符，然后组合在一起，而不是先按照Z字来排列之后再读取。这个规律就是：所有“直线列”水平读取时的重复周期都是 “2 x numRows - 2”；对于首行和末行之间的行，还会额外多读取一个位置的字符，而这一位置距离本周期起始字符的距离是 “2 x numRows - 2 - 2 x i”。代码如下所示：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> String <span class=\"token function\">convertOptimize</span><span class=\"token punctuation\">(</span>String s<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> numRows<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> len <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>len <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token operator\">||</span> numRows <span class=\"token operator\">&lt;</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> s<span class=\"token punctuation\">;</span>  \n\n    String ret <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">;</span>   \n    <span class=\"token keyword\">int</span> period <span class=\"token operator\">=</span> <span class=\"token number\">2</span> <span class=\"token operator\">*</span> numRows <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// “直线列”水平读取时的循环周期；</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> numRows<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> len<span class=\"token punctuation\">;</span> j <span class=\"token operator\">+=</span> period<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n            ret <span class=\"token operator\">+=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span>j<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n\n            <span class=\"token comment\" spellcheck=\"true\">// 非首行和末行时还要多读取一个字符；</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> i <span class=\"token operator\">&lt;</span> numRows <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n                <span class=\"token keyword\">int</span> t <span class=\"token operator\">=</span> j <span class=\"token operator\">+</span> period <span class=\"token operator\">-</span> <span class=\"token number\">2</span> <span class=\"token operator\">*</span> i<span class=\"token punctuation\">;</span>  \n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>t <span class=\"token operator\">&lt;</span> len<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n                    ret <span class=\"token operator\">+=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n                <span class=\"token punctuation\">}</span>  \n            <span class=\"token punctuation\">}</span>  \n        <span class=\"token punctuation\">}</span>  \n    <span class=\"token punctuation\">}</span>  \n    <span class=\"token keyword\">return</span> ret<span class=\"token punctuation\">;</span>  \n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">1158 / 1158 test cases passed.\nStatus: Accepted\nRuntime: 65 ms\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"id":"d453ea84e5cd1871f91c73babe35dad3","excerpt":"","more":"<p>LeetCode 每日一题系列，今天第十三题。“ZigZag” 一词的意思是 “Z 字形，锯齿形”，如果把数字按照 “ZigZag” 的方式进行排列，这会是一道怎样的题目呢？我们一起来看看。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【String】</p>\n<h4 id=\"258-ZigZag-Conversion：\"><a href=\"#258-ZigZag-Conversion：\" class=\"headerlink\" title=\"258. ZigZag Conversion：\"></a>258. <a href=\"https://leetcode.com/problems/zigzag-conversion/\" target=\"_blank\" rel=\"noopener\">ZigZag Conversion</a>：</h4><blockquote>\n<p>The string <strong>“PAYPALISHIRING”</strong> is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility).</p>\n</blockquote>\n<p><strong>Example：</strong></p>\n<pre><code class=\"text\">P   A   H   N\nA P L S I I G\nY   I   R\n</code></pre>\n<blockquote>\n<p>And then read line by line: “<strong>PAHNAPLSIIGYIR</strong>“.</p>\n</blockquote>\n<blockquote>\n<p>Write the code that will take a string and make this conversion given a number of rows:</p>\n</blockquote>\n<pre><code class=\"text\">string convert(string text, int nRows);\n</code></pre>\n<blockquote>\n<p>Here <strong>convert(“PAYPALISHIRING”, 3)</strong> should return “<strong>PAHNAPLSIIGYIR</strong>“.</p>\n</blockquote>\n<p><strong>0. 题目大意：</strong></p>\n<p>给定一组字符串，将该字符串的所有字符按照 “ZigZag” 的方式（Z形的方式，如上图，先从上至下排列然后继续向斜上方排列再继续向下排列依次循环）排列成 numRows 行，然后逐行水平方向从左到右读取这些字符并返回由这些字符组成的新字符串。</p>\n<p><strong>1. 基本方法，分析基本规律：</strong></p>\n<p>使用二维数组来模拟 “ZigZag” 的存储方式，行 (x) 和列 (y) 的规律分开进行处理。行 (x) 标一直在<strong>0</strong>和 <strong>numRows</strong> 之间循环变换，列 (y) 标在行 (x) 标增加的过程中值不变，在 (x) 标减少的时候值每次加一。总体来说有两个变化的地方，即<strong>行 (x) 标为0的时候</strong>和<strong>行 (x) 标为 numRows - 1</strong>的时候。同时不要忘记还要处理一种特殊情况，即 <strong>numRows 为1</strong>的情况，当然也可以整理到上述情况中，但思路不变，即行列的规律要分开处理。代码如下所示：</p>\n<pre><code class=\"java\">public static String convert(String s, int numRows) {\n    char[] tempCharArr = s.toCharArray();\n    int tempCharArrLen = tempCharArr.length;\n    // 计算列数；\n    int columeNum = tempCharArrLen * numRows / (2 * numRows - 1) + \n            (tempCharArrLen % (2 * numRows - 1) &lt;= numRows ? 1 : tempCharArrLen % (2 * numRows - 1) - numRows + 1);\n    char[][] charMap = new char[numRows][columeNum];\n\n    int x = 0, y = 0, k = 1, h = 1;\n    for (int i = 0; i &lt; tempCharArrLen; i++){\n        char thisChar = tempCharArr[i];\n         charMap[x][y] = thisChar;\n\n        if (x == 0) {\n            k = 1;\n            h = 0;\n        } else if (x == numRows - 1) {\n            k = -1;\n            h = 1;\n        }\n\n        // 特殊情况；\n        if (numRows == 1) {\n            k = 0;\n            h = 1;\n        }\n\n        x = x + k;\n        y = y + h;\n    }        \n\n    StringBuffer sb = new StringBuffer();\n\n    // Output string；\n    for (int i = 0; i &lt; charMap.length; i++){\n        for (int j = 0; j &lt; charMap[i].length; j++){\n            char c = charMap[i][j];\n            if (c == &#39;&#39;\\0&#39;&#39;)\n                continue;\n            else\n                sb.append(c);\n        }\n    }\n\n    return sb.toString();\n}\n</code></pre>\n<pre><code class=\"text\">1158 / 1158 test cases passed.\nStatus: Accepted\nRuntime: 51 ms\n</code></pre>\n<p><strong>2. 优化方法，进一步规律：</strong></p>\n<p>更加友好和规律化的方法就是直接按照一定规律去读取字符串某一位置的字符，然后组合在一起，而不是先按照Z字来排列之后再读取。这个规律就是：所有“直线列”水平读取时的重复周期都是 “2 x numRows - 2”；对于首行和末行之间的行，还会额外多读取一个位置的字符，而这一位置距离本周期起始字符的距离是 “2 x numRows - 2 - 2 x i”。代码如下所示：</p>\n<pre><code class=\"java\">public static String convertOptimize(String s, int numRows) {\n    int len = s.length();  \n    if (len == 0 || numRows &lt; 2) return s;  \n\n    String ret = &quot;&quot;;   \n    int period = 2 * numRows - 2; // “直线列”水平读取时的循环周期；\n    for (int i = 0; i &lt; numRows; i++) {  \n        for (int j = i; j &lt; len; j += period) {  \n            ret += s.charAt(j);  \n\n            // 非首行和末行时还要多读取一个字符；\n            if (i &gt; 0 &amp;&amp; i &lt; numRows - 1) {  \n                int t = j + period - 2 * i;  \n                if (t &lt; len) {  \n                    ret += s.charAt(t);  \n                }  \n            }  \n        }  \n    }  \n    return ret;  \n}\n</code></pre>\n<pre><code class=\"text\">1158 / 1158 test cases passed.\nStatus: Accepted\nRuntime: 65 ms\n</code></pre>\n"},{"title":"LeetCode 每日一题 - 70. Climbing Stairs","intro":"LeetCode 每日一题系列，今天第八题。这是一道读题不用费力、理解十分简单的题目。问题很清晰，但是解决的过程就需要一些思考了。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Dynamic Programming】","comments":1,"date":"2016-04-20T01:30:51.000Z","_content":"\nLeetCode 每日一题系列，今天第八题。这是一道读题不用费力、理解十分简单的题目。问题很清晰，但是解决的过程就需要一些思考了。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Dynamic Programming】\n\n#### 70. [Rotate Array](https://leetcode.com/problems/climbing-stairs/)：\n\n> You are climbing a stair case. It takes n steps to reach to the top.\n\n> Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n\n**0. 题目大意：**\n\n假设你正在爬一个楼梯，该楼梯有 **n** 阶，而你有两种爬法，每次爬**一阶**或者**两阶**。那么请问你有多少种爬法能够到达楼梯顶部？\n\n\n**1. 通用方法，递归：**\n\n抛出性能问题不考虑，对于基本上来说所有的“爬楼梯”问题都可以用递归来解决。递归的模式很清晰，每一次爬楼梯都会有两种选择，两种选择之后又是各有两种选择，以此类推。当剩余台阶数量为**2**时有两种选择：一次爬一阶爬两次，或者一次爬两阶爬一次；而对于剩余台阶数量为**1**时只有一种爬法：爬一阶一次。算法时间复杂度 “O(nk)”。代码如下所示：\n\n```java\npublic static int climbStairs(int n) {\n    if (n == 1) {  // 只剩一阶时只有一种走法；\n    \treturn 1;\n    }\n    \n    if (n == 2) {  // 剩两阶时有两种走法；\n    \treturn 2;\n    }\n    \n    return climbStairs(n - 1) + climbStairs(n - 2);  // 递归；\n}\n```\n\n\n**2. 优化的方法 — Fibonacci：**\n\n如果擅于发现规律，你会发现爬楼梯的方法数量随着楼梯阶数 **n** 的增长正对应着 Fibonacci 数列的第 **n+2** 项的值，Fibonacci（斐波那契）数列如下：0 1 1 2 3 5 8 13 ...，即从第三项开始，该项为前两项的和。这里使用三个变量来实现 Fibonacci 数列。算法时间复杂度 “O(n)”。代码如下所示：\n\n```java\npublic static int climbStairsOptimize(int n) {\n    int a = 0;\n    int b = 1;\n    int sum = 0;\n\t\n    for (int i = 0; i < n; i++) {\n    \tsum = a + b;\n    \ta = b;\n    \tb = sum;\n    }\n    \n    return sum;\n}\n```\n\n\n**3. 使用数组的实现：**\n\n这里使用数组来实现 Fibonacci 数列，为了节省内存，我们并没有把所有的 Fibonacci 数列全部放入数组，对应的我们只是获取需要的部分数列，这也是在使用“动态规划”算法时优化内存的技巧。\n\n```java\npublic static int climbStairsOptimizeArray(int n) {\n    int[] arr = new int[3];\n\t\n    arr[0] = 1;  \n    arr[1] = 1;  \n\n    for (int i = 2; i <= n; i++) {  \n    \tarr[i%3] = arr[(i-1)%3] + arr[(i-2)%3];  \n    }  \n\n    return arr[n%3]; \n}\n```\n","source":"_posts/LeetCode-每日一题-70-Climbing-Stairs.md","raw":"---\ntitle: LeetCode 每日一题 - 70. Climbing Stairs\nintro: LeetCode 每日一题系列，今天第八题。这是一道读题不用费力、理解十分简单的题目。问题很清晰，但是解决的过程就需要一些思考了。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Dynamic Programming】\ncomments: true\ndate: 2016-04-20 09:30:51\ntags:\n- 算法\n- LeetCode\n---\n\nLeetCode 每日一题系列，今天第八题。这是一道读题不用费力、理解十分简单的题目。问题很清晰，但是解决的过程就需要一些思考了。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Dynamic Programming】\n\n#### 70. [Rotate Array](https://leetcode.com/problems/climbing-stairs/)：\n\n> You are climbing a stair case. It takes n steps to reach to the top.\n\n> Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n\n**0. 题目大意：**\n\n假设你正在爬一个楼梯，该楼梯有 **n** 阶，而你有两种爬法，每次爬**一阶**或者**两阶**。那么请问你有多少种爬法能够到达楼梯顶部？\n\n\n**1. 通用方法，递归：**\n\n抛出性能问题不考虑，对于基本上来说所有的“爬楼梯”问题都可以用递归来解决。递归的模式很清晰，每一次爬楼梯都会有两种选择，两种选择之后又是各有两种选择，以此类推。当剩余台阶数量为**2**时有两种选择：一次爬一阶爬两次，或者一次爬两阶爬一次；而对于剩余台阶数量为**1**时只有一种爬法：爬一阶一次。算法时间复杂度 “O(nk)”。代码如下所示：\n\n```java\npublic static int climbStairs(int n) {\n    if (n == 1) {  // 只剩一阶时只有一种走法；\n    \treturn 1;\n    }\n    \n    if (n == 2) {  // 剩两阶时有两种走法；\n    \treturn 2;\n    }\n    \n    return climbStairs(n - 1) + climbStairs(n - 2);  // 递归；\n}\n```\n\n\n**2. 优化的方法 — Fibonacci：**\n\n如果擅于发现规律，你会发现爬楼梯的方法数量随着楼梯阶数 **n** 的增长正对应着 Fibonacci 数列的第 **n+2** 项的值，Fibonacci（斐波那契）数列如下：0 1 1 2 3 5 8 13 ...，即从第三项开始，该项为前两项的和。这里使用三个变量来实现 Fibonacci 数列。算法时间复杂度 “O(n)”。代码如下所示：\n\n```java\npublic static int climbStairsOptimize(int n) {\n    int a = 0;\n    int b = 1;\n    int sum = 0;\n\t\n    for (int i = 0; i < n; i++) {\n    \tsum = a + b;\n    \ta = b;\n    \tb = sum;\n    }\n    \n    return sum;\n}\n```\n\n\n**3. 使用数组的实现：**\n\n这里使用数组来实现 Fibonacci 数列，为了节省内存，我们并没有把所有的 Fibonacci 数列全部放入数组，对应的我们只是获取需要的部分数列，这也是在使用“动态规划”算法时优化内存的技巧。\n\n```java\npublic static int climbStairsOptimizeArray(int n) {\n    int[] arr = new int[3];\n\t\n    arr[0] = 1;  \n    arr[1] = 1;  \n\n    for (int i = 2; i <= n; i++) {  \n    \tarr[i%3] = arr[(i-1)%3] + arr[(i-2)%3];  \n    }  \n\n    return arr[n%3]; \n}\n```\n","slug":"LeetCode-每日一题-70-Climbing-Stairs","published":1,"updated":"2019-02-10T02:49:58.563Z","layout":"post","photos":[],"link":"","_id":"cjsqwht9l002qknp2pucyrqr1","content":"<p>LeetCode 每日一题系列，今天第八题。这是一道读题不用费力、理解十分简单的题目。问题很清晰，但是解决的过程就需要一些思考了。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Dynamic Programming】</p>\n<h4 id=\"70-Rotate-Array：\"><a href=\"#70-Rotate-Array：\" class=\"headerlink\" title=\"70. Rotate Array：\"></a>70. <a href=\"https://leetcode.com/problems/climbing-stairs/\" target=\"_blank\" rel=\"noopener\">Rotate Array</a>：</h4><blockquote>\n<p>You are climbing a stair case. It takes n steps to reach to the top.</p>\n</blockquote>\n<blockquote>\n<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>\n</blockquote>\n<p><strong>0. 题目大意：</strong></p>\n<p>假设你正在爬一个楼梯，该楼梯有 <strong>n</strong> 阶，而你有两种爬法，每次爬<strong>一阶</strong>或者<strong>两阶</strong>。那么请问你有多少种爬法能够到达楼梯顶部？</p>\n<p><strong>1. 通用方法，递归：</strong></p>\n<p>抛出性能问题不考虑，对于基本上来说所有的“爬楼梯”问题都可以用递归来解决。递归的模式很清晰，每一次爬楼梯都会有两种选择，两种选择之后又是各有两种选择，以此类推。当剩余台阶数量为<strong>2</strong>时有两种选择：一次爬一阶爬两次，或者一次爬两阶爬一次；而对于剩余台阶数量为<strong>1</strong>时只有一种爬法：爬一阶一次。算法时间复杂度 “O(nk)”。代码如下所示：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">climbStairs</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  <span class=\"token comment\" spellcheck=\"true\">// 只剩一阶时只有一种走法；</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">==</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  <span class=\"token comment\" spellcheck=\"true\">// 剩两阶时有两种走法；</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token function\">climbStairs</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">climbStairs</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 递归；</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>2. 优化的方法 — Fibonacci：</strong></p>\n<p>如果擅于发现规律，你会发现爬楼梯的方法数量随着楼梯阶数 <strong>n</strong> 的增长正对应着 Fibonacci 数列的第 <strong>n+2</strong> 项的值，Fibonacci（斐波那契）数列如下：0 1 1 2 3 5 8 13 …，即从第三项开始，该项为前两项的和。这里使用三个变量来实现 Fibonacci 数列。算法时间复杂度 “O(n)”。代码如下所示：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">climbStairsOptimize</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> b <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> sum <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        sum <span class=\"token operator\">=</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span>\n        a <span class=\"token operator\">=</span> b<span class=\"token punctuation\">;</span>\n        b <span class=\"token operator\">=</span> sum<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> sum<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>3. 使用数组的实现：</strong></p>\n<p>这里使用数组来实现 Fibonacci 数列，为了节省内存，我们并没有把所有的 Fibonacci 数列全部放入数组，对应的我们只是获取需要的部分数列，这也是在使用“动态规划”算法时优化内存的技巧。</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">climbStairsOptimizeArray</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arr <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">int</span><span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    arr<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>  \n    arr<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>  \n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n        arr<span class=\"token punctuation\">[</span>i<span class=\"token operator\">%</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">%</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> arr<span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token operator\">%</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  \n    <span class=\"token punctuation\">}</span>  \n\n    <span class=\"token keyword\">return</span> arr<span class=\"token punctuation\">[</span>n<span class=\"token operator\">%</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"id":"414d66d053eaa9bfe75f34f6e777922f","excerpt":"","more":"<p>LeetCode 每日一题系列，今天第八题。这是一道读题不用费力、理解十分简单的题目。问题很清晰，但是解决的过程就需要一些思考了。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Dynamic Programming】</p>\n<h4 id=\"70-Rotate-Array：\"><a href=\"#70-Rotate-Array：\" class=\"headerlink\" title=\"70. Rotate Array：\"></a>70. <a href=\"https://leetcode.com/problems/climbing-stairs/\" target=\"_blank\" rel=\"noopener\">Rotate Array</a>：</h4><blockquote>\n<p>You are climbing a stair case. It takes n steps to reach to the top.</p>\n</blockquote>\n<blockquote>\n<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>\n</blockquote>\n<p><strong>0. 题目大意：</strong></p>\n<p>假设你正在爬一个楼梯，该楼梯有 <strong>n</strong> 阶，而你有两种爬法，每次爬<strong>一阶</strong>或者<strong>两阶</strong>。那么请问你有多少种爬法能够到达楼梯顶部？</p>\n<p><strong>1. 通用方法，递归：</strong></p>\n<p>抛出性能问题不考虑，对于基本上来说所有的“爬楼梯”问题都可以用递归来解决。递归的模式很清晰，每一次爬楼梯都会有两种选择，两种选择之后又是各有两种选择，以此类推。当剩余台阶数量为<strong>2</strong>时有两种选择：一次爬一阶爬两次，或者一次爬两阶爬一次；而对于剩余台阶数量为<strong>1</strong>时只有一种爬法：爬一阶一次。算法时间复杂度 “O(nk)”。代码如下所示：</p>\n<pre><code class=\"java\">public static int climbStairs(int n) {\n    if (n == 1) {  // 只剩一阶时只有一种走法；\n        return 1;\n    }\n\n    if (n == 2) {  // 剩两阶时有两种走法；\n        return 2;\n    }\n\n    return climbStairs(n - 1) + climbStairs(n - 2);  // 递归；\n}\n</code></pre>\n<p><strong>2. 优化的方法 — Fibonacci：</strong></p>\n<p>如果擅于发现规律，你会发现爬楼梯的方法数量随着楼梯阶数 <strong>n</strong> 的增长正对应着 Fibonacci 数列的第 <strong>n+2</strong> 项的值，Fibonacci（斐波那契）数列如下：0 1 1 2 3 5 8 13 …，即从第三项开始，该项为前两项的和。这里使用三个变量来实现 Fibonacci 数列。算法时间复杂度 “O(n)”。代码如下所示：</p>\n<pre><code class=\"java\">public static int climbStairsOptimize(int n) {\n    int a = 0;\n    int b = 1;\n    int sum = 0;\n\n    for (int i = 0; i &lt; n; i++) {\n        sum = a + b;\n        a = b;\n        b = sum;\n    }\n\n    return sum;\n}\n</code></pre>\n<p><strong>3. 使用数组的实现：</strong></p>\n<p>这里使用数组来实现 Fibonacci 数列，为了节省内存，我们并没有把所有的 Fibonacci 数列全部放入数组，对应的我们只是获取需要的部分数列，这也是在使用“动态规划”算法时优化内存的技巧。</p>\n<pre><code class=\"java\">public static int climbStairsOptimizeArray(int n) {\n    int[] arr = new int[3];\n\n    arr[0] = 1;  \n    arr[1] = 1;  \n\n    for (int i = 2; i &lt;= n; i++) {  \n        arr[i%3] = arr[(i-1)%3] + arr[(i-2)%3];  \n    }  \n\n    return arr[n%3]; \n}\n</code></pre>\n"},{"title":"LeetCode 每日一题 - 7. Reverse Integer","intro":"LeetCode 每日一题系列，今天第十四题。今天这道题既可以看成是一道字符串的题目，也可以看成是一道数学相关的题目。两种解题方法对应着两种不同的思路，要学会从不同的角度去思考问题。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Math】","comments":1,"date":"2016-05-10T10:22:08.000Z","_content":"\nLeetCode 每日一题系列，今天第十四题。今天这道题既可以看成是一道字符串的题目，也可以看成是一道数学相关的题目。两种解题方法对应着两种不同的思路，要学会从不同的角度去思考问题。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Math】\n\n#### 7. [Reverse Integer](https://leetcode.com/problems/reverse-integer/)：\n\n> Reverse digits of an integer.\n\n> For the purpose of this problem, assume that your function **returns 0** when the reversed integer **overflows**.\n\n**Example：**\n\n```text\nExample1: x = 123, return 321\n\nExample2: x = -123, return -321\n```\n\n**0. 题目大意：**\n\n给定一个数字，求将该数所有位上的数倒序排列后新生成的数，新数和原数的正负性保持不变。\n\n**注意**：如果新数的大小不在 Int 类型的范围内（过大或过小）则返回数字0。\n\n**1. 第一种方法，当做字符串：**\n\n思路很简单，首先将给定的数字转换成字符串，然后再将该字符串分割转换成字符数组。此时使用我们常用的“双指针”法将数组内的所有元素倒序排列，再转换成整数类型即可。不要忘记检测转换之后的整数是否有溢出的问题，这里直接使用 `try...catch` 语句来检查是否有 **NumberFormatException** 异常出现。代码如下所示：\n\n```java\npublic static int reverse(int x) {\n    // 保存原数字的正负符号；\n    int flag = (x > 0) ? 1 : -1;\n    int result = 0;\n\n    // 取绝对值；\n    x = Math.abs(x);\n\n    // 开始拆分；\n    String temp = String.valueOf(x);\n    char [] tempChar = temp.toCharArray();\n    \n    // 用双指针方法“倒序”排列原数字；\n    for (int i = 0; i < tempChar.length; i++) {\n    \tint j = tempChar.length - i - 1;\n    \t\n    \tif(i >= j)\n    \t\tbreak;\n    \t\n    \tchar tempInt = tempChar[i];\n    \ttempChar[i] = tempChar[j];\n    \ttempChar[j] = tempInt;\n    }\n    \n    try {\n    \tresult = Integer.parseInt(String.valueOf(tempChar)) * flag;\n    } catch (NumberFormatException e) {  // 如果遇到溢出，则返回0；\n    \treturn 0;\n    }\n    \n    return result;\n}\n```\n\n```text\n1032 / 1032 test cases passed.\nStatus: Accepted\nRuntime: 6 ms\n```\n\n**2. 第二种方法，当做数字：**\n\n第二种方法的思路同样也十分简单，既然传进来的是一个数字那么我们就直接把它当做数字来处理。将数字**循环除10**来获得各个分位上的数字，最后再将各个分位的数字乘以对应的10的幂次（注意低分位应该乘以高分位对应阶数的10的幂）重新相加即可。代码如下所示：\n\n```java\npublic static int reverseOptimize(int x) {\n    // 保留正负性；\n    int flag = (x > 0) ? 1 : -1;\n\n    // 取绝对值；\n    x = Math.abs(x);\n    String temp = String.valueOf(x);\n\n    // 获得数字位数；\n    char [] tempChar = temp.toCharArray();\n    int bitLen = tempChar.length;\n    int i = 1;\n    long container = 0;\n\n    // 循环次数为位数；\n    while (i <= bitLen) {\n        int bit = x % 10;  // 取出该位；\n        container = (long)(container + bit * Math.pow(10, bitLen - i++)); // 用一个 Long 型变量来存储最后的值（防止溢出）；\n            \n        // 溢出则返回0；\n        if (container > Integer.MAX_VALUE || container < Integer.MIN_VALUE)\n            return 0;\n\n        x = x / 10;\n    }\n    \n    return (int) container * flag;\n}\n```\n\n```text\n1032 / 1032 test cases passed.\nStatus: Accepted\nRuntime: 4 ms\n```","source":"_posts/LeetCode-每日一题-7-Reverse-Integer.md","raw":"---\ntitle: LeetCode 每日一题 - 7. Reverse Integer\nintro: LeetCode 每日一题系列，今天第十四题。今天这道题既可以看成是一道字符串的题目，也可以看成是一道数学相关的题目。两种解题方法对应着两种不同的思路，要学会从不同的角度去思考问题。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Math】\ncomments: true\ndate: 2016-05-10 18:22:08\ntags:\n- 算法\n- LeetCode\n---\n\nLeetCode 每日一题系列，今天第十四题。今天这道题既可以看成是一道字符串的题目，也可以看成是一道数学相关的题目。两种解题方法对应着两种不同的思路，要学会从不同的角度去思考问题。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Math】\n\n#### 7. [Reverse Integer](https://leetcode.com/problems/reverse-integer/)：\n\n> Reverse digits of an integer.\n\n> For the purpose of this problem, assume that your function **returns 0** when the reversed integer **overflows**.\n\n**Example：**\n\n```text\nExample1: x = 123, return 321\n\nExample2: x = -123, return -321\n```\n\n**0. 题目大意：**\n\n给定一个数字，求将该数所有位上的数倒序排列后新生成的数，新数和原数的正负性保持不变。\n\n**注意**：如果新数的大小不在 Int 类型的范围内（过大或过小）则返回数字0。\n\n**1. 第一种方法，当做字符串：**\n\n思路很简单，首先将给定的数字转换成字符串，然后再将该字符串分割转换成字符数组。此时使用我们常用的“双指针”法将数组内的所有元素倒序排列，再转换成整数类型即可。不要忘记检测转换之后的整数是否有溢出的问题，这里直接使用 `try...catch` 语句来检查是否有 **NumberFormatException** 异常出现。代码如下所示：\n\n```java\npublic static int reverse(int x) {\n    // 保存原数字的正负符号；\n    int flag = (x > 0) ? 1 : -1;\n    int result = 0;\n\n    // 取绝对值；\n    x = Math.abs(x);\n\n    // 开始拆分；\n    String temp = String.valueOf(x);\n    char [] tempChar = temp.toCharArray();\n    \n    // 用双指针方法“倒序”排列原数字；\n    for (int i = 0; i < tempChar.length; i++) {\n    \tint j = tempChar.length - i - 1;\n    \t\n    \tif(i >= j)\n    \t\tbreak;\n    \t\n    \tchar tempInt = tempChar[i];\n    \ttempChar[i] = tempChar[j];\n    \ttempChar[j] = tempInt;\n    }\n    \n    try {\n    \tresult = Integer.parseInt(String.valueOf(tempChar)) * flag;\n    } catch (NumberFormatException e) {  // 如果遇到溢出，则返回0；\n    \treturn 0;\n    }\n    \n    return result;\n}\n```\n\n```text\n1032 / 1032 test cases passed.\nStatus: Accepted\nRuntime: 6 ms\n```\n\n**2. 第二种方法，当做数字：**\n\n第二种方法的思路同样也十分简单，既然传进来的是一个数字那么我们就直接把它当做数字来处理。将数字**循环除10**来获得各个分位上的数字，最后再将各个分位的数字乘以对应的10的幂次（注意低分位应该乘以高分位对应阶数的10的幂）重新相加即可。代码如下所示：\n\n```java\npublic static int reverseOptimize(int x) {\n    // 保留正负性；\n    int flag = (x > 0) ? 1 : -1;\n\n    // 取绝对值；\n    x = Math.abs(x);\n    String temp = String.valueOf(x);\n\n    // 获得数字位数；\n    char [] tempChar = temp.toCharArray();\n    int bitLen = tempChar.length;\n    int i = 1;\n    long container = 0;\n\n    // 循环次数为位数；\n    while (i <= bitLen) {\n        int bit = x % 10;  // 取出该位；\n        container = (long)(container + bit * Math.pow(10, bitLen - i++)); // 用一个 Long 型变量来存储最后的值（防止溢出）；\n            \n        // 溢出则返回0；\n        if (container > Integer.MAX_VALUE || container < Integer.MIN_VALUE)\n            return 0;\n\n        x = x / 10;\n    }\n    \n    return (int) container * flag;\n}\n```\n\n```text\n1032 / 1032 test cases passed.\nStatus: Accepted\nRuntime: 4 ms\n```","slug":"LeetCode-每日一题-7-Reverse-Integer","published":1,"updated":"2019-02-10T02:49:47.267Z","layout":"post","photos":[],"link":"","_id":"cjsqwht9m002tknp2r8w6ichf","content":"<p>LeetCode 每日一题系列，今天第十四题。今天这道题既可以看成是一道字符串的题目，也可以看成是一道数学相关的题目。两种解题方法对应着两种不同的思路，要学会从不同的角度去思考问题。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Math】</p>\n<h4 id=\"7-Reverse-Integer：\"><a href=\"#7-Reverse-Integer：\" class=\"headerlink\" title=\"7. Reverse Integer：\"></a>7. <a href=\"https://leetcode.com/problems/reverse-integer/\" target=\"_blank\" rel=\"noopener\">Reverse Integer</a>：</h4><blockquote>\n<p>Reverse digits of an integer.</p>\n</blockquote>\n<blockquote>\n<p>For the purpose of this problem, assume that your function <strong>returns 0</strong> when the reversed integer <strong>overflows</strong>.</p>\n</blockquote>\n<p><strong>Example：</strong></p>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">Example1: x = 123, return 321\n\nExample2: x = -123, return -321\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p><strong>0. 题目大意：</strong></p>\n<p>给定一个数字，求将该数所有位上的数倒序排列后新生成的数，新数和原数的正负性保持不变。</p>\n<p><strong>注意</strong>：如果新数的大小不在 Int 类型的范围内（过大或过小）则返回数字0。</p>\n<p><strong>1. 第一种方法，当做字符串：</strong></p>\n<p>思路很简单，首先将给定的数字转换成字符串，然后再将该字符串分割转换成字符数组。此时使用我们常用的“双指针”法将数组内的所有元素倒序排列，再转换成整数类型即可。不要忘记检测转换之后的整数是否有溢出的问题，这里直接使用 <code>try...catch</code> 语句来检查是否有 <strong>NumberFormatException</strong> 异常出现。代码如下所示：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">reverse</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 保存原数字的正负符号；</span>\n    <span class=\"token keyword\">int</span> flag <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>x <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token number\">1</span> <span class=\"token operator\">:</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> result <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 取绝对值；</span>\n    x <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">abs</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 开始拆分；</span>\n    String temp <span class=\"token operator\">=</span> String<span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">char</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> tempChar <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">.</span><span class=\"token function\">toCharArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 用双指针方法“倒序”排列原数字；</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> tempChar<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> tempChar<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">>=</span> j<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">char</span> tempInt <span class=\"token operator\">=</span> tempChar<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        tempChar<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> tempChar<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        tempChar<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> tempInt<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        result <span class=\"token operator\">=</span> Integer<span class=\"token punctuation\">.</span><span class=\"token function\">parseInt</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>tempChar<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> flag<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">NumberFormatException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  <span class=\"token comment\" spellcheck=\"true\">// 如果遇到溢出，则返回0；</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">1032 / 1032 test cases passed.\nStatus: Accepted\nRuntime: 6 ms\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p><strong>2. 第二种方法，当做数字：</strong></p>\n<p>第二种方法的思路同样也十分简单，既然传进来的是一个数字那么我们就直接把它当做数字来处理。将数字<strong>循环除10</strong>来获得各个分位上的数字，最后再将各个分位的数字乘以对应的10的幂次（注意低分位应该乘以高分位对应阶数的10的幂）重新相加即可。代码如下所示：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">reverseOptimize</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 保留正负性；</span>\n    <span class=\"token keyword\">int</span> flag <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>x <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token number\">1</span> <span class=\"token operator\">:</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 取绝对值；</span>\n    x <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">abs</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    String temp <span class=\"token operator\">=</span> String<span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 获得数字位数；</span>\n    <span class=\"token keyword\">char</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> tempChar <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">.</span><span class=\"token function\">toCharArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> bitLen <span class=\"token operator\">=</span> tempChar<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">long</span> container <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 循环次数为位数；</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;=</span> bitLen<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> bit <span class=\"token operator\">=</span> x <span class=\"token operator\">%</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 取出该位；</span>\n        container <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>container <span class=\"token operator\">+</span> bit <span class=\"token operator\">*</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">pow</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> bitLen <span class=\"token operator\">-</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 用一个 Long 型变量来存储最后的值（防止溢出）；</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 溢出则返回0；</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>container <span class=\"token operator\">></span> Integer<span class=\"token punctuation\">.</span>MAX_VALUE <span class=\"token operator\">||</span> container <span class=\"token operator\">&lt;</span> Integer<span class=\"token punctuation\">.</span>MIN_VALUE<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n        x <span class=\"token operator\">=</span> x <span class=\"token operator\">/</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span> container <span class=\"token operator\">*</span> flag<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">1032 / 1032 test cases passed.\nStatus: Accepted\nRuntime: 4 ms\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"id":"e3eb848263a4df8c48c892e8b13e2bb2","excerpt":"","more":"<p>LeetCode 每日一题系列，今天第十四题。今天这道题既可以看成是一道字符串的题目，也可以看成是一道数学相关的题目。两种解题方法对应着两种不同的思路，要学会从不同的角度去思考问题。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Math】</p>\n<h4 id=\"7-Reverse-Integer：\"><a href=\"#7-Reverse-Integer：\" class=\"headerlink\" title=\"7. Reverse Integer：\"></a>7. <a href=\"https://leetcode.com/problems/reverse-integer/\" target=\"_blank\" rel=\"noopener\">Reverse Integer</a>：</h4><blockquote>\n<p>Reverse digits of an integer.</p>\n</blockquote>\n<blockquote>\n<p>For the purpose of this problem, assume that your function <strong>returns 0</strong> when the reversed integer <strong>overflows</strong>.</p>\n</blockquote>\n<p><strong>Example：</strong></p>\n<pre><code class=\"text\">Example1: x = 123, return 321\n\nExample2: x = -123, return -321\n</code></pre>\n<p><strong>0. 题目大意：</strong></p>\n<p>给定一个数字，求将该数所有位上的数倒序排列后新生成的数，新数和原数的正负性保持不变。</p>\n<p><strong>注意</strong>：如果新数的大小不在 Int 类型的范围内（过大或过小）则返回数字0。</p>\n<p><strong>1. 第一种方法，当做字符串：</strong></p>\n<p>思路很简单，首先将给定的数字转换成字符串，然后再将该字符串分割转换成字符数组。此时使用我们常用的“双指针”法将数组内的所有元素倒序排列，再转换成整数类型即可。不要忘记检测转换之后的整数是否有溢出的问题，这里直接使用 <code>try...catch</code> 语句来检查是否有 <strong>NumberFormatException</strong> 异常出现。代码如下所示：</p>\n<pre><code class=\"java\">public static int reverse(int x) {\n    // 保存原数字的正负符号；\n    int flag = (x &gt; 0) ? 1 : -1;\n    int result = 0;\n\n    // 取绝对值；\n    x = Math.abs(x);\n\n    // 开始拆分；\n    String temp = String.valueOf(x);\n    char [] tempChar = temp.toCharArray();\n\n    // 用双指针方法“倒序”排列原数字；\n    for (int i = 0; i &lt; tempChar.length; i++) {\n        int j = tempChar.length - i - 1;\n\n        if(i &gt;= j)\n            break;\n\n        char tempInt = tempChar[i];\n        tempChar[i] = tempChar[j];\n        tempChar[j] = tempInt;\n    }\n\n    try {\n        result = Integer.parseInt(String.valueOf(tempChar)) * flag;\n    } catch (NumberFormatException e) {  // 如果遇到溢出，则返回0；\n        return 0;\n    }\n\n    return result;\n}\n</code></pre>\n<pre><code class=\"text\">1032 / 1032 test cases passed.\nStatus: Accepted\nRuntime: 6 ms\n</code></pre>\n<p><strong>2. 第二种方法，当做数字：</strong></p>\n<p>第二种方法的思路同样也十分简单，既然传进来的是一个数字那么我们就直接把它当做数字来处理。将数字<strong>循环除10</strong>来获得各个分位上的数字，最后再将各个分位的数字乘以对应的10的幂次（注意低分位应该乘以高分位对应阶数的10的幂）重新相加即可。代码如下所示：</p>\n<pre><code class=\"java\">public static int reverseOptimize(int x) {\n    // 保留正负性；\n    int flag = (x &gt; 0) ? 1 : -1;\n\n    // 取绝对值；\n    x = Math.abs(x);\n    String temp = String.valueOf(x);\n\n    // 获得数字位数；\n    char [] tempChar = temp.toCharArray();\n    int bitLen = tempChar.length;\n    int i = 1;\n    long container = 0;\n\n    // 循环次数为位数；\n    while (i &lt;= bitLen) {\n        int bit = x % 10;  // 取出该位；\n        container = (long)(container + bit * Math.pow(10, bitLen - i++)); // 用一个 Long 型变量来存储最后的值（防止溢出）；\n\n        // 溢出则返回0；\n        if (container &gt; Integer.MAX_VALUE || container &lt; Integer.MIN_VALUE)\n            return 0;\n\n        x = x / 10;\n    }\n\n    return (int) container * flag;\n}\n</code></pre>\n<pre><code class=\"text\">1032 / 1032 test cases passed.\nStatus: Accepted\nRuntime: 4 ms\n</code></pre>\n"},{"title":"Prism.js 在 AJAX 下的应用问题","intro":"Prism.js 是一款用于 Web 端的代码及语法高亮显示插件。整个 Prism 库的应用方法很简单，只需要在页面中加入 “Prism.js” 和 “Prism.css” 两个文件，并将要高亮显示的代码文本放置在特定的标签内即可。但是当 Prism.js 遇到了通过 AJAX 异步加载的内容，问题便出现了。","comments":1,"date":"2015-01-12T10:24:24.000Z","_content":"\nPrism.js 是一款用于 Web 端的代码及语法高亮显示插件。整个 Prism 库的应用方法很简单，只需要在页面中加入 “Prism.js” 和 “Prism.css” 两个文件，并将要高亮显示的代码文本放置在特定的标签内即可。但是当 Prism.js 遇到了通过 AJAX 异步加载的内容，问题便出现了。\n\n整个 Prism.js 库的运行机制都是在 Prism.js 的代码控制下进行的，因为 Prism.js 的代码高亮标签是非 W3C 认证的特殊名称标签，因此浏览器无法自动按照 Prism.css 里的样式来渲染代码段，所以每一次 Prism.js 的渲染过程都是在页面载入的时候进行的，即在 DOM 树加载完毕后运行 Prism.js 中的代码并根据 Prism.css 里的样式和高亮标签的属性控制进行渲染。\n\n而在使用 AJAX 加载内容时，页面只是进行局部刷新，不会重新运行页面首尾部分的 JavaScript 代码，所以如果 AJAX 返回的结果中包含有用高亮标签标记的代码时，渲染会失去效果。\n\n解决方案如下，仅供参考：\n\n```javascript\nif(typeof Rainbow != \"undefined\") {\n  Rainbow.color();\n}\n```","source":"_posts/Prism-js-在-AJAX-下的应用问题.md","raw":"---\ntitle: Prism.js 在 AJAX 下的应用问题\nintro: Prism.js 是一款用于 Web 端的代码及语法高亮显示插件。整个 Prism 库的应用方法很简单，只需要在页面中加入 “Prism.js” 和 “Prism.css” 两个文件，并将要高亮显示的代码文本放置在特定的标签内即可。但是当 Prism.js 遇到了通过 AJAX 异步加载的内容，问题便出现了。\ncomments: true\ndate: 2015-01-12 18:24:24\ntags:\n- Web\n---\n\nPrism.js 是一款用于 Web 端的代码及语法高亮显示插件。整个 Prism 库的应用方法很简单，只需要在页面中加入 “Prism.js” 和 “Prism.css” 两个文件，并将要高亮显示的代码文本放置在特定的标签内即可。但是当 Prism.js 遇到了通过 AJAX 异步加载的内容，问题便出现了。\n\n整个 Prism.js 库的运行机制都是在 Prism.js 的代码控制下进行的，因为 Prism.js 的代码高亮标签是非 W3C 认证的特殊名称标签，因此浏览器无法自动按照 Prism.css 里的样式来渲染代码段，所以每一次 Prism.js 的渲染过程都是在页面载入的时候进行的，即在 DOM 树加载完毕后运行 Prism.js 中的代码并根据 Prism.css 里的样式和高亮标签的属性控制进行渲染。\n\n而在使用 AJAX 加载内容时，页面只是进行局部刷新，不会重新运行页面首尾部分的 JavaScript 代码，所以如果 AJAX 返回的结果中包含有用高亮标签标记的代码时，渲染会失去效果。\n\n解决方案如下，仅供参考：\n\n```javascript\nif(typeof Rainbow != \"undefined\") {\n  Rainbow.color();\n}\n```","slug":"Prism-js-在-AJAX-下的应用问题","published":1,"updated":"2019-02-04T09:37:29.590Z","layout":"post","photos":[],"link":"","_id":"cjsqwht9m002uknp2i5dav7wo","content":"<p>Prism.js 是一款用于 Web 端的代码及语法高亮显示插件。整个 Prism 库的应用方法很简单，只需要在页面中加入 “Prism.js” 和 “Prism.css” 两个文件，并将要高亮显示的代码文本放置在特定的标签内即可。但是当 Prism.js 遇到了通过 AJAX 异步加载的内容，问题便出现了。</p>\n<p>整个 Prism.js 库的运行机制都是在 Prism.js 的代码控制下进行的，因为 Prism.js 的代码高亮标签是非 W3C 认证的特殊名称标签，因此浏览器无法自动按照 Prism.css 里的样式来渲染代码段，所以每一次 Prism.js 的渲染过程都是在页面载入的时候进行的，即在 DOM 树加载完毕后运行 Prism.js 中的代码并根据 Prism.css 里的样式和高亮标签的属性控制进行渲染。</p>\n<p>而在使用 AJAX 加载内容时，页面只是进行局部刷新，不会重新运行页面首尾部分的 JavaScript 代码，所以如果 AJAX 返回的结果中包含有用高亮标签标记的代码时，渲染会失去效果。</p>\n<p>解决方案如下，仅供参考：</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> Rainbow <span class=\"token operator\">!=</span> <span class=\"token string\">\"undefined\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  Rainbow<span class=\"token punctuation\">.</span><span class=\"token function\">color</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"id":"2268857b8eb14404efbf6d7013ca003e","excerpt":"","more":"<p>Prism.js 是一款用于 Web 端的代码及语法高亮显示插件。整个 Prism 库的应用方法很简单，只需要在页面中加入 “Prism.js” 和 “Prism.css” 两个文件，并将要高亮显示的代码文本放置在特定的标签内即可。但是当 Prism.js 遇到了通过 AJAX 异步加载的内容，问题便出现了。</p>\n<p>整个 Prism.js 库的运行机制都是在 Prism.js 的代码控制下进行的，因为 Prism.js 的代码高亮标签是非 W3C 认证的特殊名称标签，因此浏览器无法自动按照 Prism.css 里的样式来渲染代码段，所以每一次 Prism.js 的渲染过程都是在页面载入的时候进行的，即在 DOM 树加载完毕后运行 Prism.js 中的代码并根据 Prism.css 里的样式和高亮标签的属性控制进行渲染。</p>\n<p>而在使用 AJAX 加载内容时，页面只是进行局部刷新，不会重新运行页面首尾部分的 JavaScript 代码，所以如果 AJAX 返回的结果中包含有用高亮标签标记的代码时，渲染会失去效果。</p>\n<p>解决方案如下，仅供参考：</p>\n<pre><code class=\"javascript\">if(typeof Rainbow != &quot;undefined&quot;) {\n  Rainbow.color();\n}\n</code></pre>\n"},{"title":"LeetCode 每日一题 - 9. Palindrome Number","intro":"LeetCode 每日一题系列，今天第十五题。“回文”的意思是指将给定的一段文字左右颠倒后原意保持不变的一段文字，但今天的主角不是一段文字，而是一段数字。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Math】","comments":1,"date":"2016-05-12T06:21:03.000Z","_content":"\nLeetCode 每日一题系列，今天第十五题。“回文”的意思是指将给定的一段文字左右颠倒后原意保持不变的一段文字，但今天的主角不是一段文字，而是一段数字。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Math】\n\n#### 9. [Palindrome Number](https://leetcode.com/problems/palindrome-number/)：\n\n> Determine whether an integer is a palindrome. Do this without extra space.\n\n**Example：**\n\n```text\nExample1: x = 123321, return true\n\nExample2: x = 123123, return false\n```\n\n**0. 题目大意：**\n\n给定一个数字，判断该数字是不是回文（这里指将给定的数字左右颠倒重新排列后值与原值保持不变，可以理解为从左往右读与从右往左读保持一致）。\n\n**1. 基础解法：**\n\n如果“LeetCode 每日一题系列”之前的题目你都认真做过了，那么这道题简直是信手拈来，五分钟搞定。将给定的数字转换成字符串，并拆分成字符数组，接着利用“双指针”法依次判断第一个与最后一个，第二个与倒数第二个（以此类推）的元素是否相等，如果有一个不相等则返回 `false`；如果直到最后都保持相等则返回 `true`。循环的退出条件与之前我们用的时候保持一致。代码如下所示：\n\n```java\npublic static boolean isPalindrome(int x) {\n    String s = String.valueOf(x);\n    char[] cArr = s.toCharArray();\n    \n    for (int i = 0; i < cArr.length; i ++) {\n    \tint j = cArr.length - i - 1;\n    \tif (cArr[i] != cArr[j])\n    \t    return false;\t\n    \tif (i > j)\n    \t    break;\n    }\n    return true;\n}\n```\n\n```text\n11506 / 11506 test cases passed.\nStatus: Accepted\nRuntime: 16 ms\n```\n","source":"_posts/LeetCode-每日一题-9-Palindrome-Number.md","raw":"---\ntitle: LeetCode 每日一题 - 9. Palindrome Number\nintro: LeetCode 每日一题系列，今天第十五题。“回文”的意思是指将给定的一段文字左右颠倒后原意保持不变的一段文字，但今天的主角不是一段文字，而是一段数字。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Math】\ncomments: true\ndate: 2016-05-12 14:21:03\ntags:\n- 算法\n- LeetCode\n---\n\nLeetCode 每日一题系列，今天第十五题。“回文”的意思是指将给定的一段文字左右颠倒后原意保持不变的一段文字，但今天的主角不是一段文字，而是一段数字。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Math】\n\n#### 9. [Palindrome Number](https://leetcode.com/problems/palindrome-number/)：\n\n> Determine whether an integer is a palindrome. Do this without extra space.\n\n**Example：**\n\n```text\nExample1: x = 123321, return true\n\nExample2: x = 123123, return false\n```\n\n**0. 题目大意：**\n\n给定一个数字，判断该数字是不是回文（这里指将给定的数字左右颠倒重新排列后值与原值保持不变，可以理解为从左往右读与从右往左读保持一致）。\n\n**1. 基础解法：**\n\n如果“LeetCode 每日一题系列”之前的题目你都认真做过了，那么这道题简直是信手拈来，五分钟搞定。将给定的数字转换成字符串，并拆分成字符数组，接着利用“双指针”法依次判断第一个与最后一个，第二个与倒数第二个（以此类推）的元素是否相等，如果有一个不相等则返回 `false`；如果直到最后都保持相等则返回 `true`。循环的退出条件与之前我们用的时候保持一致。代码如下所示：\n\n```java\npublic static boolean isPalindrome(int x) {\n    String s = String.valueOf(x);\n    char[] cArr = s.toCharArray();\n    \n    for (int i = 0; i < cArr.length; i ++) {\n    \tint j = cArr.length - i - 1;\n    \tif (cArr[i] != cArr[j])\n    \t    return false;\t\n    \tif (i > j)\n    \t    break;\n    }\n    return true;\n}\n```\n\n```text\n11506 / 11506 test cases passed.\nStatus: Accepted\nRuntime: 16 ms\n```\n","slug":"LeetCode-每日一题-9-Palindrome-Number","published":1,"updated":"2019-02-10T02:49:50.010Z","layout":"post","photos":[],"link":"","_id":"cjsqwht9n002wknp2hinnkz7t","content":"<p>LeetCode 每日一题系列，今天第十五题。“回文”的意思是指将给定的一段文字左右颠倒后原意保持不变的一段文字，但今天的主角不是一段文字，而是一段数字。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Math】</p>\n<h4 id=\"9-Palindrome-Number：\"><a href=\"#9-Palindrome-Number：\" class=\"headerlink\" title=\"9. Palindrome Number：\"></a>9. <a href=\"https://leetcode.com/problems/palindrome-number/\" target=\"_blank\" rel=\"noopener\">Palindrome Number</a>：</h4><blockquote>\n<p>Determine whether an integer is a palindrome. Do this without extra space.</p>\n</blockquote>\n<p><strong>Example：</strong></p>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">Example1: x = 123321, return true\n\nExample2: x = 123123, return false\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p><strong>0. 题目大意：</strong></p>\n<p>给定一个数字，判断该数字是不是回文（这里指将给定的数字左右颠倒重新排列后值与原值保持不变，可以理解为从左往右读与从右往左读保持一致）。</p>\n<p><strong>1. 基础解法：</strong></p>\n<p>如果“LeetCode 每日一题系列”之前的题目你都认真做过了，那么这道题简直是信手拈来，五分钟搞定。将给定的数字转换成字符串，并拆分成字符数组，接着利用“双指针”法依次判断第一个与最后一个，第二个与倒数第二个（以此类推）的元素是否相等，如果有一个不相等则返回 <code>false</code>；如果直到最后都保持相等则返回 <code>true</code>。循环的退出条件与之前我们用的时候保持一致。代码如下所示：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">isPalindrome</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    String s <span class=\"token operator\">=</span> String<span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">char</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> cArr <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">toCharArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> cArr<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i <span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> cArr<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>cArr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> cArr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>    \n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">></span> j<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">11506 / 11506 test cases passed.\nStatus: Accepted\nRuntime: 16 ms\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"id":"50238a1a9fd7c70500c34af597efeeea","excerpt":"","more":"<p>LeetCode 每日一题系列，今天第十五题。“回文”的意思是指将给定的一段文字左右颠倒后原意保持不变的一段文字，但今天的主角不是一段文字，而是一段数字。建议先看原题的链接自己做一下，然后再参考本文给出的分析与解答进行总结。【Math】</p>\n<h4 id=\"9-Palindrome-Number：\"><a href=\"#9-Palindrome-Number：\" class=\"headerlink\" title=\"9. Palindrome Number：\"></a>9. <a href=\"https://leetcode.com/problems/palindrome-number/\" target=\"_blank\" rel=\"noopener\">Palindrome Number</a>：</h4><blockquote>\n<p>Determine whether an integer is a palindrome. Do this without extra space.</p>\n</blockquote>\n<p><strong>Example：</strong></p>\n<pre><code class=\"text\">Example1: x = 123321, return true\n\nExample2: x = 123123, return false\n</code></pre>\n<p><strong>0. 题目大意：</strong></p>\n<p>给定一个数字，判断该数字是不是回文（这里指将给定的数字左右颠倒重新排列后值与原值保持不变，可以理解为从左往右读与从右往左读保持一致）。</p>\n<p><strong>1. 基础解法：</strong></p>\n<p>如果“LeetCode 每日一题系列”之前的题目你都认真做过了，那么这道题简直是信手拈来，五分钟搞定。将给定的数字转换成字符串，并拆分成字符数组，接着利用“双指针”法依次判断第一个与最后一个，第二个与倒数第二个（以此类推）的元素是否相等，如果有一个不相等则返回 <code>false</code>；如果直到最后都保持相等则返回 <code>true</code>。循环的退出条件与之前我们用的时候保持一致。代码如下所示：</p>\n<pre><code class=\"java\">public static boolean isPalindrome(int x) {\n    String s = String.valueOf(x);\n    char[] cArr = s.toCharArray();\n\n    for (int i = 0; i &lt; cArr.length; i ++) {\n        int j = cArr.length - i - 1;\n        if (cArr[i] != cArr[j])\n            return false;    \n        if (i &gt; j)\n            break;\n    }\n    return true;\n}\n</code></pre>\n<pre><code class=\"text\">11506 / 11506 test cases passed.\nStatus: Accepted\nRuntime: 16 ms\n</code></pre>\n"},{"title":"Mac 配置 Commom Lisp 开发环境","intro":"由于最近在工作中遇到了一些使用 Lisp 语言编写的项目，因此在这里记录一下在 Mac 上配置 Common Lisp 编译和运行环境的步骤。这里以配置 Open-VRP 项目为主要目标。Open-VRP 是一个使用 Lisp 编写的基于启发式 Tabu Search 算法用于解决类 VRPTW 问题的工具库。","comments":1,"date":"2017-06-29T05:32:42.000Z","_content":"\n由于最近在工作中遇到了一些使用 Lisp 语言编写的项目，因此在这里记录一下在 Mac 上配置 Common Lisp 编译和运行环境的步骤。这里以配置 Open-VRP 项目为主要目标。Open-VRP 是一个使用 Lisp 编写的基于启发式 Tabu Search 算法用于解决类 VRPTW 问题的工具库。\n\n#### 1、安装 SBCL：\n\nSteel Bank Common Lisp（SBCL）是一个高性能的 Common Lisp 编译器。除了 ANSI Common Lisp 的编译器和运行时系统之外，它还提供了一个交互式环境，包括调试器，统计分析器，代码覆盖工具以及许多其他扩展。它将 Lisp 直接编译为机器语言，并可生成接近或有时比类似 C 或 Java 代码速度更快的机器语言。\n\n在 Mac 上，我们可以直接通过 `brew` 来安装 SBCL 的环境。\n\n \n```bash\nbrew install sbcl\n```\n\n#### 2、安装 QuickLisp：\n\n由于 Open-VRP 项目使用了多种 Lisp 上的第三方包，我们接下来安装 QuickLisp 来方便地对 Lisp 的第三方包进行安装和管理。这里直接使用官方给出的安装脚本进行安装。\n\n \n```bash\ncurl -O https://beta.quicklisp.org/quicklisp.lisp\n\n# 使用已安装的 SBCL 快速加载安装脚本；\nsbcl --load quicklisp.lisp\n```\n\n执行上述两条命令后会进入 SBCL 的命令行交互界面，同时自动加载 QuickLisp 到当前的环境中。我们可以通过下面给出的命令来查看、安装和卸载第三方库。\n\n```bash\n# 手动加载 QuickLisp 到当前环境；\n(load \"~/quicklisp/setup.lisp\")\n\n# 安装 QuickLisp；\n(quicklisp-quickstart:install)\n\n# 加载一个第三方库；\n(ql:quickload \"system-name\")\n\n# 查找一个第三方库；\n(ql:system-apropos \"term\")\n\n# 卸载一个第三方库；\n(ql:uninstall \"system-name\")\n\n# 进入 SBCL 时自动加载 QuickLisp；\n(ql:add-to-init-file)\n```\n\n#### 3、开始使用：\n\n接下来我们将 Open-VRP 的代码克隆到本地，直接在 SBCL 中执行下列命令即可开始使用该框架的功能。\n\n \n```bash\n(push \"/Users/jason/Desktop/Repo/Open-VRP/\" asdf:*central-registry*)\n(require 'open-vrp)\n(in-package :open-vrp)\n```\n\n比如我们尝试使用 Open-VRP 来解决一个预设的 Solomon's VRPTW 问题：\n\n \n```bash\n(solve-prob solomon100 (make-instance 'tabu-search :iterations 100))\n```\n","source":"_posts/Mac-配置-Commom-Lisp-开发环境.md","raw":"---\ntitle: Mac 配置 Commom Lisp 开发环境\nintro: 由于最近在工作中遇到了一些使用 Lisp 语言编写的项目，因此在这里记录一下在 Mac 上配置 Common Lisp 编译和运行环境的步骤。这里以配置 Open-VRP 项目为主要目标。Open-VRP 是一个使用 Lisp 编写的基于启发式 Tabu Search 算法用于解决类 VRPTW 问题的工具库。\ncomments: true\ndate: 2017-06-29 13:32:42\ntags:\n- Lisp\n---\n\n由于最近在工作中遇到了一些使用 Lisp 语言编写的项目，因此在这里记录一下在 Mac 上配置 Common Lisp 编译和运行环境的步骤。这里以配置 Open-VRP 项目为主要目标。Open-VRP 是一个使用 Lisp 编写的基于启发式 Tabu Search 算法用于解决类 VRPTW 问题的工具库。\n\n#### 1、安装 SBCL：\n\nSteel Bank Common Lisp（SBCL）是一个高性能的 Common Lisp 编译器。除了 ANSI Common Lisp 的编译器和运行时系统之外，它还提供了一个交互式环境，包括调试器，统计分析器，代码覆盖工具以及许多其他扩展。它将 Lisp 直接编译为机器语言，并可生成接近或有时比类似 C 或 Java 代码速度更快的机器语言。\n\n在 Mac 上，我们可以直接通过 `brew` 来安装 SBCL 的环境。\n\n \n```bash\nbrew install sbcl\n```\n\n#### 2、安装 QuickLisp：\n\n由于 Open-VRP 项目使用了多种 Lisp 上的第三方包，我们接下来安装 QuickLisp 来方便地对 Lisp 的第三方包进行安装和管理。这里直接使用官方给出的安装脚本进行安装。\n\n \n```bash\ncurl -O https://beta.quicklisp.org/quicklisp.lisp\n\n# 使用已安装的 SBCL 快速加载安装脚本；\nsbcl --load quicklisp.lisp\n```\n\n执行上述两条命令后会进入 SBCL 的命令行交互界面，同时自动加载 QuickLisp 到当前的环境中。我们可以通过下面给出的命令来查看、安装和卸载第三方库。\n\n```bash\n# 手动加载 QuickLisp 到当前环境；\n(load \"~/quicklisp/setup.lisp\")\n\n# 安装 QuickLisp；\n(quicklisp-quickstart:install)\n\n# 加载一个第三方库；\n(ql:quickload \"system-name\")\n\n# 查找一个第三方库；\n(ql:system-apropos \"term\")\n\n# 卸载一个第三方库；\n(ql:uninstall \"system-name\")\n\n# 进入 SBCL 时自动加载 QuickLisp；\n(ql:add-to-init-file)\n```\n\n#### 3、开始使用：\n\n接下来我们将 Open-VRP 的代码克隆到本地，直接在 SBCL 中执行下列命令即可开始使用该框架的功能。\n\n \n```bash\n(push \"/Users/jason/Desktop/Repo/Open-VRP/\" asdf:*central-registry*)\n(require 'open-vrp)\n(in-package :open-vrp)\n```\n\n比如我们尝试使用 Open-VRP 来解决一个预设的 Solomon's VRPTW 问题：\n\n \n```bash\n(solve-prob solomon100 (make-instance 'tabu-search :iterations 100))\n```\n","slug":"Mac-配置-Commom-Lisp-开发环境","published":1,"updated":"2019-02-19T09:38:14.115Z","layout":"post","photos":[],"link":"","_id":"cjsqwht9o002yknp2sw26hady","content":"<p>由于最近在工作中遇到了一些使用 Lisp 语言编写的项目，因此在这里记录一下在 Mac 上配置 Common Lisp 编译和运行环境的步骤。这里以配置 Open-VRP 项目为主要目标。Open-VRP 是一个使用 Lisp 编写的基于启发式 Tabu Search 算法用于解决类 VRPTW 问题的工具库。</p>\n<h4 id=\"1、安装-SBCL：\"><a href=\"#1、安装-SBCL：\" class=\"headerlink\" title=\"1、安装 SBCL：\"></a>1、安装 SBCL：</h4><p>Steel Bank Common Lisp（SBCL）是一个高性能的 Common Lisp 编译器。除了 ANSI Common Lisp 的编译器和运行时系统之外，它还提供了一个交互式环境，包括调试器，统计分析器，代码覆盖工具以及许多其他扩展。它将 Lisp 直接编译为机器语言，并可生成接近或有时比类似 C 或 Java 代码速度更快的机器语言。</p>\n<p>在 Mac 上，我们可以直接通过 <code>brew</code> 来安装 SBCL 的环境。</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\">brew <span class=\"token function\">install</span> sbcl\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h4 id=\"2、安装-QuickLisp：\"><a href=\"#2、安装-QuickLisp：\" class=\"headerlink\" title=\"2、安装 QuickLisp：\"></a>2、安装 QuickLisp：</h4><p>由于 Open-VRP 项目使用了多种 Lisp 上的第三方包，我们接下来安装 QuickLisp 来方便地对 Lisp 的第三方包进行安装和管理。这里直接使用官方给出的安装脚本进行安装。</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\">curl -O https://beta.quicklisp.org/quicklisp.lisp\n\n<span class=\"token comment\" spellcheck=\"true\"># 使用已安装的 SBCL 快速加载安装脚本；</span>\nsbcl --load quicklisp.lisp\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>执行上述两条命令后会进入 SBCL 的命令行交互界面，同时自动加载 QuickLisp 到当前的环境中。我们可以通过下面给出的命令来查看、安装和卸载第三方库。</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token comment\" spellcheck=\"true\"># 手动加载 QuickLisp 到当前环境；</span>\n<span class=\"token punctuation\">(</span>load <span class=\"token string\">\"~/quicklisp/setup.lisp\"</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 安装 QuickLisp；</span>\n<span class=\"token punctuation\">(</span>quicklisp-quickstart:install<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 加载一个第三方库；</span>\n<span class=\"token punctuation\">(</span>ql:quickload <span class=\"token string\">\"system-name\"</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 查找一个第三方库；</span>\n<span class=\"token punctuation\">(</span>ql:system-apropos <span class=\"token string\">\"term\"</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 卸载一个第三方库；</span>\n<span class=\"token punctuation\">(</span>ql:uninstall <span class=\"token string\">\"system-name\"</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 进入 SBCL 时自动加载 QuickLisp；</span>\n<span class=\"token punctuation\">(</span>ql:add-to-init-file<span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"3、开始使用：\"><a href=\"#3、开始使用：\" class=\"headerlink\" title=\"3、开始使用：\"></a>3、开始使用：</h4><p>接下来我们将 Open-VRP 的代码克隆到本地，直接在 SBCL 中执行下列命令即可开始使用该框架的功能。</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token punctuation\">(</span>push <span class=\"token string\">\"/Users/jason/Desktop/Repo/Open-VRP/\"</span> asdf:*central-registry*<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span>require 'open-vrp<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span>in-package :open-vrp<span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>比如我们尝试使用 Open-VRP 来解决一个预设的 Solomon’s VRPTW 问题：</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token punctuation\">(</span>solve-prob solomon100 <span class=\"token punctuation\">(</span>make-instance 'tabu-search :iterations 100<span class=\"token punctuation\">))</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n","site":{"data":{}},"id":"d17a6386fe950b70ca71a45ab3dfb217","excerpt":"","more":"<p>由于最近在工作中遇到了一些使用 Lisp 语言编写的项目，因此在这里记录一下在 Mac 上配置 Common Lisp 编译和运行环境的步骤。这里以配置 Open-VRP 项目为主要目标。Open-VRP 是一个使用 Lisp 编写的基于启发式 Tabu Search 算法用于解决类 VRPTW 问题的工具库。</p>\n<h4 id=\"1、安装-SBCL：\"><a href=\"#1、安装-SBCL：\" class=\"headerlink\" title=\"1、安装 SBCL：\"></a>1、安装 SBCL：</h4><p>Steel Bank Common Lisp（SBCL）是一个高性能的 Common Lisp 编译器。除了 ANSI Common Lisp 的编译器和运行时系统之外，它还提供了一个交互式环境，包括调试器，统计分析器，代码覆盖工具以及许多其他扩展。它将 Lisp 直接编译为机器语言，并可生成接近或有时比类似 C 或 Java 代码速度更快的机器语言。</p>\n<p>在 Mac 上，我们可以直接通过 <code>brew</code> 来安装 SBCL 的环境。</p>\n<pre><code class=\"bash\">brew install sbcl\n</code></pre>\n<h4 id=\"2、安装-QuickLisp：\"><a href=\"#2、安装-QuickLisp：\" class=\"headerlink\" title=\"2、安装 QuickLisp：\"></a>2、安装 QuickLisp：</h4><p>由于 Open-VRP 项目使用了多种 Lisp 上的第三方包，我们接下来安装 QuickLisp 来方便地对 Lisp 的第三方包进行安装和管理。这里直接使用官方给出的安装脚本进行安装。</p>\n<pre><code class=\"bash\">curl -O https://beta.quicklisp.org/quicklisp.lisp\n\n# 使用已安装的 SBCL 快速加载安装脚本；\nsbcl --load quicklisp.lisp\n</code></pre>\n<p>执行上述两条命令后会进入 SBCL 的命令行交互界面，同时自动加载 QuickLisp 到当前的环境中。我们可以通过下面给出的命令来查看、安装和卸载第三方库。</p>\n<pre><code class=\"bash\"># 手动加载 QuickLisp 到当前环境；\n(load &quot;~/quicklisp/setup.lisp&quot;)\n\n# 安装 QuickLisp；\n(quicklisp-quickstart:install)\n\n# 加载一个第三方库；\n(ql:quickload &quot;system-name&quot;)\n\n# 查找一个第三方库；\n(ql:system-apropos &quot;term&quot;)\n\n# 卸载一个第三方库；\n(ql:uninstall &quot;system-name&quot;)\n\n# 进入 SBCL 时自动加载 QuickLisp；\n(ql:add-to-init-file)\n</code></pre>\n<h4 id=\"3、开始使用：\"><a href=\"#3、开始使用：\" class=\"headerlink\" title=\"3、开始使用：\"></a>3、开始使用：</h4><p>接下来我们将 Open-VRP 的代码克隆到本地，直接在 SBCL 中执行下列命令即可开始使用该框架的功能。</p>\n<pre><code class=\"bash\">(push &quot;/Users/jason/Desktop/Repo/Open-VRP/&quot; asdf:*central-registry*)\n(require &#39;open-vrp)\n(in-package :open-vrp)\n</code></pre>\n<p>比如我们尝试使用 Open-VRP 来解决一个预设的 Solomon’s VRPTW 问题：</p>\n<pre><code class=\"bash\">(solve-prob solomon100 (make-instance &#39;tabu-search :iterations 100))\n</code></pre>\n"},{"title":"Linux 后台运行任务","intro":"我们在日常的开发过程中，可能会经常手动的去执行一些脚本来整理数据或者进行一些统计性的任务。而在执行脚本时，我们通常是通过 SSH 终端来与 Linux/Unix 服务器进行连接的；同时我们也可以通过 SSH 终端来执行命令或启动远程服务器上相应的脚本任务。而这种连接通常来说是不稳定的。","comments":1,"date":"2016-07-14T06:50:41.000Z","_content":"\n我们在日常的开发过程中，可能会经常手动的去执行一些脚本来整理数据或者进行一些统计性的任务。而在执行脚本时，我们通常是通过 SSH 终端来与 Linux/Unix 服务器进行连接的；同时我们也可以通过 SSH 终端来执行命令或启动远程服务器上相应的脚本任务。而这种连接通常来说是不稳定的。\n\n在这种“不稳定”的网络连接情况下，如果我们执行了一些耗时较长的任务或命令，则可能会由于 SSH 终端连接的关闭或者其他网络原因导致当前的任务或命令执行中断。而接下来我们要讨论的，便是如何去解决这个问题，使任务能够在 Linux 服务器的后台“默默”的运行，而不会受到终端的影响。以下我们将具体场景分为几种情况来进行讨论。\n\n#### 一、对于未运行的临时后台脚本任务：\n\n**1. nohub 命令：**\n\n`nohup` 命令的使用是十分简单方便的，只需在要处理的命令前加上 `nohup` 即可，标准输出和标准错误缺省会被重定向到当前目录的 “nohup.out” 文件中，即该文件起到了监视日志的作用。一般我们可在结尾加上 **\"&\"** 符号来将命令同时放入后台运行，同时也可以使用 `\">filename 2>&1\"` 来更改缺省的重定向文件名（0、1和2分别表示**标准输入**、**标准输出**和**标准错误信息输出**， `>filename` 即将标准输出重定向到文件 “filename” 中， `2>&1`：即将错误信息重定向到标准输出）。用法示例如下：\n\n```shell\n[root@pvcent107 ~]# nohup ping www.ibm.com &\n[1] 3059\nnohup: appending output to 'nohup.out'\n[root@pvcent107 ~]# ps -ef | grep 3059\nroot      3059   984  0 21:06 pts/3    00:00:00 ping www.ibm.com\nroot      3067   984  0 21:06 pts/3    00:00:00 grep 3059\n[root@pvcent107 ~]#\n```\n\n**2. setsid 命令：**\n\n**nohup** 命令无疑能够通过忽略 HUP 信号来使我们的进程避免中途被中断。但我们可以换个角度思考，如果我们的进程**不属于**接受 HUP 信号的终端的子进程，那么自然也就不会受到 HUP 信号的影响了。**setsid** 命令就能帮助我们做到这一点。用法示例如下：\n\n```shell\n[root@pvcent107 ~]# setsid ping www.ibm.com\n[root@pvcent107 ~]# ps -ef | grep www.ibm.com\nroot     31094     1  0 07:28 ?        00:00:00 ping www.ibm.com\nroot     31102 29217  0 07:29 pts/4    00:00:00 grep www.ibm.com\n[root@pvcent107 ~]#\n```\n\n**3. & 操作符：**\n\n我们知道，将一个或多个命名包含在 “()” 中就能让这些命令在子 shell 中运行，从而扩展出很多有趣的功能，我们现在要讨论的就是其中之一。当我们将 \"&\" 也放入 “()” 内之后，我们就会发现所提交的作业（jobs）并不在作业列表中，也就是说，该作业是无法通过 `jobs` 命令来查看的。用法示例：\n\n```text\n[root@pvcent107 ~]# (ping www.ibm.com &)\n[root@pvcent107 ~]# ps -ef | grep www.ibm.com\nroot     16270     1  0 14:13 pts/4    00:00:00 ping www.ibm.com\nroot     16278 15362  0 14:13 pts/4    00:00:00 grep www.ibm.com\n[root@pvcent107 ~]#\n```\n\n从上例中可以看出，新提交的进程的父 ID（PPID）为1（即 **init** 进程的 PID），并不是当前终端的进程 ID。因此并不属于当前终端的子进程，从而也就不会受到当前终端的 HUP 信号的影响了。\n\n#### 二、对于已经提交并正在运行中的任务：\n\n**1. disown 命令：**\n\n这时想利用 `nohup` 命令或者 `setsid` 命令已经为时已晚，只能通过作业调度和 `disown` 命令来解决这个问题了。\n\n**disown** 命令有三种常用的操作方式：\n\n* 用 `disown -h <jobspec>` 来使**某个作业**忽略 HUP 信号；\n* 用 `disown -ah` 来使**所有的作业**都忽略 HUP 信号；\n* 用 `disown -rh` 来使**正在运行的作业**忽略 HUP 信号；\n\n\n需要注意的是，当使用过 `disown` 命令后，会把目标作业从作业列表中移除，我们将不再能够使用 `jobs` 命令来查看它，但是依然能够用 `ps -ef` 命令查找到它。\n\n但是还有一个问题，这种方法的操作对象是作业，如果我们在运行命令时在结尾加了 **\"&\"** 来使它成为一个作业并在后台运行，那么就万事大吉了，我们可以通过 `jobs` 命令来得到所有作业的列表。但是如果并没有把当前命令作为作业来运行，如何才能得到它的作业号呢？答案就是用 CTRL-z（按住 Ctrl 键的同时按住 z 键）！\n\n“CTRL-z” 的用途就是将当前进程挂起（Suspend），然后我们就可以用 `jobs` 命令来查询它的作业号，再用 `bg <jobspec>` 来将它放入后台并继续运行。需要注意的是，如果挂起会影响当前进程的运行结果，请慎用此方法。\n\n* 示例1：（如果提交命令时已经用 “&” 将命令放入后台运行，则可以直接使用 “disown”）\n\n```shell\n[root@pvcent107 build]# cp -r testLargeFile largeFile &\n[1] 4825\n[root@pvcent107 build]# jobs\n[1]+  Running                 cp -i -r testLargeFile largeFile &\n[root@pvcent107 build]# disown -h %1\n[root@pvcent107 build]# ps -ef | grep largeFile\nroot      4825   968  1 09:46 pts/4    00:00:00 cp -i -r testLargeFile largeFile\nroot      4853   968  0 09:46 pts/4    00:00:00 grep largeFile\n[root@pvcent107 build]# logout\n```\n\n* 示例2：（如果提交命令时未使用 “&” 将命令放入后台运行，可使用 CTRL-z 和 “bg” 将其放入后台，再使用 “disown”）\n\n```shell\n[root@pvcent107 build]# cp -r testLargeFile largeFile2\n\n[1]+  Stopped                 cp -i -r testLargeFile largeFile2\n[root@pvcent107 build]# bg %1\n[1]+ cp -i -r testLargeFile largeFile2 &\n[root@pvcent107 build]# jobs\n[1]+  Running                 cp -i -r testLargeFile largeFile2 &\n[root@pvcent107 build]# disown -h %1\n[root@pvcent107 build]# ps -ef | grep largeFile2\nroot      5790  5577  1 10:04 pts/3    00:00:00 cp -i -r testLargeFile largeFile2\nroot      5824  5577  0 10:05 pts/3    00:00:00 grep largeFile2\n[root@pvcent107 build]#\n```\n\n#### 三、对于大量需要在后台稳定运行的任务：\n\n**1. screen 命令：**\n\n简单的说，`screen` 命令提供了 ANSI/VT100 的终端模拟器，使它能够在一个真实终端下运行多个全屏的伪终端。`screen` 命令的参数很多，具有很强大的功能，我们在此仅介绍其常用功能以及简要分析一下为什么使用 `screen` 能够避免 HUP 信号的影响。\n\n使用 screen 很方便，有以下几个常用选项：\n\n* 用 `screen -dmS <session name>` 来建立一个处于断开模式下的会话（并指定其会话名）；\n* 用 `screen -list` 来列出所有会话；\n* 用 `screen -r <session name>` 来重新连接指定会话；\n* 用快捷键 `CTRL-a d` 来暂时断开当前会话；\n\n\n* 示例：\n\n```shell\n[root@pvcent107 ~]# screen -dmS Urumchi\n[root@pvcent107 ~]# screen -list\nThere is a screen on:\n        12842.Urumchi   (Detached)\n1 Socket in /tmp/screens/S-root.\n\n[root@pvcent107 ~]# screen -r Urumchi\n```\n\n当我们用 “-r” 连接到 screen 会话后，我们就可以在这个伪终端里面做任何事情，再也不用担心 HUP 信号会对我们的进程造成影响，也不用给每个命令前都加上 “nohup” 或者 “setsid” 了。这是为什么呢？让我们来看一下这两个例子吧。\n\n1. 未使用 `screen` 时新进程的进程树：\n\n```shell\n[root@pvcent107 ~]# ping www.google.com &\n[1] 9499\n[root@pvcent107 ~]# pstree -H 9499\ninit─┬─Xvnc` \n     ├─acpid` \n     ├─atd` \n     ├─2*[sendmail]\t\n     **├─sshd─┬**─sshd───bash───pstree\n     │      ** └─sshd───bash───ping**\n```\n\n我们可以看出，未使用 `screen` 时我们所处的 bash 是 sshd 的子进程，当 ssh 断开连接时，HUP 信号自然会影响到它下面的所有子进程（包括我们新建立的 “ping” 进程）。\n\n2. 使用了 `screen` 后新进程的进程树：\n\n```shell\n[root@pvcent107 ~]# screen -r Urumchi\n[root@pvcent107 ~]# ping www.ibm.com &\n[1] 9488\n[root@pvcent107 ~]# pstree -H 9488\ninit─┬─Xvnc\n     ├─acpid\n     ├─atd\n     **├─screen───bash───ping**\n     ├─2*[sendmail]\n```\n\n而使用了 `screen` 命令后就不同了，此时 bash 是 screen 的子进程，而 screen 是 init（PID 为1）的子进程。那么当 ssh 断开连接时，HUP 信号自然不会影响到 screen 下面的子进程了。\n\n本文转载整理自“IBM 开发者社区”，同时修正了原文中的几处错误，此处为 **[原文链接](http://www.ibm.com/developerworks/cn/linux/l-cn-nohup/#ibm-pcon)**。\n\n\n\n","source":"_posts/Linux-后台运行任务.md","raw":"---\ntitle: Linux 后台运行任务\nintro: 我们在日常的开发过程中，可能会经常手动的去执行一些脚本来整理数据或者进行一些统计性的任务。而在执行脚本时，我们通常是通过 SSH 终端来与 Linux/Unix 服务器进行连接的；同时我们也可以通过 SSH 终端来执行命令或启动远程服务器上相应的脚本任务。而这种连接通常来说是不稳定的。\ncomments: true\ndate: 2016-07-14 14:50:41\ntags:\n- Linux\n---\n\n我们在日常的开发过程中，可能会经常手动的去执行一些脚本来整理数据或者进行一些统计性的任务。而在执行脚本时，我们通常是通过 SSH 终端来与 Linux/Unix 服务器进行连接的；同时我们也可以通过 SSH 终端来执行命令或启动远程服务器上相应的脚本任务。而这种连接通常来说是不稳定的。\n\n在这种“不稳定”的网络连接情况下，如果我们执行了一些耗时较长的任务或命令，则可能会由于 SSH 终端连接的关闭或者其他网络原因导致当前的任务或命令执行中断。而接下来我们要讨论的，便是如何去解决这个问题，使任务能够在 Linux 服务器的后台“默默”的运行，而不会受到终端的影响。以下我们将具体场景分为几种情况来进行讨论。\n\n#### 一、对于未运行的临时后台脚本任务：\n\n**1. nohub 命令：**\n\n`nohup` 命令的使用是十分简单方便的，只需在要处理的命令前加上 `nohup` 即可，标准输出和标准错误缺省会被重定向到当前目录的 “nohup.out” 文件中，即该文件起到了监视日志的作用。一般我们可在结尾加上 **\"&\"** 符号来将命令同时放入后台运行，同时也可以使用 `\">filename 2>&1\"` 来更改缺省的重定向文件名（0、1和2分别表示**标准输入**、**标准输出**和**标准错误信息输出**， `>filename` 即将标准输出重定向到文件 “filename” 中， `2>&1`：即将错误信息重定向到标准输出）。用法示例如下：\n\n```shell\n[root@pvcent107 ~]# nohup ping www.ibm.com &\n[1] 3059\nnohup: appending output to 'nohup.out'\n[root@pvcent107 ~]# ps -ef | grep 3059\nroot      3059   984  0 21:06 pts/3    00:00:00 ping www.ibm.com\nroot      3067   984  0 21:06 pts/3    00:00:00 grep 3059\n[root@pvcent107 ~]#\n```\n\n**2. setsid 命令：**\n\n**nohup** 命令无疑能够通过忽略 HUP 信号来使我们的进程避免中途被中断。但我们可以换个角度思考，如果我们的进程**不属于**接受 HUP 信号的终端的子进程，那么自然也就不会受到 HUP 信号的影响了。**setsid** 命令就能帮助我们做到这一点。用法示例如下：\n\n```shell\n[root@pvcent107 ~]# setsid ping www.ibm.com\n[root@pvcent107 ~]# ps -ef | grep www.ibm.com\nroot     31094     1  0 07:28 ?        00:00:00 ping www.ibm.com\nroot     31102 29217  0 07:29 pts/4    00:00:00 grep www.ibm.com\n[root@pvcent107 ~]#\n```\n\n**3. & 操作符：**\n\n我们知道，将一个或多个命名包含在 “()” 中就能让这些命令在子 shell 中运行，从而扩展出很多有趣的功能，我们现在要讨论的就是其中之一。当我们将 \"&\" 也放入 “()” 内之后，我们就会发现所提交的作业（jobs）并不在作业列表中，也就是说，该作业是无法通过 `jobs` 命令来查看的。用法示例：\n\n```text\n[root@pvcent107 ~]# (ping www.ibm.com &)\n[root@pvcent107 ~]# ps -ef | grep www.ibm.com\nroot     16270     1  0 14:13 pts/4    00:00:00 ping www.ibm.com\nroot     16278 15362  0 14:13 pts/4    00:00:00 grep www.ibm.com\n[root@pvcent107 ~]#\n```\n\n从上例中可以看出，新提交的进程的父 ID（PPID）为1（即 **init** 进程的 PID），并不是当前终端的进程 ID。因此并不属于当前终端的子进程，从而也就不会受到当前终端的 HUP 信号的影响了。\n\n#### 二、对于已经提交并正在运行中的任务：\n\n**1. disown 命令：**\n\n这时想利用 `nohup` 命令或者 `setsid` 命令已经为时已晚，只能通过作业调度和 `disown` 命令来解决这个问题了。\n\n**disown** 命令有三种常用的操作方式：\n\n* 用 `disown -h <jobspec>` 来使**某个作业**忽略 HUP 信号；\n* 用 `disown -ah` 来使**所有的作业**都忽略 HUP 信号；\n* 用 `disown -rh` 来使**正在运行的作业**忽略 HUP 信号；\n\n\n需要注意的是，当使用过 `disown` 命令后，会把目标作业从作业列表中移除，我们将不再能够使用 `jobs` 命令来查看它，但是依然能够用 `ps -ef` 命令查找到它。\n\n但是还有一个问题，这种方法的操作对象是作业，如果我们在运行命令时在结尾加了 **\"&\"** 来使它成为一个作业并在后台运行，那么就万事大吉了，我们可以通过 `jobs` 命令来得到所有作业的列表。但是如果并没有把当前命令作为作业来运行，如何才能得到它的作业号呢？答案就是用 CTRL-z（按住 Ctrl 键的同时按住 z 键）！\n\n“CTRL-z” 的用途就是将当前进程挂起（Suspend），然后我们就可以用 `jobs` 命令来查询它的作业号，再用 `bg <jobspec>` 来将它放入后台并继续运行。需要注意的是，如果挂起会影响当前进程的运行结果，请慎用此方法。\n\n* 示例1：（如果提交命令时已经用 “&” 将命令放入后台运行，则可以直接使用 “disown”）\n\n```shell\n[root@pvcent107 build]# cp -r testLargeFile largeFile &\n[1] 4825\n[root@pvcent107 build]# jobs\n[1]+  Running                 cp -i -r testLargeFile largeFile &\n[root@pvcent107 build]# disown -h %1\n[root@pvcent107 build]# ps -ef | grep largeFile\nroot      4825   968  1 09:46 pts/4    00:00:00 cp -i -r testLargeFile largeFile\nroot      4853   968  0 09:46 pts/4    00:00:00 grep largeFile\n[root@pvcent107 build]# logout\n```\n\n* 示例2：（如果提交命令时未使用 “&” 将命令放入后台运行，可使用 CTRL-z 和 “bg” 将其放入后台，再使用 “disown”）\n\n```shell\n[root@pvcent107 build]# cp -r testLargeFile largeFile2\n\n[1]+  Stopped                 cp -i -r testLargeFile largeFile2\n[root@pvcent107 build]# bg %1\n[1]+ cp -i -r testLargeFile largeFile2 &\n[root@pvcent107 build]# jobs\n[1]+  Running                 cp -i -r testLargeFile largeFile2 &\n[root@pvcent107 build]# disown -h %1\n[root@pvcent107 build]# ps -ef | grep largeFile2\nroot      5790  5577  1 10:04 pts/3    00:00:00 cp -i -r testLargeFile largeFile2\nroot      5824  5577  0 10:05 pts/3    00:00:00 grep largeFile2\n[root@pvcent107 build]#\n```\n\n#### 三、对于大量需要在后台稳定运行的任务：\n\n**1. screen 命令：**\n\n简单的说，`screen` 命令提供了 ANSI/VT100 的终端模拟器，使它能够在一个真实终端下运行多个全屏的伪终端。`screen` 命令的参数很多，具有很强大的功能，我们在此仅介绍其常用功能以及简要分析一下为什么使用 `screen` 能够避免 HUP 信号的影响。\n\n使用 screen 很方便，有以下几个常用选项：\n\n* 用 `screen -dmS <session name>` 来建立一个处于断开模式下的会话（并指定其会话名）；\n* 用 `screen -list` 来列出所有会话；\n* 用 `screen -r <session name>` 来重新连接指定会话；\n* 用快捷键 `CTRL-a d` 来暂时断开当前会话；\n\n\n* 示例：\n\n```shell\n[root@pvcent107 ~]# screen -dmS Urumchi\n[root@pvcent107 ~]# screen -list\nThere is a screen on:\n        12842.Urumchi   (Detached)\n1 Socket in /tmp/screens/S-root.\n\n[root@pvcent107 ~]# screen -r Urumchi\n```\n\n当我们用 “-r” 连接到 screen 会话后，我们就可以在这个伪终端里面做任何事情，再也不用担心 HUP 信号会对我们的进程造成影响，也不用给每个命令前都加上 “nohup” 或者 “setsid” 了。这是为什么呢？让我们来看一下这两个例子吧。\n\n1. 未使用 `screen` 时新进程的进程树：\n\n```shell\n[root@pvcent107 ~]# ping www.google.com &\n[1] 9499\n[root@pvcent107 ~]# pstree -H 9499\ninit─┬─Xvnc` \n     ├─acpid` \n     ├─atd` \n     ├─2*[sendmail]\t\n     **├─sshd─┬**─sshd───bash───pstree\n     │      ** └─sshd───bash───ping**\n```\n\n我们可以看出，未使用 `screen` 时我们所处的 bash 是 sshd 的子进程，当 ssh 断开连接时，HUP 信号自然会影响到它下面的所有子进程（包括我们新建立的 “ping” 进程）。\n\n2. 使用了 `screen` 后新进程的进程树：\n\n```shell\n[root@pvcent107 ~]# screen -r Urumchi\n[root@pvcent107 ~]# ping www.ibm.com &\n[1] 9488\n[root@pvcent107 ~]# pstree -H 9488\ninit─┬─Xvnc\n     ├─acpid\n     ├─atd\n     **├─screen───bash───ping**\n     ├─2*[sendmail]\n```\n\n而使用了 `screen` 命令后就不同了，此时 bash 是 screen 的子进程，而 screen 是 init（PID 为1）的子进程。那么当 ssh 断开连接时，HUP 信号自然不会影响到 screen 下面的子进程了。\n\n本文转载整理自“IBM 开发者社区”，同时修正了原文中的几处错误，此处为 **[原文链接](http://www.ibm.com/developerworks/cn/linux/l-cn-nohup/#ibm-pcon)**。\n\n\n\n","slug":"Linux-后台运行任务","published":1,"updated":"2019-02-07T15:24:26.757Z","layout":"post","photos":[],"link":"","_id":"cjsqwht9o0030knp2tp16rwfc","content":"<p>我们在日常的开发过程中，可能会经常手动的去执行一些脚本来整理数据或者进行一些统计性的任务。而在执行脚本时，我们通常是通过 SSH 终端来与 Linux/Unix 服务器进行连接的；同时我们也可以通过 SSH 终端来执行命令或启动远程服务器上相应的脚本任务。而这种连接通常来说是不稳定的。</p>\n<p>在这种“不稳定”的网络连接情况下，如果我们执行了一些耗时较长的任务或命令，则可能会由于 SSH 终端连接的关闭或者其他网络原因导致当前的任务或命令执行中断。而接下来我们要讨论的，便是如何去解决这个问题，使任务能够在 Linux 服务器的后台“默默”的运行，而不会受到终端的影响。以下我们将具体场景分为几种情况来进行讨论。</p>\n<h4 id=\"一、对于未运行的临时后台脚本任务：\"><a href=\"#一、对于未运行的临时后台脚本任务：\" class=\"headerlink\" title=\"一、对于未运行的临时后台脚本任务：\"></a>一、对于未运行的临时后台脚本任务：</h4><p><strong>1. nohub 命令：</strong></p>\n<p><code>nohup</code> 命令的使用是十分简单方便的，只需在要处理的命令前加上 <code>nohup</code> 即可，标准输出和标准错误缺省会被重定向到当前目录的 “nohup.out” 文件中，即该文件起到了监视日志的作用。一般我们可在结尾加上 <strong>“&amp;”</strong> 符号来将命令同时放入后台运行，同时也可以使用 <code>&quot;&gt;filename 2&gt;&amp;1&quot;</code> 来更改缺省的重定向文件名（0、1和2分别表示<strong>标准输入</strong>、<strong>标准输出</strong>和<strong>标准错误信息输出</strong>， <code>&gt;filename</code> 即将标准输出重定向到文件 “filename” 中， <code>2&gt;&amp;1</code>：即将错误信息重定向到标准输出）。用法示例如下：</p>\n<pre class=\"line-numbers language-shell\"><code class=\"language-shell\">[root@pvcent107 ~]# nohup ping www.ibm.com &\n[1] 3059\nnohup: appending output to 'nohup.out'\n[root@pvcent107 ~]# ps -ef | grep 3059\nroot      3059   984  0 21:06 pts/3    00:00:00 ping www.ibm.com\nroot      3067   984  0 21:06 pts/3    00:00:00 grep 3059\n[root@pvcent107 ~]#\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>2. setsid 命令：</strong></p>\n<p><strong>nohup</strong> 命令无疑能够通过忽略 HUP 信号来使我们的进程避免中途被中断。但我们可以换个角度思考，如果我们的进程<strong>不属于</strong>接受 HUP 信号的终端的子进程，那么自然也就不会受到 HUP 信号的影响了。<strong>setsid</strong> 命令就能帮助我们做到这一点。用法示例如下：</p>\n<pre class=\"line-numbers language-shell\"><code class=\"language-shell\">[root@pvcent107 ~]# setsid ping www.ibm.com\n[root@pvcent107 ~]# ps -ef | grep www.ibm.com\nroot     31094     1  0 07:28 ?        00:00:00 ping www.ibm.com\nroot     31102 29217  0 07:29 pts/4    00:00:00 grep www.ibm.com\n[root@pvcent107 ~]#\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>3. &amp; 操作符：</strong></p>\n<p>我们知道，将一个或多个命名包含在 “()” 中就能让这些命令在子 shell 中运行，从而扩展出很多有趣的功能，我们现在要讨论的就是其中之一。当我们将 “&amp;” 也放入 “()” 内之后，我们就会发现所提交的作业（jobs）并不在作业列表中，也就是说，该作业是无法通过 <code>jobs</code> 命令来查看的。用法示例：</p>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">[root@pvcent107 ~]# (ping www.ibm.com &)\n[root@pvcent107 ~]# ps -ef | grep www.ibm.com\nroot     16270     1  0 14:13 pts/4    00:00:00 ping www.ibm.com\nroot     16278 15362  0 14:13 pts/4    00:00:00 grep www.ibm.com\n[root@pvcent107 ~]#\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>从上例中可以看出，新提交的进程的父 ID（PPID）为1（即 <strong>init</strong> 进程的 PID），并不是当前终端的进程 ID。因此并不属于当前终端的子进程，从而也就不会受到当前终端的 HUP 信号的影响了。</p>\n<h4 id=\"二、对于已经提交并正在运行中的任务：\"><a href=\"#二、对于已经提交并正在运行中的任务：\" class=\"headerlink\" title=\"二、对于已经提交并正在运行中的任务：\"></a>二、对于已经提交并正在运行中的任务：</h4><p><strong>1. disown 命令：</strong></p>\n<p>这时想利用 <code>nohup</code> 命令或者 <code>setsid</code> 命令已经为时已晚，只能通过作业调度和 <code>disown</code> 命令来解决这个问题了。</p>\n<p><strong>disown</strong> 命令有三种常用的操作方式：</p>\n<ul>\n<li>用 <code>disown -h &lt;jobspec&gt;</code> 来使<strong>某个作业</strong>忽略 HUP 信号；</li>\n<li>用 <code>disown -ah</code> 来使<strong>所有的作业</strong>都忽略 HUP 信号；</li>\n<li>用 <code>disown -rh</code> 来使<strong>正在运行的作业</strong>忽略 HUP 信号；</li>\n</ul>\n<p>需要注意的是，当使用过 <code>disown</code> 命令后，会把目标作业从作业列表中移除，我们将不再能够使用 <code>jobs</code> 命令来查看它，但是依然能够用 <code>ps -ef</code> 命令查找到它。</p>\n<p>但是还有一个问题，这种方法的操作对象是作业，如果我们在运行命令时在结尾加了 <strong>“&amp;”</strong> 来使它成为一个作业并在后台运行，那么就万事大吉了，我们可以通过 <code>jobs</code> 命令来得到所有作业的列表。但是如果并没有把当前命令作为作业来运行，如何才能得到它的作业号呢？答案就是用 CTRL-z（按住 Ctrl 键的同时按住 z 键）！</p>\n<p>“CTRL-z” 的用途就是将当前进程挂起（Suspend），然后我们就可以用 <code>jobs</code> 命令来查询它的作业号，再用 <code>bg &lt;jobspec&gt;</code> 来将它放入后台并继续运行。需要注意的是，如果挂起会影响当前进程的运行结果，请慎用此方法。</p>\n<ul>\n<li>示例1：（如果提交命令时已经用 “&amp;” 将命令放入后台运行，则可以直接使用 “disown”）</li>\n</ul>\n<pre class=\"line-numbers language-shell\"><code class=\"language-shell\">[root@pvcent107 build]# cp -r testLargeFile largeFile &\n[1] 4825\n[root@pvcent107 build]# jobs\n[1]+  Running                 cp -i -r testLargeFile largeFile &\n[root@pvcent107 build]# disown -h %1\n[root@pvcent107 build]# ps -ef | grep largeFile\nroot      4825   968  1 09:46 pts/4    00:00:00 cp -i -r testLargeFile largeFile\nroot      4853   968  0 09:46 pts/4    00:00:00 grep largeFile\n[root@pvcent107 build]# logout\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>示例2：（如果提交命令时未使用 “&amp;” 将命令放入后台运行，可使用 CTRL-z 和 “bg” 将其放入后台，再使用 “disown”）</li>\n</ul>\n<pre class=\"line-numbers language-shell\"><code class=\"language-shell\">[root@pvcent107 build]# cp -r testLargeFile largeFile2\n\n[1]+  Stopped                 cp -i -r testLargeFile largeFile2\n[root@pvcent107 build]# bg %1\n[1]+ cp -i -r testLargeFile largeFile2 &\n[root@pvcent107 build]# jobs\n[1]+  Running                 cp -i -r testLargeFile largeFile2 &\n[root@pvcent107 build]# disown -h %1\n[root@pvcent107 build]# ps -ef | grep largeFile2\nroot      5790  5577  1 10:04 pts/3    00:00:00 cp -i -r testLargeFile largeFile2\nroot      5824  5577  0 10:05 pts/3    00:00:00 grep largeFile2\n[root@pvcent107 build]#\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"三、对于大量需要在后台稳定运行的任务：\"><a href=\"#三、对于大量需要在后台稳定运行的任务：\" class=\"headerlink\" title=\"三、对于大量需要在后台稳定运行的任务：\"></a>三、对于大量需要在后台稳定运行的任务：</h4><p><strong>1. screen 命令：</strong></p>\n<p>简单的说，<code>screen</code> 命令提供了 ANSI/VT100 的终端模拟器，使它能够在一个真实终端下运行多个全屏的伪终端。<code>screen</code> 命令的参数很多，具有很强大的功能，我们在此仅介绍其常用功能以及简要分析一下为什么使用 <code>screen</code> 能够避免 HUP 信号的影响。</p>\n<p>使用 screen 很方便，有以下几个常用选项：</p>\n<ul>\n<li>用 <code>screen -dmS &lt;session name&gt;</code> 来建立一个处于断开模式下的会话（并指定其会话名）；</li>\n<li>用 <code>screen -list</code> 来列出所有会话；</li>\n<li>用 <code>screen -r &lt;session name&gt;</code> 来重新连接指定会话；</li>\n<li>用快捷键 <code>CTRL-a d</code> 来暂时断开当前会话；</li>\n</ul>\n<ul>\n<li>示例：</li>\n</ul>\n<pre class=\"line-numbers language-shell\"><code class=\"language-shell\">[root@pvcent107 ~]# screen -dmS Urumchi\n[root@pvcent107 ~]# screen -list\nThere is a screen on:\n        12842.Urumchi   (Detached)\n1 Socket in /tmp/screens/S-root.\n\n[root@pvcent107 ~]# screen -r Urumchi\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>当我们用 “-r” 连接到 screen 会话后，我们就可以在这个伪终端里面做任何事情，再也不用担心 HUP 信号会对我们的进程造成影响，也不用给每个命令前都加上 “nohup” 或者 “setsid” 了。这是为什么呢？让我们来看一下这两个例子吧。</p>\n<ol>\n<li>未使用 <code>screen</code> 时新进程的进程树：</li>\n</ol>\n<pre class=\"line-numbers language-shell\"><code class=\"language-shell\">[root@pvcent107 ~]# ping www.google.com &\n[1] 9499\n[root@pvcent107 ~]# pstree -H 9499\ninit─┬─Xvnc` \n     ├─acpid` \n     ├─atd` \n     ├─2*[sendmail]    \n     **├─sshd─┬**─sshd───bash───pstree\n     │      ** └─sshd───bash───ping**\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>我们可以看出，未使用 <code>screen</code> 时我们所处的 bash 是 sshd 的子进程，当 ssh 断开连接时，HUP 信号自然会影响到它下面的所有子进程（包括我们新建立的 “ping” 进程）。</p>\n<ol start=\"2\">\n<li>使用了 <code>screen</code> 后新进程的进程树：</li>\n</ol>\n<pre class=\"line-numbers language-shell\"><code class=\"language-shell\">[root@pvcent107 ~]# screen -r Urumchi\n[root@pvcent107 ~]# ping www.ibm.com &\n[1] 9488\n[root@pvcent107 ~]# pstree -H 9488\ninit─┬─Xvnc\n     ├─acpid\n     ├─atd\n     **├─screen───bash───ping**\n     ├─2*[sendmail]\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>而使用了 <code>screen</code> 命令后就不同了，此时 bash 是 screen 的子进程，而 screen 是 init（PID 为1）的子进程。那么当 ssh 断开连接时，HUP 信号自然不会影响到 screen 下面的子进程了。</p>\n<p>本文转载整理自“IBM 开发者社区”，同时修正了原文中的几处错误，此处为 <strong><a href=\"http://www.ibm.com/developerworks/cn/linux/l-cn-nohup/#ibm-pcon\" target=\"_blank\" rel=\"noopener\">原文链接</a></strong>。</p>\n","site":{"data":{}},"id":"8f7b4e03fd65d033f06809403c7df729","excerpt":"","more":"<p>我们在日常的开发过程中，可能会经常手动的去执行一些脚本来整理数据或者进行一些统计性的任务。而在执行脚本时，我们通常是通过 SSH 终端来与 Linux/Unix 服务器进行连接的；同时我们也可以通过 SSH 终端来执行命令或启动远程服务器上相应的脚本任务。而这种连接通常来说是不稳定的。</p>\n<p>在这种“不稳定”的网络连接情况下，如果我们执行了一些耗时较长的任务或命令，则可能会由于 SSH 终端连接的关闭或者其他网络原因导致当前的任务或命令执行中断。而接下来我们要讨论的，便是如何去解决这个问题，使任务能够在 Linux 服务器的后台“默默”的运行，而不会受到终端的影响。以下我们将具体场景分为几种情况来进行讨论。</p>\n<h4 id=\"一、对于未运行的临时后台脚本任务：\"><a href=\"#一、对于未运行的临时后台脚本任务：\" class=\"headerlink\" title=\"一、对于未运行的临时后台脚本任务：\"></a>一、对于未运行的临时后台脚本任务：</h4><p><strong>1. nohub 命令：</strong></p>\n<p><code>nohup</code> 命令的使用是十分简单方便的，只需在要处理的命令前加上 <code>nohup</code> 即可，标准输出和标准错误缺省会被重定向到当前目录的 “nohup.out” 文件中，即该文件起到了监视日志的作用。一般我们可在结尾加上 <strong>“&amp;”</strong> 符号来将命令同时放入后台运行，同时也可以使用 <code>&quot;&gt;filename 2&gt;&amp;1&quot;</code> 来更改缺省的重定向文件名（0、1和2分别表示<strong>标准输入</strong>、<strong>标准输出</strong>和<strong>标准错误信息输出</strong>， <code>&gt;filename</code> 即将标准输出重定向到文件 “filename” 中， <code>2&gt;&amp;1</code>：即将错误信息重定向到标准输出）。用法示例如下：</p>\n<pre><code class=\"shell\">[root@pvcent107 ~]# nohup ping www.ibm.com &amp;\n[1] 3059\nnohup: appending output to &#39;nohup.out&#39;\n[root@pvcent107 ~]# ps -ef | grep 3059\nroot      3059   984  0 21:06 pts/3    00:00:00 ping www.ibm.com\nroot      3067   984  0 21:06 pts/3    00:00:00 grep 3059\n[root@pvcent107 ~]#\n</code></pre>\n<p><strong>2. setsid 命令：</strong></p>\n<p><strong>nohup</strong> 命令无疑能够通过忽略 HUP 信号来使我们的进程避免中途被中断。但我们可以换个角度思考，如果我们的进程<strong>不属于</strong>接受 HUP 信号的终端的子进程，那么自然也就不会受到 HUP 信号的影响了。<strong>setsid</strong> 命令就能帮助我们做到这一点。用法示例如下：</p>\n<pre><code class=\"shell\">[root@pvcent107 ~]# setsid ping www.ibm.com\n[root@pvcent107 ~]# ps -ef | grep www.ibm.com\nroot     31094     1  0 07:28 ?        00:00:00 ping www.ibm.com\nroot     31102 29217  0 07:29 pts/4    00:00:00 grep www.ibm.com\n[root@pvcent107 ~]#\n</code></pre>\n<p><strong>3. &amp; 操作符：</strong></p>\n<p>我们知道，将一个或多个命名包含在 “()” 中就能让这些命令在子 shell 中运行，从而扩展出很多有趣的功能，我们现在要讨论的就是其中之一。当我们将 “&amp;” 也放入 “()” 内之后，我们就会发现所提交的作业（jobs）并不在作业列表中，也就是说，该作业是无法通过 <code>jobs</code> 命令来查看的。用法示例：</p>\n<pre><code class=\"text\">[root@pvcent107 ~]# (ping www.ibm.com &amp;)\n[root@pvcent107 ~]# ps -ef | grep www.ibm.com\nroot     16270     1  0 14:13 pts/4    00:00:00 ping www.ibm.com\nroot     16278 15362  0 14:13 pts/4    00:00:00 grep www.ibm.com\n[root@pvcent107 ~]#\n</code></pre>\n<p>从上例中可以看出，新提交的进程的父 ID（PPID）为1（即 <strong>init</strong> 进程的 PID），并不是当前终端的进程 ID。因此并不属于当前终端的子进程，从而也就不会受到当前终端的 HUP 信号的影响了。</p>\n<h4 id=\"二、对于已经提交并正在运行中的任务：\"><a href=\"#二、对于已经提交并正在运行中的任务：\" class=\"headerlink\" title=\"二、对于已经提交并正在运行中的任务：\"></a>二、对于已经提交并正在运行中的任务：</h4><p><strong>1. disown 命令：</strong></p>\n<p>这时想利用 <code>nohup</code> 命令或者 <code>setsid</code> 命令已经为时已晚，只能通过作业调度和 <code>disown</code> 命令来解决这个问题了。</p>\n<p><strong>disown</strong> 命令有三种常用的操作方式：</p>\n<ul>\n<li>用 <code>disown -h &lt;jobspec&gt;</code> 来使<strong>某个作业</strong>忽略 HUP 信号；</li>\n<li>用 <code>disown -ah</code> 来使<strong>所有的作业</strong>都忽略 HUP 信号；</li>\n<li>用 <code>disown -rh</code> 来使<strong>正在运行的作业</strong>忽略 HUP 信号；</li>\n</ul>\n<p>需要注意的是，当使用过 <code>disown</code> 命令后，会把目标作业从作业列表中移除，我们将不再能够使用 <code>jobs</code> 命令来查看它，但是依然能够用 <code>ps -ef</code> 命令查找到它。</p>\n<p>但是还有一个问题，这种方法的操作对象是作业，如果我们在运行命令时在结尾加了 <strong>“&amp;”</strong> 来使它成为一个作业并在后台运行，那么就万事大吉了，我们可以通过 <code>jobs</code> 命令来得到所有作业的列表。但是如果并没有把当前命令作为作业来运行，如何才能得到它的作业号呢？答案就是用 CTRL-z（按住 Ctrl 键的同时按住 z 键）！</p>\n<p>“CTRL-z” 的用途就是将当前进程挂起（Suspend），然后我们就可以用 <code>jobs</code> 命令来查询它的作业号，再用 <code>bg &lt;jobspec&gt;</code> 来将它放入后台并继续运行。需要注意的是，如果挂起会影响当前进程的运行结果，请慎用此方法。</p>\n<ul>\n<li>示例1：（如果提交命令时已经用 “&amp;” 将命令放入后台运行，则可以直接使用 “disown”）</li>\n</ul>\n<pre><code class=\"shell\">[root@pvcent107 build]# cp -r testLargeFile largeFile &amp;\n[1] 4825\n[root@pvcent107 build]# jobs\n[1]+  Running                 cp -i -r testLargeFile largeFile &amp;\n[root@pvcent107 build]# disown -h %1\n[root@pvcent107 build]# ps -ef | grep largeFile\nroot      4825   968  1 09:46 pts/4    00:00:00 cp -i -r testLargeFile largeFile\nroot      4853   968  0 09:46 pts/4    00:00:00 grep largeFile\n[root@pvcent107 build]# logout\n</code></pre>\n<ul>\n<li>示例2：（如果提交命令时未使用 “&amp;” 将命令放入后台运行，可使用 CTRL-z 和 “bg” 将其放入后台，再使用 “disown”）</li>\n</ul>\n<pre><code class=\"shell\">[root@pvcent107 build]# cp -r testLargeFile largeFile2\n\n[1]+  Stopped                 cp -i -r testLargeFile largeFile2\n[root@pvcent107 build]# bg %1\n[1]+ cp -i -r testLargeFile largeFile2 &amp;\n[root@pvcent107 build]# jobs\n[1]+  Running                 cp -i -r testLargeFile largeFile2 &amp;\n[root@pvcent107 build]# disown -h %1\n[root@pvcent107 build]# ps -ef | grep largeFile2\nroot      5790  5577  1 10:04 pts/3    00:00:00 cp -i -r testLargeFile largeFile2\nroot      5824  5577  0 10:05 pts/3    00:00:00 grep largeFile2\n[root@pvcent107 build]#\n</code></pre>\n<h4 id=\"三、对于大量需要在后台稳定运行的任务：\"><a href=\"#三、对于大量需要在后台稳定运行的任务：\" class=\"headerlink\" title=\"三、对于大量需要在后台稳定运行的任务：\"></a>三、对于大量需要在后台稳定运行的任务：</h4><p><strong>1. screen 命令：</strong></p>\n<p>简单的说，<code>screen</code> 命令提供了 ANSI/VT100 的终端模拟器，使它能够在一个真实终端下运行多个全屏的伪终端。<code>screen</code> 命令的参数很多，具有很强大的功能，我们在此仅介绍其常用功能以及简要分析一下为什么使用 <code>screen</code> 能够避免 HUP 信号的影响。</p>\n<p>使用 screen 很方便，有以下几个常用选项：</p>\n<ul>\n<li>用 <code>screen -dmS &lt;session name&gt;</code> 来建立一个处于断开模式下的会话（并指定其会话名）；</li>\n<li>用 <code>screen -list</code> 来列出所有会话；</li>\n<li>用 <code>screen -r &lt;session name&gt;</code> 来重新连接指定会话；</li>\n<li>用快捷键 <code>CTRL-a d</code> 来暂时断开当前会话；</li>\n</ul>\n<ul>\n<li>示例：</li>\n</ul>\n<pre><code class=\"shell\">[root@pvcent107 ~]# screen -dmS Urumchi\n[root@pvcent107 ~]# screen -list\nThere is a screen on:\n        12842.Urumchi   (Detached)\n1 Socket in /tmp/screens/S-root.\n\n[root@pvcent107 ~]# screen -r Urumchi\n</code></pre>\n<p>当我们用 “-r” 连接到 screen 会话后，我们就可以在这个伪终端里面做任何事情，再也不用担心 HUP 信号会对我们的进程造成影响，也不用给每个命令前都加上 “nohup” 或者 “setsid” 了。这是为什么呢？让我们来看一下这两个例子吧。</p>\n<ol>\n<li>未使用 <code>screen</code> 时新进程的进程树：</li>\n</ol>\n<pre><code class=\"shell\">[root@pvcent107 ~]# ping www.google.com &amp;\n[1] 9499\n[root@pvcent107 ~]# pstree -H 9499\ninit─┬─Xvnc` \n     ├─acpid` \n     ├─atd` \n     ├─2*[sendmail]    \n     **├─sshd─┬**─sshd───bash───pstree\n     │      ** └─sshd───bash───ping**\n</code></pre>\n<p>我们可以看出，未使用 <code>screen</code> 时我们所处的 bash 是 sshd 的子进程，当 ssh 断开连接时，HUP 信号自然会影响到它下面的所有子进程（包括我们新建立的 “ping” 进程）。</p>\n<ol start=\"2\">\n<li>使用了 <code>screen</code> 后新进程的进程树：</li>\n</ol>\n<pre><code class=\"shell\">[root@pvcent107 ~]# screen -r Urumchi\n[root@pvcent107 ~]# ping www.ibm.com &amp;\n[1] 9488\n[root@pvcent107 ~]# pstree -H 9488\ninit─┬─Xvnc\n     ├─acpid\n     ├─atd\n     **├─screen───bash───ping**\n     ├─2*[sendmail]\n</code></pre>\n<p>而使用了 <code>screen</code> 命令后就不同了，此时 bash 是 screen 的子进程，而 screen 是 init（PID 为1）的子进程。那么当 ssh 断开连接时，HUP 信号自然不会影响到 screen 下面的子进程了。</p>\n<p>本文转载整理自“IBM 开发者社区”，同时修正了原文中的几处错误，此处为 <strong><a href=\"http://www.ibm.com/developerworks/cn/linux/l-cn-nohup/#ibm-pcon\" target=\"_blank\" rel=\"noopener\">原文链接</a></strong>。</p>\n"},{"title":"Promise 浅谈","intro":"Promise A+ 规范表面上解决了在 JavaScript 中异步调用过多会产生“回调地狱”的问题。但实际上，Promise 的核心思想，是回调函数控制机制的改变。以往的回调函数是被动的放在被调用的异步请求中，但基于 Promise 的规范，我们可以先获得一个“通知”，然后再根据情况进行处理。","comments":1,"date":"2016-12-22T03:55:41.000Z","_content":"\nPromise A+ 规范表面上解决了在 JavaScript 中异步调用过多会产生“回调地狱”的问题。但实际上，Promise 的核心思想，是回调函数控制机制的改变。以往的回调函数是被动的放在被调用的异步请求中，但基于 Promise 的规范，我们可以先获得一个“通知”，然后再根据情况进行处理。\n\n传统的基于 Promise 的异步函数可以用如下方式来编写，构造出的对象为 thenable 对象，该对象可以直接被 Promise 调用，并返回一个 Promise 对象。批判性地看，Promises 所做的只是改变了你传递回调的地方。但由于 Promise 是一个有限状态机，因此我们可预见的结果只有 resolve 和 reject 两种情况，相比较之前回调函数的各种不确定性（回调被调用了几次？是否返回了正确的参数？返回参数是否可以认为本次回调已经完成？），我们在 Promise 中进行处理会保证回调的可靠性。\n\n\n```javascript\n// 构建异步方法，使用基于 PromiseA+ 的思想构建；\nfunction myAsyncFunc() {\n  this.i = 0;\n}\n\n// 该方法对象为一个 thenable 对象，可以被 Promise.resolve 转换成一个 Promise 对象；\nmyAsyncFunc.prototype.then = function(resolve, reject) {\n  this.main(resolve, reject);\n}\n\n// 该异步方法的主要逻辑；\nmyAsyncFunc.prototype.main = function(resolve, reject) {\n  var self = this;\n  setTimeout(function() {\n    // 处理业务逻辑；\n    self.i = self.i + 100;\n    resolve(self.i);\n  }, 2000);\n}\n\n// 使用 Promise 处理异步事务；\nPromise.resolve(new myAsyncFunc()).then(function(data) {\n// 获得通知，调用其他异步方法继续处理数据；\n  return new Promise(function(resolve, reject) {\n    setTimeout(function() {\n      // 处理接下来的异步业务逻辑；\n      resolve(++data);\n    }, 2000);\n  });\n}).then(function(data) {\n  console.log(data);\n}).catch(function(err) {\n  // 通知被拒，或发生异常时在此处理；\n  console.error(err);\n});\n```\n\nPromise 可靠性的另一个保障的机制是 Promise A+本身规范的准则：\n\n1. 如果 Promise 被 resolve，它要不是 success 就是 failure，不可能同时存在；\n2. 一旦 Promise 被 resolve，它就再也不会被再次 resolve (不会出现重复调用)；\n3. 如果 Promise 返回了成功的信息，那么你绑定在成功事件上的回调会得到这个消息；\n4. 如果发生了错误，Promise 会收到一个带有错误信息的错误通知；\n5. 无论 Promise 最后的结果是什么（success / failure），他都不会改变了。而你总是可以获得这个消息只要你不销毁该 Promise；\n\n使用 Promises 是基于可靠性的。可靠性是：**基于 Promise 的状态是与外部影响隔离的，只有创建者能够改变**。在 ES6 的规范中，Promise 被规定为一个类，因此它可以被继承并实例化。但同样的规范放在 ES5 以前的环境下是无法做到的（保证一个 Promise 对象的 state 为私有属性）。\n\n怎样解决？在 ES5 以下的环境中我们可以使用一个类似 ES6 的 WeakMap 结构来实现对所有 Promise 状态的全局引用，示例代码如下。但由于 WeakMap 的强引用机制，这种用法非常容易导致内存泄漏。\n\n\n```javascript\nvar MyPromise = function() {\n  // 初始化每个实例的状态（resolve, reject）；\n  this.statsMap.set(this, 0);\t\n}\n// 绑定一个全局的状态列表；\nMyPromise.prototype.statsMap = new WeakMap();\n\n// 构建方法；\nMyPromise.prototype.then = function(cb_resolve, cb_reject) {\n  if (this.statsMap.get(this) === 1) {\n    cb_resolve && cb_resolve.call(this, \"This is a resolved callback.\");\n  } else if(this.statsMap.get(this) === 0) {\n    cb_reject && cb_reject.call(this, \"This is a rejected callback.\");\n  }\n}\n\nMyPromise.prototype.showStatsMap = function() {\n  console.log(this.statsMap);\n}\n```\n","source":"_posts/Promise-浅谈.md","raw":"---\ntitle: Promise 浅谈\nintro: Promise A+ 规范表面上解决了在 JavaScript 中异步调用过多会产生“回调地狱”的问题。但实际上，Promise 的核心思想，是回调函数控制机制的改变。以往的回调函数是被动的放在被调用的异步请求中，但基于 Promise 的规范，我们可以先获得一个“通知”，然后再根据情况进行处理。\ncomments: true\ndate: 2016-12-22 11:55:41\ntags:\n- JavaScript\n---\n\nPromise A+ 规范表面上解决了在 JavaScript 中异步调用过多会产生“回调地狱”的问题。但实际上，Promise 的核心思想，是回调函数控制机制的改变。以往的回调函数是被动的放在被调用的异步请求中，但基于 Promise 的规范，我们可以先获得一个“通知”，然后再根据情况进行处理。\n\n传统的基于 Promise 的异步函数可以用如下方式来编写，构造出的对象为 thenable 对象，该对象可以直接被 Promise 调用，并返回一个 Promise 对象。批判性地看，Promises 所做的只是改变了你传递回调的地方。但由于 Promise 是一个有限状态机，因此我们可预见的结果只有 resolve 和 reject 两种情况，相比较之前回调函数的各种不确定性（回调被调用了几次？是否返回了正确的参数？返回参数是否可以认为本次回调已经完成？），我们在 Promise 中进行处理会保证回调的可靠性。\n\n\n```javascript\n// 构建异步方法，使用基于 PromiseA+ 的思想构建；\nfunction myAsyncFunc() {\n  this.i = 0;\n}\n\n// 该方法对象为一个 thenable 对象，可以被 Promise.resolve 转换成一个 Promise 对象；\nmyAsyncFunc.prototype.then = function(resolve, reject) {\n  this.main(resolve, reject);\n}\n\n// 该异步方法的主要逻辑；\nmyAsyncFunc.prototype.main = function(resolve, reject) {\n  var self = this;\n  setTimeout(function() {\n    // 处理业务逻辑；\n    self.i = self.i + 100;\n    resolve(self.i);\n  }, 2000);\n}\n\n// 使用 Promise 处理异步事务；\nPromise.resolve(new myAsyncFunc()).then(function(data) {\n// 获得通知，调用其他异步方法继续处理数据；\n  return new Promise(function(resolve, reject) {\n    setTimeout(function() {\n      // 处理接下来的异步业务逻辑；\n      resolve(++data);\n    }, 2000);\n  });\n}).then(function(data) {\n  console.log(data);\n}).catch(function(err) {\n  // 通知被拒，或发生异常时在此处理；\n  console.error(err);\n});\n```\n\nPromise 可靠性的另一个保障的机制是 Promise A+本身规范的准则：\n\n1. 如果 Promise 被 resolve，它要不是 success 就是 failure，不可能同时存在；\n2. 一旦 Promise 被 resolve，它就再也不会被再次 resolve (不会出现重复调用)；\n3. 如果 Promise 返回了成功的信息，那么你绑定在成功事件上的回调会得到这个消息；\n4. 如果发生了错误，Promise 会收到一个带有错误信息的错误通知；\n5. 无论 Promise 最后的结果是什么（success / failure），他都不会改变了。而你总是可以获得这个消息只要你不销毁该 Promise；\n\n使用 Promises 是基于可靠性的。可靠性是：**基于 Promise 的状态是与外部影响隔离的，只有创建者能够改变**。在 ES6 的规范中，Promise 被规定为一个类，因此它可以被继承并实例化。但同样的规范放在 ES5 以前的环境下是无法做到的（保证一个 Promise 对象的 state 为私有属性）。\n\n怎样解决？在 ES5 以下的环境中我们可以使用一个类似 ES6 的 WeakMap 结构来实现对所有 Promise 状态的全局引用，示例代码如下。但由于 WeakMap 的强引用机制，这种用法非常容易导致内存泄漏。\n\n\n```javascript\nvar MyPromise = function() {\n  // 初始化每个实例的状态（resolve, reject）；\n  this.statsMap.set(this, 0);\t\n}\n// 绑定一个全局的状态列表；\nMyPromise.prototype.statsMap = new WeakMap();\n\n// 构建方法；\nMyPromise.prototype.then = function(cb_resolve, cb_reject) {\n  if (this.statsMap.get(this) === 1) {\n    cb_resolve && cb_resolve.call(this, \"This is a resolved callback.\");\n  } else if(this.statsMap.get(this) === 0) {\n    cb_reject && cb_reject.call(this, \"This is a rejected callback.\");\n  }\n}\n\nMyPromise.prototype.showStatsMap = function() {\n  console.log(this.statsMap);\n}\n```\n","slug":"Promise-浅谈","published":1,"updated":"2019-02-12T03:46:15.597Z","layout":"post","photos":[],"link":"","_id":"cjsqwht9p0032knp2uf37ds8z","content":"<p>Promise A+ 规范表面上解决了在 JavaScript 中异步调用过多会产生“回调地狱”的问题。但实际上，Promise 的核心思想，是回调函数控制机制的改变。以往的回调函数是被动的放在被调用的异步请求中，但基于 Promise 的规范，我们可以先获得一个“通知”，然后再根据情况进行处理。</p>\n<p>传统的基于 Promise 的异步函数可以用如下方式来编写，构造出的对象为 thenable 对象，该对象可以直接被 Promise 调用，并返回一个 Promise 对象。批判性地看，Promises 所做的只是改变了你传递回调的地方。但由于 Promise 是一个有限状态机，因此我们可预见的结果只有 resolve 和 reject 两种情况，相比较之前回调函数的各种不确定性（回调被调用了几次？是否返回了正确的参数？返回参数是否可以认为本次回调已经完成？），我们在 Promise 中进行处理会保证回调的可靠性。</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">// 构建异步方法，使用基于 PromiseA+ 的思想构建；</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">myAsyncFunc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 该方法对象为一个 thenable 对象，可以被 Promise.resolve 转换成一个 Promise 对象；</span>\nmyAsyncFunc<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>then <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">main</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 该异步方法的主要逻辑；</span>\nmyAsyncFunc<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>main <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> self <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 处理业务逻辑；</span>\n    self<span class=\"token punctuation\">.</span>i <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>i <span class=\"token operator\">+</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 使用 Promise 处理异步事务；</span>\nPromise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">myAsyncFunc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token comment\" spellcheck=\"true\">// 获得通知，调用其他异步方法继续处理数据；</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 处理接下来的异步业务逻辑；</span>\n      <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token operator\">++</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 通知被拒，或发生异常时在此处理；</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>Promise 可靠性的另一个保障的机制是 Promise A+本身规范的准则：</p>\n<ol>\n<li>如果 Promise 被 resolve，它要不是 success 就是 failure，不可能同时存在；</li>\n<li>一旦 Promise 被 resolve，它就再也不会被再次 resolve (不会出现重复调用)；</li>\n<li>如果 Promise 返回了成功的信息，那么你绑定在成功事件上的回调会得到这个消息；</li>\n<li>如果发生了错误，Promise 会收到一个带有错误信息的错误通知；</li>\n<li>无论 Promise 最后的结果是什么（success / failure），他都不会改变了。而你总是可以获得这个消息只要你不销毁该 Promise；</li>\n</ol>\n<p>使用 Promises 是基于可靠性的。可靠性是：<strong>基于 Promise 的状态是与外部影响隔离的，只有创建者能够改变</strong>。在 ES6 的规范中，Promise 被规定为一个类，因此它可以被继承并实例化。但同样的规范放在 ES5 以前的环境下是无法做到的（保证一个 Promise 对象的 state 为私有属性）。</p>\n<p>怎样解决？在 ES5 以下的环境中我们可以使用一个类似 ES6 的 WeakMap 结构来实现对所有 Promise 状态的全局引用，示例代码如下。但由于 WeakMap 的强引用机制，这种用法非常容易导致内存泄漏。</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> MyPromise <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 初始化每个实例的状态（resolve, reject）；</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>statsMap<span class=\"token punctuation\">.</span><span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    \n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">// 绑定一个全局的状态列表；</span>\nMyPromise<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>statsMap <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">WeakMap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 构建方法；</span>\nMyPromise<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>then <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>cb_resolve<span class=\"token punctuation\">,</span> cb_reject<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>statsMap<span class=\"token punctuation\">.</span><span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    cb_resolve <span class=\"token operator\">&amp;&amp;</span> cb_resolve<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"This is a resolved callback.\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>statsMap<span class=\"token punctuation\">.</span><span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    cb_reject <span class=\"token operator\">&amp;&amp;</span> cb_reject<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"This is a rejected callback.\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\nMyPromise<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>showStatsMap <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>statsMap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"id":"1b3988e1295c102c016ec4c04542c275","excerpt":"","more":"<p>Promise A+ 规范表面上解决了在 JavaScript 中异步调用过多会产生“回调地狱”的问题。但实际上，Promise 的核心思想，是回调函数控制机制的改变。以往的回调函数是被动的放在被调用的异步请求中，但基于 Promise 的规范，我们可以先获得一个“通知”，然后再根据情况进行处理。</p>\n<p>传统的基于 Promise 的异步函数可以用如下方式来编写，构造出的对象为 thenable 对象，该对象可以直接被 Promise 调用，并返回一个 Promise 对象。批判性地看，Promises 所做的只是改变了你传递回调的地方。但由于 Promise 是一个有限状态机，因此我们可预见的结果只有 resolve 和 reject 两种情况，相比较之前回调函数的各种不确定性（回调被调用了几次？是否返回了正确的参数？返回参数是否可以认为本次回调已经完成？），我们在 Promise 中进行处理会保证回调的可靠性。</p>\n<pre><code class=\"javascript\">// 构建异步方法，使用基于 PromiseA+ 的思想构建；\nfunction myAsyncFunc() {\n  this.i = 0;\n}\n\n// 该方法对象为一个 thenable 对象，可以被 Promise.resolve 转换成一个 Promise 对象；\nmyAsyncFunc.prototype.then = function(resolve, reject) {\n  this.main(resolve, reject);\n}\n\n// 该异步方法的主要逻辑；\nmyAsyncFunc.prototype.main = function(resolve, reject) {\n  var self = this;\n  setTimeout(function() {\n    // 处理业务逻辑；\n    self.i = self.i + 100;\n    resolve(self.i);\n  }, 2000);\n}\n\n// 使用 Promise 处理异步事务；\nPromise.resolve(new myAsyncFunc()).then(function(data) {\n// 获得通知，调用其他异步方法继续处理数据；\n  return new Promise(function(resolve, reject) {\n    setTimeout(function() {\n      // 处理接下来的异步业务逻辑；\n      resolve(++data);\n    }, 2000);\n  });\n}).then(function(data) {\n  console.log(data);\n}).catch(function(err) {\n  // 通知被拒，或发生异常时在此处理；\n  console.error(err);\n});\n</code></pre>\n<p>Promise 可靠性的另一个保障的机制是 Promise A+本身规范的准则：</p>\n<ol>\n<li>如果 Promise 被 resolve，它要不是 success 就是 failure，不可能同时存在；</li>\n<li>一旦 Promise 被 resolve，它就再也不会被再次 resolve (不会出现重复调用)；</li>\n<li>如果 Promise 返回了成功的信息，那么你绑定在成功事件上的回调会得到这个消息；</li>\n<li>如果发生了错误，Promise 会收到一个带有错误信息的错误通知；</li>\n<li>无论 Promise 最后的结果是什么（success / failure），他都不会改变了。而你总是可以获得这个消息只要你不销毁该 Promise；</li>\n</ol>\n<p>使用 Promises 是基于可靠性的。可靠性是：<strong>基于 Promise 的状态是与外部影响隔离的，只有创建者能够改变</strong>。在 ES6 的规范中，Promise 被规定为一个类，因此它可以被继承并实例化。但同样的规范放在 ES5 以前的环境下是无法做到的（保证一个 Promise 对象的 state 为私有属性）。</p>\n<p>怎样解决？在 ES5 以下的环境中我们可以使用一个类似 ES6 的 WeakMap 结构来实现对所有 Promise 状态的全局引用，示例代码如下。但由于 WeakMap 的强引用机制，这种用法非常容易导致内存泄漏。</p>\n<pre><code class=\"javascript\">var MyPromise = function() {\n  // 初始化每个实例的状态（resolve, reject）；\n  this.statsMap.set(this, 0);    \n}\n// 绑定一个全局的状态列表；\nMyPromise.prototype.statsMap = new WeakMap();\n\n// 构建方法；\nMyPromise.prototype.then = function(cb_resolve, cb_reject) {\n  if (this.statsMap.get(this) === 1) {\n    cb_resolve &amp;&amp; cb_resolve.call(this, &quot;This is a resolved callback.&quot;);\n  } else if(this.statsMap.get(this) === 0) {\n    cb_reject &amp;&amp; cb_reject.call(this, &quot;This is a rejected callback.&quot;);\n  }\n}\n\nMyPromise.prototype.showStatsMap = function() {\n  console.log(this.statsMap);\n}\n</code></pre>\n"},{"title":"PureRenderMixin & immutable.js 提高 VDOM 渲染效率","intro":"最近用了一段时间的 Reactjs，其实大部分前端框架的核心原理都很相似，包括响应式、足够轻量级、基于 Virtual-DOM 等特性。从整体上来看，Vuejs 是基于模版进行应用构建的，在中小型应用中有一定的优势。而 Reactjs 则需要我们在 JavaScript 中使用 JSX 手动的来创建 DOM。","comments":1,"date":"2017-05-18T08:04:49.000Z","_content":"\n\n最近用了一段时间的 Reactjs，其实大部分前端框架的核心原理都很相似，包括响应式、足够轻量级、基于 Virtual-DOM 等特性。从整体上来看，Vuejs 是基于模版进行应用构建的，在中小型应用中有一定的优势。而 Reactjs 则需要我们在 JavaScript 中使用 JSX 手动的来创建 DOM。\n\n开始一个新的 Reactjs 项目，我们通过自动化的脚手架创建工具 [create-react-app](https://github.com/facebookincubator/create-react-app) 来创建一个初始化的全新 Reactjs 工程。\n\nReactjs 本身通过计算 Virtual DOM 之间的差异（Diff）来更新 UI 组件。每当 `props` 或者 `state` 改变时，Reactjs 会重新计算生成一个 Virtual DOM 对象，并且通过比较两个 VD 对象之间的差异来找出数据改变引起对应在 UI 上的差异，最后采用最小的成本来更新 UI。在纯函数组件（同样的数据对应同样的 UI）下，对于相同的 `props` 和 `state`，其对应的 UI 显示应该是相同的。因此，当传递给组件的 `props` 或者 `state` 的改变与之前相同时，Reactjs 可以完全省略掉此时对组件 VD 的 Diff 计算，这在某种程度上可以提高 Reactjs 组件的渲染性能。为此，Reactjs 为我们提供了扩展的插件（Addon）“PureRenderMixin” 来解决这个问题。\n\n\n```javascript\nimport PureRenderMixin from 'react-addons-pure-render-mixin';\nclass FooComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.shouldComponentUpdate = PureRenderMixin.shouldComponentUpdate.bind(this);\n  }\n\n  render() {\n    return <div className={this.props.className}>foo</div>;\n  }\n}\n```\n\n“PureRenderMixin” 的原理就是它实现了 `shouldComponentUpdate`。在 `shouldComponentUpdate` 内部，它比较当前的 `props` 和 `state` 和接下来的 `props` 以及 `state`，当两者相等的时候返回 `false`，这样组件就不会进行 Virtual DOM 上的 Diff 计算了。但 “PureRenderMixin” 仅进行简单的浅比较，对简单数据类型有效，如果需要对复杂数据类型进行比较来决定是否需要更新 UI，则需要从另一方面来考虑比较两个复杂数据结构所花费的成本和构建 VD 计算 Diff 所花费的成本哪个更大了。如果一定需要对复杂结构的数据来进行差异比较，也可以使用 immutable.js 来帮助我们提高性能。\n\n总的来说，immutable.js 可以帮助我们提高深拷贝的性能，也即在深度比较两个复杂数据类型时会有更高的性能。immutable.js 提供了7种数据结构，并且这些数据结构均是“不可变数据”，即操作改变这些元素的值时会返回一个新的元素，而原先元素的值不受影响。不仅如此，immutable.js 基于“哈希映射树”和“向量映射树”，在克隆一个数据结构时只会克隆改变的节点以及该节点的所有子节点，因此对于其上层的父节点可以得到完全的复用，这样也可以大大提高“深拷贝”的效率。\n\n![](1.gif)\n\n\n```javascript\nshouldComponentUpdate: function(nextProps, nextState) {\n  return deepCompare(this, nextProps, nextState);\n},\n\n...\n\nfunction deepCompare(instance, nextProps, nextState) {\n  return !Immutable.is(instance.props, nextProps) || !Immutable.is(instance.state, nextState);\n}\n```\n\n但使用 immutable.js 也有相对应以下几点的缺点与不足：\n\n1. 导致最后打包编译的源码体积增大；\n2. immutable.js 的数据类型在与服务器进行交互时需要转换成基础的 JavaScript 数据类型\n","source":"_posts/PureRenderMixin-immutable-js-提高-VDOM-渲染效率.md","raw":"---\ntitle: PureRenderMixin & immutable.js 提高 VDOM 渲染效率\nintro: 最近用了一段时间的 Reactjs，其实大部分前端框架的核心原理都很相似，包括响应式、足够轻量级、基于 Virtual-DOM 等特性。从整体上来看，Vuejs 是基于模版进行应用构建的，在中小型应用中有一定的优势。而 Reactjs 则需要我们在 JavaScript 中使用 JSX 手动的来创建 DOM。\ncomments: true\ndate: 2017-05-18 16:04:49\ntags:\n- React\n---\n\n\n最近用了一段时间的 Reactjs，其实大部分前端框架的核心原理都很相似，包括响应式、足够轻量级、基于 Virtual-DOM 等特性。从整体上来看，Vuejs 是基于模版进行应用构建的，在中小型应用中有一定的优势。而 Reactjs 则需要我们在 JavaScript 中使用 JSX 手动的来创建 DOM。\n\n开始一个新的 Reactjs 项目，我们通过自动化的脚手架创建工具 [create-react-app](https://github.com/facebookincubator/create-react-app) 来创建一个初始化的全新 Reactjs 工程。\n\nReactjs 本身通过计算 Virtual DOM 之间的差异（Diff）来更新 UI 组件。每当 `props` 或者 `state` 改变时，Reactjs 会重新计算生成一个 Virtual DOM 对象，并且通过比较两个 VD 对象之间的差异来找出数据改变引起对应在 UI 上的差异，最后采用最小的成本来更新 UI。在纯函数组件（同样的数据对应同样的 UI）下，对于相同的 `props` 和 `state`，其对应的 UI 显示应该是相同的。因此，当传递给组件的 `props` 或者 `state` 的改变与之前相同时，Reactjs 可以完全省略掉此时对组件 VD 的 Diff 计算，这在某种程度上可以提高 Reactjs 组件的渲染性能。为此，Reactjs 为我们提供了扩展的插件（Addon）“PureRenderMixin” 来解决这个问题。\n\n\n```javascript\nimport PureRenderMixin from 'react-addons-pure-render-mixin';\nclass FooComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.shouldComponentUpdate = PureRenderMixin.shouldComponentUpdate.bind(this);\n  }\n\n  render() {\n    return <div className={this.props.className}>foo</div>;\n  }\n}\n```\n\n“PureRenderMixin” 的原理就是它实现了 `shouldComponentUpdate`。在 `shouldComponentUpdate` 内部，它比较当前的 `props` 和 `state` 和接下来的 `props` 以及 `state`，当两者相等的时候返回 `false`，这样组件就不会进行 Virtual DOM 上的 Diff 计算了。但 “PureRenderMixin” 仅进行简单的浅比较，对简单数据类型有效，如果需要对复杂数据类型进行比较来决定是否需要更新 UI，则需要从另一方面来考虑比较两个复杂数据结构所花费的成本和构建 VD 计算 Diff 所花费的成本哪个更大了。如果一定需要对复杂结构的数据来进行差异比较，也可以使用 immutable.js 来帮助我们提高性能。\n\n总的来说，immutable.js 可以帮助我们提高深拷贝的性能，也即在深度比较两个复杂数据类型时会有更高的性能。immutable.js 提供了7种数据结构，并且这些数据结构均是“不可变数据”，即操作改变这些元素的值时会返回一个新的元素，而原先元素的值不受影响。不仅如此，immutable.js 基于“哈希映射树”和“向量映射树”，在克隆一个数据结构时只会克隆改变的节点以及该节点的所有子节点，因此对于其上层的父节点可以得到完全的复用，这样也可以大大提高“深拷贝”的效率。\n\n![](1.gif)\n\n\n```javascript\nshouldComponentUpdate: function(nextProps, nextState) {\n  return deepCompare(this, nextProps, nextState);\n},\n\n...\n\nfunction deepCompare(instance, nextProps, nextState) {\n  return !Immutable.is(instance.props, nextProps) || !Immutable.is(instance.state, nextState);\n}\n```\n\n但使用 immutable.js 也有相对应以下几点的缺点与不足：\n\n1. 导致最后打包编译的源码体积增大；\n2. immutable.js 的数据类型在与服务器进行交互时需要转换成基础的 JavaScript 数据类型\n","slug":"PureRenderMixin-immutable-js-提高-VDOM-渲染效率","published":1,"updated":"2019-02-18T02:12:26.232Z","layout":"post","photos":[],"link":"","_id":"cjsqwht9q0035knp2a0bczrk2","content":"<p>最近用了一段时间的 Reactjs，其实大部分前端框架的核心原理都很相似，包括响应式、足够轻量级、基于 Virtual-DOM 等特性。从整体上来看，Vuejs 是基于模版进行应用构建的，在中小型应用中有一定的优势。而 Reactjs 则需要我们在 JavaScript 中使用 JSX 手动的来创建 DOM。</p>\n<p>开始一个新的 Reactjs 项目，我们通过自动化的脚手架创建工具 <a href=\"https://github.com/facebookincubator/create-react-app\" target=\"_blank\" rel=\"noopener\">create-react-app</a> 来创建一个初始化的全新 Reactjs 工程。</p>\n<p>Reactjs 本身通过计算 Virtual DOM 之间的差异（Diff）来更新 UI 组件。每当 <code>props</code> 或者 <code>state</code> 改变时，Reactjs 会重新计算生成一个 Virtual DOM 对象，并且通过比较两个 VD 对象之间的差异来找出数据改变引起对应在 UI 上的差异，最后采用最小的成本来更新 UI。在纯函数组件（同样的数据对应同样的 UI）下，对于相同的 <code>props</code> 和 <code>state</code>，其对应的 UI 显示应该是相同的。因此，当传递给组件的 <code>props</code> 或者 <code>state</code> 的改变与之前相同时，Reactjs 可以完全省略掉此时对组件 VD 的 Diff 计算，这在某种程度上可以提高 Reactjs 组件的渲染性能。为此，Reactjs 为我们提供了扩展的插件（Addon）“PureRenderMixin” 来解决这个问题。</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">import</span> PureRenderMixin <span class=\"token keyword\">from</span> <span class=\"token string\">'react-addons-pure-render-mixin'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">FooComponent</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>shouldComponentUpdate <span class=\"token operator\">=</span> PureRenderMixin<span class=\"token punctuation\">.</span>shouldComponentUpdate<span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>div className<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>className<span class=\"token punctuation\">}</span><span class=\"token operator\">></span>foo<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>“PureRenderMixin” 的原理就是它实现了 <code>shouldComponentUpdate</code>。在 <code>shouldComponentUpdate</code> 内部，它比较当前的 <code>props</code> 和 <code>state</code> 和接下来的 <code>props</code> 以及 <code>state</code>，当两者相等的时候返回 <code>false</code>，这样组件就不会进行 Virtual DOM 上的 Diff 计算了。但 “PureRenderMixin” 仅进行简单的浅比较，对简单数据类型有效，如果需要对复杂数据类型进行比较来决定是否需要更新 UI，则需要从另一方面来考虑比较两个复杂数据结构所花费的成本和构建 VD 计算 Diff 所花费的成本哪个更大了。如果一定需要对复杂结构的数据来进行差异比较，也可以使用 immutable.js 来帮助我们提高性能。</p>\n<p>总的来说，immutable.js 可以帮助我们提高深拷贝的性能，也即在深度比较两个复杂数据类型时会有更高的性能。immutable.js 提供了7种数据结构，并且这些数据结构均是“不可变数据”，即操作改变这些元素的值时会返回一个新的元素，而原先元素的值不受影响。不仅如此，immutable.js 基于“哈希映射树”和“向量映射树”，在克隆一个数据结构时只会克隆改变的节点以及该节点的所有子节点，因此对于其上层的父节点可以得到完全的复用，这样也可以大大提高“深拷贝”的效率。</p>\n<p><img src=\"1.gif\" alt></p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\">shouldComponentUpdate<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>nextProps<span class=\"token punctuation\">,</span> nextState<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">deepCompare</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> nextProps<span class=\"token punctuation\">,</span> nextState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\n<span class=\"token operator\">...</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">deepCompare</span><span class=\"token punctuation\">(</span>instance<span class=\"token punctuation\">,</span> nextProps<span class=\"token punctuation\">,</span> nextState<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">!</span>Immutable<span class=\"token punctuation\">.</span><span class=\"token function\">is</span><span class=\"token punctuation\">(</span>instance<span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">,</span> nextProps<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> <span class=\"token operator\">!</span>Immutable<span class=\"token punctuation\">.</span><span class=\"token function\">is</span><span class=\"token punctuation\">(</span>instance<span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">,</span> nextState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>但使用 immutable.js 也有相对应以下几点的缺点与不足：</p>\n<ol>\n<li>导致最后打包编译的源码体积增大；</li>\n<li>immutable.js 的数据类型在与服务器进行交互时需要转换成基础的 JavaScript 数据类型</li>\n</ol>\n","site":{"data":{}},"id":"4a2d401bb64e5f5123febce4b342684f","excerpt":"","more":"<p>最近用了一段时间的 Reactjs，其实大部分前端框架的核心原理都很相似，包括响应式、足够轻量级、基于 Virtual-DOM 等特性。从整体上来看，Vuejs 是基于模版进行应用构建的，在中小型应用中有一定的优势。而 Reactjs 则需要我们在 JavaScript 中使用 JSX 手动的来创建 DOM。</p>\n<p>开始一个新的 Reactjs 项目，我们通过自动化的脚手架创建工具 <a href=\"https://github.com/facebookincubator/create-react-app\" target=\"_blank\" rel=\"noopener\">create-react-app</a> 来创建一个初始化的全新 Reactjs 工程。</p>\n<p>Reactjs 本身通过计算 Virtual DOM 之间的差异（Diff）来更新 UI 组件。每当 <code>props</code> 或者 <code>state</code> 改变时，Reactjs 会重新计算生成一个 Virtual DOM 对象，并且通过比较两个 VD 对象之间的差异来找出数据改变引起对应在 UI 上的差异，最后采用最小的成本来更新 UI。在纯函数组件（同样的数据对应同样的 UI）下，对于相同的 <code>props</code> 和 <code>state</code>，其对应的 UI 显示应该是相同的。因此，当传递给组件的 <code>props</code> 或者 <code>state</code> 的改变与之前相同时，Reactjs 可以完全省略掉此时对组件 VD 的 Diff 计算，这在某种程度上可以提高 Reactjs 组件的渲染性能。为此，Reactjs 为我们提供了扩展的插件（Addon）“PureRenderMixin” 来解决这个问题。</p>\n<pre><code class=\"javascript\">import PureRenderMixin from &#39;react-addons-pure-render-mixin&#39;;\nclass FooComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.shouldComponentUpdate = PureRenderMixin.shouldComponentUpdate.bind(this);\n  }\n\n  render() {\n    return &lt;div className={this.props.className}&gt;foo&lt;/div&gt;;\n  }\n}\n</code></pre>\n<p>“PureRenderMixin” 的原理就是它实现了 <code>shouldComponentUpdate</code>。在 <code>shouldComponentUpdate</code> 内部，它比较当前的 <code>props</code> 和 <code>state</code> 和接下来的 <code>props</code> 以及 <code>state</code>，当两者相等的时候返回 <code>false</code>，这样组件就不会进行 Virtual DOM 上的 Diff 计算了。但 “PureRenderMixin” 仅进行简单的浅比较，对简单数据类型有效，如果需要对复杂数据类型进行比较来决定是否需要更新 UI，则需要从另一方面来考虑比较两个复杂数据结构所花费的成本和构建 VD 计算 Diff 所花费的成本哪个更大了。如果一定需要对复杂结构的数据来进行差异比较，也可以使用 immutable.js 来帮助我们提高性能。</p>\n<p>总的来说，immutable.js 可以帮助我们提高深拷贝的性能，也即在深度比较两个复杂数据类型时会有更高的性能。immutable.js 提供了7种数据结构，并且这些数据结构均是“不可变数据”，即操作改变这些元素的值时会返回一个新的元素，而原先元素的值不受影响。不仅如此，immutable.js 基于“哈希映射树”和“向量映射树”，在克隆一个数据结构时只会克隆改变的节点以及该节点的所有子节点，因此对于其上层的父节点可以得到完全的复用，这样也可以大大提高“深拷贝”的效率。</p>\n<p><img src=\"1.gif\" alt></p>\n<pre><code class=\"javascript\">shouldComponentUpdate: function(nextProps, nextState) {\n  return deepCompare(this, nextProps, nextState);\n},\n\n...\n\nfunction deepCompare(instance, nextProps, nextState) {\n  return !Immutable.is(instance.props, nextProps) || !Immutable.is(instance.state, nextState);\n}\n</code></pre>\n<p>但使用 immutable.js 也有相对应以下几点的缺点与不足：</p>\n<ol>\n<li>导致最后打包编译的源码体积增大；</li>\n<li>immutable.js 的数据类型在与服务器进行交互时需要转换成基础的 JavaScript 数据类型</li>\n</ol>\n"},{"title":"Promise A+ 调用详谈","intro":"Promise A+ 规范是对 Promise A 规范的增强和补充，本文不会对 Promise A+ 规范进行详细的讲解，而会从应用的角度来对 Promise A+ 规范的实现流程进行梳理。我们会以 ES6 的 Promise A+ 实现的常用应用方式入手，最后从几段代码的剖析中结束文章内容。","comments":1,"date":"2017-02-28T02:52:03.000Z","_content":"\n\nPromise A+ 规范是对 Promise A 规范的增强和补充，本文不会对 Promise A+ 规范进行详细的讲解，而会从应用的角度来对 Promise A+ 规范的实现流程进行梳理。我们会以 ES6 的 Promise A+ 实现的常用应用方式入手，最后从几段代码的剖析中结束文章内容。\n\n我们最常见的实现了 Promise A+ 规范的 `Promise` 对象用法如下代码所示。将需要耗时的异步操作放在 Promise 的“构造函数”里，当异步操作执行完后，根据 Promise A+ 规范，Promise 对象会返回一个 thenable 的对象。即一个含有 `then` 方法的对象或函数。`then` 方法中两个参数分别对应 Promise 对象的 `resolve` 状态和 `reject` 状态的结果（即一个成功结果，一个失败结果）回调函数，相应的结果会作为参数传递到对应的回调函数中。示例代码如下所示：\n\n\n```javascript\nnew Promise((resolve, reject) => {\n  setTimeout(() => {\n    return resolve(\"SUCCESS\");\n    // return reject(\"FAIL\");\n  }, 2000);\n}).then((resolveResult) => {\n  console.log(resolveResult);\n}, (rejectMessage) => {\n  console.error(rejectMessage);\n});\n```\n\n\n一个 Promise 对象应该含有三个状态：Pending 状态（可以迁移至另外两个状态）、Resolve 状态以及 Reject 状态。处于 Resolve 或 Reject 状态的 Promise 必须含有一个不可变的终止结果，即恒等（===）的结果，该结果不能在传递时中途被改变。\n\n官方的 Promise A+ 规范中并没有提供对 `Promise.all` 和 `Promise.race` 方法的规范定义。对于处理 Reject 状态的回调，我们也可以用以下方式的 `Promise.prototype.catch` 方式来处理：\n\n\n```javascript\nnew Promise((resolve, reject) => {\n  setTimeout(() => {\n    return resolve(\"SUCCESS\");\n    // return reject(\"FAIL\");\n  }, 2000);\n}).then((resolveResult) => {\n  console.log(resolveResult);\n}).catch((rejectMessage) => {\n  console.error(rejectMessage);\n});\n```\n\n\n这里要讨论下 `then` 方法中两个参数方法的回调时机，可以看如下代码：\n\n\n```javascript\nconsole.log(\"script start\");\n\nsetTimeout(function() {\n  console.log(\"setTimeout\");\n}, 0);\n\nPromise.resolve().then(function() {\n  console.log(\"promise1\");\n}).then(function() {\n  console.log(\"promise2\");\n});\nconsole.log(\"script end\");\n```\n\n\n首先，要区分浏览器在解释执行 JS 脚本时存在的两个任务队列，分别是 “TaskQueue” 和 “Microtasks” 这两个任务队列。这两个队列分别对应处理以下相关事情。TaskQueue 主要负责存放和处理 script（脚本代码）, `setTimeout`, `setInterval`, `setImmediate`, I/O, UI rendering 相关的任务；Microtasks 主要负责存放处理 `process.nextTick`, `Promises`, `Object.observe`, `MutationObserver` 相关的任务。浏览器在解析 JS 代码时会优先执行 TaskQueue 中的排队任务，然后再执行 Microtasks 中的任务，接下来就是循环上述处理流程，直到所有任务均已完成。\n\n运行脚本时，解释器会把当前 script 的运行作为第一个 task 放入 TaskQueue 中，首先输出 “script start”，接下来绑定 `setTimeout`。而 `setTimeout` 的回调函数则是作为 TaskQueue 中的第二个 task 来执行的，因此它会被放到 TaskQueue 中位于 script 任务之后。接下来 Promise 的 then 回调函数会被作为 Microtasks 中的第一个任务来执行。当最后一条日志 “script end” 被输出后，TaskQueue 中的第一个 script 任务执行完毕，此时解释器会开始处理 Microtasks 中的任务。这里需要注意的是，**只有在 Microtasks 中的任务被全部处理完毕后，解释器才会开始新一轮的 TaskQueue 处理，即处理 TaskQueue 中的下一个任务**。在处理 Microtasks 队列的任务时会连续输出 Promise 对象回调函数中的结果。\n\n下面的代码可以加深你对 TaskQueue 和 Microtasks 的印象和理解。\n\n\n```html\n<div class=\"outer\">\n  <div class=\"inner\"></div>\n</div>\n```\n\n\n```javascript\nvar outer = document.querySelector(\".outer\");\nvar inner = document.querySelector(\".inner\");\n\n// DOM 监听器；\nnew MutationObserver(function() {\n  console.log(\"mutate\");\n}).observe(outer, {\n  attributes: true\n});\n\n// 事件监听器；\nfunction onClick() {\n  console.log(\"click\");\n\n  setTimeout(function() {\n    console.log(\"timeout\");\n  }, 0);\n\n  Promise.resolve().then(function() {\n    console.log(\"promise\");\n  });\n\n  outer.setAttribute(\"data-random\", Math.random());\n}\n\ninner.addEventListener(\"click\", onClick);\nouter.addEventListener(\"click\", onClick);\n```\n\n\n首先，仍然是 script 作为 TaskQueue 的第一个任务来执行，绑定事件，设置 DOM 观察器。接下来点击 inner 区域，click 事件分发作为第一个 TaskQueue 的任务开始执行，接下来 `setTimeout` 的回调函数被作为 TaskQueue 的第二个任务进行排队。Promise 的状态回调函数作为任务被放入 Microtasks 队列，同理 `setAttribute` 触发了 `MutationObserver` 的绑定事件，这个事件也被作为任务放入了 Microtasks 队列中。当 Microtasks 中的任务执行完成后，由于事件冒泡机制，当前的 click 分发继续执行（**事件分发包括处理冒泡的过程，不会在 TaskQueue 中新增任务**），直到最后。\n\n根据规范，Microtasks 存在的意义是：在当前 task 执行完，准备进行 I/O，repaint，redraw 等原生操作之前，需要执行一些低延迟的异步操作，使得浏览器渲染和原生运算变得更加流畅。这里的低延迟异步操作就是 Microtasks。原生的 `setTimeout` 就算是将延迟设置为 0 也仍然会有 4 ms 的延迟，它会将一个完整的 task 放进队列延迟执行，而且每个 task 之间会进行渲染等原生操作。假如每执行一个异步操作都要重新生成一个 task，将提高宿主平台的负担和响应时间。所以，需要有一个概念，在进行下一个 task 之前，将当前 task 生成的低延迟的，与下一个 task 无关的异步操作执行完，这就是 Microtasks。\n\n说些其他的问题。如果是在 Node 环境下，`setTimeout(fn, 0)` 和 `setImmediate` 两个函数谁先被触发？可以看到之前我们提到的，`setTimeout` 和`setImmediate` 的回调函数均会被放到 TaskQueue 中来执行，为了解决这个问题，我们来看下 Node 中 timer 的实现过程：\n\n\n\n```javascript\n// https://github.com/nodejs/node-v0.x-archive/blob/master/lib/timers.js\nexports.setTimeout = function(callback, after) {\n  var timer;\n\n  after *= 1; // coalesce to number or NaN\n\n  if (!(after >= 1 && after <= TIMEOUT_MAX)) {\n    after = 1; // schedule on next tick, follows browser behaviour\n  }\n\n  timer = new Timeout(after);\n  ...\n```\n\n\n我们可以看到，`setTimeout(fn, 0)` 最终会被转换成 `setTimeout(fn, 1)` 来执行。因此从某种程度上来说，`setImmediate` 会先于 `setTimeout(fn, 0)`执行。但是无论如何，在 Node 中请直接使用 `setImmediate` 来执行异步方法。因为 `setTimeout` 在创建过程中可能涉及到红黑树的创建，性能较低。\n","source":"_posts/Promise-A-调用详谈.md","raw":"---\ntitle: Promise A+ 调用详谈\nintro: Promise A+ 规范是对 Promise A 规范的增强和补充，本文不会对 Promise A+ 规范进行详细的讲解，而会从应用的角度来对 Promise A+ 规范的实现流程进行梳理。我们会以 ES6 的 Promise A+ 实现的常用应用方式入手，最后从几段代码的剖析中结束文章内容。\ncomments: true\ndate: 2017-02-28 10:52:03\ntags:\n- JavaScript\n---\n\n\nPromise A+ 规范是对 Promise A 规范的增强和补充，本文不会对 Promise A+ 规范进行详细的讲解，而会从应用的角度来对 Promise A+ 规范的实现流程进行梳理。我们会以 ES6 的 Promise A+ 实现的常用应用方式入手，最后从几段代码的剖析中结束文章内容。\n\n我们最常见的实现了 Promise A+ 规范的 `Promise` 对象用法如下代码所示。将需要耗时的异步操作放在 Promise 的“构造函数”里，当异步操作执行完后，根据 Promise A+ 规范，Promise 对象会返回一个 thenable 的对象。即一个含有 `then` 方法的对象或函数。`then` 方法中两个参数分别对应 Promise 对象的 `resolve` 状态和 `reject` 状态的结果（即一个成功结果，一个失败结果）回调函数，相应的结果会作为参数传递到对应的回调函数中。示例代码如下所示：\n\n\n```javascript\nnew Promise((resolve, reject) => {\n  setTimeout(() => {\n    return resolve(\"SUCCESS\");\n    // return reject(\"FAIL\");\n  }, 2000);\n}).then((resolveResult) => {\n  console.log(resolveResult);\n}, (rejectMessage) => {\n  console.error(rejectMessage);\n});\n```\n\n\n一个 Promise 对象应该含有三个状态：Pending 状态（可以迁移至另外两个状态）、Resolve 状态以及 Reject 状态。处于 Resolve 或 Reject 状态的 Promise 必须含有一个不可变的终止结果，即恒等（===）的结果，该结果不能在传递时中途被改变。\n\n官方的 Promise A+ 规范中并没有提供对 `Promise.all` 和 `Promise.race` 方法的规范定义。对于处理 Reject 状态的回调，我们也可以用以下方式的 `Promise.prototype.catch` 方式来处理：\n\n\n```javascript\nnew Promise((resolve, reject) => {\n  setTimeout(() => {\n    return resolve(\"SUCCESS\");\n    // return reject(\"FAIL\");\n  }, 2000);\n}).then((resolveResult) => {\n  console.log(resolveResult);\n}).catch((rejectMessage) => {\n  console.error(rejectMessage);\n});\n```\n\n\n这里要讨论下 `then` 方法中两个参数方法的回调时机，可以看如下代码：\n\n\n```javascript\nconsole.log(\"script start\");\n\nsetTimeout(function() {\n  console.log(\"setTimeout\");\n}, 0);\n\nPromise.resolve().then(function() {\n  console.log(\"promise1\");\n}).then(function() {\n  console.log(\"promise2\");\n});\nconsole.log(\"script end\");\n```\n\n\n首先，要区分浏览器在解释执行 JS 脚本时存在的两个任务队列，分别是 “TaskQueue” 和 “Microtasks” 这两个任务队列。这两个队列分别对应处理以下相关事情。TaskQueue 主要负责存放和处理 script（脚本代码）, `setTimeout`, `setInterval`, `setImmediate`, I/O, UI rendering 相关的任务；Microtasks 主要负责存放处理 `process.nextTick`, `Promises`, `Object.observe`, `MutationObserver` 相关的任务。浏览器在解析 JS 代码时会优先执行 TaskQueue 中的排队任务，然后再执行 Microtasks 中的任务，接下来就是循环上述处理流程，直到所有任务均已完成。\n\n运行脚本时，解释器会把当前 script 的运行作为第一个 task 放入 TaskQueue 中，首先输出 “script start”，接下来绑定 `setTimeout`。而 `setTimeout` 的回调函数则是作为 TaskQueue 中的第二个 task 来执行的，因此它会被放到 TaskQueue 中位于 script 任务之后。接下来 Promise 的 then 回调函数会被作为 Microtasks 中的第一个任务来执行。当最后一条日志 “script end” 被输出后，TaskQueue 中的第一个 script 任务执行完毕，此时解释器会开始处理 Microtasks 中的任务。这里需要注意的是，**只有在 Microtasks 中的任务被全部处理完毕后，解释器才会开始新一轮的 TaskQueue 处理，即处理 TaskQueue 中的下一个任务**。在处理 Microtasks 队列的任务时会连续输出 Promise 对象回调函数中的结果。\n\n下面的代码可以加深你对 TaskQueue 和 Microtasks 的印象和理解。\n\n\n```html\n<div class=\"outer\">\n  <div class=\"inner\"></div>\n</div>\n```\n\n\n```javascript\nvar outer = document.querySelector(\".outer\");\nvar inner = document.querySelector(\".inner\");\n\n// DOM 监听器；\nnew MutationObserver(function() {\n  console.log(\"mutate\");\n}).observe(outer, {\n  attributes: true\n});\n\n// 事件监听器；\nfunction onClick() {\n  console.log(\"click\");\n\n  setTimeout(function() {\n    console.log(\"timeout\");\n  }, 0);\n\n  Promise.resolve().then(function() {\n    console.log(\"promise\");\n  });\n\n  outer.setAttribute(\"data-random\", Math.random());\n}\n\ninner.addEventListener(\"click\", onClick);\nouter.addEventListener(\"click\", onClick);\n```\n\n\n首先，仍然是 script 作为 TaskQueue 的第一个任务来执行，绑定事件，设置 DOM 观察器。接下来点击 inner 区域，click 事件分发作为第一个 TaskQueue 的任务开始执行，接下来 `setTimeout` 的回调函数被作为 TaskQueue 的第二个任务进行排队。Promise 的状态回调函数作为任务被放入 Microtasks 队列，同理 `setAttribute` 触发了 `MutationObserver` 的绑定事件，这个事件也被作为任务放入了 Microtasks 队列中。当 Microtasks 中的任务执行完成后，由于事件冒泡机制，当前的 click 分发继续执行（**事件分发包括处理冒泡的过程，不会在 TaskQueue 中新增任务**），直到最后。\n\n根据规范，Microtasks 存在的意义是：在当前 task 执行完，准备进行 I/O，repaint，redraw 等原生操作之前，需要执行一些低延迟的异步操作，使得浏览器渲染和原生运算变得更加流畅。这里的低延迟异步操作就是 Microtasks。原生的 `setTimeout` 就算是将延迟设置为 0 也仍然会有 4 ms 的延迟，它会将一个完整的 task 放进队列延迟执行，而且每个 task 之间会进行渲染等原生操作。假如每执行一个异步操作都要重新生成一个 task，将提高宿主平台的负担和响应时间。所以，需要有一个概念，在进行下一个 task 之前，将当前 task 生成的低延迟的，与下一个 task 无关的异步操作执行完，这就是 Microtasks。\n\n说些其他的问题。如果是在 Node 环境下，`setTimeout(fn, 0)` 和 `setImmediate` 两个函数谁先被触发？可以看到之前我们提到的，`setTimeout` 和`setImmediate` 的回调函数均会被放到 TaskQueue 中来执行，为了解决这个问题，我们来看下 Node 中 timer 的实现过程：\n\n\n\n```javascript\n// https://github.com/nodejs/node-v0.x-archive/blob/master/lib/timers.js\nexports.setTimeout = function(callback, after) {\n  var timer;\n\n  after *= 1; // coalesce to number or NaN\n\n  if (!(after >= 1 && after <= TIMEOUT_MAX)) {\n    after = 1; // schedule on next tick, follows browser behaviour\n  }\n\n  timer = new Timeout(after);\n  ...\n```\n\n\n我们可以看到，`setTimeout(fn, 0)` 最终会被转换成 `setTimeout(fn, 1)` 来执行。因此从某种程度上来说，`setImmediate` 会先于 `setTimeout(fn, 0)`执行。但是无论如何，在 Node 中请直接使用 `setImmediate` 来执行异步方法。因为 `setTimeout` 在创建过程中可能涉及到红黑树的创建，性能较低。\n","slug":"Promise-A-调用详谈","published":1,"updated":"2019-02-12T05:43:26.350Z","layout":"post","photos":[],"link":"","_id":"cjsqwht9r0037knp2senpefiq","content":"<p>Promise A+ 规范是对 Promise A 规范的增强和补充，本文不会对 Promise A+ 规范进行详细的讲解，而会从应用的角度来对 Promise A+ 规范的实现流程进行梳理。我们会以 ES6 的 Promise A+ 实现的常用应用方式入手，最后从几段代码的剖析中结束文章内容。</p>\n<p>我们最常见的实现了 Promise A+ 规范的 <code>Promise</code> 对象用法如下代码所示。将需要耗时的异步操作放在 Promise 的“构造函数”里，当异步操作执行完后，根据 Promise A+ 规范，Promise 对象会返回一个 thenable 的对象。即一个含有 <code>then</code> 方法的对象或函数。<code>then</code> 方法中两个参数分别对应 Promise 对象的 <code>resolve</code> 状态和 <code>reject</code> 状态的结果（即一个成功结果，一个失败结果）回调函数，相应的结果会作为参数传递到对应的回调函数中。示例代码如下所示：</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"SUCCESS\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// return reject(\"FAIL\");</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolveResult<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>resolveResult<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>rejectMessage<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span>rejectMessage<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>一个 Promise 对象应该含有三个状态：Pending 状态（可以迁移至另外两个状态）、Resolve 状态以及 Reject 状态。处于 Resolve 或 Reject 状态的 Promise 必须含有一个不可变的终止结果，即恒等（===）的结果，该结果不能在传递时中途被改变。</p>\n<p>官方的 Promise A+ 规范中并没有提供对 <code>Promise.all</code> 和 <code>Promise.race</code> 方法的规范定义。对于处理 Reject 状态的回调，我们也可以用以下方式的 <code>Promise.prototype.catch</code> 方式来处理：</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"SUCCESS\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// return reject(\"FAIL\");</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolveResult<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>resolveResult<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>rejectMessage<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span>rejectMessage<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这里要讨论下 <code>then</code> 方法中两个参数方法的回调时机，可以看如下代码：</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"script start\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"setTimeout\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nPromise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"promise1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"promise2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"script end\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>首先，要区分浏览器在解释执行 JS 脚本时存在的两个任务队列，分别是 “TaskQueue” 和 “Microtasks” 这两个任务队列。这两个队列分别对应处理以下相关事情。TaskQueue 主要负责存放和处理 script（脚本代码）, <code>setTimeout</code>, <code>setInterval</code>, <code>setImmediate</code>, I/O, UI rendering 相关的任务；Microtasks 主要负责存放处理 <code>process.nextTick</code>, <code>Promises</code>, <code>Object.observe</code>, <code>MutationObserver</code> 相关的任务。浏览器在解析 JS 代码时会优先执行 TaskQueue 中的排队任务，然后再执行 Microtasks 中的任务，接下来就是循环上述处理流程，直到所有任务均已完成。</p>\n<p>运行脚本时，解释器会把当前 script 的运行作为第一个 task 放入 TaskQueue 中，首先输出 “script start”，接下来绑定 <code>setTimeout</code>。而 <code>setTimeout</code> 的回调函数则是作为 TaskQueue 中的第二个 task 来执行的，因此它会被放到 TaskQueue 中位于 script 任务之后。接下来 Promise 的 then 回调函数会被作为 Microtasks 中的第一个任务来执行。当最后一条日志 “script end” 被输出后，TaskQueue 中的第一个 script 任务执行完毕，此时解释器会开始处理 Microtasks 中的任务。这里需要注意的是，<strong>只有在 Microtasks 中的任务被全部处理完毕后，解释器才会开始新一轮的 TaskQueue 处理，即处理 TaskQueue 中的下一个任务</strong>。在处理 Microtasks 队列的任务时会连续输出 Promise 对象回调函数中的结果。</p>\n<p>下面的代码可以加深你对 TaskQueue 和 Microtasks 的印象和理解。</p>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>outer<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>inner<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> outer <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">\".outer\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> inner <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">\".inner\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// DOM 监听器；</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">MutationObserver</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"mutate\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">observe</span><span class=\"token punctuation\">(</span>outer<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n  attributes<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 事件监听器；</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">onClick</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"click\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"timeout\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"promise\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  outer<span class=\"token punctuation\">.</span><span class=\"token function\">setAttribute</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"data-random\"</span><span class=\"token punctuation\">,</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\ninner<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"click\"</span><span class=\"token punctuation\">,</span> onClick<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nouter<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"click\"</span><span class=\"token punctuation\">,</span> onClick<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>首先，仍然是 script 作为 TaskQueue 的第一个任务来执行，绑定事件，设置 DOM 观察器。接下来点击 inner 区域，click 事件分发作为第一个 TaskQueue 的任务开始执行，接下来 <code>setTimeout</code> 的回调函数被作为 TaskQueue 的第二个任务进行排队。Promise 的状态回调函数作为任务被放入 Microtasks 队列，同理 <code>setAttribute</code> 触发了 <code>MutationObserver</code> 的绑定事件，这个事件也被作为任务放入了 Microtasks 队列中。当 Microtasks 中的任务执行完成后，由于事件冒泡机制，当前的 click 分发继续执行（<strong>事件分发包括处理冒泡的过程，不会在 TaskQueue 中新增任务</strong>），直到最后。</p>\n<p>根据规范，Microtasks 存在的意义是：在当前 task 执行完，准备进行 I/O，repaint，redraw 等原生操作之前，需要执行一些低延迟的异步操作，使得浏览器渲染和原生运算变得更加流畅。这里的低延迟异步操作就是 Microtasks。原生的 <code>setTimeout</code> 就算是将延迟设置为 0 也仍然会有 4 ms 的延迟，它会将一个完整的 task 放进队列延迟执行，而且每个 task 之间会进行渲染等原生操作。假如每执行一个异步操作都要重新生成一个 task，将提高宿主平台的负担和响应时间。所以，需要有一个概念，在进行下一个 task 之前，将当前 task 生成的低延迟的，与下一个 task 无关的异步操作执行完，这就是 Microtasks。</p>\n<p>说些其他的问题。如果是在 Node 环境下，<code>setTimeout(fn, 0)</code> 和 <code>setImmediate</code> 两个函数谁先被触发？可以看到之前我们提到的，<code>setTimeout</code> 和<code>setImmediate</code> 的回调函数均会被放到 TaskQueue 中来执行，为了解决这个问题，我们来看下 Node 中 timer 的实现过程：</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">// https://github.com/nodejs/node-v0.x-archive/blob/master/lib/timers.js</span>\nexports<span class=\"token punctuation\">.</span>setTimeout <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>callback<span class=\"token punctuation\">,</span> after<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> timer<span class=\"token punctuation\">;</span>\n\n  after <span class=\"token operator\">*</span><span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// coalesce to number or NaN</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>after <span class=\"token operator\">>=</span> <span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span> after <span class=\"token operator\">&lt;=</span> TIMEOUT_MAX<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    after <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// schedule on next tick, follows browser behaviour</span>\n  <span class=\"token punctuation\">}</span>\n\n  timer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Timeout</span><span class=\"token punctuation\">(</span>after<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token operator\">...</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>我们可以看到，<code>setTimeout(fn, 0)</code> 最终会被转换成 <code>setTimeout(fn, 1)</code> 来执行。因此从某种程度上来说，<code>setImmediate</code> 会先于 <code>setTimeout(fn, 0)</code>执行。但是无论如何，在 Node 中请直接使用 <code>setImmediate</code> 来执行异步方法。因为 <code>setTimeout</code> 在创建过程中可能涉及到红黑树的创建，性能较低。</p>\n","site":{"data":{}},"id":"c13048e43360c40dce3a8e3523e8db9d","excerpt":"","more":"<p>Promise A+ 规范是对 Promise A 规范的增强和补充，本文不会对 Promise A+ 规范进行详细的讲解，而会从应用的角度来对 Promise A+ 规范的实现流程进行梳理。我们会以 ES6 的 Promise A+ 实现的常用应用方式入手，最后从几段代码的剖析中结束文章内容。</p>\n<p>我们最常见的实现了 Promise A+ 规范的 <code>Promise</code> 对象用法如下代码所示。将需要耗时的异步操作放在 Promise 的“构造函数”里，当异步操作执行完后，根据 Promise A+ 规范，Promise 对象会返回一个 thenable 的对象。即一个含有 <code>then</code> 方法的对象或函数。<code>then</code> 方法中两个参数分别对应 Promise 对象的 <code>resolve</code> 状态和 <code>reject</code> 状态的结果（即一个成功结果，一个失败结果）回调函数，相应的结果会作为参数传递到对应的回调函数中。示例代码如下所示：</p>\n<pre><code class=\"javascript\">new Promise((resolve, reject) =&gt; {\n  setTimeout(() =&gt; {\n    return resolve(&quot;SUCCESS&quot;);\n    // return reject(&quot;FAIL&quot;);\n  }, 2000);\n}).then((resolveResult) =&gt; {\n  console.log(resolveResult);\n}, (rejectMessage) =&gt; {\n  console.error(rejectMessage);\n});\n</code></pre>\n<p>一个 Promise 对象应该含有三个状态：Pending 状态（可以迁移至另外两个状态）、Resolve 状态以及 Reject 状态。处于 Resolve 或 Reject 状态的 Promise 必须含有一个不可变的终止结果，即恒等（===）的结果，该结果不能在传递时中途被改变。</p>\n<p>官方的 Promise A+ 规范中并没有提供对 <code>Promise.all</code> 和 <code>Promise.race</code> 方法的规范定义。对于处理 Reject 状态的回调，我们也可以用以下方式的 <code>Promise.prototype.catch</code> 方式来处理：</p>\n<pre><code class=\"javascript\">new Promise((resolve, reject) =&gt; {\n  setTimeout(() =&gt; {\n    return resolve(&quot;SUCCESS&quot;);\n    // return reject(&quot;FAIL&quot;);\n  }, 2000);\n}).then((resolveResult) =&gt; {\n  console.log(resolveResult);\n}).catch((rejectMessage) =&gt; {\n  console.error(rejectMessage);\n});\n</code></pre>\n<p>这里要讨论下 <code>then</code> 方法中两个参数方法的回调时机，可以看如下代码：</p>\n<pre><code class=\"javascript\">console.log(&quot;script start&quot;);\n\nsetTimeout(function() {\n  console.log(&quot;setTimeout&quot;);\n}, 0);\n\nPromise.resolve().then(function() {\n  console.log(&quot;promise1&quot;);\n}).then(function() {\n  console.log(&quot;promise2&quot;);\n});\nconsole.log(&quot;script end&quot;);\n</code></pre>\n<p>首先，要区分浏览器在解释执行 JS 脚本时存在的两个任务队列，分别是 “TaskQueue” 和 “Microtasks” 这两个任务队列。这两个队列分别对应处理以下相关事情。TaskQueue 主要负责存放和处理 script（脚本代码）, <code>setTimeout</code>, <code>setInterval</code>, <code>setImmediate</code>, I/O, UI rendering 相关的任务；Microtasks 主要负责存放处理 <code>process.nextTick</code>, <code>Promises</code>, <code>Object.observe</code>, <code>MutationObserver</code> 相关的任务。浏览器在解析 JS 代码时会优先执行 TaskQueue 中的排队任务，然后再执行 Microtasks 中的任务，接下来就是循环上述处理流程，直到所有任务均已完成。</p>\n<p>运行脚本时，解释器会把当前 script 的运行作为第一个 task 放入 TaskQueue 中，首先输出 “script start”，接下来绑定 <code>setTimeout</code>。而 <code>setTimeout</code> 的回调函数则是作为 TaskQueue 中的第二个 task 来执行的，因此它会被放到 TaskQueue 中位于 script 任务之后。接下来 Promise 的 then 回调函数会被作为 Microtasks 中的第一个任务来执行。当最后一条日志 “script end” 被输出后，TaskQueue 中的第一个 script 任务执行完毕，此时解释器会开始处理 Microtasks 中的任务。这里需要注意的是，<strong>只有在 Microtasks 中的任务被全部处理完毕后，解释器才会开始新一轮的 TaskQueue 处理，即处理 TaskQueue 中的下一个任务</strong>。在处理 Microtasks 队列的任务时会连续输出 Promise 对象回调函数中的结果。</p>\n<p>下面的代码可以加深你对 TaskQueue 和 Microtasks 的印象和理解。</p>\n<pre><code class=\"html\">&lt;div class=&quot;outer&quot;&gt;\n  &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n<pre><code class=\"javascript\">var outer = document.querySelector(&quot;.outer&quot;);\nvar inner = document.querySelector(&quot;.inner&quot;);\n\n// DOM 监听器；\nnew MutationObserver(function() {\n  console.log(&quot;mutate&quot;);\n}).observe(outer, {\n  attributes: true\n});\n\n// 事件监听器；\nfunction onClick() {\n  console.log(&quot;click&quot;);\n\n  setTimeout(function() {\n    console.log(&quot;timeout&quot;);\n  }, 0);\n\n  Promise.resolve().then(function() {\n    console.log(&quot;promise&quot;);\n  });\n\n  outer.setAttribute(&quot;data-random&quot;, Math.random());\n}\n\ninner.addEventListener(&quot;click&quot;, onClick);\nouter.addEventListener(&quot;click&quot;, onClick);\n</code></pre>\n<p>首先，仍然是 script 作为 TaskQueue 的第一个任务来执行，绑定事件，设置 DOM 观察器。接下来点击 inner 区域，click 事件分发作为第一个 TaskQueue 的任务开始执行，接下来 <code>setTimeout</code> 的回调函数被作为 TaskQueue 的第二个任务进行排队。Promise 的状态回调函数作为任务被放入 Microtasks 队列，同理 <code>setAttribute</code> 触发了 <code>MutationObserver</code> 的绑定事件，这个事件也被作为任务放入了 Microtasks 队列中。当 Microtasks 中的任务执行完成后，由于事件冒泡机制，当前的 click 分发继续执行（<strong>事件分发包括处理冒泡的过程，不会在 TaskQueue 中新增任务</strong>），直到最后。</p>\n<p>根据规范，Microtasks 存在的意义是：在当前 task 执行完，准备进行 I/O，repaint，redraw 等原生操作之前，需要执行一些低延迟的异步操作，使得浏览器渲染和原生运算变得更加流畅。这里的低延迟异步操作就是 Microtasks。原生的 <code>setTimeout</code> 就算是将延迟设置为 0 也仍然会有 4 ms 的延迟，它会将一个完整的 task 放进队列延迟执行，而且每个 task 之间会进行渲染等原生操作。假如每执行一个异步操作都要重新生成一个 task，将提高宿主平台的负担和响应时间。所以，需要有一个概念，在进行下一个 task 之前，将当前 task 生成的低延迟的，与下一个 task 无关的异步操作执行完，这就是 Microtasks。</p>\n<p>说些其他的问题。如果是在 Node 环境下，<code>setTimeout(fn, 0)</code> 和 <code>setImmediate</code> 两个函数谁先被触发？可以看到之前我们提到的，<code>setTimeout</code> 和<code>setImmediate</code> 的回调函数均会被放到 TaskQueue 中来执行，为了解决这个问题，我们来看下 Node 中 timer 的实现过程：</p>\n<pre><code class=\"javascript\">// https://github.com/nodejs/node-v0.x-archive/blob/master/lib/timers.js\nexports.setTimeout = function(callback, after) {\n  var timer;\n\n  after *= 1; // coalesce to number or NaN\n\n  if (!(after &gt;= 1 &amp;&amp; after &lt;= TIMEOUT_MAX)) {\n    after = 1; // schedule on next tick, follows browser behaviour\n  }\n\n  timer = new Timeout(after);\n  ...\n</code></pre>\n<p>我们可以看到，<code>setTimeout(fn, 0)</code> 最终会被转换成 <code>setTimeout(fn, 1)</code> 来执行。因此从某种程度上来说，<code>setImmediate</code> 会先于 <code>setTimeout(fn, 0)</code>执行。但是无论如何，在 Node 中请直接使用 <code>setImmediate</code> 来执行异步方法。因为 <code>setTimeout</code> 在创建过程中可能涉及到红黑树的创建，性能较低。</p>\n"},{"title":"Python 高级用法","intro":"之前的一篇博客记录了一些 Python 相关的基本语法和知识点，这篇文章会记录一些 Python 相对高级的用法。内容主要包括函数式、面向对象等一些高级特性。","comments":1,"date":"2017-07-20T06:32:44.000Z","_content":"\n之前的一篇博客记录了一些 Python 相关的基本语法和知识点，这篇文章会记录一些 Python 相对高级的用法。内容主要包括函数式、面向对象等一些高级特性。\n\n#### 1、xrange 和 range：\n\n在 Python 2.x 中，`xrange` 的性能要好于 `range`，因为 range 本质是基于 List 构建的，range(30) 会在内存中生成一个大小为30个元素的 List，而 xrange 是则会生成一个序列对象（迭代器），该对象会在程序运行时再进行求值（懒求值）。而在 Python 3.x 中，xrange 已经被更名为 range。\n\n#### 2、super().\\_\\_init\\_\\_()：\n\n避免了显式的调用父类构造函数。\n\n```python\nclass ChildA(Base):\n    def __init__(self):\n        Base.__init__(self)\n\nclass ChildB(Base):\n    def __init__(self):\n        super().__init__()\n```\n\n#### 3、read / readline / readlines：\n\n\n```python\n# 可能产生内存溢出；\nwith open('./file.txt') as file:\n    print(file.read())\n\n# 性能最优，返回一个包含所有行的 List；\nwith open('./file.txt') as file:\n    for line in file.readlines():\n        print(line.strip())\n\n# 一次读取一行；\nwith open('./file.txt') as file:\n    while True:\n        line = file.readline()\n        if line:\n            print(line)\n        else:\n            break\n```\n\n#### 4、is：\n\n`is` 是比较两个变量所在的内存地址，`==` 是对比两个变量的值。\n\n#### 5、GC：\n\nPython 的垃圾回收机制主要包括引用计数、标记清除和分代技术。\n\n","source":"_posts/Python-高级用法.md","raw":"---\ntitle: Python 高级用法\nintro: 之前的一篇博客记录了一些 Python 相关的基本语法和知识点，这篇文章会记录一些 Python 相对高级的用法。内容主要包括函数式、面向对象等一些高级特性。\ncomments: true\ndate: 2017-07-20 14:32:44\ntags:\n- Python\n---\n\n之前的一篇博客记录了一些 Python 相关的基本语法和知识点，这篇文章会记录一些 Python 相对高级的用法。内容主要包括函数式、面向对象等一些高级特性。\n\n#### 1、xrange 和 range：\n\n在 Python 2.x 中，`xrange` 的性能要好于 `range`，因为 range 本质是基于 List 构建的，range(30) 会在内存中生成一个大小为30个元素的 List，而 xrange 是则会生成一个序列对象（迭代器），该对象会在程序运行时再进行求值（懒求值）。而在 Python 3.x 中，xrange 已经被更名为 range。\n\n#### 2、super().\\_\\_init\\_\\_()：\n\n避免了显式的调用父类构造函数。\n\n```python\nclass ChildA(Base):\n    def __init__(self):\n        Base.__init__(self)\n\nclass ChildB(Base):\n    def __init__(self):\n        super().__init__()\n```\n\n#### 3、read / readline / readlines：\n\n\n```python\n# 可能产生内存溢出；\nwith open('./file.txt') as file:\n    print(file.read())\n\n# 性能最优，返回一个包含所有行的 List；\nwith open('./file.txt') as file:\n    for line in file.readlines():\n        print(line.strip())\n\n# 一次读取一行；\nwith open('./file.txt') as file:\n    while True:\n        line = file.readline()\n        if line:\n            print(line)\n        else:\n            break\n```\n\n#### 4、is：\n\n`is` 是比较两个变量所在的内存地址，`==` 是对比两个变量的值。\n\n#### 5、GC：\n\nPython 的垃圾回收机制主要包括引用计数、标记清除和分代技术。\n\n","slug":"Python-高级用法","published":1,"updated":"2019-02-19T10:15:07.232Z","layout":"post","photos":[],"link":"","_id":"cjsqwht9s003aknp2xsq3tgf6","content":"<p>之前的一篇博客记录了一些 Python 相关的基本语法和知识点，这篇文章会记录一些 Python 相对高级的用法。内容主要包括函数式、面向对象等一些高级特性。</p>\n<h4 id=\"1、xrange-和-range：\"><a href=\"#1、xrange-和-range：\" class=\"headerlink\" title=\"1、xrange 和 range：\"></a>1、xrange 和 range：</h4><p>在 Python 2.x 中，<code>xrange</code> 的性能要好于 <code>range</code>，因为 range 本质是基于 List 构建的，range(30) 会在内存中生成一个大小为30个元素的 List，而 xrange 是则会生成一个序列对象（迭代器），该对象会在程序运行时再进行求值（懒求值）。而在 Python 3.x 中，xrange 已经被更名为 range。</p>\n<h4 id=\"2、super-init-：\"><a href=\"#2、super-init-：\" class=\"headerlink\" title=\"2、super().__init__()：\"></a>2、super().__init__()：</h4><p>避免了显式的调用父类构造函数。</p>\n<pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">ChildA</span><span class=\"token punctuation\">(</span>Base<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        Base<span class=\"token punctuation\">.</span>__init__<span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">ChildB</span><span class=\"token punctuation\">(</span>Base<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        super<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>__init__<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"3、read-readline-readlines：\"><a href=\"#3、read-readline-readlines：\" class=\"headerlink\" title=\"3、read / readline / readlines：\"></a>3、read / readline / readlines：</h4><pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token comment\" spellcheck=\"true\"># 可能产生内存溢出；</span>\n<span class=\"token keyword\">with</span> open<span class=\"token punctuation\">(</span><span class=\"token string\">'./file.txt'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> file<span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>file<span class=\"token punctuation\">.</span>read<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 性能最优，返回一个包含所有行的 List；</span>\n<span class=\"token keyword\">with</span> open<span class=\"token punctuation\">(</span><span class=\"token string\">'./file.txt'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> file<span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">for</span> line <span class=\"token keyword\">in</span> file<span class=\"token punctuation\">.</span>readlines<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>line<span class=\"token punctuation\">.</span>strip<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 一次读取一行；</span>\n<span class=\"token keyword\">with</span> open<span class=\"token punctuation\">(</span><span class=\"token string\">'./file.txt'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> file<span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">while</span> <span class=\"token boolean\">True</span><span class=\"token punctuation\">:</span>\n        line <span class=\"token operator\">=</span> file<span class=\"token punctuation\">.</span>readline<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span> line<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>line<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">break</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"4、is：\"><a href=\"#4、is：\" class=\"headerlink\" title=\"4、is：\"></a>4、is：</h4><p><code>is</code> 是比较两个变量所在的内存地址，<code>==</code> 是对比两个变量的值。</p>\n<h4 id=\"5、GC：\"><a href=\"#5、GC：\" class=\"headerlink\" title=\"5、GC：\"></a>5、GC：</h4><p>Python 的垃圾回收机制主要包括引用计数、标记清除和分代技术。</p>\n","site":{"data":{}},"id":"8dbefae832775ba64947daffd84e4c64","excerpt":"","more":"<p>之前的一篇博客记录了一些 Python 相关的基本语法和知识点，这篇文章会记录一些 Python 相对高级的用法。内容主要包括函数式、面向对象等一些高级特性。</p>\n<h4 id=\"1、xrange-和-range：\"><a href=\"#1、xrange-和-range：\" class=\"headerlink\" title=\"1、xrange 和 range：\"></a>1、xrange 和 range：</h4><p>在 Python 2.x 中，<code>xrange</code> 的性能要好于 <code>range</code>，因为 range 本质是基于 List 构建的，range(30) 会在内存中生成一个大小为30个元素的 List，而 xrange 是则会生成一个序列对象（迭代器），该对象会在程序运行时再进行求值（懒求值）。而在 Python 3.x 中，xrange 已经被更名为 range。</p>\n<h4 id=\"2、super-init-：\"><a href=\"#2、super-init-：\" class=\"headerlink\" title=\"2、super().__init__()：\"></a>2、super().__init__()：</h4><p>避免了显式的调用父类构造函数。</p>\n<pre><code class=\"python\">class ChildA(Base):\n    def __init__(self):\n        Base.__init__(self)\n\nclass ChildB(Base):\n    def __init__(self):\n        super().__init__()\n</code></pre>\n<h4 id=\"3、read-readline-readlines：\"><a href=\"#3、read-readline-readlines：\" class=\"headerlink\" title=\"3、read / readline / readlines：\"></a>3、read / readline / readlines：</h4><pre><code class=\"python\"># 可能产生内存溢出；\nwith open(&#39;./file.txt&#39;) as file:\n    print(file.read())\n\n# 性能最优，返回一个包含所有行的 List；\nwith open(&#39;./file.txt&#39;) as file:\n    for line in file.readlines():\n        print(line.strip())\n\n# 一次读取一行；\nwith open(&#39;./file.txt&#39;) as file:\n    while True:\n        line = file.readline()\n        if line:\n            print(line)\n        else:\n            break\n</code></pre>\n<h4 id=\"4、is：\"><a href=\"#4、is：\" class=\"headerlink\" title=\"4、is：\"></a>4、is：</h4><p><code>is</code> 是比较两个变量所在的内存地址，<code>==</code> 是对比两个变量的值。</p>\n<h4 id=\"5、GC：\"><a href=\"#5、GC：\" class=\"headerlink\" title=\"5、GC：\"></a>5、GC：</h4><p>Python 的垃圾回收机制主要包括引用计数、标记清除和分代技术。</p>\n"},{"title":"Python 小记","intro":"最近在工作中一直在从事 Python 相关的工作，因为以前 Python 用的比较少，特地趁此机会好好学习和复习一下，将一些基础性的知识点整理在这里。同时也方便以后的回顾和查找。关于 Python 的编码规范，有两种常用规范可以选择。一个是 PEP8，另一个是 Google Python 规范。","comments":1,"date":"2017-07-13T15:54:21.000Z","_content":"\n最近在工作中一直在从事 Python 相关的工作，因为以前 Python 用的比较少，特地趁此机会好好学习和复习一下，将一些基础性的知识点整理在这里。同时也方便以后的回顾和查找。关于 Python 的编码规范，有两种常用规范可以选择。一个是 PEP8，另一个是 Google Python 规范。\n\n\n```python\n# 控制台输入；\ns = input(\"Please input:\")\n\n# 类型转换（Python 不允许类型的隐式转换）；\ns = int(s)\ns = str(s)\n\n# 可迭代对象；\nfrom collections import Iterable\nisinstance([], Iterable) # True\n\n# Python 的 for 循环本质上是通过不断调用 next() 函数实现的;\nfor x in [1, 2, 3, 4, 5]:\n    pass\n\n# 首先获得 Iterator 对象；\nit = iter([1, 2, 3, 4, 5])\n# 循环；\nwhile True:\n    try:\n        # 获得下一个值:\n        x = next(it)\n    except StopIteration:\n        # 遇到 StopIteration 就退出循环；\n        break\n\n\n# 多行模式，续行模式；\nprint('''line1\nline2 \nline2''');\n\n# 编码转换；\nord('A') # 65\nchr(66) # 'B'\n\n# 字符串模版；\n'Hi, %s, you have $%d.' % ('Michael', 1000000);\n# 'Hi, Michael, you have $1000000.'\n\n# 判断某一个键值对是否在一个 dict 中；\n'Name' in {'Name': 'Jason', 'Age': 18}\n\n# Set 相关；\ns = set([1, 1, 3, 4])\ns.add(4)\ns.remove(1)\n\n# 交集；\ns &amp; set([1, 3])\n\n# 偏函数；\nimport functools\ndef log(level, message, stack):\n    print(level + \": \" + message)\n    print(stack)\n    \nlog_unknown_error = functools.partial(functools.partial(log, \"Error\"), \"Unknown\")\n\n# 使用不变类型做默认参数；\ndef add_end(L = None):\n    if L is None:\n        L = []\n    L.append('END')\n    return L\n\n# 可变参数和关键字参数；\ndef f1(a, b, c = 0, *args, **kw):\n    print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw)\n\nargs = (1, 2, 3, 4);\nkw = {'d': 99, 'x': '#'}\nf1(args, kw);\n# a = 1 b = 2 c = 3 args = (4,) kw = {'d': 99, 'x': '#'}\n\n# 列表生成式；\n[x * x for x in range(1, 11) if x % 2 == 0]\n\nd = {'x': 'A', 'y': 'B', 'z': 'C' }\n[k + '=' + v for k, v in d.items()]\n\nL = ['Hello', 'World', 'IBM', 'Apple']\n[s.lower() for s in L]\n\n# 切片；\nl = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack'];\nl[:3]\nl[-2:]\nl[:]\nl[::2]\n'ABCDEFG'[:3]\n'ABCDEFG'[::2]\n\n# 生成器（从列表生成式演化过来）；\ng = (x * x for x in range(10));\nnext(g);\n\nfor n in g:\n\tprint(n);\n\n# 断言（不成立会抛出 Assertion Error）；\nassert 1 == 1\n\n# 无参数装饰器；\nimport functools\n\ndef log(func):\n    @functools.wraps(func) # 修正函数的 __name__ 属性；\n    def wrapper(*args, **kw):\n        print('call %s():' % func.__name__)\n        return func(*args, **kw)\n    return wrapper\n# 带参数装饰器；\nimport functools\n\ndef log(text):\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kw):\n            print('%s %s():' % (text, func.__name__))\n            return func(*args, **kw)\n        return wrapper\n    return decorator\n\n# 匿名函数；\nfunc = lambda:1 + 1     # 无参；\nfunc = lambda x:x + 1   # 有参；\n\n# 字符串格式化：\nprint('{},{}'.format('Hongten','Welcome to my space!'))\nprint('Hi,{name},{message}'.format(name = 'Tom',message = 'How old are you?'))\n\ntable = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678}\n    for name, phone in table.items():\n        print('{0:10} ==> {1:10d}'.format(name, phone))\n\n# 字符串格式化，填充与宽度限制（^居中、<左对齐、>右对齐）；\n'{:>8}'.format('189')\n'{:0>8}'.format('189')\n'{:a>8}'.format('189')\n\n# 字符串格式化，精度限制；\n'{:.2f}'.format(321.33345)\n\n# 字符串格式化，进制限制（d/b/o/x）；\n'{:d}'.format(17)\n\n# 字符串格式化，千分位分隔符；\n'{:,}'.format(1234567890)\n```\n\n**闭包和 LEGB 法则：**\n\n* **Local**：可能是在一个函数或者类方法内部；\n* **Enclosed**：可能是嵌套函数内，比如说一个函数包裹在另一个函数内部；\n* **Global**：代表的是执行脚本自身的最高层次；\n* **Built-in**：Python 为自身保留的特殊名称；\n\n闭包最重要的使用价值在于封存函数执行的上下文环境；闭包在其捕捉的执行环境（`def` 语句块所在上下文）中，遵循 LEGB 规则逐层查找，直至找到符合要求的变量，或者抛出异常。可以看如下的 Python 闭包和 Javscript 闭包的示例代码。会产生闭包的根本原因是因为语言的灵活性，可以将函数作为参数或者返回值，这样某层函数的作用域环境会在特定情况下被“保存”下来。\n\n\n```python\n# Python Version；\ndef func1():\n    i = 0\n    def func2():\n        nonlocal i\n        print(++i)\n    return func2\n\nref = func1() # 保存最外层函数的环境和引用；\nref() # 1\nref() # 2\nref() # 3\n```\n\n\n```javascript\n// Javascript；\nfunction func1() {\n  var i = 0;\n  function func2() {\n    console.log(++i);\n  }\n  return func2;\n}\nvar ref = func1();\nref();\nref();\nref();\n```\n","source":"_posts/Python-小记.md","raw":"---\ntitle: Python 小记\nintro: 最近在工作中一直在从事 Python 相关的工作，因为以前 Python 用的比较少，特地趁此机会好好学习和复习一下，将一些基础性的知识点整理在这里。同时也方便以后的回顾和查找。关于 Python 的编码规范，有两种常用规范可以选择。一个是 PEP8，另一个是 Google Python 规范。\ncomments: true\ndate: 2017-07-13 23:54:21\ntags:\n- python\n---\n\n最近在工作中一直在从事 Python 相关的工作，因为以前 Python 用的比较少，特地趁此机会好好学习和复习一下，将一些基础性的知识点整理在这里。同时也方便以后的回顾和查找。关于 Python 的编码规范，有两种常用规范可以选择。一个是 PEP8，另一个是 Google Python 规范。\n\n\n```python\n# 控制台输入；\ns = input(\"Please input:\")\n\n# 类型转换（Python 不允许类型的隐式转换）；\ns = int(s)\ns = str(s)\n\n# 可迭代对象；\nfrom collections import Iterable\nisinstance([], Iterable) # True\n\n# Python 的 for 循环本质上是通过不断调用 next() 函数实现的;\nfor x in [1, 2, 3, 4, 5]:\n    pass\n\n# 首先获得 Iterator 对象；\nit = iter([1, 2, 3, 4, 5])\n# 循环；\nwhile True:\n    try:\n        # 获得下一个值:\n        x = next(it)\n    except StopIteration:\n        # 遇到 StopIteration 就退出循环；\n        break\n\n\n# 多行模式，续行模式；\nprint('''line1\nline2 \nline2''');\n\n# 编码转换；\nord('A') # 65\nchr(66) # 'B'\n\n# 字符串模版；\n'Hi, %s, you have $%d.' % ('Michael', 1000000);\n# 'Hi, Michael, you have $1000000.'\n\n# 判断某一个键值对是否在一个 dict 中；\n'Name' in {'Name': 'Jason', 'Age': 18}\n\n# Set 相关；\ns = set([1, 1, 3, 4])\ns.add(4)\ns.remove(1)\n\n# 交集；\ns &amp; set([1, 3])\n\n# 偏函数；\nimport functools\ndef log(level, message, stack):\n    print(level + \": \" + message)\n    print(stack)\n    \nlog_unknown_error = functools.partial(functools.partial(log, \"Error\"), \"Unknown\")\n\n# 使用不变类型做默认参数；\ndef add_end(L = None):\n    if L is None:\n        L = []\n    L.append('END')\n    return L\n\n# 可变参数和关键字参数；\ndef f1(a, b, c = 0, *args, **kw):\n    print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw)\n\nargs = (1, 2, 3, 4);\nkw = {'d': 99, 'x': '#'}\nf1(args, kw);\n# a = 1 b = 2 c = 3 args = (4,) kw = {'d': 99, 'x': '#'}\n\n# 列表生成式；\n[x * x for x in range(1, 11) if x % 2 == 0]\n\nd = {'x': 'A', 'y': 'B', 'z': 'C' }\n[k + '=' + v for k, v in d.items()]\n\nL = ['Hello', 'World', 'IBM', 'Apple']\n[s.lower() for s in L]\n\n# 切片；\nl = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack'];\nl[:3]\nl[-2:]\nl[:]\nl[::2]\n'ABCDEFG'[:3]\n'ABCDEFG'[::2]\n\n# 生成器（从列表生成式演化过来）；\ng = (x * x for x in range(10));\nnext(g);\n\nfor n in g:\n\tprint(n);\n\n# 断言（不成立会抛出 Assertion Error）；\nassert 1 == 1\n\n# 无参数装饰器；\nimport functools\n\ndef log(func):\n    @functools.wraps(func) # 修正函数的 __name__ 属性；\n    def wrapper(*args, **kw):\n        print('call %s():' % func.__name__)\n        return func(*args, **kw)\n    return wrapper\n# 带参数装饰器；\nimport functools\n\ndef log(text):\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kw):\n            print('%s %s():' % (text, func.__name__))\n            return func(*args, **kw)\n        return wrapper\n    return decorator\n\n# 匿名函数；\nfunc = lambda:1 + 1     # 无参；\nfunc = lambda x:x + 1   # 有参；\n\n# 字符串格式化：\nprint('{},{}'.format('Hongten','Welcome to my space!'))\nprint('Hi,{name},{message}'.format(name = 'Tom',message = 'How old are you?'))\n\ntable = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678}\n    for name, phone in table.items():\n        print('{0:10} ==> {1:10d}'.format(name, phone))\n\n# 字符串格式化，填充与宽度限制（^居中、<左对齐、>右对齐）；\n'{:>8}'.format('189')\n'{:0>8}'.format('189')\n'{:a>8}'.format('189')\n\n# 字符串格式化，精度限制；\n'{:.2f}'.format(321.33345)\n\n# 字符串格式化，进制限制（d/b/o/x）；\n'{:d}'.format(17)\n\n# 字符串格式化，千分位分隔符；\n'{:,}'.format(1234567890)\n```\n\n**闭包和 LEGB 法则：**\n\n* **Local**：可能是在一个函数或者类方法内部；\n* **Enclosed**：可能是嵌套函数内，比如说一个函数包裹在另一个函数内部；\n* **Global**：代表的是执行脚本自身的最高层次；\n* **Built-in**：Python 为自身保留的特殊名称；\n\n闭包最重要的使用价值在于封存函数执行的上下文环境；闭包在其捕捉的执行环境（`def` 语句块所在上下文）中，遵循 LEGB 规则逐层查找，直至找到符合要求的变量，或者抛出异常。可以看如下的 Python 闭包和 Javscript 闭包的示例代码。会产生闭包的根本原因是因为语言的灵活性，可以将函数作为参数或者返回值，这样某层函数的作用域环境会在特定情况下被“保存”下来。\n\n\n```python\n# Python Version；\ndef func1():\n    i = 0\n    def func2():\n        nonlocal i\n        print(++i)\n    return func2\n\nref = func1() # 保存最外层函数的环境和引用；\nref() # 1\nref() # 2\nref() # 3\n```\n\n\n```javascript\n// Javascript；\nfunction func1() {\n  var i = 0;\n  function func2() {\n    console.log(++i);\n  }\n  return func2;\n}\nvar ref = func1();\nref();\nref();\nref();\n```\n","slug":"Python-小记","published":1,"updated":"2019-02-19T10:00:01.814Z","layout":"post","photos":[],"link":"","_id":"cjsqwht9s003cknp2jvlbjjeg","content":"<p>最近在工作中一直在从事 Python 相关的工作，因为以前 Python 用的比较少，特地趁此机会好好学习和复习一下，将一些基础性的知识点整理在这里。同时也方便以后的回顾和查找。关于 Python 的编码规范，有两种常用规范可以选择。一个是 PEP8，另一个是 Google Python 规范。</p>\n<pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token comment\" spellcheck=\"true\"># 控制台输入；</span>\ns <span class=\"token operator\">=</span> input<span class=\"token punctuation\">(</span><span class=\"token string\">\"Please input:\"</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 类型转换（Python 不允许类型的隐式转换）；</span>\ns <span class=\"token operator\">=</span> int<span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span>\ns <span class=\"token operator\">=</span> str<span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 可迭代对象；</span>\n<span class=\"token keyword\">from</span> collections <span class=\"token keyword\">import</span> Iterable\nisinstance<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> Iterable<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\"># True</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># Python 的 for 循环本质上是通过不断调用 next() 函数实现的;</span>\n<span class=\"token keyword\">for</span> x <span class=\"token keyword\">in</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">pass</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 首先获得 Iterator 对象；</span>\nit <span class=\"token operator\">=</span> iter<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\" spellcheck=\"true\"># 循环；</span>\n<span class=\"token keyword\">while</span> <span class=\"token boolean\">True</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">try</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\" spellcheck=\"true\"># 获得下一个值:</span>\n        x <span class=\"token operator\">=</span> next<span class=\"token punctuation\">(</span>it<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">except</span> StopIteration<span class=\"token punctuation\">:</span>\n        <span class=\"token comment\" spellcheck=\"true\"># 遇到 StopIteration 就退出循环；</span>\n        <span class=\"token keyword\">break</span>\n\n\n<span class=\"token comment\" spellcheck=\"true\"># 多行模式，续行模式；</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token triple-quoted-string string\">'''line1\nline2 \nline2'''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 编码转换；</span>\nord<span class=\"token punctuation\">(</span><span class=\"token string\">'A'</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\"># 65</span>\nchr<span class=\"token punctuation\">(</span><span class=\"token number\">66</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\"># 'B'</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 字符串模版；</span>\n<span class=\"token string\">'Hi, %s, you have $%d.'</span> <span class=\"token operator\">%</span> <span class=\"token punctuation\">(</span><span class=\"token string\">'Michael'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\"># 'Hi, Michael, you have $1000000.'</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 判断某一个键值对是否在一个 dict 中；</span>\n<span class=\"token string\">'Name'</span> <span class=\"token keyword\">in</span> <span class=\"token punctuation\">{</span><span class=\"token string\">'Name'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'Jason'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Age'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">18</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># Set 相关；</span>\ns <span class=\"token operator\">=</span> set<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\ns<span class=\"token punctuation\">.</span>add<span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span>\ns<span class=\"token punctuation\">.</span>remove<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 交集；</span>\ns <span class=\"token operator\">&amp;</span>amp<span class=\"token punctuation\">;</span> set<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 偏函数；</span>\n<span class=\"token keyword\">import</span> functools\n<span class=\"token keyword\">def</span> <span class=\"token function\">log</span><span class=\"token punctuation\">(</span>level<span class=\"token punctuation\">,</span> message<span class=\"token punctuation\">,</span> stack<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>level <span class=\"token operator\">+</span> <span class=\"token string\">\": \"</span> <span class=\"token operator\">+</span> message<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>stack<span class=\"token punctuation\">)</span>\n\nlog_unknown_error <span class=\"token operator\">=</span> functools<span class=\"token punctuation\">.</span>partial<span class=\"token punctuation\">(</span>functools<span class=\"token punctuation\">.</span>partial<span class=\"token punctuation\">(</span>log<span class=\"token punctuation\">,</span> <span class=\"token string\">\"Error\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Unknown\"</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 使用不变类型做默认参数；</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">add_end</span><span class=\"token punctuation\">(</span>L <span class=\"token operator\">=</span> None<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">if</span> L <span class=\"token keyword\">is</span> None<span class=\"token punctuation\">:</span>\n        L <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    L<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token string\">'END'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> L\n\n<span class=\"token comment\" spellcheck=\"true\"># 可变参数和关键字参数；</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">f1</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">,</span> c <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>args<span class=\"token punctuation\">,</span> <span class=\"token operator\">**</span>kw<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'a ='</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span> <span class=\"token string\">'b ='</span><span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">,</span> <span class=\"token string\">'c ='</span><span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">,</span> <span class=\"token string\">'args ='</span><span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">,</span> <span class=\"token string\">'kw ='</span><span class=\"token punctuation\">,</span> kw<span class=\"token punctuation\">)</span>\n\nargs <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nkw <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token string\">'d'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">99</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'x'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'#'</span><span class=\"token punctuation\">}</span>\nf1<span class=\"token punctuation\">(</span>args<span class=\"token punctuation\">,</span> kw<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\"># a = 1 b = 2 c = 3 args = (4,) kw = {'d': 99, 'x': '#'}</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 列表生成式；</span>\n<span class=\"token punctuation\">[</span>x <span class=\"token operator\">*</span> x <span class=\"token keyword\">for</span> x <span class=\"token keyword\">in</span> range<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">11</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">if</span> x <span class=\"token operator\">%</span> <span class=\"token number\">2</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\n\nd <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token string\">'x'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'A'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'y'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'B'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'z'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'C'</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">[</span>k <span class=\"token operator\">+</span> <span class=\"token string\">'='</span> <span class=\"token operator\">+</span> v <span class=\"token keyword\">for</span> k<span class=\"token punctuation\">,</span> v <span class=\"token keyword\">in</span> d<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n\nL <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'Hello'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'World'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'IBM'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Apple'</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">[</span>s<span class=\"token punctuation\">.</span>lower<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">for</span> s <span class=\"token keyword\">in</span> L<span class=\"token punctuation\">]</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 切片；</span>\nl <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'Michael'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Sarah'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Tracy'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Bob'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Jack'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nl<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span>\nl<span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span>\nl<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span>\nl<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span>\n<span class=\"token string\">'ABCDEFG'</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span>\n<span class=\"token string\">'ABCDEFG'</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 生成器（从列表生成式演化过来）；</span>\ng <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>x <span class=\"token operator\">*</span> x <span class=\"token keyword\">for</span> x <span class=\"token keyword\">in</span> range<span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nnext<span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">for</span> n <span class=\"token keyword\">in</span> g<span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 断言（不成立会抛出 Assertion Error）；</span>\n<span class=\"token keyword\">assert</span> <span class=\"token number\">1</span> <span class=\"token operator\">==</span> <span class=\"token number\">1</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 无参数装饰器；</span>\n<span class=\"token keyword\">import</span> functools\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">log</span><span class=\"token punctuation\">(</span>func<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    @functools<span class=\"token punctuation\">.</span>wraps<span class=\"token punctuation\">(</span>func<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\"># 修正函数的 __name__ 属性；</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">wrapper</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>args<span class=\"token punctuation\">,</span> <span class=\"token operator\">**</span>kw<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'call %s():'</span> <span class=\"token operator\">%</span> func<span class=\"token punctuation\">.</span>__name__<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> func<span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>args<span class=\"token punctuation\">,</span> <span class=\"token operator\">**</span>kw<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> wrapper\n<span class=\"token comment\" spellcheck=\"true\"># 带参数装饰器；</span>\n<span class=\"token keyword\">import</span> functools\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">log</span><span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">decorator</span><span class=\"token punctuation\">(</span>func<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        @functools<span class=\"token punctuation\">.</span>wraps<span class=\"token punctuation\">(</span>func<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">def</span> <span class=\"token function\">wrapper</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>args<span class=\"token punctuation\">,</span> <span class=\"token operator\">**</span>kw<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'%s %s():'</span> <span class=\"token operator\">%</span> <span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">,</span> func<span class=\"token punctuation\">.</span>__name__<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> func<span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>args<span class=\"token punctuation\">,</span> <span class=\"token operator\">**</span>kw<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> wrapper\n    <span class=\"token keyword\">return</span> decorator\n\n<span class=\"token comment\" spellcheck=\"true\"># 匿名函数；</span>\nfunc <span class=\"token operator\">=</span> <span class=\"token keyword\">lambda</span><span class=\"token punctuation\">:</span><span class=\"token number\">1</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span>     <span class=\"token comment\" spellcheck=\"true\"># 无参；</span>\nfunc <span class=\"token operator\">=</span> <span class=\"token keyword\">lambda</span> x<span class=\"token punctuation\">:</span>x <span class=\"token operator\">+</span> <span class=\"token number\">1</span>   <span class=\"token comment\" spellcheck=\"true\"># 有参；</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 字符串格式化：</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'{},{}'</span><span class=\"token punctuation\">.</span>format<span class=\"token punctuation\">(</span><span class=\"token string\">'Hongten'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'Welcome to my space!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Hi,{name},{message}'</span><span class=\"token punctuation\">.</span>format<span class=\"token punctuation\">(</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'Tom'</span><span class=\"token punctuation\">,</span>message <span class=\"token operator\">=</span> <span class=\"token string\">'How old are you?'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\ntable <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token string\">'Sjoerd'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">4127</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Jack'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">4098</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Dcab'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">7678</span><span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">for</span> name<span class=\"token punctuation\">,</span> phone <span class=\"token keyword\">in</span> table<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'{0:10} ==> {1:10d}'</span><span class=\"token punctuation\">.</span>format<span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> phone<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 字符串格式化，填充与宽度限制（^居中、&lt;左对齐、>右对齐）；</span>\n<span class=\"token string\">'{:>8}'</span><span class=\"token punctuation\">.</span>format<span class=\"token punctuation\">(</span><span class=\"token string\">'189'</span><span class=\"token punctuation\">)</span>\n<span class=\"token string\">'{:0>8}'</span><span class=\"token punctuation\">.</span>format<span class=\"token punctuation\">(</span><span class=\"token string\">'189'</span><span class=\"token punctuation\">)</span>\n<span class=\"token string\">'{:a>8}'</span><span class=\"token punctuation\">.</span>format<span class=\"token punctuation\">(</span><span class=\"token string\">'189'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 字符串格式化，精度限制；</span>\n<span class=\"token string\">'{:.2f}'</span><span class=\"token punctuation\">.</span>format<span class=\"token punctuation\">(</span><span class=\"token number\">321.33345</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 字符串格式化，进制限制（d/b/o/x）；</span>\n<span class=\"token string\">'{:d}'</span><span class=\"token punctuation\">.</span>format<span class=\"token punctuation\">(</span><span class=\"token number\">17</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 字符串格式化，千分位分隔符；</span>\n<span class=\"token string\">'{:,}'</span><span class=\"token punctuation\">.</span>format<span class=\"token punctuation\">(</span><span class=\"token number\">1234567890</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>闭包和 LEGB 法则：</strong></p>\n<ul>\n<li><strong>Local</strong>：可能是在一个函数或者类方法内部；</li>\n<li><strong>Enclosed</strong>：可能是嵌套函数内，比如说一个函数包裹在另一个函数内部；</li>\n<li><strong>Global</strong>：代表的是执行脚本自身的最高层次；</li>\n<li><strong>Built-in</strong>：Python 为自身保留的特殊名称；</li>\n</ul>\n<p>闭包最重要的使用价值在于封存函数执行的上下文环境；闭包在其捕捉的执行环境（<code>def</code> 语句块所在上下文）中，遵循 LEGB 规则逐层查找，直至找到符合要求的变量，或者抛出异常。可以看如下的 Python 闭包和 Javscript 闭包的示例代码。会产生闭包的根本原因是因为语言的灵活性，可以将函数作为参数或者返回值，这样某层函数的作用域环境会在特定情况下被“保存”下来。</p>\n<pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token comment\" spellcheck=\"true\"># Python Version；</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">func1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    i <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">func2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        nonlocal i\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token operator\">+</span><span class=\"token operator\">+</span>i<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> func2\n\nref <span class=\"token operator\">=</span> func1<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\"># 保存最外层函数的环境和引用；</span>\nref<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\"># 1</span>\nref<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\"># 2</span>\nref<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\"># 3</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">// Javascript；</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">func1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">func2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> func2<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">var</span> ref <span class=\"token operator\">=</span> <span class=\"token function\">func1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">ref</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">ref</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">ref</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"id":"737213a93bbff339bde15bd99a44e524","excerpt":"","more":"<p>最近在工作中一直在从事 Python 相关的工作，因为以前 Python 用的比较少，特地趁此机会好好学习和复习一下，将一些基础性的知识点整理在这里。同时也方便以后的回顾和查找。关于 Python 的编码规范，有两种常用规范可以选择。一个是 PEP8，另一个是 Google Python 规范。</p>\n<pre><code class=\"python\"># 控制台输入；\ns = input(&quot;Please input:&quot;)\n\n# 类型转换（Python 不允许类型的隐式转换）；\ns = int(s)\ns = str(s)\n\n# 可迭代对象；\nfrom collections import Iterable\nisinstance([], Iterable) # True\n\n# Python 的 for 循环本质上是通过不断调用 next() 函数实现的;\nfor x in [1, 2, 3, 4, 5]:\n    pass\n\n# 首先获得 Iterator 对象；\nit = iter([1, 2, 3, 4, 5])\n# 循环；\nwhile True:\n    try:\n        # 获得下一个值:\n        x = next(it)\n    except StopIteration:\n        # 遇到 StopIteration 就退出循环；\n        break\n\n\n# 多行模式，续行模式；\nprint(&#39;&#39;&#39;line1\nline2 \nline2&#39;&#39;&#39;);\n\n# 编码转换；\nord(&#39;A&#39;) # 65\nchr(66) # &#39;B&#39;\n\n# 字符串模版；\n&#39;Hi, %s, you have $%d.&#39; % (&#39;Michael&#39;, 1000000);\n# &#39;Hi, Michael, you have $1000000.&#39;\n\n# 判断某一个键值对是否在一个 dict 中；\n&#39;Name&#39; in {&#39;Name&#39;: &#39;Jason&#39;, &#39;Age&#39;: 18}\n\n# Set 相关；\ns = set([1, 1, 3, 4])\ns.add(4)\ns.remove(1)\n\n# 交集；\ns &amp;amp; set([1, 3])\n\n# 偏函数；\nimport functools\ndef log(level, message, stack):\n    print(level + &quot;: &quot; + message)\n    print(stack)\n\nlog_unknown_error = functools.partial(functools.partial(log, &quot;Error&quot;), &quot;Unknown&quot;)\n\n# 使用不变类型做默认参数；\ndef add_end(L = None):\n    if L is None:\n        L = []\n    L.append(&#39;END&#39;)\n    return L\n\n# 可变参数和关键字参数；\ndef f1(a, b, c = 0, *args, **kw):\n    print(&#39;a =&#39;, a, &#39;b =&#39;, b, &#39;c =&#39;, c, &#39;args =&#39;, args, &#39;kw =&#39;, kw)\n\nargs = (1, 2, 3, 4);\nkw = {&#39;d&#39;: 99, &#39;x&#39;: &#39;#&#39;}\nf1(args, kw);\n# a = 1 b = 2 c = 3 args = (4,) kw = {&#39;d&#39;: 99, &#39;x&#39;: &#39;#&#39;}\n\n# 列表生成式；\n[x * x for x in range(1, 11) if x % 2 == 0]\n\nd = {&#39;x&#39;: &#39;A&#39;, &#39;y&#39;: &#39;B&#39;, &#39;z&#39;: &#39;C&#39; }\n[k + &#39;=&#39; + v for k, v in d.items()]\n\nL = [&#39;Hello&#39;, &#39;World&#39;, &#39;IBM&#39;, &#39;Apple&#39;]\n[s.lower() for s in L]\n\n# 切片；\nl = [&#39;Michael&#39;, &#39;Sarah&#39;, &#39;Tracy&#39;, &#39;Bob&#39;, &#39;Jack&#39;];\nl[:3]\nl[-2:]\nl[:]\nl[::2]\n&#39;ABCDEFG&#39;[:3]\n&#39;ABCDEFG&#39;[::2]\n\n# 生成器（从列表生成式演化过来）；\ng = (x * x for x in range(10));\nnext(g);\n\nfor n in g:\n    print(n);\n\n# 断言（不成立会抛出 Assertion Error）；\nassert 1 == 1\n\n# 无参数装饰器；\nimport functools\n\ndef log(func):\n    @functools.wraps(func) # 修正函数的 __name__ 属性；\n    def wrapper(*args, **kw):\n        print(&#39;call %s():&#39; % func.__name__)\n        return func(*args, **kw)\n    return wrapper\n# 带参数装饰器；\nimport functools\n\ndef log(text):\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kw):\n            print(&#39;%s %s():&#39; % (text, func.__name__))\n            return func(*args, **kw)\n        return wrapper\n    return decorator\n\n# 匿名函数；\nfunc = lambda:1 + 1     # 无参；\nfunc = lambda x:x + 1   # 有参；\n\n# 字符串格式化：\nprint(&#39;{},{}&#39;.format(&#39;Hongten&#39;,&#39;Welcome to my space!&#39;))\nprint(&#39;Hi,{name},{message}&#39;.format(name = &#39;Tom&#39;,message = &#39;How old are you?&#39;))\n\ntable = {&#39;Sjoerd&#39;: 4127, &#39;Jack&#39;: 4098, &#39;Dcab&#39;: 7678}\n    for name, phone in table.items():\n        print(&#39;{0:10} ==&gt; {1:10d}&#39;.format(name, phone))\n\n# 字符串格式化，填充与宽度限制（^居中、&lt;左对齐、&gt;右对齐）；\n&#39;{:&gt;8}&#39;.format(&#39;189&#39;)\n&#39;{:0&gt;8}&#39;.format(&#39;189&#39;)\n&#39;{:a&gt;8}&#39;.format(&#39;189&#39;)\n\n# 字符串格式化，精度限制；\n&#39;{:.2f}&#39;.format(321.33345)\n\n# 字符串格式化，进制限制（d/b/o/x）；\n&#39;{:d}&#39;.format(17)\n\n# 字符串格式化，千分位分隔符；\n&#39;{:,}&#39;.format(1234567890)\n</code></pre>\n<p><strong>闭包和 LEGB 法则：</strong></p>\n<ul>\n<li><strong>Local</strong>：可能是在一个函数或者类方法内部；</li>\n<li><strong>Enclosed</strong>：可能是嵌套函数内，比如说一个函数包裹在另一个函数内部；</li>\n<li><strong>Global</strong>：代表的是执行脚本自身的最高层次；</li>\n<li><strong>Built-in</strong>：Python 为自身保留的特殊名称；</li>\n</ul>\n<p>闭包最重要的使用价值在于封存函数执行的上下文环境；闭包在其捕捉的执行环境（<code>def</code> 语句块所在上下文）中，遵循 LEGB 规则逐层查找，直至找到符合要求的变量，或者抛出异常。可以看如下的 Python 闭包和 Javscript 闭包的示例代码。会产生闭包的根本原因是因为语言的灵活性，可以将函数作为参数或者返回值，这样某层函数的作用域环境会在特定情况下被“保存”下来。</p>\n<pre><code class=\"python\"># Python Version；\ndef func1():\n    i = 0\n    def func2():\n        nonlocal i\n        print(++i)\n    return func2\n\nref = func1() # 保存最外层函数的环境和引用；\nref() # 1\nref() # 2\nref() # 3\n</code></pre>\n<pre><code class=\"javascript\">// Javascript；\nfunction func1() {\n  var i = 0;\n  function func2() {\n    console.log(++i);\n  }\n  return func2;\n}\nvar ref = func1();\nref();\nref();\nref();\n</code></pre>\n"},{"title":"STC 与 PTC","intro":"要讲 STC 与 PTC ，则要从“尾递归”先开始说起，相信递归调用大家应该都很熟悉，递归就是指在一个函数内部再次调用该函数本身。那么尾递归从形式上来看就可以理解为在一个函数内部的“最后一行语句”中调用自己。","comments":1,"date":"2017-05-06T15:56:05.000Z","_content":"\n要讲 STC 与 PTC ，则要从“尾递归”先开始说起，相信递归调用大家应该都很熟悉，递归就是指在一个函数内部再次调用该函数本身。那么尾递归从形式上来看就可以理解为在一个函数内部的“最后一行语句”中调用自己。\n\n#### 一、尾递归：\n\n递归调用，比如斐波那契数列：1、1、2、3、5、8 ... 总结之后我们可以发现一个规律 F(N) = F(N-1) + F(N-2) (N 不等于1和2)。因此一个常用的求斐波那契数列第 N 项值的函数便诞生如下：\n\n\n```javascript\nfunction fibonacci(n) {\n  if (n <= 0) {\n    return 0;\n  } else if (n === 1) {\n    return 1;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2)\n}\n```\n\n\n为什么不合适的递归会造成堆栈溢出呢？因为递归在每一次调用自身时都会保留上一层调用的环境参数（局部变量、返回地址入口等），如果递归层数太多就会造成堆栈段内存溢出。比如对于上述的斐波那契数列计算函数，我们举例 `fibonacci(4)`，其堆栈大致示意图如下：\n\n\n```shell\nfibonacci(4)\nfibonacci(3) + fibonacci(2)\nfibonacci(2) + fibonacci(1) + fibonacci(1) + fibonacci(0)\nfibonacci(1) + fibonacci(0) + 1 + 1 + 0\n1 + 0 + 1 + 1 + 0\n```\n\n\n下面给出一个求斐波那契数列第 N 项值函数的尾递归版本：\n\n\n```javascript\nfunction fibonacci(n, num1 = 1, num2 = 1) {\n  if (n <= 0) {\n    return 0;\n  } else if (n === 1) {\n    return num1;\n  }\n  return fibonacci(n - 1, num2, num1 + num2);\n}\n```\n\n\n其对应的调用栈如下所示：\n\n\n```shell\nfibonacci(4)\nfibonacci(3, 1, 2)\nfibonacci(2, 2, 3)\nfibonacci(1, 3, 5)\n3\n```\n\n\n尾递归的本质实际上就是将每层递归需要的参数以**传参**的方式直接传入下一次的调用过程之中，这样之前的堆栈信息便可以不再保留，并被即时的释放掉。但这样带来的问题是参数没办法语义化，对外的接口不够友好，因此在使用尾递归时需要用 **ES6 的默认参数**或者**函数柯理化**等方式进行优化。\n\n其实从根本上来讲，递归操作这种比较重型的密集计算不适合在前端进行，对于单线程的浏览器引擎，如果在主线程运行很有可能导致页面失去响应。因此可以考虑利用 Web Worker 放到单独的计算线程中进行，同时还要做好必要的尾递归优化。\n\n#### 二、PTC (Proper Tail Call)：\n\nPTC 是在 ES6 中提出的尾递归优化草案，该草案只能在严格模式下实现。草案对应的功能仍然在 TC39 标准委员会中进行讨论，现在还并没有部署到各个浏览器的 JavaScript 引擎上。\n\n![](1.jpg)\n\nES6 草案中定义了 PTC 规范，其规定在严格模式下的尾递归调用绝对不会出现堆栈溢出的问题。但 PTC 目前还存在一些问题比如：\n\n1. PTC 标准性能在各个 JS 引擎上的实现并不统一；\n2. 由于为了优化性能，使得递归调用中的很多调用帧被丢弃，所以可能会对代码调试带来问题；\n3. 启用 PTC 会改变以往的错误栈信息；\n4. 可能并不符合开发者意图（如开发者并不想进行尾递归优化）；\n\n因此在 PTC 的基础上，又提出了 STC。\n\n#### 三、STC (Syntactic Tail Call)：\n\nSTC 提出了新的语法，可以使开发者“主动”的去触发尾递归优化，新语法分别对应三种不同情况的语法环境：\n\n\n```javascript\nfunction factorial(n, acc = 1) {\n  if (n === 1) {\n    return acc;\n  }\n  return continue factorial(n - 1, acc * n)\n}\n```\n\n```javascript\n#function() { /* all calls in tail position are tail calls */ }\n```\n\n```javascript\nfunction () { \n  !return expr;\n}\n```\n","source":"_posts/STC-与-PTC.md","raw":"---\ntitle: STC 与 PTC\nintro: 要讲 STC 与 PTC ，则要从“尾递归”先开始说起，相信递归调用大家应该都很熟悉，递归就是指在一个函数内部再次调用该函数本身。那么尾递归从形式上来看就可以理解为在一个函数内部的“最后一行语句”中调用自己。\ncomments: true\ndate: 2017-05-06 23:56:05\ntags:\n- 尾递归\n---\n\n要讲 STC 与 PTC ，则要从“尾递归”先开始说起，相信递归调用大家应该都很熟悉，递归就是指在一个函数内部再次调用该函数本身。那么尾递归从形式上来看就可以理解为在一个函数内部的“最后一行语句”中调用自己。\n\n#### 一、尾递归：\n\n递归调用，比如斐波那契数列：1、1、2、3、5、8 ... 总结之后我们可以发现一个规律 F(N) = F(N-1) + F(N-2) (N 不等于1和2)。因此一个常用的求斐波那契数列第 N 项值的函数便诞生如下：\n\n\n```javascript\nfunction fibonacci(n) {\n  if (n <= 0) {\n    return 0;\n  } else if (n === 1) {\n    return 1;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2)\n}\n```\n\n\n为什么不合适的递归会造成堆栈溢出呢？因为递归在每一次调用自身时都会保留上一层调用的环境参数（局部变量、返回地址入口等），如果递归层数太多就会造成堆栈段内存溢出。比如对于上述的斐波那契数列计算函数，我们举例 `fibonacci(4)`，其堆栈大致示意图如下：\n\n\n```shell\nfibonacci(4)\nfibonacci(3) + fibonacci(2)\nfibonacci(2) + fibonacci(1) + fibonacci(1) + fibonacci(0)\nfibonacci(1) + fibonacci(0) + 1 + 1 + 0\n1 + 0 + 1 + 1 + 0\n```\n\n\n下面给出一个求斐波那契数列第 N 项值函数的尾递归版本：\n\n\n```javascript\nfunction fibonacci(n, num1 = 1, num2 = 1) {\n  if (n <= 0) {\n    return 0;\n  } else if (n === 1) {\n    return num1;\n  }\n  return fibonacci(n - 1, num2, num1 + num2);\n}\n```\n\n\n其对应的调用栈如下所示：\n\n\n```shell\nfibonacci(4)\nfibonacci(3, 1, 2)\nfibonacci(2, 2, 3)\nfibonacci(1, 3, 5)\n3\n```\n\n\n尾递归的本质实际上就是将每层递归需要的参数以**传参**的方式直接传入下一次的调用过程之中，这样之前的堆栈信息便可以不再保留，并被即时的释放掉。但这样带来的问题是参数没办法语义化，对外的接口不够友好，因此在使用尾递归时需要用 **ES6 的默认参数**或者**函数柯理化**等方式进行优化。\n\n其实从根本上来讲，递归操作这种比较重型的密集计算不适合在前端进行，对于单线程的浏览器引擎，如果在主线程运行很有可能导致页面失去响应。因此可以考虑利用 Web Worker 放到单独的计算线程中进行，同时还要做好必要的尾递归优化。\n\n#### 二、PTC (Proper Tail Call)：\n\nPTC 是在 ES6 中提出的尾递归优化草案，该草案只能在严格模式下实现。草案对应的功能仍然在 TC39 标准委员会中进行讨论，现在还并没有部署到各个浏览器的 JavaScript 引擎上。\n\n![](1.jpg)\n\nES6 草案中定义了 PTC 规范，其规定在严格模式下的尾递归调用绝对不会出现堆栈溢出的问题。但 PTC 目前还存在一些问题比如：\n\n1. PTC 标准性能在各个 JS 引擎上的实现并不统一；\n2. 由于为了优化性能，使得递归调用中的很多调用帧被丢弃，所以可能会对代码调试带来问题；\n3. 启用 PTC 会改变以往的错误栈信息；\n4. 可能并不符合开发者意图（如开发者并不想进行尾递归优化）；\n\n因此在 PTC 的基础上，又提出了 STC。\n\n#### 三、STC (Syntactic Tail Call)：\n\nSTC 提出了新的语法，可以使开发者“主动”的去触发尾递归优化，新语法分别对应三种不同情况的语法环境：\n\n\n```javascript\nfunction factorial(n, acc = 1) {\n  if (n === 1) {\n    return acc;\n  }\n  return continue factorial(n - 1, acc * n)\n}\n```\n\n```javascript\n#function() { /* all calls in tail position are tail calls */ }\n```\n\n```javascript\nfunction () { \n  !return expr;\n}\n```\n","slug":"STC-与-PTC","published":1,"updated":"2019-02-18T01:41:46.323Z","layout":"post","photos":[],"link":"","_id":"cjsqwht9t003fknp2sz7lazp4","content":"<p>要讲 STC 与 PTC ，则要从“尾递归”先开始说起，相信递归调用大家应该都很熟悉，递归就是指在一个函数内部再次调用该函数本身。那么尾递归从形式上来看就可以理解为在一个函数内部的“最后一行语句”中调用自己。</p>\n<h4 id=\"一、尾递归：\"><a href=\"#一、尾递归：\" class=\"headerlink\" title=\"一、尾递归：\"></a>一、尾递归：</h4><p>递归调用，比如斐波那契数列：1、1、2、3、5、8 … 总结之后我们可以发现一个规律 F(N) = F(N-1) + F(N-2) (N 不等于1和2)。因此一个常用的求斐波那契数列第 N 项值的函数便诞生如下：</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">fibonacci</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">===</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">fibonacci</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">fibonacci</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>为什么不合适的递归会造成堆栈溢出呢？因为递归在每一次调用自身时都会保留上一层调用的环境参数（局部变量、返回地址入口等），如果递归层数太多就会造成堆栈段内存溢出。比如对于上述的斐波那契数列计算函数，我们举例 <code>fibonacci(4)</code>，其堆栈大致示意图如下：</p>\n<pre class=\"line-numbers language-shell\"><code class=\"language-shell\">fibonacci(4)\nfibonacci(3) + fibonacci(2)\nfibonacci(2) + fibonacci(1) + fibonacci(1) + fibonacci(0)\nfibonacci(1) + fibonacci(0) + 1 + 1 + 0\n1 + 0 + 1 + 1 + 0\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>下面给出一个求斐波那契数列第 N 项值函数的尾递归版本：</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">fibonacci</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">,</span> num1 <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> num2 <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">===</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> num1<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">fibonacci</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> num2<span class=\"token punctuation\">,</span> num1 <span class=\"token operator\">+</span> num2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>其对应的调用栈如下所示：</p>\n<pre class=\"line-numbers language-shell\"><code class=\"language-shell\">fibonacci(4)\nfibonacci(3, 1, 2)\nfibonacci(2, 2, 3)\nfibonacci(1, 3, 5)\n3\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>尾递归的本质实际上就是将每层递归需要的参数以<strong>传参</strong>的方式直接传入下一次的调用过程之中，这样之前的堆栈信息便可以不再保留，并被即时的释放掉。但这样带来的问题是参数没办法语义化，对外的接口不够友好，因此在使用尾递归时需要用 <strong>ES6 的默认参数</strong>或者<strong>函数柯理化</strong>等方式进行优化。</p>\n<p>其实从根本上来讲，递归操作这种比较重型的密集计算不适合在前端进行，对于单线程的浏览器引擎，如果在主线程运行很有可能导致页面失去响应。因此可以考虑利用 Web Worker 放到单独的计算线程中进行，同时还要做好必要的尾递归优化。</p>\n<h4 id=\"二、PTC-Proper-Tail-Call-：\"><a href=\"#二、PTC-Proper-Tail-Call-：\" class=\"headerlink\" title=\"二、PTC (Proper Tail Call)：\"></a>二、PTC (Proper Tail Call)：</h4><p>PTC 是在 ES6 中提出的尾递归优化草案，该草案只能在严格模式下实现。草案对应的功能仍然在 TC39 标准委员会中进行讨论，现在还并没有部署到各个浏览器的 JavaScript 引擎上。</p>\n<p><img src=\"1.jpg\" alt></p>\n<p>ES6 草案中定义了 PTC 规范，其规定在严格模式下的尾递归调用绝对不会出现堆栈溢出的问题。但 PTC 目前还存在一些问题比如：</p>\n<ol>\n<li>PTC 标准性能在各个 JS 引擎上的实现并不统一；</li>\n<li>由于为了优化性能，使得递归调用中的很多调用帧被丢弃，所以可能会对代码调试带来问题；</li>\n<li>启用 PTC 会改变以往的错误栈信息；</li>\n<li>可能并不符合开发者意图（如开发者并不想进行尾递归优化）；</li>\n</ol>\n<p>因此在 PTC 的基础上，又提出了 STC。</p>\n<h4 id=\"三、STC-Syntactic-Tail-Call-：\"><a href=\"#三、STC-Syntactic-Tail-Call-：\" class=\"headerlink\" title=\"三、STC (Syntactic Tail Call)：\"></a>三、STC (Syntactic Tail Call)：</h4><p>STC 提出了新的语法，可以使开发者“主动”的去触发尾递归优化，新语法分别对应三种不同情况的语法环境：</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">factorial</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">,</span> acc <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">===</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> acc<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">continue</span> <span class=\"token function\">factorial</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> acc <span class=\"token operator\">*</span> n<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\">#<span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">/* all calls in tail position are tail calls */</span> <span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n  <span class=\"token operator\">!</span><span class=\"token keyword\">return</span> expr<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"id":"60a3b09f380143be457255f7ed446aeb","excerpt":"","more":"<p>要讲 STC 与 PTC ，则要从“尾递归”先开始说起，相信递归调用大家应该都很熟悉，递归就是指在一个函数内部再次调用该函数本身。那么尾递归从形式上来看就可以理解为在一个函数内部的“最后一行语句”中调用自己。</p>\n<h4 id=\"一、尾递归：\"><a href=\"#一、尾递归：\" class=\"headerlink\" title=\"一、尾递归：\"></a>一、尾递归：</h4><p>递归调用，比如斐波那契数列：1、1、2、3、5、8 … 总结之后我们可以发现一个规律 F(N) = F(N-1) + F(N-2) (N 不等于1和2)。因此一个常用的求斐波那契数列第 N 项值的函数便诞生如下：</p>\n<pre><code class=\"javascript\">function fibonacci(n) {\n  if (n &lt;= 0) {\n    return 0;\n  } else if (n === 1) {\n    return 1;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2)\n}\n</code></pre>\n<p>为什么不合适的递归会造成堆栈溢出呢？因为递归在每一次调用自身时都会保留上一层调用的环境参数（局部变量、返回地址入口等），如果递归层数太多就会造成堆栈段内存溢出。比如对于上述的斐波那契数列计算函数，我们举例 <code>fibonacci(4)</code>，其堆栈大致示意图如下：</p>\n<pre><code class=\"shell\">fibonacci(4)\nfibonacci(3) + fibonacci(2)\nfibonacci(2) + fibonacci(1) + fibonacci(1) + fibonacci(0)\nfibonacci(1) + fibonacci(0) + 1 + 1 + 0\n1 + 0 + 1 + 1 + 0\n</code></pre>\n<p>下面给出一个求斐波那契数列第 N 项值函数的尾递归版本：</p>\n<pre><code class=\"javascript\">function fibonacci(n, num1 = 1, num2 = 1) {\n  if (n &lt;= 0) {\n    return 0;\n  } else if (n === 1) {\n    return num1;\n  }\n  return fibonacci(n - 1, num2, num1 + num2);\n}\n</code></pre>\n<p>其对应的调用栈如下所示：</p>\n<pre><code class=\"shell\">fibonacci(4)\nfibonacci(3, 1, 2)\nfibonacci(2, 2, 3)\nfibonacci(1, 3, 5)\n3\n</code></pre>\n<p>尾递归的本质实际上就是将每层递归需要的参数以<strong>传参</strong>的方式直接传入下一次的调用过程之中，这样之前的堆栈信息便可以不再保留，并被即时的释放掉。但这样带来的问题是参数没办法语义化，对外的接口不够友好，因此在使用尾递归时需要用 <strong>ES6 的默认参数</strong>或者<strong>函数柯理化</strong>等方式进行优化。</p>\n<p>其实从根本上来讲，递归操作这种比较重型的密集计算不适合在前端进行，对于单线程的浏览器引擎，如果在主线程运行很有可能导致页面失去响应。因此可以考虑利用 Web Worker 放到单独的计算线程中进行，同时还要做好必要的尾递归优化。</p>\n<h4 id=\"二、PTC-Proper-Tail-Call-：\"><a href=\"#二、PTC-Proper-Tail-Call-：\" class=\"headerlink\" title=\"二、PTC (Proper Tail Call)：\"></a>二、PTC (Proper Tail Call)：</h4><p>PTC 是在 ES6 中提出的尾递归优化草案，该草案只能在严格模式下实现。草案对应的功能仍然在 TC39 标准委员会中进行讨论，现在还并没有部署到各个浏览器的 JavaScript 引擎上。</p>\n<p><img src=\"1.jpg\" alt></p>\n<p>ES6 草案中定义了 PTC 规范，其规定在严格模式下的尾递归调用绝对不会出现堆栈溢出的问题。但 PTC 目前还存在一些问题比如：</p>\n<ol>\n<li>PTC 标准性能在各个 JS 引擎上的实现并不统一；</li>\n<li>由于为了优化性能，使得递归调用中的很多调用帧被丢弃，所以可能会对代码调试带来问题；</li>\n<li>启用 PTC 会改变以往的错误栈信息；</li>\n<li>可能并不符合开发者意图（如开发者并不想进行尾递归优化）；</li>\n</ol>\n<p>因此在 PTC 的基础上，又提出了 STC。</p>\n<h4 id=\"三、STC-Syntactic-Tail-Call-：\"><a href=\"#三、STC-Syntactic-Tail-Call-：\" class=\"headerlink\" title=\"三、STC (Syntactic Tail Call)：\"></a>三、STC (Syntactic Tail Call)：</h4><p>STC 提出了新的语法，可以使开发者“主动”的去触发尾递归优化，新语法分别对应三种不同情况的语法环境：</p>\n<pre><code class=\"javascript\">function factorial(n, acc = 1) {\n  if (n === 1) {\n    return acc;\n  }\n  return continue factorial(n - 1, acc * n)\n}\n</code></pre>\n<pre><code class=\"javascript\">#function() { /* all calls in tail position are tail calls */ }\n</code></pre>\n<pre><code class=\"javascript\">function () { \n  !return expr;\n}\n</code></pre>\n"},{"title":"Redis 源码之内存管理 - zmalloc / zfree","intro":"之前在为 Eufa 添加本地缓存管理的功能时，基本的数据存储功能使用了简单的双向链表来实现，但由于在 Wasm32 架构上的最大可用内存只有 4GB，因此我们需要对本地内存的使用大小做一个限制，但如何才能够精确地获得应用所使用的内存大小呢？我们都知道，譬如 malloc 等标准库中的内存分配函数会根据当前的系统架构类型自动地进行4/8字节的内存对齐，因此对于应用在存储数据时底层系统实际分配的内存大小我们很难直接进行计算。","comments":1,"date":"2017-08-22T01:49:03.000Z","_content":"\n之前在为 Eufa 添加本地缓存管理的功能时，基本的数据存储功能使用了简单的双向链表来实现，但由于在 Wasm32 架构上的最大可用内存只有 4GB，因此我们需要对本地内存的使用大小做一个限制，**但如何才能够精确地获得应用所使用的内存大小呢？**我们都知道，譬如 `malloc` 等标准库中的内存分配函数会根据当前的系统架构类型自动地进行4/8字节的内存对齐，因此对于应用在存储数据时底层系统实际分配的内存大小我们很难直接进行计算。\n\n而为了解决这个问题，在这里我直接借鉴了 Redis 在其内存管理上的实现方式。如下所示，我们直接来看 Redis 源码（不是最新版本）中自定义的 zmalloc 函数，该函数与 malloc 等常规函数的使用方式完全一致，不同的在于其内部的具体实现细节。\n\n\n```c\nvoid *zmalloc(size_t size) {\n    // 分配内存；\n    void *ptr = malloc(size + PREFIX_SIZE);\n    // 分配失败抛出异常；\n    if (!ptr) zmalloc_oom_handler(size);\n// 系统是否可以使用”malloc_size“函数？\n#ifdef HAVE_MALLOC_SIZE\n    update_zmalloc_stat_alloc(zmalloc_size(ptr));\n    return ptr;\n#else\n    // 在数据域保存分配数据的实际大小；\n    *((size_t*)ptr) = size;\n    // 计算对齐后的内存使用大小，并更新”used_memory“变量；\n    update_zmalloc_stat_alloc(size + PREFIX_SIZE);\n    // 返回数据体的初始位置；\n    return (char*)ptr + PREFIX_SIZE;\n#endif\n}\n```\n\n其实，标准库中的 malloc 函数已经能够自动为分配的内存实现对齐，因此 zmalloc 方法在这里其主要目的是为了能够精确地计算每一次数据存储时所分配的内存大小。在每一次分配内存时，zmalloc 都会在该次分配的数据内存大小的基础上再加上一个 **PREFIX_SIZE** 大小的额外内存空间，这个 PREFIX_SIZE 宏代表了当前系统的最大内存寻址空间大小（size_t），其依赖于具体系统的类型不同而不同。这里我们可以简称这个 PREFIX_SIZE 大小的空间为一个存储单元的“数据头”部分。\n\n![](1.jpg)\n\n\n如上图所示，通过 `*((size_t*)ptr) = size;` 语句，Redis 在当前分配内存块的前 PREFIX_SIZE 个字节，即数据头内存储了本次实际分配的数据块大小，而在后面 ”size“ 大小的内存空间中才真正存放了二进制的数据实体。在这里名为 **update_zmalloc_stat_alloc** 的函数在其内部会维护一个名为 **used_memory** 的全局变量，该变量累加了每次新分配的内存大小。函数在最后返回了一个偏移的指针，指向了当前分配内存的数据体部分。update_zmalloc_stat_alloc 函数的具体实现细节如下。\n\n```c\n#define update_zmalloc_stat_alloc(__n) do { \n    size_t _n = (__n); \n    // 手动内存补齐；\n    if (_n&(sizeof(long)-1)) _n += sizeof(long)-(_n&(sizeof(long)-1)); \n    atomicIncr(used_memory, __n); \n} while(0)\n```\n\n这里需要注意的重点是 `_n += sizeof(long)-(_n&(sizeof(long)-1));` 这行语句。整个宏函数首先判断本次分配的内存大小是否为 sizeof(long) 大小的整数倍（64位机对应着8字节的内存对齐；32位机则对应着4字节的内存对齐），如果不是则通过我们之前给出的语句在该数据段后添加相应的占位空间来补足位数以满足内存对齐（4/8字节）的要求。最后的 atomicIncr 函数用来在保证线程安全的情况下更新全局的 used_memory 变量值。\n\n而该版本 Redis 中内存释放与其内存分配的过程则正好相反。如下所示代码为对应 “zfree” 函数的实现细节。首先该函数通过 `(char*)ptr-PREFIX_SIZE` 语句（向内存低地址移动）指向了包含有该数据块实际占用大小的数据域首地址，然后通过 `*((size_t*)realptr)` 语句获得到了该数据块分配的真实内存大小（不包含内存对齐区域）。最后再通过 update_zmalloc_stat_free 函数来更新全局变量 used_memory 的值，并释放该段内存。\n\n```c\nvoid zfree(void *ptr) {\n#ifndef HAVE_MALLOC_SIZE\n    void *realptr;\n    size_t oldsize;\n#endif\n\n    if (ptr == NULL) return;\n#ifdef HAVE_MALLOC_SIZE\n    update_zmalloc_stat_free(zmalloc_size(ptr));\n    free(ptr);\n#else\n    realptr = (char*)ptr-PREFIX_SIZE;\n    oldsize = *((size_t*)realptr);\n    update_zmalloc_stat_free(oldsize+PREFIX_SIZE);\n    free(realptr);\n#endif\n}\n```\n\n如下所示，这里如果我们再来看 update_zmalloc_stat_free 函数的实现细节，你会发现它与之前的 update_zmalloc_stat_alloc 函数其执行过程类似。通过计算需要补足的内存字节大小，并从 used_memory 变量中减去相应大小的内存空间，即可实现对内存空间使用率的精确计算。\n\n```c\n#define update_zmalloc_stat_free(__n) do { \\\n    size_t _n = (__n); \\\n    if (_n&(sizeof(long)-1)) _n += sizeof(long)-(_n&(sizeof(long)-1)); \\\n    atomicDecr(used_memory,__n); \\\n} while(0) \n```\n\n最后再来仔细回顾一下刚刚我们在 update_zmalloc_stat_alloc 函数中执行内存补齐操作的部分。在 Wasm32 架构中，sizeof(long) 的值是4，因此对应的补齐操作语句就变成了 `if(_n&3) _n += 4 - (_n&3);`，即需要满足4字节对齐。如果此时用户端有一个大小为”**13字节**“的数据需要存储，那么经过内存对齐处理，应用实际存放到内存中的数据大小便为：13 + 4 - 1 = 16 字节大小，内存对齐字节的计算过程可以参考下图。\n\n![](2.jpg)\n\n\n以上便是 Redis 在其整体复杂设计实现过程中的一个十分细小但却精妙的设计点。\n","source":"_posts/Redis-源码之内存管理-zmalloc-zfree.md","raw":"---\ntitle: Redis 源码之内存管理 - zmalloc / zfree\nintro: 之前在为 Eufa 添加本地缓存管理的功能时，基本的数据存储功能使用了简单的双向链表来实现，但由于在 Wasm32 架构上的最大可用内存只有 4GB，因此我们需要对本地内存的使用大小做一个限制，但如何才能够精确地获得应用所使用的内存大小呢？我们都知道，譬如 malloc 等标准库中的内存分配函数会根据当前的系统架构类型自动地进行4/8字节的内存对齐，因此对于应用在存储数据时底层系统实际分配的内存大小我们很难直接进行计算。\ncomments: true\ndate: 2017-08-22 09:49:03\ntags:\n- Redis\n---\n\n之前在为 Eufa 添加本地缓存管理的功能时，基本的数据存储功能使用了简单的双向链表来实现，但由于在 Wasm32 架构上的最大可用内存只有 4GB，因此我们需要对本地内存的使用大小做一个限制，**但如何才能够精确地获得应用所使用的内存大小呢？**我们都知道，譬如 `malloc` 等标准库中的内存分配函数会根据当前的系统架构类型自动地进行4/8字节的内存对齐，因此对于应用在存储数据时底层系统实际分配的内存大小我们很难直接进行计算。\n\n而为了解决这个问题，在这里我直接借鉴了 Redis 在其内存管理上的实现方式。如下所示，我们直接来看 Redis 源码（不是最新版本）中自定义的 zmalloc 函数，该函数与 malloc 等常规函数的使用方式完全一致，不同的在于其内部的具体实现细节。\n\n\n```c\nvoid *zmalloc(size_t size) {\n    // 分配内存；\n    void *ptr = malloc(size + PREFIX_SIZE);\n    // 分配失败抛出异常；\n    if (!ptr) zmalloc_oom_handler(size);\n// 系统是否可以使用”malloc_size“函数？\n#ifdef HAVE_MALLOC_SIZE\n    update_zmalloc_stat_alloc(zmalloc_size(ptr));\n    return ptr;\n#else\n    // 在数据域保存分配数据的实际大小；\n    *((size_t*)ptr) = size;\n    // 计算对齐后的内存使用大小，并更新”used_memory“变量；\n    update_zmalloc_stat_alloc(size + PREFIX_SIZE);\n    // 返回数据体的初始位置；\n    return (char*)ptr + PREFIX_SIZE;\n#endif\n}\n```\n\n其实，标准库中的 malloc 函数已经能够自动为分配的内存实现对齐，因此 zmalloc 方法在这里其主要目的是为了能够精确地计算每一次数据存储时所分配的内存大小。在每一次分配内存时，zmalloc 都会在该次分配的数据内存大小的基础上再加上一个 **PREFIX_SIZE** 大小的额外内存空间，这个 PREFIX_SIZE 宏代表了当前系统的最大内存寻址空间大小（size_t），其依赖于具体系统的类型不同而不同。这里我们可以简称这个 PREFIX_SIZE 大小的空间为一个存储单元的“数据头”部分。\n\n![](1.jpg)\n\n\n如上图所示，通过 `*((size_t*)ptr) = size;` 语句，Redis 在当前分配内存块的前 PREFIX_SIZE 个字节，即数据头内存储了本次实际分配的数据块大小，而在后面 ”size“ 大小的内存空间中才真正存放了二进制的数据实体。在这里名为 **update_zmalloc_stat_alloc** 的函数在其内部会维护一个名为 **used_memory** 的全局变量，该变量累加了每次新分配的内存大小。函数在最后返回了一个偏移的指针，指向了当前分配内存的数据体部分。update_zmalloc_stat_alloc 函数的具体实现细节如下。\n\n```c\n#define update_zmalloc_stat_alloc(__n) do { \n    size_t _n = (__n); \n    // 手动内存补齐；\n    if (_n&(sizeof(long)-1)) _n += sizeof(long)-(_n&(sizeof(long)-1)); \n    atomicIncr(used_memory, __n); \n} while(0)\n```\n\n这里需要注意的重点是 `_n += sizeof(long)-(_n&(sizeof(long)-1));` 这行语句。整个宏函数首先判断本次分配的内存大小是否为 sizeof(long) 大小的整数倍（64位机对应着8字节的内存对齐；32位机则对应着4字节的内存对齐），如果不是则通过我们之前给出的语句在该数据段后添加相应的占位空间来补足位数以满足内存对齐（4/8字节）的要求。最后的 atomicIncr 函数用来在保证线程安全的情况下更新全局的 used_memory 变量值。\n\n而该版本 Redis 中内存释放与其内存分配的过程则正好相反。如下所示代码为对应 “zfree” 函数的实现细节。首先该函数通过 `(char*)ptr-PREFIX_SIZE` 语句（向内存低地址移动）指向了包含有该数据块实际占用大小的数据域首地址，然后通过 `*((size_t*)realptr)` 语句获得到了该数据块分配的真实内存大小（不包含内存对齐区域）。最后再通过 update_zmalloc_stat_free 函数来更新全局变量 used_memory 的值，并释放该段内存。\n\n```c\nvoid zfree(void *ptr) {\n#ifndef HAVE_MALLOC_SIZE\n    void *realptr;\n    size_t oldsize;\n#endif\n\n    if (ptr == NULL) return;\n#ifdef HAVE_MALLOC_SIZE\n    update_zmalloc_stat_free(zmalloc_size(ptr));\n    free(ptr);\n#else\n    realptr = (char*)ptr-PREFIX_SIZE;\n    oldsize = *((size_t*)realptr);\n    update_zmalloc_stat_free(oldsize+PREFIX_SIZE);\n    free(realptr);\n#endif\n}\n```\n\n如下所示，这里如果我们再来看 update_zmalloc_stat_free 函数的实现细节，你会发现它与之前的 update_zmalloc_stat_alloc 函数其执行过程类似。通过计算需要补足的内存字节大小，并从 used_memory 变量中减去相应大小的内存空间，即可实现对内存空间使用率的精确计算。\n\n```c\n#define update_zmalloc_stat_free(__n) do { \\\n    size_t _n = (__n); \\\n    if (_n&(sizeof(long)-1)) _n += sizeof(long)-(_n&(sizeof(long)-1)); \\\n    atomicDecr(used_memory,__n); \\\n} while(0) \n```\n\n最后再来仔细回顾一下刚刚我们在 update_zmalloc_stat_alloc 函数中执行内存补齐操作的部分。在 Wasm32 架构中，sizeof(long) 的值是4，因此对应的补齐操作语句就变成了 `if(_n&3) _n += 4 - (_n&3);`，即需要满足4字节对齐。如果此时用户端有一个大小为”**13字节**“的数据需要存储，那么经过内存对齐处理，应用实际存放到内存中的数据大小便为：13 + 4 - 1 = 16 字节大小，内存对齐字节的计算过程可以参考下图。\n\n![](2.jpg)\n\n\n以上便是 Redis 在其整体复杂设计实现过程中的一个十分细小但却精妙的设计点。\n","slug":"Redis-源码之内存管理-zmalloc-zfree","published":1,"updated":"2019-02-19T10:25:15.739Z","layout":"post","photos":[],"link":"","_id":"cjsqwht9v003hknp22029tq07","content":"<p>之前在为 Eufa 添加本地缓存管理的功能时，基本的数据存储功能使用了简单的双向链表来实现，但由于在 Wasm32 架构上的最大可用内存只有 4GB，因此我们需要对本地内存的使用大小做一个限制，<strong>但如何才能够精确地获得应用所使用的内存大小呢？</strong>我们都知道，譬如 <code>malloc</code> 等标准库中的内存分配函数会根据当前的系统架构类型自动地进行4/8字节的内存对齐，因此对于应用在存储数据时底层系统实际分配的内存大小我们很难直接进行计算。</p>\n<p>而为了解决这个问题，在这里我直接借鉴了 Redis 在其内存管理上的实现方式。如下所示，我们直接来看 Redis 源码（不是最新版本）中自定义的 zmalloc 函数，该函数与 malloc 等常规函数的使用方式完全一致，不同的在于其内部的具体实现细节。</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token function\">zmalloc</span><span class=\"token punctuation\">(</span>size_t size<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 分配内存；</span>\n    <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>ptr <span class=\"token operator\">=</span> <span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span>size <span class=\"token operator\">+</span> PREFIX_SIZE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 分配失败抛出异常；</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>ptr<span class=\"token punctuation\">)</span> <span class=\"token function\">zmalloc_oom_handler</span><span class=\"token punctuation\">(</span>size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// 系统是否可以使用”malloc_size“函数？</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">ifdef</span> HAVE_MALLOC_SIZE</span>\n    <span class=\"token function\">update_zmalloc_stat_alloc</span><span class=\"token punctuation\">(</span><span class=\"token function\">zmalloc_size</span><span class=\"token punctuation\">(</span>ptr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> ptr<span class=\"token punctuation\">;</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">else</span></span>\n    <span class=\"token comment\" spellcheck=\"true\">// 在数据域保存分配数据的实际大小；</span>\n    <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>size_t<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>ptr<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> size<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 计算对齐后的内存使用大小，并更新”used_memory“变量；</span>\n    <span class=\"token function\">update_zmalloc_stat_alloc</span><span class=\"token punctuation\">(</span>size <span class=\"token operator\">+</span> PREFIX_SIZE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 返回数据体的初始位置；</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>ptr <span class=\"token operator\">+</span> PREFIX_SIZE<span class=\"token punctuation\">;</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">endif</span></span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>其实，标准库中的 malloc 函数已经能够自动为分配的内存实现对齐，因此 zmalloc 方法在这里其主要目的是为了能够精确地计算每一次数据存储时所分配的内存大小。在每一次分配内存时，zmalloc 都会在该次分配的数据内存大小的基础上再加上一个 <strong>PREFIX_SIZE</strong> 大小的额外内存空间，这个 PREFIX_SIZE 宏代表了当前系统的最大内存寻址空间大小（size_t），其依赖于具体系统的类型不同而不同。这里我们可以简称这个 PREFIX_SIZE 大小的空间为一个存储单元的“数据头”部分。</p>\n<p><img src=\"1.jpg\" alt></p>\n<p>如上图所示，通过 <code>*((size_t*)ptr) = size;</code> 语句，Redis 在当前分配内存块的前 PREFIX_SIZE 个字节，即数据头内存储了本次实际分配的数据块大小，而在后面 ”size“ 大小的内存空间中才真正存放了二进制的数据实体。在这里名为 <strong>update_zmalloc_stat_alloc</strong> 的函数在其内部会维护一个名为 <strong>used_memory</strong> 的全局变量，该变量累加了每次新分配的内存大小。函数在最后返回了一个偏移的指针，指向了当前分配内存的数据体部分。update_zmalloc_stat_alloc 函数的具体实现细节如下。</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> update_zmalloc_stat_alloc(__n) do { </span>\n    size_t _n <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>__n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n    <span class=\"token comment\" spellcheck=\"true\">// 手动内存补齐；</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>_n<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> _n <span class=\"token operator\">+</span><span class=\"token operator\">=</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token punctuation\">(</span>_n<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n    <span class=\"token function\">atomicIncr</span><span class=\"token punctuation\">(</span>used_memory<span class=\"token punctuation\">,</span> __n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这里需要注意的重点是 <code>_n += sizeof(long)-(_n&amp;(sizeof(long)-1));</code> 这行语句。整个宏函数首先判断本次分配的内存大小是否为 sizeof(long) 大小的整数倍（64位机对应着8字节的内存对齐；32位机则对应着4字节的内存对齐），如果不是则通过我们之前给出的语句在该数据段后添加相应的占位空间来补足位数以满足内存对齐（4/8字节）的要求。最后的 atomicIncr 函数用来在保证线程安全的情况下更新全局的 used_memory 变量值。</p>\n<p>而该版本 Redis 中内存释放与其内存分配的过程则正好相反。如下所示代码为对应 “zfree” 函数的实现细节。首先该函数通过 <code>(char*)ptr-PREFIX_SIZE</code> 语句（向内存低地址移动）指向了包含有该数据块实际占用大小的数据域首地址，然后通过 <code>*((size_t*)realptr)</code> 语句获得到了该数据块分配的真实内存大小（不包含内存对齐区域）。最后再通过 update_zmalloc_stat_free 函数来更新全局变量 used_memory 的值，并释放该段内存。</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">zfree</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>ptr<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">ifndef</span> HAVE_MALLOC_SIZE</span>\n    <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>realptr<span class=\"token punctuation\">;</span>\n    size_t oldsize<span class=\"token punctuation\">;</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">endif</span></span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ptr <span class=\"token operator\">==</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">ifdef</span> HAVE_MALLOC_SIZE</span>\n    <span class=\"token function\">update_zmalloc_stat_free</span><span class=\"token punctuation\">(</span><span class=\"token function\">zmalloc_size</span><span class=\"token punctuation\">(</span>ptr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">free</span><span class=\"token punctuation\">(</span>ptr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">else</span></span>\n    realptr <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>ptr<span class=\"token operator\">-</span>PREFIX_SIZE<span class=\"token punctuation\">;</span>\n    oldsize <span class=\"token operator\">=</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>size_t<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>realptr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">update_zmalloc_stat_free</span><span class=\"token punctuation\">(</span>oldsize<span class=\"token operator\">+</span>PREFIX_SIZE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">free</span><span class=\"token punctuation\">(</span>realptr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">endif</span></span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>如下所示，这里如果我们再来看 update_zmalloc_stat_free 函数的实现细节，你会发现它与之前的 update_zmalloc_stat_alloc 函数其执行过程类似。通过计算需要补足的内存字节大小，并从 used_memory 变量中减去相应大小的内存空间，即可实现对内存空间使用率的精确计算。</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> update_zmalloc_stat_free(__n) do { \\\n    size_t _n = (__n); \\\n    if (_n&amp;(sizeof(long)-1)) _n += sizeof(long)-(_n&amp;(sizeof(long)-1)); \\\n    atomicDecr(used_memory,__n); \\\n} while(0) </span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>最后再来仔细回顾一下刚刚我们在 update_zmalloc_stat_alloc 函数中执行内存补齐操作的部分。在 Wasm32 架构中，sizeof(long) 的值是4，因此对应的补齐操作语句就变成了 <code>if(_n&amp;3) _n += 4 - (_n&amp;3);</code>，即需要满足4字节对齐。如果此时用户端有一个大小为”<strong>13字节</strong>“的数据需要存储，那么经过内存对齐处理，应用实际存放到内存中的数据大小便为：13 + 4 - 1 = 16 字节大小，内存对齐字节的计算过程可以参考下图。</p>\n<p><img src=\"2.jpg\" alt></p>\n<p>以上便是 Redis 在其整体复杂设计实现过程中的一个十分细小但却精妙的设计点。</p>\n","site":{"data":{}},"id":"92ca0adc41bab4cbe5a48db7546aede1","excerpt":"","more":"<p>之前在为 Eufa 添加本地缓存管理的功能时，基本的数据存储功能使用了简单的双向链表来实现，但由于在 Wasm32 架构上的最大可用内存只有 4GB，因此我们需要对本地内存的使用大小做一个限制，<strong>但如何才能够精确地获得应用所使用的内存大小呢？</strong>我们都知道，譬如 <code>malloc</code> 等标准库中的内存分配函数会根据当前的系统架构类型自动地进行4/8字节的内存对齐，因此对于应用在存储数据时底层系统实际分配的内存大小我们很难直接进行计算。</p>\n<p>而为了解决这个问题，在这里我直接借鉴了 Redis 在其内存管理上的实现方式。如下所示，我们直接来看 Redis 源码（不是最新版本）中自定义的 zmalloc 函数，该函数与 malloc 等常规函数的使用方式完全一致，不同的在于其内部的具体实现细节。</p>\n<pre><code class=\"c\">void *zmalloc(size_t size) {\n    // 分配内存；\n    void *ptr = malloc(size + PREFIX_SIZE);\n    // 分配失败抛出异常；\n    if (!ptr) zmalloc_oom_handler(size);\n// 系统是否可以使用”malloc_size“函数？\n#ifdef HAVE_MALLOC_SIZE\n    update_zmalloc_stat_alloc(zmalloc_size(ptr));\n    return ptr;\n#else\n    // 在数据域保存分配数据的实际大小；\n    *((size_t*)ptr) = size;\n    // 计算对齐后的内存使用大小，并更新”used_memory“变量；\n    update_zmalloc_stat_alloc(size + PREFIX_SIZE);\n    // 返回数据体的初始位置；\n    return (char*)ptr + PREFIX_SIZE;\n#endif\n}\n</code></pre>\n<p>其实，标准库中的 malloc 函数已经能够自动为分配的内存实现对齐，因此 zmalloc 方法在这里其主要目的是为了能够精确地计算每一次数据存储时所分配的内存大小。在每一次分配内存时，zmalloc 都会在该次分配的数据内存大小的基础上再加上一个 <strong>PREFIX_SIZE</strong> 大小的额外内存空间，这个 PREFIX_SIZE 宏代表了当前系统的最大内存寻址空间大小（size_t），其依赖于具体系统的类型不同而不同。这里我们可以简称这个 PREFIX_SIZE 大小的空间为一个存储单元的“数据头”部分。</p>\n<p><img src=\"1.jpg\" alt></p>\n<p>如上图所示，通过 <code>*((size_t*)ptr) = size;</code> 语句，Redis 在当前分配内存块的前 PREFIX_SIZE 个字节，即数据头内存储了本次实际分配的数据块大小，而在后面 ”size“ 大小的内存空间中才真正存放了二进制的数据实体。在这里名为 <strong>update_zmalloc_stat_alloc</strong> 的函数在其内部会维护一个名为 <strong>used_memory</strong> 的全局变量，该变量累加了每次新分配的内存大小。函数在最后返回了一个偏移的指针，指向了当前分配内存的数据体部分。update_zmalloc_stat_alloc 函数的具体实现细节如下。</p>\n<pre><code class=\"c\">#define update_zmalloc_stat_alloc(__n) do { \n    size_t _n = (__n); \n    // 手动内存补齐；\n    if (_n&amp;(sizeof(long)-1)) _n += sizeof(long)-(_n&amp;(sizeof(long)-1)); \n    atomicIncr(used_memory, __n); \n} while(0)\n</code></pre>\n<p>这里需要注意的重点是 <code>_n += sizeof(long)-(_n&amp;(sizeof(long)-1));</code> 这行语句。整个宏函数首先判断本次分配的内存大小是否为 sizeof(long) 大小的整数倍（64位机对应着8字节的内存对齐；32位机则对应着4字节的内存对齐），如果不是则通过我们之前给出的语句在该数据段后添加相应的占位空间来补足位数以满足内存对齐（4/8字节）的要求。最后的 atomicIncr 函数用来在保证线程安全的情况下更新全局的 used_memory 变量值。</p>\n<p>而该版本 Redis 中内存释放与其内存分配的过程则正好相反。如下所示代码为对应 “zfree” 函数的实现细节。首先该函数通过 <code>(char*)ptr-PREFIX_SIZE</code> 语句（向内存低地址移动）指向了包含有该数据块实际占用大小的数据域首地址，然后通过 <code>*((size_t*)realptr)</code> 语句获得到了该数据块分配的真实内存大小（不包含内存对齐区域）。最后再通过 update_zmalloc_stat_free 函数来更新全局变量 used_memory 的值，并释放该段内存。</p>\n<pre><code class=\"c\">void zfree(void *ptr) {\n#ifndef HAVE_MALLOC_SIZE\n    void *realptr;\n    size_t oldsize;\n#endif\n\n    if (ptr == NULL) return;\n#ifdef HAVE_MALLOC_SIZE\n    update_zmalloc_stat_free(zmalloc_size(ptr));\n    free(ptr);\n#else\n    realptr = (char*)ptr-PREFIX_SIZE;\n    oldsize = *((size_t*)realptr);\n    update_zmalloc_stat_free(oldsize+PREFIX_SIZE);\n    free(realptr);\n#endif\n}\n</code></pre>\n<p>如下所示，这里如果我们再来看 update_zmalloc_stat_free 函数的实现细节，你会发现它与之前的 update_zmalloc_stat_alloc 函数其执行过程类似。通过计算需要补足的内存字节大小，并从 used_memory 变量中减去相应大小的内存空间，即可实现对内存空间使用率的精确计算。</p>\n<pre><code class=\"c\">#define update_zmalloc_stat_free(__n) do { \\\n    size_t _n = (__n); \\\n    if (_n&amp;(sizeof(long)-1)) _n += sizeof(long)-(_n&amp;(sizeof(long)-1)); \\\n    atomicDecr(used_memory,__n); \\\n} while(0) \n</code></pre>\n<p>最后再来仔细回顾一下刚刚我们在 update_zmalloc_stat_alloc 函数中执行内存补齐操作的部分。在 Wasm32 架构中，sizeof(long) 的值是4，因此对应的补齐操作语句就变成了 <code>if(_n&amp;3) _n += 4 - (_n&amp;3);</code>，即需要满足4字节对齐。如果此时用户端有一个大小为”<strong>13字节</strong>“的数据需要存储，那么经过内存对齐处理，应用实际存放到内存中的数据大小便为：13 + 4 - 1 = 16 字节大小，内存对齐字节的计算过程可以参考下图。</p>\n<p><img src=\"2.jpg\" alt></p>\n<p>以上便是 Redis 在其整体复杂设计实现过程中的一个十分细小但却精妙的设计点。</p>\n"},{"title":"SVG 技术之 - 路径","intro":"近期在进行“连接世界”项目，其中用到了很多关于自定义图形的类库和方法，关于项目的详情，在这里我不多说。回到正题，那么这篇文章主要向大家介绍 SVG 中 “path” 标签的用法。SVG 说复杂也复杂，细节上的掌控非常精细，但其语法格式却并不难理解，所以相对来说又很简单。直到 HTML5 出现的今天，使用 Canvas 的人越来越多，但 SVG 还是不会被其取代，毕竟各有其优势和劣势，具体用到哪里怎么样，就依各位客官老爷们的心意了。","comments":1,"date":"2015-11-08T14:43:18.000Z","_content":"\n近期在进行“连接世界”项目，其中用到了很多关于自定义图形的类库和方法，关于项目的详情，在这里我不多说。回到正题，那么这篇文章主要向大家介绍 SVG 中 `path` 标签的用法。SVG 说复杂也复杂，细节上的掌控非常精细，但其语法格式却并不难理解，所以相对来说又很简单。直到 HTML5 出现的今天，使用 Canvas 的人越来越多，但 SVG 还是不会被其取代，毕竟各有其优势和劣势，具体用到哪里怎么样，就依各位客官老爷们的心意了。\n\n先来一个小例子：\n```html\n<svg height=\"100px\" width=\"100px\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M50 0 L0 100 L100 100 Z\"></path>\n</svg>\n```\n![SVG 例子的实际效果](1.png)\n\n\n上面这段代码中的 `path` 标签绘制了一个三角形，其中主要由属性 “d” 来控制绘制图形的具体形状。“d” 属性的属性值可以分成一段一段的形式，每一段都是这样的形式 “X POSX POSY”，其中 “X” 表示对 `path` 标签提出的命令，可以理解为告诉 `path` 标签下一步应该绘制什么图像，或者是应该怎样绘制；后边的两个 POS 表示下一个将要绘制的点，POSX 表示点的 X 坐标，POSY 表示点的 Y 坐标。命令 X 如果大写，表示绝对定位，小写则表示相对定位。\n\n在这些所有的命令中，有一个命令后面不需要或者说不可以加任何的位置信息，那就是 “Z” 命令，“Z” 命令表示闭合此段曲线，当 `path` 标签“运行”到这个命令时将会结束绘制，并将此命令的前一个点与开始的第一个点进行连接以闭合曲线，所以 “Z” 命令一般用在绘制的结尾处。\n\n同样的 `path` 标签里也可以嵌入 `style` 属性来制定该段绘制的图形外观的。\n\n这里给出所有的 `path` 标签“命令”供参考：\n\n* M : 画笔移动到某处；\n* L : 绘制直线到某处；\n* H : 绘制水平线到某处；\n* V : 绘制垂直线到某处；\n* C : 绘制曲线到某处；\n* S : 绘制平滑曲线到某处；\n* Q : 绘制二次 Belzier 曲线到某处；\n* T : 绘制光滑二次 Belzier 曲线到某处；\n* A : 绘制椭圆弧线到某处；\n* Z : 关闭标签；\n","source":"_posts/SVG-技术之-路径.md","raw":"---\ntitle: SVG 技术之 - 路径\nintro: 近期在进行“连接世界”项目，其中用到了很多关于自定义图形的类库和方法，关于项目的详情，在这里我不多说。回到正题，那么这篇文章主要向大家介绍 SVG 中 “path” 标签的用法。SVG 说复杂也复杂，细节上的掌控非常精细，但其语法格式却并不难理解，所以相对来说又很简单。直到 HTML5 出现的今天，使用 Canvas 的人越来越多，但 SVG 还是不会被其取代，毕竟各有其优势和劣势，具体用到哪里怎么样，就依各位客官老爷们的心意了。\ncomments: true\ndate: 2015-11-08 22:43:18\ntags:\n- CSS\n---\n\n近期在进行“连接世界”项目，其中用到了很多关于自定义图形的类库和方法，关于项目的详情，在这里我不多说。回到正题，那么这篇文章主要向大家介绍 SVG 中 `path` 标签的用法。SVG 说复杂也复杂，细节上的掌控非常精细，但其语法格式却并不难理解，所以相对来说又很简单。直到 HTML5 出现的今天，使用 Canvas 的人越来越多，但 SVG 还是不会被其取代，毕竟各有其优势和劣势，具体用到哪里怎么样，就依各位客官老爷们的心意了。\n\n先来一个小例子：\n```html\n<svg height=\"100px\" width=\"100px\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M50 0 L0 100 L100 100 Z\"></path>\n</svg>\n```\n![SVG 例子的实际效果](1.png)\n\n\n上面这段代码中的 `path` 标签绘制了一个三角形，其中主要由属性 “d” 来控制绘制图形的具体形状。“d” 属性的属性值可以分成一段一段的形式，每一段都是这样的形式 “X POSX POSY”，其中 “X” 表示对 `path` 标签提出的命令，可以理解为告诉 `path` 标签下一步应该绘制什么图像，或者是应该怎样绘制；后边的两个 POS 表示下一个将要绘制的点，POSX 表示点的 X 坐标，POSY 表示点的 Y 坐标。命令 X 如果大写，表示绝对定位，小写则表示相对定位。\n\n在这些所有的命令中，有一个命令后面不需要或者说不可以加任何的位置信息，那就是 “Z” 命令，“Z” 命令表示闭合此段曲线，当 `path` 标签“运行”到这个命令时将会结束绘制，并将此命令的前一个点与开始的第一个点进行连接以闭合曲线，所以 “Z” 命令一般用在绘制的结尾处。\n\n同样的 `path` 标签里也可以嵌入 `style` 属性来制定该段绘制的图形外观的。\n\n这里给出所有的 `path` 标签“命令”供参考：\n\n* M : 画笔移动到某处；\n* L : 绘制直线到某处；\n* H : 绘制水平线到某处；\n* V : 绘制垂直线到某处；\n* C : 绘制曲线到某处；\n* S : 绘制平滑曲线到某处；\n* Q : 绘制二次 Belzier 曲线到某处；\n* T : 绘制光滑二次 Belzier 曲线到某处；\n* A : 绘制椭圆弧线到某处；\n* Z : 关闭标签；\n","slug":"SVG-技术之-路径","published":1,"updated":"2019-02-04T16:53:18.947Z","layout":"post","photos":[],"link":"","_id":"cjsqwht9w003kknp24mdf28up","content":"<p>近期在进行“连接世界”项目，其中用到了很多关于自定义图形的类库和方法，关于项目的详情，在这里我不多说。回到正题，那么这篇文章主要向大家介绍 SVG 中 <code>path</code> 标签的用法。SVG 说复杂也复杂，细节上的掌控非常精细，但其语法格式却并不难理解，所以相对来说又很简单。直到 HTML5 出现的今天，使用 Canvas 的人越来越多，但 SVG 还是不会被其取代，毕竟各有其优势和劣势，具体用到哪里怎么样，就依各位客官老爷们的心意了。</p>\n<p>先来一个小例子：</p>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>svg</span> <span class=\"token attr-name\">height</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>100px<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">width</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>100px<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">version</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>1.1<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">xmlns</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>http://www.w3.org/2000/svg<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>path</span> <span class=\"token attr-name\">d</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>M50 0 L0 100 L100 100 Z<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>path</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>svg</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p><img src=\"1.png\" alt=\"SVG 例子的实际效果\"></p>\n<p>上面这段代码中的 <code>path</code> 标签绘制了一个三角形，其中主要由属性 “d” 来控制绘制图形的具体形状。“d” 属性的属性值可以分成一段一段的形式，每一段都是这样的形式 “X POSX POSY”，其中 “X” 表示对 <code>path</code> 标签提出的命令，可以理解为告诉 <code>path</code> 标签下一步应该绘制什么图像，或者是应该怎样绘制；后边的两个 POS 表示下一个将要绘制的点，POSX 表示点的 X 坐标，POSY 表示点的 Y 坐标。命令 X 如果大写，表示绝对定位，小写则表示相对定位。</p>\n<p>在这些所有的命令中，有一个命令后面不需要或者说不可以加任何的位置信息，那就是 “Z” 命令，“Z” 命令表示闭合此段曲线，当 <code>path</code> 标签“运行”到这个命令时将会结束绘制，并将此命令的前一个点与开始的第一个点进行连接以闭合曲线，所以 “Z” 命令一般用在绘制的结尾处。</p>\n<p>同样的 <code>path</code> 标签里也可以嵌入 <code>style</code> 属性来制定该段绘制的图形外观的。</p>\n<p>这里给出所有的 <code>path</code> 标签“命令”供参考：</p>\n<ul>\n<li>M : 画笔移动到某处；</li>\n<li>L : 绘制直线到某处；</li>\n<li>H : 绘制水平线到某处；</li>\n<li>V : 绘制垂直线到某处；</li>\n<li>C : 绘制曲线到某处；</li>\n<li>S : 绘制平滑曲线到某处；</li>\n<li>Q : 绘制二次 Belzier 曲线到某处；</li>\n<li>T : 绘制光滑二次 Belzier 曲线到某处；</li>\n<li>A : 绘制椭圆弧线到某处；</li>\n<li>Z : 关闭标签；</li>\n</ul>\n","site":{"data":{}},"id":"f3437111b0a78d87acd3e6af063ffe60","excerpt":"","more":"<p>近期在进行“连接世界”项目，其中用到了很多关于自定义图形的类库和方法，关于项目的详情，在这里我不多说。回到正题，那么这篇文章主要向大家介绍 SVG 中 <code>path</code> 标签的用法。SVG 说复杂也复杂，细节上的掌控非常精细，但其语法格式却并不难理解，所以相对来说又很简单。直到 HTML5 出现的今天，使用 Canvas 的人越来越多，但 SVG 还是不会被其取代，毕竟各有其优势和劣势，具体用到哪里怎么样，就依各位客官老爷们的心意了。</p>\n<p>先来一个小例子：</p>\n<pre><code class=\"html\">&lt;svg height=&quot;100px&quot; width=&quot;100px&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;\n&lt;path d=&quot;M50 0 L0 100 L100 100 Z&quot;&gt;&lt;/path&gt;\n&lt;/svg&gt;\n</code></pre>\n<p><img src=\"1.png\" alt=\"SVG 例子的实际效果\"></p>\n<p>上面这段代码中的 <code>path</code> 标签绘制了一个三角形，其中主要由属性 “d” 来控制绘制图形的具体形状。“d” 属性的属性值可以分成一段一段的形式，每一段都是这样的形式 “X POSX POSY”，其中 “X” 表示对 <code>path</code> 标签提出的命令，可以理解为告诉 <code>path</code> 标签下一步应该绘制什么图像，或者是应该怎样绘制；后边的两个 POS 表示下一个将要绘制的点，POSX 表示点的 X 坐标，POSY 表示点的 Y 坐标。命令 X 如果大写，表示绝对定位，小写则表示相对定位。</p>\n<p>在这些所有的命令中，有一个命令后面不需要或者说不可以加任何的位置信息，那就是 “Z” 命令，“Z” 命令表示闭合此段曲线，当 <code>path</code> 标签“运行”到这个命令时将会结束绘制，并将此命令的前一个点与开始的第一个点进行连接以闭合曲线，所以 “Z” 命令一般用在绘制的结尾处。</p>\n<p>同样的 <code>path</code> 标签里也可以嵌入 <code>style</code> 属性来制定该段绘制的图形外观的。</p>\n<p>这里给出所有的 <code>path</code> 标签“命令”供参考：</p>\n<ul>\n<li>M : 画笔移动到某处；</li>\n<li>L : 绘制直线到某处；</li>\n<li>H : 绘制水平线到某处；</li>\n<li>V : 绘制垂直线到某处；</li>\n<li>C : 绘制曲线到某处；</li>\n<li>S : 绘制平滑曲线到某处；</li>\n<li>Q : 绘制二次 Belzier 曲线到某处；</li>\n<li>T : 绘制光滑二次 Belzier 曲线到某处；</li>\n<li>A : 绘制椭圆弧线到某处；</li>\n<li>Z : 关闭标签；</li>\n</ul>\n"},{"title":"UCS-2 编码的妙用","intro":"我们在日常的开发当中经常会碰到诸如 UTF-8、UTF-16 等字符编码方式，其实这些字符编码方式都是 Unicode 编码的一种实现方式。而今天我们的主角就是Unicode 编码的另一种实现方式 - “UCS-2” 编码。借助于 “UCS-2” 编码，我们可以实现一些相对“特殊”的需求。","comments":1,"date":"2016-02-19T15:42:57.000Z","_content":"\n我们在日常的开发当中经常会碰到诸如 UTF-8、UTF-16 等字符编码方式，其实这些字符编码方式都是 Unicode 编码的一种实现方式。而今天我们的主角就是Unicode 编码的另一种实现方式 - “UCS-2” 编码。借助于 “UCS-2” 编码，我们可以实现一些相对“特殊”的需求。\n\n在介绍 “UCS-2” 之前，我们先来复习一下 Unicode 编码的相关知识。Unicode 编码是一种可以容纳全世界所有语言文字的编码方案。Unicode 使用一个确定的名字和一个叫做“码位”的**十六进制数**来定义一个字符。例如字符 “A” 对应的 Unicode 码位为 0x0041（十进制整数为65）的码位。而实际上 Unicode 编码的码位从 u0000（0x0000）到 u007F（0x007F）与 ASCII 完全一致。\n\nUnicode 的码空间范围从 u0000（0x0000）到 u10FFFF（0x10FFFF），共有“1,112,064”个码位可用来映射字符. 而其中码位从 u0000 至 uFFFF 的范围内包含了最常用的字符，这一部分被称为基本多语言平面（Basic Multilingual Plane），缩写为 BMP。处于其他范围的码位则称为辅助平面(Supplementary Planes)。\n\n**UCS-2** 英文全称为 “2-byte Universal Character Set”，而相对 UTF-8（变长编码）不同，它是一种**定长**的编码方式，UCS-2 仅仅简单的使用一个16位码元来表示码位，也就是说它可以表示 Unicode 编码从 u0000 到 uFFFF 码位范围内的所有字符。但请记住，UCS-2 只是一种 Unicode 编码的具体实现方式。\n\n那么，我们可以拿 “UCS-2” 编码来做些什么呢？因为 “UCS-2” 在码位范围 u0000 到 uFFFF 范围内的编码与 Unicode 的码位完全一致，因此我们用这一特性来进行对字符的“语言识别”。通过判断某一字符的 UCS-2 编码的码位值（16进制值）其大小，可以判断该字符是属于那一语言或语系。比如汉语的 USC-2 编码码位范围为 u4E00（0x4E00）到 u9FFF（0x9FFF），其他语系也以此类推拥有其对应的码位范围。\n\n下面给出基于 PHP的实现代码：（此段代码会自动分析用户输入字符串内的所有字符的所属语言体系）\n\n```php\nclass Util {\n    public static function charAnaylze($str) {   \n        // 转换成 UCS-2 定长编码；\n        $str = iconv('UTF-8', 'UCS-2', $str);\n\n        // 获取字符串总长度；\n        $strLen = strlen($str);\n\n        $tempStr = '';\n        $resultArr = array();\n\n        // 每次处理一个字符；\n        for ($i = 0; $i < $strLen - 1; $i = $i + 2) {\n            $lowByte = $str[$i];\n            $highByte = $str[$i + 1];\n\n            // 按位转换并填充；\n            $lowByteEncoded = str_pad(base_convert(ord($lowByte), 10, 16), 2, 0, STR_PAD_LEFT);\n            $highByteEncoded = str_pad(base_convert(ord($highByte), 10, 16), 2, 0, STR_PAD_LEFT);\n            $hexStr = $lowByteEncoded . $highByteEncoded;\n            $value = hexdec($hexStr);\n\n            // 创建临时字符；\n            $tempStr = iconv('UTF-8', 'UCS-2', \"A\");\n            $tempStr[0] = $lowByte;\n            $tempStr[1] = $highByte;\n\n            // 编码；\n            $char = iconv('UCS-2', 'UTF-8', $tempStr);\n            \n            if($value >= 65 && $value <= 122) {\n                // Latin 字母；\n                $resultArr['Latin字母'][] = $char;\n            }\n\n            if($value >= 48 && $value <= 57) {\n                // Latin 数字；\n                $resultArr['Latin数字'][] = $char;\n            }\n\n            if(($value >= 33 && $value <= 47) || ($value >= 58 && $value <= 64)) {\n                // Latin 符号；\n                $resultArr['Latin符号'][] = $char;\n            }\n\n            if(($value >= 1536 && $value <= 1791)) {\n                // 阿拉伯语；\n                $resultArr['阿拉伯语'][] = $char;\n            }\n\n            if(($value >= 19968 && $value <= 40959)) {\n                // 汉字；\n                $resultArr['汉字字符'][] = $char;\n            }\n        }\n\n        return $resultArr;\n    }\n}\n```\n","source":"_posts/UCS-2-编码的妙用.md","raw":"---\ntitle: UCS-2 编码的妙用\nintro: 我们在日常的开发当中经常会碰到诸如 UTF-8、UTF-16 等字符编码方式，其实这些字符编码方式都是 Unicode 编码的一种实现方式。而今天我们的主角就是Unicode 编码的另一种实现方式 - “UCS-2” 编码。借助于 “UCS-2” 编码，我们可以实现一些相对“特殊”的需求。\ncomments: true\ndate: 2016-02-19 23:42:57\ntags:\n- 编码\n---\n\n我们在日常的开发当中经常会碰到诸如 UTF-8、UTF-16 等字符编码方式，其实这些字符编码方式都是 Unicode 编码的一种实现方式。而今天我们的主角就是Unicode 编码的另一种实现方式 - “UCS-2” 编码。借助于 “UCS-2” 编码，我们可以实现一些相对“特殊”的需求。\n\n在介绍 “UCS-2” 之前，我们先来复习一下 Unicode 编码的相关知识。Unicode 编码是一种可以容纳全世界所有语言文字的编码方案。Unicode 使用一个确定的名字和一个叫做“码位”的**十六进制数**来定义一个字符。例如字符 “A” 对应的 Unicode 码位为 0x0041（十进制整数为65）的码位。而实际上 Unicode 编码的码位从 u0000（0x0000）到 u007F（0x007F）与 ASCII 完全一致。\n\nUnicode 的码空间范围从 u0000（0x0000）到 u10FFFF（0x10FFFF），共有“1,112,064”个码位可用来映射字符. 而其中码位从 u0000 至 uFFFF 的范围内包含了最常用的字符，这一部分被称为基本多语言平面（Basic Multilingual Plane），缩写为 BMP。处于其他范围的码位则称为辅助平面(Supplementary Planes)。\n\n**UCS-2** 英文全称为 “2-byte Universal Character Set”，而相对 UTF-8（变长编码）不同，它是一种**定长**的编码方式，UCS-2 仅仅简单的使用一个16位码元来表示码位，也就是说它可以表示 Unicode 编码从 u0000 到 uFFFF 码位范围内的所有字符。但请记住，UCS-2 只是一种 Unicode 编码的具体实现方式。\n\n那么，我们可以拿 “UCS-2” 编码来做些什么呢？因为 “UCS-2” 在码位范围 u0000 到 uFFFF 范围内的编码与 Unicode 的码位完全一致，因此我们用这一特性来进行对字符的“语言识别”。通过判断某一字符的 UCS-2 编码的码位值（16进制值）其大小，可以判断该字符是属于那一语言或语系。比如汉语的 USC-2 编码码位范围为 u4E00（0x4E00）到 u9FFF（0x9FFF），其他语系也以此类推拥有其对应的码位范围。\n\n下面给出基于 PHP的实现代码：（此段代码会自动分析用户输入字符串内的所有字符的所属语言体系）\n\n```php\nclass Util {\n    public static function charAnaylze($str) {   \n        // 转换成 UCS-2 定长编码；\n        $str = iconv('UTF-8', 'UCS-2', $str);\n\n        // 获取字符串总长度；\n        $strLen = strlen($str);\n\n        $tempStr = '';\n        $resultArr = array();\n\n        // 每次处理一个字符；\n        for ($i = 0; $i < $strLen - 1; $i = $i + 2) {\n            $lowByte = $str[$i];\n            $highByte = $str[$i + 1];\n\n            // 按位转换并填充；\n            $lowByteEncoded = str_pad(base_convert(ord($lowByte), 10, 16), 2, 0, STR_PAD_LEFT);\n            $highByteEncoded = str_pad(base_convert(ord($highByte), 10, 16), 2, 0, STR_PAD_LEFT);\n            $hexStr = $lowByteEncoded . $highByteEncoded;\n            $value = hexdec($hexStr);\n\n            // 创建临时字符；\n            $tempStr = iconv('UTF-8', 'UCS-2', \"A\");\n            $tempStr[0] = $lowByte;\n            $tempStr[1] = $highByte;\n\n            // 编码；\n            $char = iconv('UCS-2', 'UTF-8', $tempStr);\n            \n            if($value >= 65 && $value <= 122) {\n                // Latin 字母；\n                $resultArr['Latin字母'][] = $char;\n            }\n\n            if($value >= 48 && $value <= 57) {\n                // Latin 数字；\n                $resultArr['Latin数字'][] = $char;\n            }\n\n            if(($value >= 33 && $value <= 47) || ($value >= 58 && $value <= 64)) {\n                // Latin 符号；\n                $resultArr['Latin符号'][] = $char;\n            }\n\n            if(($value >= 1536 && $value <= 1791)) {\n                // 阿拉伯语；\n                $resultArr['阿拉伯语'][] = $char;\n            }\n\n            if(($value >= 19968 && $value <= 40959)) {\n                // 汉字；\n                $resultArr['汉字字符'][] = $char;\n            }\n        }\n\n        return $resultArr;\n    }\n}\n```\n","slug":"UCS-2-编码的妙用","published":1,"updated":"2019-02-05T09:14:18.898Z","layout":"post","photos":[],"link":"","_id":"cjsqwht9w003lknp2fi3ngx9k","content":"<p>我们在日常的开发当中经常会碰到诸如 UTF-8、UTF-16 等字符编码方式，其实这些字符编码方式都是 Unicode 编码的一种实现方式。而今天我们的主角就是Unicode 编码的另一种实现方式 - “UCS-2” 编码。借助于 “UCS-2” 编码，我们可以实现一些相对“特殊”的需求。</p>\n<p>在介绍 “UCS-2” 之前，我们先来复习一下 Unicode 编码的相关知识。Unicode 编码是一种可以容纳全世界所有语言文字的编码方案。Unicode 使用一个确定的名字和一个叫做“码位”的<strong>十六进制数</strong>来定义一个字符。例如字符 “A” 对应的 Unicode 码位为 0x0041（十进制整数为65）的码位。而实际上 Unicode 编码的码位从 u0000（0x0000）到 u007F（0x007F）与 ASCII 完全一致。</p>\n<p>Unicode 的码空间范围从 u0000（0x0000）到 u10FFFF（0x10FFFF），共有“1,112,064”个码位可用来映射字符. 而其中码位从 u0000 至 uFFFF 的范围内包含了最常用的字符，这一部分被称为基本多语言平面（Basic Multilingual Plane），缩写为 BMP。处于其他范围的码位则称为辅助平面(Supplementary Planes)。</p>\n<p><strong>UCS-2</strong> 英文全称为 “2-byte Universal Character Set”，而相对 UTF-8（变长编码）不同，它是一种<strong>定长</strong>的编码方式，UCS-2 仅仅简单的使用一个16位码元来表示码位，也就是说它可以表示 Unicode 编码从 u0000 到 uFFFF 码位范围内的所有字符。但请记住，UCS-2 只是一种 Unicode 编码的具体实现方式。</p>\n<p>那么，我们可以拿 “UCS-2” 编码来做些什么呢？因为 “UCS-2” 在码位范围 u0000 到 uFFFF 范围内的编码与 Unicode 的码位完全一致，因此我们用这一特性来进行对字符的“语言识别”。通过判断某一字符的 UCS-2 编码的码位值（16进制值）其大小，可以判断该字符是属于那一语言或语系。比如汉语的 USC-2 编码码位范围为 u4E00（0x4E00）到 u9FFF（0x9FFF），其他语系也以此类推拥有其对应的码位范围。</p>\n<p>下面给出基于 PHP的实现代码：（此段代码会自动分析用户输入字符串内的所有字符的所属语言体系）</p>\n<pre class=\"line-numbers language-php\"><code class=\"language-php\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Util</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">function</span> <span class=\"token function\">charAnaylze</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$str</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>   \n        <span class=\"token comment\" spellcheck=\"true\">// 转换成 UCS-2 定长编码；</span>\n        <span class=\"token variable\">$str</span> <span class=\"token operator\">=</span> <span class=\"token function\">iconv</span><span class=\"token punctuation\">(</span><span class=\"token string\">'UTF-8'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'UCS-2'</span><span class=\"token punctuation\">,</span> <span class=\"token variable\">$str</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 获取字符串总长度；</span>\n        <span class=\"token variable\">$strLen</span> <span class=\"token operator\">=</span> <span class=\"token function\">strlen</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$str</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token variable\">$tempStr</span> <span class=\"token operator\">=</span> <span class=\"token string\">''</span><span class=\"token punctuation\">;</span>\n        <span class=\"token variable\">$resultArr</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">array</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 每次处理一个字符；</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token variable\">$i</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token variable\">$i</span> <span class=\"token operator\">&lt;</span> <span class=\"token variable\">$strLen</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token variable\">$i</span> <span class=\"token operator\">=</span> <span class=\"token variable\">$i</span> <span class=\"token operator\">+</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token variable\">$lowByte</span> <span class=\"token operator\">=</span> <span class=\"token variable\">$str</span><span class=\"token punctuation\">[</span><span class=\"token variable\">$i</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token variable\">$highByte</span> <span class=\"token operator\">=</span> <span class=\"token variable\">$str</span><span class=\"token punctuation\">[</span><span class=\"token variable\">$i</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">// 按位转换并填充；</span>\n            <span class=\"token variable\">$lowByteEncoded</span> <span class=\"token operator\">=</span> <span class=\"token function\">str_pad</span><span class=\"token punctuation\">(</span><span class=\"token function\">base_convert</span><span class=\"token punctuation\">(</span><span class=\"token function\">ord</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$lowByte</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">16</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">STR_PAD_LEFT</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token variable\">$highByteEncoded</span> <span class=\"token operator\">=</span> <span class=\"token function\">str_pad</span><span class=\"token punctuation\">(</span><span class=\"token function\">base_convert</span><span class=\"token punctuation\">(</span><span class=\"token function\">ord</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$highByte</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">16</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">STR_PAD_LEFT</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token variable\">$hexStr</span> <span class=\"token operator\">=</span> <span class=\"token variable\">$lowByteEncoded</span> <span class=\"token punctuation\">.</span> <span class=\"token variable\">$highByteEncoded</span><span class=\"token punctuation\">;</span>\n            <span class=\"token variable\">$value</span> <span class=\"token operator\">=</span> <span class=\"token function\">hexdec</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$hexStr</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">// 创建临时字符；</span>\n            <span class=\"token variable\">$tempStr</span> <span class=\"token operator\">=</span> <span class=\"token function\">iconv</span><span class=\"token punctuation\">(</span><span class=\"token string\">'UTF-8'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'UCS-2'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"A\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token variable\">$tempStr</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token variable\">$lowByte</span><span class=\"token punctuation\">;</span>\n            <span class=\"token variable\">$tempStr</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token variable\">$highByte</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">// 编码；</span>\n            <span class=\"token variable\">$char</span> <span class=\"token operator\">=</span> <span class=\"token function\">iconv</span><span class=\"token punctuation\">(</span><span class=\"token string\">'UCS-2'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'UTF-8'</span><span class=\"token punctuation\">,</span> <span class=\"token variable\">$tempStr</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$value</span> <span class=\"token operator\">>=</span> <span class=\"token number\">65</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token variable\">$value</span> <span class=\"token operator\">&lt;=</span> <span class=\"token number\">122</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">// Latin 字母；</span>\n                <span class=\"token variable\">$resultArr</span><span class=\"token punctuation\">[</span><span class=\"token string\">'Latin字母'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token variable\">$char</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$value</span> <span class=\"token operator\">>=</span> <span class=\"token number\">48</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token variable\">$value</span> <span class=\"token operator\">&lt;=</span> <span class=\"token number\">57</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">// Latin 数字；</span>\n                <span class=\"token variable\">$resultArr</span><span class=\"token punctuation\">[</span><span class=\"token string\">'Latin数字'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token variable\">$char</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$value</span> <span class=\"token operator\">>=</span> <span class=\"token number\">33</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token variable\">$value</span> <span class=\"token markup\">&lt;= 47) || ($value ></span><span class=\"token operator\">=</span> <span class=\"token number\">58</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token variable\">$value</span> <span class=\"token operator\">&lt;=</span> <span class=\"token number\">64</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">// Latin 符号；</span>\n                <span class=\"token variable\">$resultArr</span><span class=\"token punctuation\">[</span><span class=\"token string\">'Latin符号'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token variable\">$char</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$value</span> <span class=\"token operator\">>=</span> <span class=\"token number\">1536</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token variable\">$value</span> <span class=\"token operator\">&lt;=</span> <span class=\"token number\">1791</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">// 阿拉伯语；</span>\n                <span class=\"token variable\">$resultArr</span><span class=\"token punctuation\">[</span><span class=\"token string\">'阿拉伯语'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token variable\">$char</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$value</span> <span class=\"token operator\">>=</span> <span class=\"token number\">19968</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token variable\">$value</span> <span class=\"token operator\">&lt;=</span> <span class=\"token number\">40959</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">// 汉字；</span>\n                <span class=\"token variable\">$resultArr</span><span class=\"token punctuation\">[</span><span class=\"token string\">'汉字字符'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token variable\">$char</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">return</span> <span class=\"token variable\">$resultArr</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"id":"29e13ae4c2780787f9a0b10e61f5338b","excerpt":"","more":"<p>我们在日常的开发当中经常会碰到诸如 UTF-8、UTF-16 等字符编码方式，其实这些字符编码方式都是 Unicode 编码的一种实现方式。而今天我们的主角就是Unicode 编码的另一种实现方式 - “UCS-2” 编码。借助于 “UCS-2” 编码，我们可以实现一些相对“特殊”的需求。</p>\n<p>在介绍 “UCS-2” 之前，我们先来复习一下 Unicode 编码的相关知识。Unicode 编码是一种可以容纳全世界所有语言文字的编码方案。Unicode 使用一个确定的名字和一个叫做“码位”的<strong>十六进制数</strong>来定义一个字符。例如字符 “A” 对应的 Unicode 码位为 0x0041（十进制整数为65）的码位。而实际上 Unicode 编码的码位从 u0000（0x0000）到 u007F（0x007F）与 ASCII 完全一致。</p>\n<p>Unicode 的码空间范围从 u0000（0x0000）到 u10FFFF（0x10FFFF），共有“1,112,064”个码位可用来映射字符. 而其中码位从 u0000 至 uFFFF 的范围内包含了最常用的字符，这一部分被称为基本多语言平面（Basic Multilingual Plane），缩写为 BMP。处于其他范围的码位则称为辅助平面(Supplementary Planes)。</p>\n<p><strong>UCS-2</strong> 英文全称为 “2-byte Universal Character Set”，而相对 UTF-8（变长编码）不同，它是一种<strong>定长</strong>的编码方式，UCS-2 仅仅简单的使用一个16位码元来表示码位，也就是说它可以表示 Unicode 编码从 u0000 到 uFFFF 码位范围内的所有字符。但请记住，UCS-2 只是一种 Unicode 编码的具体实现方式。</p>\n<p>那么，我们可以拿 “UCS-2” 编码来做些什么呢？因为 “UCS-2” 在码位范围 u0000 到 uFFFF 范围内的编码与 Unicode 的码位完全一致，因此我们用这一特性来进行对字符的“语言识别”。通过判断某一字符的 UCS-2 编码的码位值（16进制值）其大小，可以判断该字符是属于那一语言或语系。比如汉语的 USC-2 编码码位范围为 u4E00（0x4E00）到 u9FFF（0x9FFF），其他语系也以此类推拥有其对应的码位范围。</p>\n<p>下面给出基于 PHP的实现代码：（此段代码会自动分析用户输入字符串内的所有字符的所属语言体系）</p>\n<pre><code class=\"php\">class Util {\n    public static function charAnaylze($str) {   \n        // 转换成 UCS-2 定长编码；\n        $str = iconv(&#39;UTF-8&#39;, &#39;UCS-2&#39;, $str);\n\n        // 获取字符串总长度；\n        $strLen = strlen($str);\n\n        $tempStr = &#39;&#39;;\n        $resultArr = array();\n\n        // 每次处理一个字符；\n        for ($i = 0; $i &lt; $strLen - 1; $i = $i + 2) {\n            $lowByte = $str[$i];\n            $highByte = $str[$i + 1];\n\n            // 按位转换并填充；\n            $lowByteEncoded = str_pad(base_convert(ord($lowByte), 10, 16), 2, 0, STR_PAD_LEFT);\n            $highByteEncoded = str_pad(base_convert(ord($highByte), 10, 16), 2, 0, STR_PAD_LEFT);\n            $hexStr = $lowByteEncoded . $highByteEncoded;\n            $value = hexdec($hexStr);\n\n            // 创建临时字符；\n            $tempStr = iconv(&#39;UTF-8&#39;, &#39;UCS-2&#39;, &quot;A&quot;);\n            $tempStr[0] = $lowByte;\n            $tempStr[1] = $highByte;\n\n            // 编码；\n            $char = iconv(&#39;UCS-2&#39;, &#39;UTF-8&#39;, $tempStr);\n\n            if($value &gt;= 65 &amp;&amp; $value &lt;= 122) {\n                // Latin 字母；\n                $resultArr[&#39;Latin字母&#39;][] = $char;\n            }\n\n            if($value &gt;= 48 &amp;&amp; $value &lt;= 57) {\n                // Latin 数字；\n                $resultArr[&#39;Latin数字&#39;][] = $char;\n            }\n\n            if(($value &gt;= 33 &amp;&amp; $value &lt;= 47) || ($value &gt;= 58 &amp;&amp; $value &lt;= 64)) {\n                // Latin 符号；\n                $resultArr[&#39;Latin符号&#39;][] = $char;\n            }\n\n            if(($value &gt;= 1536 &amp;&amp; $value &lt;= 1791)) {\n                // 阿拉伯语；\n                $resultArr[&#39;阿拉伯语&#39;][] = $char;\n            }\n\n            if(($value &gt;= 19968 &amp;&amp; $value &lt;= 40959)) {\n                // 汉字；\n                $resultArr[&#39;汉字字符&#39;][] = $char;\n            }\n        }\n\n        return $resultArr;\n    }\n}\n</code></pre>\n"},{"title":"The Twelve-Factor App","intro":"如今，软件通常会作为一种服务来交付，它们被称为网络应用程序，或软件即服务（SaaS）。12-Factor 为构建如下的 SaaS 应用提供了方法论。这套理论适用于任意语言和后端服务（数据库. 消息队列. 缓存等）开发的应用程序。","comments":1,"date":"2017-11-12T03:47:34.000Z","_content":"\n如今，软件通常会作为一种服务来交付，它们被称为网络应用程序，或软件即服务（SaaS）。12-Factor 为构建如下的 SaaS 应用提供了方法论。这套理论适用于任意语言和后端服务（数据库. 消息队列. 缓存等）开发的应用程序。 \n\n#### 一. 概述总结：\n\n 1. 使用**标准化**流程自动配置，降低加入成本； \n 2. 保证**最大的系统可移植性** ；\n 3. **部署**在**云计算平台**，节省资源； \n 4. 将开发环境和生产环境的**差异降至最低**，基于 **CI/CD **实施敏捷开发；\n 5. 保证在最低成改动本下实现**高扩展性**；\n\n\n #### 二. 12个因素：\n\n1. **基准代码**：\n\n使用版本控制系统管理代码，每个应用只对应一份基准代码，但可以同时进行多份部署（本地，线上）。 \n\n2. **依赖**：\n\n应用需要的所有依赖一定需要通过 ***依赖清单*** ，确切完整的声明出来。\n \n3. **配置**：\n\n配置文件在各部署环境间存在大幅差异，但配置项却应该完全一致。推荐将应用的配置存储于 ***环境变量*** 中。 \n\n4. **后端服务**：\n\n应用与后端服务应该保持“松耦合”，后端服务（数据库，消息队列等）可以 ***随时替换***，而不用修改应用本身的代码。 \n\n5. **构建，发布，运行**：\n\n按照特定的流程进行发布，整个发布的流程不可逆。发布版本号不可逆。 \n\n6. **进程**：\n\n以一个或多个**无状态进程**运行应用，不可使用粘性 session（将用户 session 中的数据缓存至某进程的内存中，并将同一用户的后续请求路由到同一个进程）。需要持久化的数据放到后端服务中。 \n\n7. **端口绑定**：\n\n***应用完全自我加载*** 而不依赖于任何网络服务器就可以创建一个面向网络的服务。互联网应用 ***通过端口绑定来提供服务*** ，并监听发送至该端口的请求。 \n\n8. **并发**：\n\n进程结构基于 ***Unix 守护进程模型***，进程间无共享，水平分区。意味着添加并发会变得简单而稳妥。这些进程的类型以及每个类型中进程的数量就被称作 ***进程构成*** 。 \n\n9. **易处理**：\n\n应用应该是可以被 ***快速启动和停止*** 的。同时在面对突然死亡时 ***保持健壮***。 \n\n10. **开发环境与线上环境等价**：\n\n应用想要做到持续部署（CD）就必须 ***缩小本地与线上环境差异***，应用的开发人员应该反对在不同环境间使用不同的后端服务。 \n\n11. **日志**：\n\n将日志输出 ***当作事件流来处理***，而不是直接存入文档。比如将日志输入到日志索引及分析系统等。 \n\n12. **管理进程**：\n\n后台管理任务（定时脚本等）当作一次性进程运行，使用同“常驻进程”一样的环境和配置。 \n\n","source":"_posts/The-Twelve-Factor-App.md","raw":"---\ntitle: The Twelve-Factor App\nintro: 如今，软件通常会作为一种服务来交付，它们被称为网络应用程序，或软件即服务（SaaS）。12-Factor 为构建如下的 SaaS 应用提供了方法论。这套理论适用于任意语言和后端服务（数据库. 消息队列. 缓存等）开发的应用程序。 \ncomments: true\ndate: 2017-11-12 11:47:34\ntags:\n- Twelve-Factor\n---\n\n如今，软件通常会作为一种服务来交付，它们被称为网络应用程序，或软件即服务（SaaS）。12-Factor 为构建如下的 SaaS 应用提供了方法论。这套理论适用于任意语言和后端服务（数据库. 消息队列. 缓存等）开发的应用程序。 \n\n#### 一. 概述总结：\n\n 1. 使用**标准化**流程自动配置，降低加入成本； \n 2. 保证**最大的系统可移植性** ；\n 3. **部署**在**云计算平台**，节省资源； \n 4. 将开发环境和生产环境的**差异降至最低**，基于 **CI/CD **实施敏捷开发；\n 5. 保证在最低成改动本下实现**高扩展性**；\n\n\n #### 二. 12个因素：\n\n1. **基准代码**：\n\n使用版本控制系统管理代码，每个应用只对应一份基准代码，但可以同时进行多份部署（本地，线上）。 \n\n2. **依赖**：\n\n应用需要的所有依赖一定需要通过 ***依赖清单*** ，确切完整的声明出来。\n \n3. **配置**：\n\n配置文件在各部署环境间存在大幅差异，但配置项却应该完全一致。推荐将应用的配置存储于 ***环境变量*** 中。 \n\n4. **后端服务**：\n\n应用与后端服务应该保持“松耦合”，后端服务（数据库，消息队列等）可以 ***随时替换***，而不用修改应用本身的代码。 \n\n5. **构建，发布，运行**：\n\n按照特定的流程进行发布，整个发布的流程不可逆。发布版本号不可逆。 \n\n6. **进程**：\n\n以一个或多个**无状态进程**运行应用，不可使用粘性 session（将用户 session 中的数据缓存至某进程的内存中，并将同一用户的后续请求路由到同一个进程）。需要持久化的数据放到后端服务中。 \n\n7. **端口绑定**：\n\n***应用完全自我加载*** 而不依赖于任何网络服务器就可以创建一个面向网络的服务。互联网应用 ***通过端口绑定来提供服务*** ，并监听发送至该端口的请求。 \n\n8. **并发**：\n\n进程结构基于 ***Unix 守护进程模型***，进程间无共享，水平分区。意味着添加并发会变得简单而稳妥。这些进程的类型以及每个类型中进程的数量就被称作 ***进程构成*** 。 \n\n9. **易处理**：\n\n应用应该是可以被 ***快速启动和停止*** 的。同时在面对突然死亡时 ***保持健壮***。 \n\n10. **开发环境与线上环境等价**：\n\n应用想要做到持续部署（CD）就必须 ***缩小本地与线上环境差异***，应用的开发人员应该反对在不同环境间使用不同的后端服务。 \n\n11. **日志**：\n\n将日志输出 ***当作事件流来处理***，而不是直接存入文档。比如将日志输入到日志索引及分析系统等。 \n\n12. **管理进程**：\n\n后台管理任务（定时脚本等）当作一次性进程运行，使用同“常驻进程”一样的环境和配置。 \n\n","slug":"The-Twelve-Factor-App","published":1,"updated":"2019-02-20T06:09:06.269Z","layout":"post","photos":[],"link":"","_id":"cjsqwht9x003oknp2rs211u08","content":"<p>如今，软件通常会作为一种服务来交付，它们被称为网络应用程序，或软件即服务（SaaS）。12-Factor 为构建如下的 SaaS 应用提供了方法论。这套理论适用于任意语言和后端服务（数据库. 消息队列. 缓存等）开发的应用程序。 </p>\n<h4 id=\"一-概述总结：\"><a href=\"#一-概述总结：\" class=\"headerlink\" title=\"一. 概述总结：\"></a>一. 概述总结：</h4><ol>\n<li>使用<strong>标准化</strong>流程自动配置，降低加入成本； </li>\n<li>保证<strong>最大的系统可移植性</strong> ；</li>\n<li><strong>部署</strong>在<strong>云计算平台</strong>，节省资源； </li>\n<li>将开发环境和生产环境的<strong>差异降至最低</strong>，基于 <strong>CI/CD </strong>实施敏捷开发；</li>\n<li>保证在最低成改动本下实现<strong>高扩展性</strong>；</li>\n</ol>\n<h4 id=\"二-12个因素：\"><a href=\"#二-12个因素：\" class=\"headerlink\" title=\"二. 12个因素：\"></a>二. 12个因素：</h4><ol>\n<li><strong>基准代码</strong>：</li>\n</ol>\n<p>使用版本控制系统管理代码，每个应用只对应一份基准代码，但可以同时进行多份部署（本地，线上）。 </p>\n<ol start=\"2\">\n<li><strong>依赖</strong>：</li>\n</ol>\n<p>应用需要的所有依赖一定需要通过 <strong><em>依赖清单</em></strong> ，确切完整的声明出来。</p>\n<ol start=\"3\">\n<li><strong>配置</strong>：</li>\n</ol>\n<p>配置文件在各部署环境间存在大幅差异，但配置项却应该完全一致。推荐将应用的配置存储于 <strong><em>环境变量</em></strong> 中。 </p>\n<ol start=\"4\">\n<li><strong>后端服务</strong>：</li>\n</ol>\n<p>应用与后端服务应该保持“松耦合”，后端服务（数据库，消息队列等）可以 <strong><em>随时替换</em></strong>，而不用修改应用本身的代码。 </p>\n<ol start=\"5\">\n<li><strong>构建，发布，运行</strong>：</li>\n</ol>\n<p>按照特定的流程进行发布，整个发布的流程不可逆。发布版本号不可逆。 </p>\n<ol start=\"6\">\n<li><strong>进程</strong>：</li>\n</ol>\n<p>以一个或多个<strong>无状态进程</strong>运行应用，不可使用粘性 session（将用户 session 中的数据缓存至某进程的内存中，并将同一用户的后续请求路由到同一个进程）。需要持久化的数据放到后端服务中。 </p>\n<ol start=\"7\">\n<li><strong>端口绑定</strong>：</li>\n</ol>\n<p><strong><em>应用完全自我加载</em></strong> 而不依赖于任何网络服务器就可以创建一个面向网络的服务。互联网应用 <strong><em>通过端口绑定来提供服务</em></strong> ，并监听发送至该端口的请求。 </p>\n<ol start=\"8\">\n<li><strong>并发</strong>：</li>\n</ol>\n<p>进程结构基于 <strong><em>Unix 守护进程模型</em></strong>，进程间无共享，水平分区。意味着添加并发会变得简单而稳妥。这些进程的类型以及每个类型中进程的数量就被称作 <strong><em>进程构成</em></strong> 。 </p>\n<ol start=\"9\">\n<li><strong>易处理</strong>：</li>\n</ol>\n<p>应用应该是可以被 <strong><em>快速启动和停止</em></strong> 的。同时在面对突然死亡时 <strong><em>保持健壮</em></strong>。 </p>\n<ol start=\"10\">\n<li><strong>开发环境与线上环境等价</strong>：</li>\n</ol>\n<p>应用想要做到持续部署（CD）就必须 <strong><em>缩小本地与线上环境差异</em></strong>，应用的开发人员应该反对在不同环境间使用不同的后端服务。 </p>\n<ol start=\"11\">\n<li><strong>日志</strong>：</li>\n</ol>\n<p>将日志输出 <strong><em>当作事件流来处理</em></strong>，而不是直接存入文档。比如将日志输入到日志索引及分析系统等。 </p>\n<ol start=\"12\">\n<li><strong>管理进程</strong>：</li>\n</ol>\n<p>后台管理任务（定时脚本等）当作一次性进程运行，使用同“常驻进程”一样的环境和配置。 </p>\n","site":{"data":{}},"id":"faa4627f5ea79b9529fa5ce9a4c55bc2","excerpt":"","more":"<p>如今，软件通常会作为一种服务来交付，它们被称为网络应用程序，或软件即服务（SaaS）。12-Factor 为构建如下的 SaaS 应用提供了方法论。这套理论适用于任意语言和后端服务（数据库. 消息队列. 缓存等）开发的应用程序。 </p>\n<h4 id=\"一-概述总结：\"><a href=\"#一-概述总结：\" class=\"headerlink\" title=\"一. 概述总结：\"></a>一. 概述总结：</h4><ol>\n<li>使用<strong>标准化</strong>流程自动配置，降低加入成本； </li>\n<li>保证<strong>最大的系统可移植性</strong> ；</li>\n<li><strong>部署</strong>在<strong>云计算平台</strong>，节省资源； </li>\n<li>将开发环境和生产环境的<strong>差异降至最低</strong>，基于 <strong>CI/CD </strong>实施敏捷开发；</li>\n<li>保证在最低成改动本下实现<strong>高扩展性</strong>；</li>\n</ol>\n<h4 id=\"二-12个因素：\"><a href=\"#二-12个因素：\" class=\"headerlink\" title=\"二. 12个因素：\"></a>二. 12个因素：</h4><ol>\n<li><strong>基准代码</strong>：</li>\n</ol>\n<p>使用版本控制系统管理代码，每个应用只对应一份基准代码，但可以同时进行多份部署（本地，线上）。 </p>\n<ol start=\"2\">\n<li><strong>依赖</strong>：</li>\n</ol>\n<p>应用需要的所有依赖一定需要通过 <strong><em>依赖清单</em></strong> ，确切完整的声明出来。</p>\n<ol start=\"3\">\n<li><strong>配置</strong>：</li>\n</ol>\n<p>配置文件在各部署环境间存在大幅差异，但配置项却应该完全一致。推荐将应用的配置存储于 <strong><em>环境变量</em></strong> 中。 </p>\n<ol start=\"4\">\n<li><strong>后端服务</strong>：</li>\n</ol>\n<p>应用与后端服务应该保持“松耦合”，后端服务（数据库，消息队列等）可以 <strong><em>随时替换</em></strong>，而不用修改应用本身的代码。 </p>\n<ol start=\"5\">\n<li><strong>构建，发布，运行</strong>：</li>\n</ol>\n<p>按照特定的流程进行发布，整个发布的流程不可逆。发布版本号不可逆。 </p>\n<ol start=\"6\">\n<li><strong>进程</strong>：</li>\n</ol>\n<p>以一个或多个<strong>无状态进程</strong>运行应用，不可使用粘性 session（将用户 session 中的数据缓存至某进程的内存中，并将同一用户的后续请求路由到同一个进程）。需要持久化的数据放到后端服务中。 </p>\n<ol start=\"7\">\n<li><strong>端口绑定</strong>：</li>\n</ol>\n<p><strong><em>应用完全自我加载</em></strong> 而不依赖于任何网络服务器就可以创建一个面向网络的服务。互联网应用 <strong><em>通过端口绑定来提供服务</em></strong> ，并监听发送至该端口的请求。 </p>\n<ol start=\"8\">\n<li><strong>并发</strong>：</li>\n</ol>\n<p>进程结构基于 <strong><em>Unix 守护进程模型</em></strong>，进程间无共享，水平分区。意味着添加并发会变得简单而稳妥。这些进程的类型以及每个类型中进程的数量就被称作 <strong><em>进程构成</em></strong> 。 </p>\n<ol start=\"9\">\n<li><strong>易处理</strong>：</li>\n</ol>\n<p>应用应该是可以被 <strong><em>快速启动和停止</em></strong> 的。同时在面对突然死亡时 <strong><em>保持健壮</em></strong>。 </p>\n<ol start=\"10\">\n<li><strong>开发环境与线上环境等价</strong>：</li>\n</ol>\n<p>应用想要做到持续部署（CD）就必须 <strong><em>缩小本地与线上环境差异</em></strong>，应用的开发人员应该反对在不同环境间使用不同的后端服务。 </p>\n<ol start=\"11\">\n<li><strong>日志</strong>：</li>\n</ol>\n<p>将日志输出 <strong><em>当作事件流来处理</em></strong>，而不是直接存入文档。比如将日志输入到日志索引及分析系统等。 </p>\n<ol start=\"12\">\n<li><strong>管理进程</strong>：</li>\n</ol>\n<p>后台管理任务（定时脚本等）当作一次性进程运行，使用同“常驻进程”一样的环境和配置。 </p>\n"},{"title":"URL 编码的那些事儿","intro":"最近一段时间积累的很多面试经验，也发现了自己薄弱的地方。企业最需要的是基本的业务推动，其次才能谈梦想。基础业务对应着基本能力，基本知识是否扎实是大企业十分看重的一个问题。“T型人才”和“I型人才”，是时候恶补一下基础知识了。今天讲一下 URL 编码。","comments":1,"date":"2017-03-23T06:17:59.000Z","_content":"\n最近一段时间积累的很多面试经验，也发现了自己薄弱的地方。企业最需要的是基本的业务推动，其次才能谈梦想。基础业务对应着基本能力，基本知识是否扎实是大企业十分看重的一个问题。“T型人才”和“I型人才”，是时候恶补一下基础知识了。今天讲一下 URL 编码。\n\nJavaScript 中有两个方法与 URL 的编码相关，分别是 `encodeURI` 和 `encodeURIComponent`。还有一个与字符串的编码相关，对应的函数是 `escape`。\n\n#### 1. 字符串编码用 escape：\n\n`escape` 函数用来编码所有的字符串，使其可以在所有的平台上以同一种形式进行阅读。`escape` 函数会编码除字母，数字和 “@*_+-./” 这些字符之外的所有字符。因此不可以将它直接用在 URL 的编码上。`escape` 函数编码后的字符会以 \"%XX\" 或 \"%XXXX\" 的格式表示。\n\n#### 2. encodeURIComponent 比 encodeURI 的编码范围大：\n\n`encodeURIComponent` 会编码除数字、字母和 “- _ . ! ~ * ' ( )” 以外的所有字符，因此不能使用 `encodeURIComponent` 来编码整个 URL，它更适合用于编码 URL 中的参数部分。而 `encodeURI` 适合用于编码整个 URL 的场景，比如会将 URL 中的空格编码成 \"20%\"。\n\n#### 3. PHP 中的 rawurlencode 和 urlencode：\n\n`urlencode` 返回字符串，此字符串中除了 “-_.” 之外的所有非字母数字字符都将被替换成百分号（%）后跟两位十六进制数，空格则编码为加号（+）。此编码与 WWW 表单 POST 数据的编码方式是一样的，同时与 “application/x-www-form-urlencoded” 的媒体类型编码方式一样。由于历史原因，此编码在将**空格编码为加号（+）**方面与 RFC1738 编码不同。\n\n`rawurlencode` 返回字符串，此字符串中除了 “-_.” 之外的所有非字母数字字符都将被替换成百分号（%）后跟两位十六进制数。这是在 RFC3986 中描述的编码，是为了保护原义字符以免其被解释为特殊的 URL 定界符，同时保护 URL 格式以免其被传输媒体（像一些邮件系统）使用字符转换时弄乱。\n\n","source":"_posts/URL-编码的那些事儿.md","raw":"---\ntitle: URL 编码的那些事儿\nintro: 最近一段时间积累的很多面试经验，也发现了自己薄弱的地方。企业最需要的是基本的业务推动，其次才能谈梦想。基础业务对应着基本能力，基本知识是否扎实是大企业十分看重的一个问题。“T型人才”和“I型人才”，是时候恶补一下基础知识了。今天讲一下 URL 编码。\ncomments: true\ndate: 2017-03-23 14:17:59\ntags:\n- JavaScript\n- PHP\n---\n\n最近一段时间积累的很多面试经验，也发现了自己薄弱的地方。企业最需要的是基本的业务推动，其次才能谈梦想。基础业务对应着基本能力，基本知识是否扎实是大企业十分看重的一个问题。“T型人才”和“I型人才”，是时候恶补一下基础知识了。今天讲一下 URL 编码。\n\nJavaScript 中有两个方法与 URL 的编码相关，分别是 `encodeURI` 和 `encodeURIComponent`。还有一个与字符串的编码相关，对应的函数是 `escape`。\n\n#### 1. 字符串编码用 escape：\n\n`escape` 函数用来编码所有的字符串，使其可以在所有的平台上以同一种形式进行阅读。`escape` 函数会编码除字母，数字和 “@*_+-./” 这些字符之外的所有字符。因此不可以将它直接用在 URL 的编码上。`escape` 函数编码后的字符会以 \"%XX\" 或 \"%XXXX\" 的格式表示。\n\n#### 2. encodeURIComponent 比 encodeURI 的编码范围大：\n\n`encodeURIComponent` 会编码除数字、字母和 “- _ . ! ~ * ' ( )” 以外的所有字符，因此不能使用 `encodeURIComponent` 来编码整个 URL，它更适合用于编码 URL 中的参数部分。而 `encodeURI` 适合用于编码整个 URL 的场景，比如会将 URL 中的空格编码成 \"20%\"。\n\n#### 3. PHP 中的 rawurlencode 和 urlencode：\n\n`urlencode` 返回字符串，此字符串中除了 “-_.” 之外的所有非字母数字字符都将被替换成百分号（%）后跟两位十六进制数，空格则编码为加号（+）。此编码与 WWW 表单 POST 数据的编码方式是一样的，同时与 “application/x-www-form-urlencoded” 的媒体类型编码方式一样。由于历史原因，此编码在将**空格编码为加号（+）**方面与 RFC1738 编码不同。\n\n`rawurlencode` 返回字符串，此字符串中除了 “-_.” 之外的所有非字母数字字符都将被替换成百分号（%）后跟两位十六进制数。这是在 RFC3986 中描述的编码，是为了保护原义字符以免其被解释为特殊的 URL 定界符，同时保护 URL 格式以免其被传输媒体（像一些邮件系统）使用字符转换时弄乱。\n\n","slug":"URL-编码的那些事儿","published":1,"updated":"2019-02-12T06:22:44.106Z","layout":"post","photos":[],"link":"","_id":"cjsqwht9y003qknp2tyas98kq","content":"<p>最近一段时间积累的很多面试经验，也发现了自己薄弱的地方。企业最需要的是基本的业务推动，其次才能谈梦想。基础业务对应着基本能力，基本知识是否扎实是大企业十分看重的一个问题。“T型人才”和“I型人才”，是时候恶补一下基础知识了。今天讲一下 URL 编码。</p>\n<p>JavaScript 中有两个方法与 URL 的编码相关，分别是 <code>encodeURI</code> 和 <code>encodeURIComponent</code>。还有一个与字符串的编码相关，对应的函数是 <code>escape</code>。</p>\n<h4 id=\"1-字符串编码用-escape：\"><a href=\"#1-字符串编码用-escape：\" class=\"headerlink\" title=\"1. 字符串编码用 escape：\"></a>1. 字符串编码用 escape：</h4><p><code>escape</code> 函数用来编码所有的字符串，使其可以在所有的平台上以同一种形式进行阅读。<code>escape</code> 函数会编码除字母，数字和 “@*_+-./” 这些字符之外的所有字符。因此不可以将它直接用在 URL 的编码上。<code>escape</code> 函数编码后的字符会以 “%XX” 或 “%XXXX” 的格式表示。</p>\n<h4 id=\"2-encodeURIComponent-比-encodeURI-的编码范围大：\"><a href=\"#2-encodeURIComponent-比-encodeURI-的编码范围大：\" class=\"headerlink\" title=\"2. encodeURIComponent 比 encodeURI 的编码范围大：\"></a>2. encodeURIComponent 比 encodeURI 的编码范围大：</h4><p><code>encodeURIComponent</code> 会编码除数字、字母和 “- _ . ! ~ * ‘ ( )” 以外的所有字符，因此不能使用 <code>encodeURIComponent</code> 来编码整个 URL，它更适合用于编码 URL 中的参数部分。而 <code>encodeURI</code> 适合用于编码整个 URL 的场景，比如会将 URL 中的空格编码成 “20%”。</p>\n<h4 id=\"3-PHP-中的-rawurlencode-和-urlencode：\"><a href=\"#3-PHP-中的-rawurlencode-和-urlencode：\" class=\"headerlink\" title=\"3. PHP 中的 rawurlencode 和 urlencode：\"></a>3. PHP 中的 rawurlencode 和 urlencode：</h4><p><code>urlencode</code> 返回字符串，此字符串中除了 “-_.” 之外的所有非字母数字字符都将被替换成百分号（%）后跟两位十六进制数，空格则编码为加号（+）。此编码与 WWW 表单 POST 数据的编码方式是一样的，同时与 “application/x-www-form-urlencoded” 的媒体类型编码方式一样。由于历史原因，此编码在将<strong>空格编码为加号（+）</strong>方面与 RFC1738 编码不同。</p>\n<p><code>rawurlencode</code> 返回字符串，此字符串中除了 “-_.” 之外的所有非字母数字字符都将被替换成百分号（%）后跟两位十六进制数。这是在 RFC3986 中描述的编码，是为了保护原义字符以免其被解释为特殊的 URL 定界符，同时保护 URL 格式以免其被传输媒体（像一些邮件系统）使用字符转换时弄乱。</p>\n","site":{"data":{}},"id":"3a54cedab13728ac9546413bdd54c062","excerpt":"","more":"<p>最近一段时间积累的很多面试经验，也发现了自己薄弱的地方。企业最需要的是基本的业务推动，其次才能谈梦想。基础业务对应着基本能力，基本知识是否扎实是大企业十分看重的一个问题。“T型人才”和“I型人才”，是时候恶补一下基础知识了。今天讲一下 URL 编码。</p>\n<p>JavaScript 中有两个方法与 URL 的编码相关，分别是 <code>encodeURI</code> 和 <code>encodeURIComponent</code>。还有一个与字符串的编码相关，对应的函数是 <code>escape</code>。</p>\n<h4 id=\"1-字符串编码用-escape：\"><a href=\"#1-字符串编码用-escape：\" class=\"headerlink\" title=\"1. 字符串编码用 escape：\"></a>1. 字符串编码用 escape：</h4><p><code>escape</code> 函数用来编码所有的字符串，使其可以在所有的平台上以同一种形式进行阅读。<code>escape</code> 函数会编码除字母，数字和 “@*_+-./” 这些字符之外的所有字符。因此不可以将它直接用在 URL 的编码上。<code>escape</code> 函数编码后的字符会以 “%XX” 或 “%XXXX” 的格式表示。</p>\n<h4 id=\"2-encodeURIComponent-比-encodeURI-的编码范围大：\"><a href=\"#2-encodeURIComponent-比-encodeURI-的编码范围大：\" class=\"headerlink\" title=\"2. encodeURIComponent 比 encodeURI 的编码范围大：\"></a>2. encodeURIComponent 比 encodeURI 的编码范围大：</h4><p><code>encodeURIComponent</code> 会编码除数字、字母和 “- _ . ! ~ * ‘ ( )” 以外的所有字符，因此不能使用 <code>encodeURIComponent</code> 来编码整个 URL，它更适合用于编码 URL 中的参数部分。而 <code>encodeURI</code> 适合用于编码整个 URL 的场景，比如会将 URL 中的空格编码成 “20%”。</p>\n<h4 id=\"3-PHP-中的-rawurlencode-和-urlencode：\"><a href=\"#3-PHP-中的-rawurlencode-和-urlencode：\" class=\"headerlink\" title=\"3. PHP 中的 rawurlencode 和 urlencode：\"></a>3. PHP 中的 rawurlencode 和 urlencode：</h4><p><code>urlencode</code> 返回字符串，此字符串中除了 “-_.” 之外的所有非字母数字字符都将被替换成百分号（%）后跟两位十六进制数，空格则编码为加号（+）。此编码与 WWW 表单 POST 数据的编码方式是一样的，同时与 “application/x-www-form-urlencoded” 的媒体类型编码方式一样。由于历史原因，此编码在将<strong>空格编码为加号（+）</strong>方面与 RFC1738 编码不同。</p>\n<p><code>rawurlencode</code> 返回字符串，此字符串中除了 “-_.” 之外的所有非字母数字字符都将被替换成百分号（%）后跟两位十六进制数。这是在 RFC3986 中描述的编码，是为了保护原义字符以免其被解释为特殊的 URL 定界符，同时保护 URL 格式以免其被传输媒体（像一些邮件系统）使用字符转换时弄乱。</p>\n"},{"title":"WebAssembly 尝试研究报告 - DIP 实践","intro":"从本次报告开始，我们将花一点时间从零开始构建一个基于 WebAssembly 的 DIP（数字图像处理）应用。该应用的主要功能是可以给一段在线视频添加实时滤镜。在 JS 层我们的主要任务是截取视频中的每一帧画面，同时把该帧画面转换成对应的像素矩阵，然后调用 Wasm 模块对这些像素矩阵进行滤镜处理，最后再将处理后的像素矩阵绘制到页面上。对视频进行实时帧像素处理的部分我们会放到 WebAssembly 模块中来实现。","comments":1,"date":"2017-06-16T06:13:41.000Z","_content":"\n从本次报告开始，我们将花一点时间从零开始构建一个基于 WebAssembly 的 DIP（数字图像处理）应用。该应用的主要功能是可以给一段在线视频添加实时滤镜。在 JS 层我们的主要任务是截取视频中的每一帧画面，同时把该帧画面转换成对应的像素矩阵，然后调用 Wasm 模块对这些像素矩阵进行滤镜处理，最后再将处理后的像素矩阵绘制到页面上。对视频进行实时帧像素处理的部分我们会放到 WebAssembly 模块中来实现。\n\n这个项目的源代码可以在**[这里](https://github.com/Becavalier/WasmPlay/tree/master/SimpleDIP)**找到。\n\n先来看一下效果对比图。下面给出的两张图中，第一张为视频经过滤镜处理前的截图效果。第二张为视频经过滤镜处理后的截图效果。本次实验中我们将使用一个卷积核对视频每一帧画面中的像素进行卷积操作，这里使用的卷积核是一个三乘三矩阵`[[-1, -1, 1], [-1, 14, -1], [1, -1, -1]]`。卷积核是在对图像进行卷积运算时的参数矩阵，常用的卷积核有低通滤波器（模糊效果）、高斯滤波器（基于正态分布）和用于边沿检测的滤波器等。\n\n![](1.png)\n\n![](2.png)\n\n\n为了便于更加深入地了解 Web 应用与 WebAssembly 模块的详细交互过程，我们将整个应用的架构图绘制如下：首先我们在页面上放置一个 `canvas` 标签和一个 `video` 标签。画布和视频画面的同步都是通过中间的 JS 逻辑层来控制的。JS 首先会读取视频标签返回的每一帧数据，然后将每一帧画面的像素数据传递给 Wasm 进行处理，接下来再将处理好的帧画面数据渲染到画布上，这样应用的整个生命周期就构建完成了。\n\n![](3.png)\n\n#### 1、画布视频同步：\n\n首先，我们要实现的是将 `video` 标签的画面实时地显示在画布上。这部分的代码如下所示：\n\n \n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>SimpleDIP</title>\n    <style>\n        #video {\n            display: none;\n        }\n    </style>\n</head>\n<body>\n\t<canvas id=\"canvas\">\n\t<video id=\"video\" loop=\"true\" autoplay=\"\" src=\"media/scenery.mp4\" type=\"video/mp4\">\n</body>\n<script>\n  var video = document.getElementById(\"video\");\n  var canvas = document.getElementById(\"canvas\");\n  // 获得画布的绘制上下文；\n  var context = canvas.getContext(\"2d\");\n  // 当视频的第一帧完全载入时触发回调；\n  video.addEventListener(\"loadeddata\", function() {\n    // 设置画布的大小；\n    canvas.setAttribute(\"height\", video.videoHeight);\n    canvas.setAttribute(\"width\", video.videoWidth);\n    // 获得画布的舞台（可绘制区域）大小；\n    clientx = canvas.clientWidth;\n    clienty = canvas.clientHeight;\n    // 开始绘制；\n    draw();\n  });\n\n  function draw() {\n    // 从画布的左上角开始绘制当前视频的第一帧；\n    context.drawImage(video, 0, 0);\n    // 获得当前帧画面的 ImageData 对象；\n    pixels = context.getImageData(0, 0, video.videoWidth, video.videoHeight);\n\n    // 调用 Wasm 模块处理该帧像素；\n    // ... \n\n    // 将之前获得 ImageData 对象绘制到画布上；\n    context.putImageData(pixels, 0, 0);\n    // 逐帧绘制（通常60帧每秒）；\n    requestAnimationFrame(draw);\n  }\n</script>\n</html>\n```\n\n这部分代码很简单，这里首先根据视频大小来初始化对应大小的画布，接下来通过画布提供的 `drawImage` 方法来将当前的视频播放帧绘制到画布上，然后再从绘制好的画布上提取像素矩阵。\n\n#### 2、WebAssembly 模块代码：\n\n接下来我们要完成的是 WebAssembly 模块的 C/C++ 代码部分，这部分代码如下所示。算法的具体流程来自 Github 的开源项目。我们需要注意的是要为导出的方法添加 Emscripten 编译器后端对应的宏以保证该方法不会被编译器清除（DCE）。\n\n```c\n// program.cpp\n\n#include <emscripten/emscripten.h>\n#include <math.h>\n\nextern \"C\" {\n  void EMSCRIPTEN_KEEPALIVE convFilter (float* data, int width, int height, float* kern, int kWidth, int kHeight, float divisor, float bias, int count) {\n    float r, g, b;\n    int yy, xx, imageOffset, kernelOffset, pix; \n    int kCenterY = floor(kHeight / 2);\n    int kCenterX = floor(kWidth / 2);\n    for (int i = 0; i < count; ++i) {\n      for (int y = kCenterY; y < height - kCenterY; ++y) {\n        for (int x = kCenterX; x < width - kCenterX; ++x) {\n          r = 0;\n          g = 0;\n          b = 0;\n          for (int ky = 0; ky < kHeight; ++ky) {\n            for (int kx = 0; kx < kWidth; ++kx) {\n              imageOffset = (width * (y - kCenterY + ky) + (x - kCenterX + kx)) * 4;\n              kernelOffset = kWidth * ky + kx;\n              // 对当前像素点进行卷积操作；\n              r += data[imageOffset + 0] * kern[kernelOffset];\n              g += data[imageOffset + 1] * kern[kernelOffset];\n              b += data[imageOffset + 2] * kern[kernelOffset];\n            }\n          }\n          pix = (width * y + x) * 4;\n          data[pix + 0] =  ((r / divisor)>255.0) ? 255.0 : ((r / divisor)<0.0) ? 0.0 : r / divisor;\n          data[pix + 1] =  ((g / divisor)>255.0) ? 255.0 : ((g / divisor)<0.0) ? 0.0 : g / divisor;\n          data[pix + 2] =  ((b / divisor)>255.0) ? 255.0 : ((b / divisor)<0.0) ? 0.0 : b / divisor;\n        }\n      }\n    }\n  }\n}\n```\n\n代码写好后，我们可以使用 Emscripten 的编译器前端工具 emcc 来编译 C++ 源码到对应的 Wast 二进制格式。命令如下所示：\n\n \n```bash\nemcc -s WASM=1 -s ALLOW_MEMORY_GROWTH=1 -O3 -o program.js program.cpp\n```\n\n上述编译命令的使用方法与我们之前报告中的用法基本相同，其中新加入的 LOW_MEMORY_GROWTH 参数允许 Wasm 模块在使用时根据应用程序的使用情况自动扩大自身的可用内存。由于我们很难估计模块在处理帧数据时会消耗多少内存，因此无法在程序初始化时为模块创建固定大小的内存对象。在这里我们将内存大小管理完全交由应用自己进行控制。\n\n#### 3、Emscripten Glue 连接应用：\n\n接下来最后一步我们需要将 Wasm 模块和 JS 的逻辑层进行连接。在“连接”的过程中我们需要使用 Emscripten 为我们生成的的前端“胶水”工具。这部分 JS 逻辑层的代码我们单独放到一个文件中。代码如下所示：\n\n \n```javascript\n// dip.js\n\nvar Module = {};\n\nfunction loadWASM() {\n  return new Promise((resolve, reject) => {\n    fetch(\"./program.wasm\")\n      .then(response => response.arrayBuffer())\n      .then(buffer => {\n        // 初始化 Wasm 模块；\n        Module.wasmBinary = buffer;\n        \n        // 加载 Emscripten \"胶水\"模块；\n        var script = document.createElement(\"script\");\n        script.src = \"./program.js\";\n        document.body.appendChild(script);\n        \n        // 加载完成后初始化像素过滤方法；\n        window.onload = function() {\n          var filter = function(pixelData, width, height) {\n            // 设置卷积核；\n            var kernel = [[-1, -1, 1], [-1, 14, -1], [1, -1, -1]];\n            var divisor = 3;\n            const arLen = pixelData.length;\n            // \n            const memData = _malloc(arLen * Float32Array.BYTES_PER_ELEMENT);\n\n            // var memory = new Float32Array(Module.wasmMemory.buffer);\n            // memory.set(pixelData, memData / Float32Array.BYTES_PER_ELEMENT);\n            HEAPF32.set(pixelData, memData / Float32Array.BYTES_PER_ELEMENT);\n            const kerWidth = kernel[0].length;\n            const kerHeight = kernel.length;\n            const kerLen = kerWidth * kerHeight;\n            const flatKernel = kernel.reduce((acc, cur) => acc.concat(cur));\n            const memKernel = _malloc(kerLen * Float32Array.BYTES_PER_ELEMENT);\n            HEAPF32.set(flatKernel, memKernel / Float32Array.BYTES_PER_ELEMENT);\n            // 处理像素矩阵；\n            _convFilter(memData, width, height, memKernel, 3, 3, divisor, 0, 1);\n            const filtered = HEAPF32.subarray(memData / Float32Array.BYTES_PER_ELEMENT, memData / Float32Array.BYTES_PER_ELEMENT + arLen);\n            // 释放内存；\n            _free(memData);\n            _free(memKernel);\n            return filtered;\n          }\n          resolve(filter);\n        }\n      });\n  });\n}\n```\n\n在上述代码中，我们需要手动为像素矩阵分配内存。这里的 `_malloc` 和 `_free` 等方法都是由 Emscripten 工具链为我们提供的以用来在前端分配和释放内存的方法。代码中的 HEAPF32 是一个包含了 WebAssembly.Memoory 对象的 TypedArray 类型，我们可以直接使用它的 `set` 方法来将数据以“32位浮点”的类型写入到内存中。这里要注意线性内存地址是以1字节为单位的，1字节等于 4bytes，我们使用的 Float32Array 类型是以 32bytes 为单位，因此对应8字节偏移需要将新分配的内存地址除以8。如果不想使用 HEAPF32 来操作内存，我们也可以自己通过 TypedArray 进行封装，具体可以查看代码注释的两行。最后将上述 JS 文件起名为 ”dip.js“ 并插入到之前的超文本页面中，这里我们还需要在超文本页面中的脚本加入初始化 Wasm 模块和调用对应方法的逻辑，修改后的超文本页面代码如下所示：\n\n \n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>SimpleDIP</title>\n    <style>\n        #video {\n            display: none;\n        }\n    </style>\n</head>\n<body>\n\t<canvas id=\"canvas\">\n\t<video id=\"video\" loop=\"true\" autoplay=\"\" src=\"media/scenery.mp4\" type=\"video/mp4\">\n</body>\n<script src = \"./dip.js\" type = \"text/javascript\"></script>\n<script>\n  loadWASM().then(filter => {\n    var video = document.getElementById(\"video\");\n    var canvas = document.getElementById(\"canvas\");\n    // 获得画布的绘制上下文；\n    var context = canvas.getContext(\"2d\");\n    // 当视频的第一帧完全载入时触发回调；\n    video.addEventListener(\"loadeddata\", function() {\n      // 设置画布的大小；\n      canvas.setAttribute(\"height\", video.videoHeight);\n      canvas.setAttribute(\"width\", video.videoWidth);\n      // 获得画布的舞台（可绘制区域）大小；\n      clientx = canvas.clientWidth;\n      clienty = canvas.clientHeight;\n      // 开始绘制；\n      draw();\n    });\n\n    function draw() {\n      // 从画布的左上角开始绘制当前视频的第一帧；\n      context.drawImage(video, 0, 0);\n      // 获得当前帧画面的 ImageData 对象；\n      pixels = context.getImageData(0, 0, video.videoWidth, video.videoHeight);\n      pixels.data.set(filter(pixels.data, clientx, clienty));\n      // 将之前获得 ImageData 对象绘制到画布上；\n      context.putImageData(pixels, 0, 0);\n      // 逐帧绘制（通常60帧每秒）；\n      requestAnimationFrame(draw);\n    }\n  });\n</script>\n</html>\n```\n\n至此，这个简单的 DIP 应用便完成了。\n","source":"_posts/WebAssembly-尝试研究报告-DIP-实践.md","raw":"---\ntitle: WebAssembly 尝试研究报告 - DIP 实践\nintro: 从本次报告开始，我们将花一点时间从零开始构建一个基于 WebAssembly 的 DIP（数字图像处理）应用。该应用的主要功能是可以给一段在线视频添加实时滤镜。在 JS 层我们的主要任务是截取视频中的每一帧画面，同时把该帧画面转换成对应的像素矩阵，然后调用 Wasm 模块对这些像素矩阵进行滤镜处理，最后再将处理后的像素矩阵绘制到页面上。对视频进行实时帧像素处理的部分我们会放到 WebAssembly 模块中来实现。\ncomments: true\ndate: 2017-06-16 14:13:41\ntags:\n- WebAssembly\n---\n\n从本次报告开始，我们将花一点时间从零开始构建一个基于 WebAssembly 的 DIP（数字图像处理）应用。该应用的主要功能是可以给一段在线视频添加实时滤镜。在 JS 层我们的主要任务是截取视频中的每一帧画面，同时把该帧画面转换成对应的像素矩阵，然后调用 Wasm 模块对这些像素矩阵进行滤镜处理，最后再将处理后的像素矩阵绘制到页面上。对视频进行实时帧像素处理的部分我们会放到 WebAssembly 模块中来实现。\n\n这个项目的源代码可以在**[这里](https://github.com/Becavalier/WasmPlay/tree/master/SimpleDIP)**找到。\n\n先来看一下效果对比图。下面给出的两张图中，第一张为视频经过滤镜处理前的截图效果。第二张为视频经过滤镜处理后的截图效果。本次实验中我们将使用一个卷积核对视频每一帧画面中的像素进行卷积操作，这里使用的卷积核是一个三乘三矩阵`[[-1, -1, 1], [-1, 14, -1], [1, -1, -1]]`。卷积核是在对图像进行卷积运算时的参数矩阵，常用的卷积核有低通滤波器（模糊效果）、高斯滤波器（基于正态分布）和用于边沿检测的滤波器等。\n\n![](1.png)\n\n![](2.png)\n\n\n为了便于更加深入地了解 Web 应用与 WebAssembly 模块的详细交互过程，我们将整个应用的架构图绘制如下：首先我们在页面上放置一个 `canvas` 标签和一个 `video` 标签。画布和视频画面的同步都是通过中间的 JS 逻辑层来控制的。JS 首先会读取视频标签返回的每一帧数据，然后将每一帧画面的像素数据传递给 Wasm 进行处理，接下来再将处理好的帧画面数据渲染到画布上，这样应用的整个生命周期就构建完成了。\n\n![](3.png)\n\n#### 1、画布视频同步：\n\n首先，我们要实现的是将 `video` 标签的画面实时地显示在画布上。这部分的代码如下所示：\n\n \n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>SimpleDIP</title>\n    <style>\n        #video {\n            display: none;\n        }\n    </style>\n</head>\n<body>\n\t<canvas id=\"canvas\">\n\t<video id=\"video\" loop=\"true\" autoplay=\"\" src=\"media/scenery.mp4\" type=\"video/mp4\">\n</body>\n<script>\n  var video = document.getElementById(\"video\");\n  var canvas = document.getElementById(\"canvas\");\n  // 获得画布的绘制上下文；\n  var context = canvas.getContext(\"2d\");\n  // 当视频的第一帧完全载入时触发回调；\n  video.addEventListener(\"loadeddata\", function() {\n    // 设置画布的大小；\n    canvas.setAttribute(\"height\", video.videoHeight);\n    canvas.setAttribute(\"width\", video.videoWidth);\n    // 获得画布的舞台（可绘制区域）大小；\n    clientx = canvas.clientWidth;\n    clienty = canvas.clientHeight;\n    // 开始绘制；\n    draw();\n  });\n\n  function draw() {\n    // 从画布的左上角开始绘制当前视频的第一帧；\n    context.drawImage(video, 0, 0);\n    // 获得当前帧画面的 ImageData 对象；\n    pixels = context.getImageData(0, 0, video.videoWidth, video.videoHeight);\n\n    // 调用 Wasm 模块处理该帧像素；\n    // ... \n\n    // 将之前获得 ImageData 对象绘制到画布上；\n    context.putImageData(pixels, 0, 0);\n    // 逐帧绘制（通常60帧每秒）；\n    requestAnimationFrame(draw);\n  }\n</script>\n</html>\n```\n\n这部分代码很简单，这里首先根据视频大小来初始化对应大小的画布，接下来通过画布提供的 `drawImage` 方法来将当前的视频播放帧绘制到画布上，然后再从绘制好的画布上提取像素矩阵。\n\n#### 2、WebAssembly 模块代码：\n\n接下来我们要完成的是 WebAssembly 模块的 C/C++ 代码部分，这部分代码如下所示。算法的具体流程来自 Github 的开源项目。我们需要注意的是要为导出的方法添加 Emscripten 编译器后端对应的宏以保证该方法不会被编译器清除（DCE）。\n\n```c\n// program.cpp\n\n#include <emscripten/emscripten.h>\n#include <math.h>\n\nextern \"C\" {\n  void EMSCRIPTEN_KEEPALIVE convFilter (float* data, int width, int height, float* kern, int kWidth, int kHeight, float divisor, float bias, int count) {\n    float r, g, b;\n    int yy, xx, imageOffset, kernelOffset, pix; \n    int kCenterY = floor(kHeight / 2);\n    int kCenterX = floor(kWidth / 2);\n    for (int i = 0; i < count; ++i) {\n      for (int y = kCenterY; y < height - kCenterY; ++y) {\n        for (int x = kCenterX; x < width - kCenterX; ++x) {\n          r = 0;\n          g = 0;\n          b = 0;\n          for (int ky = 0; ky < kHeight; ++ky) {\n            for (int kx = 0; kx < kWidth; ++kx) {\n              imageOffset = (width * (y - kCenterY + ky) + (x - kCenterX + kx)) * 4;\n              kernelOffset = kWidth * ky + kx;\n              // 对当前像素点进行卷积操作；\n              r += data[imageOffset + 0] * kern[kernelOffset];\n              g += data[imageOffset + 1] * kern[kernelOffset];\n              b += data[imageOffset + 2] * kern[kernelOffset];\n            }\n          }\n          pix = (width * y + x) * 4;\n          data[pix + 0] =  ((r / divisor)>255.0) ? 255.0 : ((r / divisor)<0.0) ? 0.0 : r / divisor;\n          data[pix + 1] =  ((g / divisor)>255.0) ? 255.0 : ((g / divisor)<0.0) ? 0.0 : g / divisor;\n          data[pix + 2] =  ((b / divisor)>255.0) ? 255.0 : ((b / divisor)<0.0) ? 0.0 : b / divisor;\n        }\n      }\n    }\n  }\n}\n```\n\n代码写好后，我们可以使用 Emscripten 的编译器前端工具 emcc 来编译 C++ 源码到对应的 Wast 二进制格式。命令如下所示：\n\n \n```bash\nemcc -s WASM=1 -s ALLOW_MEMORY_GROWTH=1 -O3 -o program.js program.cpp\n```\n\n上述编译命令的使用方法与我们之前报告中的用法基本相同，其中新加入的 LOW_MEMORY_GROWTH 参数允许 Wasm 模块在使用时根据应用程序的使用情况自动扩大自身的可用内存。由于我们很难估计模块在处理帧数据时会消耗多少内存，因此无法在程序初始化时为模块创建固定大小的内存对象。在这里我们将内存大小管理完全交由应用自己进行控制。\n\n#### 3、Emscripten Glue 连接应用：\n\n接下来最后一步我们需要将 Wasm 模块和 JS 的逻辑层进行连接。在“连接”的过程中我们需要使用 Emscripten 为我们生成的的前端“胶水”工具。这部分 JS 逻辑层的代码我们单独放到一个文件中。代码如下所示：\n\n \n```javascript\n// dip.js\n\nvar Module = {};\n\nfunction loadWASM() {\n  return new Promise((resolve, reject) => {\n    fetch(\"./program.wasm\")\n      .then(response => response.arrayBuffer())\n      .then(buffer => {\n        // 初始化 Wasm 模块；\n        Module.wasmBinary = buffer;\n        \n        // 加载 Emscripten \"胶水\"模块；\n        var script = document.createElement(\"script\");\n        script.src = \"./program.js\";\n        document.body.appendChild(script);\n        \n        // 加载完成后初始化像素过滤方法；\n        window.onload = function() {\n          var filter = function(pixelData, width, height) {\n            // 设置卷积核；\n            var kernel = [[-1, -1, 1], [-1, 14, -1], [1, -1, -1]];\n            var divisor = 3;\n            const arLen = pixelData.length;\n            // \n            const memData = _malloc(arLen * Float32Array.BYTES_PER_ELEMENT);\n\n            // var memory = new Float32Array(Module.wasmMemory.buffer);\n            // memory.set(pixelData, memData / Float32Array.BYTES_PER_ELEMENT);\n            HEAPF32.set(pixelData, memData / Float32Array.BYTES_PER_ELEMENT);\n            const kerWidth = kernel[0].length;\n            const kerHeight = kernel.length;\n            const kerLen = kerWidth * kerHeight;\n            const flatKernel = kernel.reduce((acc, cur) => acc.concat(cur));\n            const memKernel = _malloc(kerLen * Float32Array.BYTES_PER_ELEMENT);\n            HEAPF32.set(flatKernel, memKernel / Float32Array.BYTES_PER_ELEMENT);\n            // 处理像素矩阵；\n            _convFilter(memData, width, height, memKernel, 3, 3, divisor, 0, 1);\n            const filtered = HEAPF32.subarray(memData / Float32Array.BYTES_PER_ELEMENT, memData / Float32Array.BYTES_PER_ELEMENT + arLen);\n            // 释放内存；\n            _free(memData);\n            _free(memKernel);\n            return filtered;\n          }\n          resolve(filter);\n        }\n      });\n  });\n}\n```\n\n在上述代码中，我们需要手动为像素矩阵分配内存。这里的 `_malloc` 和 `_free` 等方法都是由 Emscripten 工具链为我们提供的以用来在前端分配和释放内存的方法。代码中的 HEAPF32 是一个包含了 WebAssembly.Memoory 对象的 TypedArray 类型，我们可以直接使用它的 `set` 方法来将数据以“32位浮点”的类型写入到内存中。这里要注意线性内存地址是以1字节为单位的，1字节等于 4bytes，我们使用的 Float32Array 类型是以 32bytes 为单位，因此对应8字节偏移需要将新分配的内存地址除以8。如果不想使用 HEAPF32 来操作内存，我们也可以自己通过 TypedArray 进行封装，具体可以查看代码注释的两行。最后将上述 JS 文件起名为 ”dip.js“ 并插入到之前的超文本页面中，这里我们还需要在超文本页面中的脚本加入初始化 Wasm 模块和调用对应方法的逻辑，修改后的超文本页面代码如下所示：\n\n \n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>SimpleDIP</title>\n    <style>\n        #video {\n            display: none;\n        }\n    </style>\n</head>\n<body>\n\t<canvas id=\"canvas\">\n\t<video id=\"video\" loop=\"true\" autoplay=\"\" src=\"media/scenery.mp4\" type=\"video/mp4\">\n</body>\n<script src = \"./dip.js\" type = \"text/javascript\"></script>\n<script>\n  loadWASM().then(filter => {\n    var video = document.getElementById(\"video\");\n    var canvas = document.getElementById(\"canvas\");\n    // 获得画布的绘制上下文；\n    var context = canvas.getContext(\"2d\");\n    // 当视频的第一帧完全载入时触发回调；\n    video.addEventListener(\"loadeddata\", function() {\n      // 设置画布的大小；\n      canvas.setAttribute(\"height\", video.videoHeight);\n      canvas.setAttribute(\"width\", video.videoWidth);\n      // 获得画布的舞台（可绘制区域）大小；\n      clientx = canvas.clientWidth;\n      clienty = canvas.clientHeight;\n      // 开始绘制；\n      draw();\n    });\n\n    function draw() {\n      // 从画布的左上角开始绘制当前视频的第一帧；\n      context.drawImage(video, 0, 0);\n      // 获得当前帧画面的 ImageData 对象；\n      pixels = context.getImageData(0, 0, video.videoWidth, video.videoHeight);\n      pixels.data.set(filter(pixels.data, clientx, clienty));\n      // 将之前获得 ImageData 对象绘制到画布上；\n      context.putImageData(pixels, 0, 0);\n      // 逐帧绘制（通常60帧每秒）；\n      requestAnimationFrame(draw);\n    }\n  });\n</script>\n</html>\n```\n\n至此，这个简单的 DIP 应用便完成了。\n","slug":"WebAssembly-尝试研究报告-DIP-实践","published":1,"updated":"2019-02-19T09:07:14.728Z","layout":"post","photos":[],"link":"","_id":"cjsqwht9z003tknp2v5zz2mg9","content":"<p>从本次报告开始，我们将花一点时间从零开始构建一个基于 WebAssembly 的 DIP（数字图像处理）应用。该应用的主要功能是可以给一段在线视频添加实时滤镜。在 JS 层我们的主要任务是截取视频中的每一帧画面，同时把该帧画面转换成对应的像素矩阵，然后调用 Wasm 模块对这些像素矩阵进行滤镜处理，最后再将处理后的像素矩阵绘制到页面上。对视频进行实时帧像素处理的部分我们会放到 WebAssembly 模块中来实现。</p>\n<p>这个项目的源代码可以在<strong><a href=\"https://github.com/Becavalier/WasmPlay/tree/master/SimpleDIP\" target=\"_blank\" rel=\"noopener\">这里</a></strong>找到。</p>\n<p>先来看一下效果对比图。下面给出的两张图中，第一张为视频经过滤镜处理前的截图效果。第二张为视频经过滤镜处理后的截图效果。本次实验中我们将使用一个卷积核对视频每一帧画面中的像素进行卷积操作，这里使用的卷积核是一个三乘三矩阵<code>[[-1, -1, 1], [-1, 14, -1], [1, -1, -1]]</code>。卷积核是在对图像进行卷积运算时的参数矩阵，常用的卷积核有低通滤波器（模糊效果）、高斯滤波器（基于正态分布）和用于边沿检测的滤波器等。</p>\n<p><img src=\"1.png\" alt></p>\n<p><img src=\"2.png\" alt></p>\n<p>为了便于更加深入地了解 Web 应用与 WebAssembly 模块的详细交互过程，我们将整个应用的架构图绘制如下：首先我们在页面上放置一个 <code>canvas</code> 标签和一个 <code>video</code> 标签。画布和视频画面的同步都是通过中间的 JS 逻辑层来控制的。JS 首先会读取视频标签返回的每一帧数据，然后将每一帧画面的像素数据传递给 Wasm 进行处理，接下来再将处理好的帧画面数据渲染到画布上，这样应用的整个生命周期就构建完成了。</p>\n<p><img src=\"3.png\" alt></p>\n<h4 id=\"1、画布视频同步：\"><a href=\"#1、画布视频同步：\" class=\"headerlink\" title=\"1、画布视频同步：\"></a>1、画布视频同步：</h4><p>首先，我们要实现的是将 <code>video</code> 标签的画面实时地显示在画布上。这部分的代码如下所示：</p>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token doctype\">&lt;!DOCTYPE html></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>html</span> <span class=\"token attr-name\">lang</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>en<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>head</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>meta</span> <span class=\"token attr-name\">charset</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>UTF-8<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>title</span><span class=\"token punctuation\">></span></span>SimpleDIP<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>title</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>style</span><span class=\"token punctuation\">></span></span><span class=\"token style language-css\">\n        <span class=\"token selector\"><span class=\"token id\">#video</span> </span><span class=\"token punctuation\">{</span>\n            <span class=\"token property\">display</span><span class=\"token punctuation\">:</span> none<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>style</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>head</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>body</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>canvas</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>canvas<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>video</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>video<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">loop</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>true<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">autoplay</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span><span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>media/scenery.mp4<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>video/mp4<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>body</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span><span class=\"token punctuation\">></span></span><span class=\"token script language-javascript\">\n  <span class=\"token keyword\">var</span> video <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"video\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> canvas <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"canvas\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 获得画布的绘制上下文；</span>\n  <span class=\"token keyword\">var</span> context <span class=\"token operator\">=</span> canvas<span class=\"token punctuation\">.</span><span class=\"token function\">getContext</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"2d\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 当视频的第一帧完全载入时触发回调；</span>\n  video<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"loadeddata\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 设置画布的大小；</span>\n    canvas<span class=\"token punctuation\">.</span><span class=\"token function\">setAttribute</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"height\"</span><span class=\"token punctuation\">,</span> video<span class=\"token punctuation\">.</span>videoHeight<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    canvas<span class=\"token punctuation\">.</span><span class=\"token function\">setAttribute</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"width\"</span><span class=\"token punctuation\">,</span> video<span class=\"token punctuation\">.</span>videoWidth<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 获得画布的舞台（可绘制区域）大小；</span>\n    clientx <span class=\"token operator\">=</span> canvas<span class=\"token punctuation\">.</span>clientWidth<span class=\"token punctuation\">;</span>\n    clienty <span class=\"token operator\">=</span> canvas<span class=\"token punctuation\">.</span>clientHeight<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 开始绘制；</span>\n    <span class=\"token function\">draw</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">function</span> <span class=\"token function\">draw</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 从画布的左上角开始绘制当前视频的第一帧；</span>\n    context<span class=\"token punctuation\">.</span><span class=\"token function\">drawImage</span><span class=\"token punctuation\">(</span>video<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 获得当前帧画面的 ImageData 对象；</span>\n    pixels <span class=\"token operator\">=</span> context<span class=\"token punctuation\">.</span><span class=\"token function\">getImageData</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> video<span class=\"token punctuation\">.</span>videoWidth<span class=\"token punctuation\">,</span> video<span class=\"token punctuation\">.</span>videoHeight<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 调用 Wasm 模块处理该帧像素；</span>\n    <span class=\"token comment\" spellcheck=\"true\">// ... </span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 将之前获得 ImageData 对象绘制到画布上；</span>\n    context<span class=\"token punctuation\">.</span><span class=\"token function\">putImageData</span><span class=\"token punctuation\">(</span>pixels<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 逐帧绘制（通常60帧每秒）；</span>\n    <span class=\"token function\">requestAnimationFrame</span><span class=\"token punctuation\">(</span>draw<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>html</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这部分代码很简单，这里首先根据视频大小来初始化对应大小的画布，接下来通过画布提供的 <code>drawImage</code> 方法来将当前的视频播放帧绘制到画布上，然后再从绘制好的画布上提取像素矩阵。</p>\n<h4 id=\"2、WebAssembly-模块代码：\"><a href=\"#2、WebAssembly-模块代码：\" class=\"headerlink\" title=\"2、WebAssembly 模块代码：\"></a>2、WebAssembly 模块代码：</h4><p>接下来我们要完成的是 WebAssembly 模块的 C/C++ 代码部分，这部分代码如下所示。算法的具体流程来自 Github 的开源项目。我们需要注意的是要为导出的方法添加 Emscripten 编译器后端对应的宏以保证该方法不会被编译器清除（DCE）。</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token comment\" spellcheck=\"true\">// program.cpp</span>\n\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;emscripten/emscripten.h></span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;math.h></span></span>\n\n<span class=\"token keyword\">extern</span> <span class=\"token string\">\"C\"</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">void</span> EMSCRIPTEN_KEEPALIVE <span class=\"token function\">convFilter</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span><span class=\"token operator\">*</span> data<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> width<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> height<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span><span class=\"token operator\">*</span> kern<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> kWidth<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> kHeight<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> divisor<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> bias<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> count<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">float</span> r<span class=\"token punctuation\">,</span> g<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> yy<span class=\"token punctuation\">,</span> xx<span class=\"token punctuation\">,</span> imageOffset<span class=\"token punctuation\">,</span> kernelOffset<span class=\"token punctuation\">,</span> pix<span class=\"token punctuation\">;</span> \n    <span class=\"token keyword\">int</span> kCenterY <span class=\"token operator\">=</span> <span class=\"token function\">floor</span><span class=\"token punctuation\">(</span>kHeight <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> kCenterX <span class=\"token operator\">=</span> <span class=\"token function\">floor</span><span class=\"token punctuation\">(</span>kWidth <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> count<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> y <span class=\"token operator\">=</span> kCenterY<span class=\"token punctuation\">;</span> y <span class=\"token operator\">&lt;</span> height <span class=\"token operator\">-</span> kCenterY<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>y<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x <span class=\"token operator\">=</span> kCenterX<span class=\"token punctuation\">;</span> x <span class=\"token operator\">&lt;</span> width <span class=\"token operator\">-</span> kCenterX<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          r <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n          g <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n          b <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> ky <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> ky <span class=\"token operator\">&lt;</span> kHeight<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>ky<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> kx <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> kx <span class=\"token operator\">&lt;</span> kWidth<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>kx<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n              imageOffset <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>width <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>y <span class=\"token operator\">-</span> kCenterY <span class=\"token operator\">+</span> ky<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>x <span class=\"token operator\">-</span> kCenterX <span class=\"token operator\">+</span> kx<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span>\n              kernelOffset <span class=\"token operator\">=</span> kWidth <span class=\"token operator\">*</span> ky <span class=\"token operator\">+</span> kx<span class=\"token punctuation\">;</span>\n              <span class=\"token comment\" spellcheck=\"true\">// 对当前像素点进行卷积操作；</span>\n              r <span class=\"token operator\">+</span><span class=\"token operator\">=</span> data<span class=\"token punctuation\">[</span>imageOffset <span class=\"token operator\">+</span> <span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> kern<span class=\"token punctuation\">[</span>kernelOffset<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n              g <span class=\"token operator\">+</span><span class=\"token operator\">=</span> data<span class=\"token punctuation\">[</span>imageOffset <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> kern<span class=\"token punctuation\">[</span>kernelOffset<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n              b <span class=\"token operator\">+</span><span class=\"token operator\">=</span> data<span class=\"token punctuation\">[</span>imageOffset <span class=\"token operator\">+</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> kern<span class=\"token punctuation\">[</span>kernelOffset<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n          <span class=\"token punctuation\">}</span>\n          pix <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>width <span class=\"token operator\">*</span> y <span class=\"token operator\">+</span> x<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span>\n          data<span class=\"token punctuation\">[</span>pix <span class=\"token operator\">+</span> <span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span>  <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>r <span class=\"token operator\">/</span> divisor<span class=\"token punctuation\">)</span><span class=\"token operator\">></span><span class=\"token number\">255.0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token number\">255.0</span> <span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>r <span class=\"token operator\">/</span> divisor<span class=\"token punctuation\">)</span><span class=\"token operator\">&lt;</span><span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token number\">0.0</span> <span class=\"token punctuation\">:</span> r <span class=\"token operator\">/</span> divisor<span class=\"token punctuation\">;</span>\n          data<span class=\"token punctuation\">[</span>pix <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span>  <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>g <span class=\"token operator\">/</span> divisor<span class=\"token punctuation\">)</span><span class=\"token operator\">></span><span class=\"token number\">255.0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token number\">255.0</span> <span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>g <span class=\"token operator\">/</span> divisor<span class=\"token punctuation\">)</span><span class=\"token operator\">&lt;</span><span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token number\">0.0</span> <span class=\"token punctuation\">:</span> g <span class=\"token operator\">/</span> divisor<span class=\"token punctuation\">;</span>\n          data<span class=\"token punctuation\">[</span>pix <span class=\"token operator\">+</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span>  <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>b <span class=\"token operator\">/</span> divisor<span class=\"token punctuation\">)</span><span class=\"token operator\">></span><span class=\"token number\">255.0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token number\">255.0</span> <span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>b <span class=\"token operator\">/</span> divisor<span class=\"token punctuation\">)</span><span class=\"token operator\">&lt;</span><span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token number\">0.0</span> <span class=\"token punctuation\">:</span> b <span class=\"token operator\">/</span> divisor<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>代码写好后，我们可以使用 Emscripten 的编译器前端工具 emcc 来编译 C++ 源码到对应的 Wast 二进制格式。命令如下所示：</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\">emcc -s WASM<span class=\"token operator\">=</span>1 -s ALLOW_MEMORY_GROWTH<span class=\"token operator\">=</span>1 -O3 -o program.js program.cpp\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>上述编译命令的使用方法与我们之前报告中的用法基本相同，其中新加入的 LOW_MEMORY_GROWTH 参数允许 Wasm 模块在使用时根据应用程序的使用情况自动扩大自身的可用内存。由于我们很难估计模块在处理帧数据时会消耗多少内存，因此无法在程序初始化时为模块创建固定大小的内存对象。在这里我们将内存大小管理完全交由应用自己进行控制。</p>\n<h4 id=\"3、Emscripten-Glue-连接应用：\"><a href=\"#3、Emscripten-Glue-连接应用：\" class=\"headerlink\" title=\"3、Emscripten Glue 连接应用：\"></a>3、Emscripten Glue 连接应用：</h4><p>接下来最后一步我们需要将 Wasm 模块和 JS 的逻辑层进行连接。在“连接”的过程中我们需要使用 Emscripten 为我们生成的的前端“胶水”工具。这部分 JS 逻辑层的代码我们单独放到一个文件中。代码如下所示：</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">// dip.js</span>\n\n<span class=\"token keyword\">var</span> Module <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">loadWASM</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"./program.wasm\"</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>response <span class=\"token operator\">=</span><span class=\"token operator\">></span> response<span class=\"token punctuation\">.</span><span class=\"token function\">arrayBuffer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>buffer <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 初始化 Wasm 模块；</span>\n        Module<span class=\"token punctuation\">.</span>wasmBinary <span class=\"token operator\">=</span> buffer<span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 加载 Emscripten \"胶水\"模块；</span>\n        <span class=\"token keyword\">var</span> script <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"script\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        script<span class=\"token punctuation\">.</span>src <span class=\"token operator\">=</span> <span class=\"token string\">\"./program.js\"</span><span class=\"token punctuation\">;</span>\n        document<span class=\"token punctuation\">.</span>body<span class=\"token punctuation\">.</span><span class=\"token function\">appendChild</span><span class=\"token punctuation\">(</span>script<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 加载完成后初始化像素过滤方法；</span>\n        window<span class=\"token punctuation\">.</span>onload <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">var</span> filter <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>pixelData<span class=\"token punctuation\">,</span> width<span class=\"token punctuation\">,</span> height<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 设置卷积核；</span>\n            <span class=\"token keyword\">var</span> kernel <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">14</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">var</span> divisor <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">const</span> arLen <span class=\"token operator\">=</span> pixelData<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">// </span>\n            <span class=\"token keyword\">const</span> memData <span class=\"token operator\">=</span> <span class=\"token function\">_malloc</span><span class=\"token punctuation\">(</span>arLen <span class=\"token operator\">*</span> Float32Array<span class=\"token punctuation\">.</span>BYTES_PER_ELEMENT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">// var memory = new Float32Array(Module.wasmMemory.buffer);</span>\n            <span class=\"token comment\" spellcheck=\"true\">// memory.set(pixelData, memData / Float32Array.BYTES_PER_ELEMENT);</span>\n            HEAPF32<span class=\"token punctuation\">.</span><span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span>pixelData<span class=\"token punctuation\">,</span> memData <span class=\"token operator\">/</span> Float32Array<span class=\"token punctuation\">.</span>BYTES_PER_ELEMENT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">const</span> kerWidth <span class=\"token operator\">=</span> kernel<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">const</span> kerHeight <span class=\"token operator\">=</span> kernel<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">const</span> kerLen <span class=\"token operator\">=</span> kerWidth <span class=\"token operator\">*</span> kerHeight<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">const</span> flatKernel <span class=\"token operator\">=</span> kernel<span class=\"token punctuation\">.</span><span class=\"token function\">reduce</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>acc<span class=\"token punctuation\">,</span> cur<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> acc<span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span>cur<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">const</span> memKernel <span class=\"token operator\">=</span> <span class=\"token function\">_malloc</span><span class=\"token punctuation\">(</span>kerLen <span class=\"token operator\">*</span> Float32Array<span class=\"token punctuation\">.</span>BYTES_PER_ELEMENT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            HEAPF32<span class=\"token punctuation\">.</span><span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span>flatKernel<span class=\"token punctuation\">,</span> memKernel <span class=\"token operator\">/</span> Float32Array<span class=\"token punctuation\">.</span>BYTES_PER_ELEMENT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 处理像素矩阵；</span>\n            <span class=\"token function\">_convFilter</span><span class=\"token punctuation\">(</span>memData<span class=\"token punctuation\">,</span> width<span class=\"token punctuation\">,</span> height<span class=\"token punctuation\">,</span> memKernel<span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> divisor<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">const</span> filtered <span class=\"token operator\">=</span> HEAPF32<span class=\"token punctuation\">.</span><span class=\"token function\">subarray</span><span class=\"token punctuation\">(</span>memData <span class=\"token operator\">/</span> Float32Array<span class=\"token punctuation\">.</span>BYTES_PER_ELEMENT<span class=\"token punctuation\">,</span> memData <span class=\"token operator\">/</span> Float32Array<span class=\"token punctuation\">.</span>BYTES_PER_ELEMENT <span class=\"token operator\">+</span> arLen<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 释放内存；</span>\n            <span class=\"token function\">_free</span><span class=\"token punctuation\">(</span>memData<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">_free</span><span class=\"token punctuation\">(</span>memKernel<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> filtered<span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span>\n          <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>filter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>在上述代码中，我们需要手动为像素矩阵分配内存。这里的 <code>_malloc</code> 和 <code>_free</code> 等方法都是由 Emscripten 工具链为我们提供的以用来在前端分配和释放内存的方法。代码中的 HEAPF32 是一个包含了 WebAssembly.Memoory 对象的 TypedArray 类型，我们可以直接使用它的 <code>set</code> 方法来将数据以“32位浮点”的类型写入到内存中。这里要注意线性内存地址是以1字节为单位的，1字节等于 4bytes，我们使用的 Float32Array 类型是以 32bytes 为单位，因此对应8字节偏移需要将新分配的内存地址除以8。如果不想使用 HEAPF32 来操作内存，我们也可以自己通过 TypedArray 进行封装，具体可以查看代码注释的两行。最后将上述 JS 文件起名为 ”dip.js“ 并插入到之前的超文本页面中，这里我们还需要在超文本页面中的脚本加入初始化 Wasm 模块和调用对应方法的逻辑，修改后的超文本页面代码如下所示：</p>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token doctype\">&lt;!DOCTYPE html></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>html</span> <span class=\"token attr-name\">lang</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>en<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>head</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>meta</span> <span class=\"token attr-name\">charset</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>UTF-8<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>title</span><span class=\"token punctuation\">></span></span>SimpleDIP<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>title</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>style</span><span class=\"token punctuation\">></span></span><span class=\"token style language-css\">\n        <span class=\"token selector\"><span class=\"token id\">#video</span> </span><span class=\"token punctuation\">{</span>\n            <span class=\"token property\">display</span><span class=\"token punctuation\">:</span> none<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>style</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>head</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>body</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>canvas</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>canvas<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>video</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>video<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">loop</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>true<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">autoplay</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span><span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>media/scenery.mp4<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>video/mp4<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>body</span><span class=\"token punctuation\">></span></span>\n&lt;script src = \"./dip.js\" type = \"text/javascript\"><span class=\"token script language-javascript\"></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span><span class=\"token punctuation\">></span></span><span class=\"token script language-javascript\">\n  <span class=\"token function\">loadWASM</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>filter <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> video <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"video\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> canvas <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"canvas\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 获得画布的绘制上下文；</span>\n    <span class=\"token keyword\">var</span> context <span class=\"token operator\">=</span> canvas<span class=\"token punctuation\">.</span><span class=\"token function\">getContext</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"2d\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 当视频的第一帧完全载入时触发回调；</span>\n    video<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"loadeddata\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 设置画布的大小；</span>\n      canvas<span class=\"token punctuation\">.</span><span class=\"token function\">setAttribute</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"height\"</span><span class=\"token punctuation\">,</span> video<span class=\"token punctuation\">.</span>videoHeight<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      canvas<span class=\"token punctuation\">.</span><span class=\"token function\">setAttribute</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"width\"</span><span class=\"token punctuation\">,</span> video<span class=\"token punctuation\">.</span>videoWidth<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 获得画布的舞台（可绘制区域）大小；</span>\n      clientx <span class=\"token operator\">=</span> canvas<span class=\"token punctuation\">.</span>clientWidth<span class=\"token punctuation\">;</span>\n      clienty <span class=\"token operator\">=</span> canvas<span class=\"token punctuation\">.</span>clientHeight<span class=\"token punctuation\">;</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 开始绘制；</span>\n      <span class=\"token function\">draw</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">function</span> <span class=\"token function\">draw</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 从画布的左上角开始绘制当前视频的第一帧；</span>\n      context<span class=\"token punctuation\">.</span><span class=\"token function\">drawImage</span><span class=\"token punctuation\">(</span>video<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 获得当前帧画面的 ImageData 对象；</span>\n      pixels <span class=\"token operator\">=</span> context<span class=\"token punctuation\">.</span><span class=\"token function\">getImageData</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> video<span class=\"token punctuation\">.</span>videoWidth<span class=\"token punctuation\">,</span> video<span class=\"token punctuation\">.</span>videoHeight<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      pixels<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span><span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>pixels<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">,</span> clientx<span class=\"token punctuation\">,</span> clienty<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 将之前获得 ImageData 对象绘制到画布上；</span>\n      context<span class=\"token punctuation\">.</span><span class=\"token function\">putImageData</span><span class=\"token punctuation\">(</span>pixels<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 逐帧绘制（通常60帧每秒）；</span>\n      <span class=\"token function\">requestAnimationFrame</span><span class=\"token punctuation\">(</span>draw<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>html</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>至此，这个简单的 DIP 应用便完成了。</p>\n","site":{"data":{}},"id":"8a4e4f852480a43ae754a6c299466a78","excerpt":"","more":"<p>从本次报告开始，我们将花一点时间从零开始构建一个基于 WebAssembly 的 DIP（数字图像处理）应用。该应用的主要功能是可以给一段在线视频添加实时滤镜。在 JS 层我们的主要任务是截取视频中的每一帧画面，同时把该帧画面转换成对应的像素矩阵，然后调用 Wasm 模块对这些像素矩阵进行滤镜处理，最后再将处理后的像素矩阵绘制到页面上。对视频进行实时帧像素处理的部分我们会放到 WebAssembly 模块中来实现。</p>\n<p>这个项目的源代码可以在<strong><a href=\"https://github.com/Becavalier/WasmPlay/tree/master/SimpleDIP\" target=\"_blank\" rel=\"noopener\">这里</a></strong>找到。</p>\n<p>先来看一下效果对比图。下面给出的两张图中，第一张为视频经过滤镜处理前的截图效果。第二张为视频经过滤镜处理后的截图效果。本次实验中我们将使用一个卷积核对视频每一帧画面中的像素进行卷积操作，这里使用的卷积核是一个三乘三矩阵<code>[[-1, -1, 1], [-1, 14, -1], [1, -1, -1]]</code>。卷积核是在对图像进行卷积运算时的参数矩阵，常用的卷积核有低通滤波器（模糊效果）、高斯滤波器（基于正态分布）和用于边沿检测的滤波器等。</p>\n<p><img src=\"1.png\" alt></p>\n<p><img src=\"2.png\" alt></p>\n<p>为了便于更加深入地了解 Web 应用与 WebAssembly 模块的详细交互过程，我们将整个应用的架构图绘制如下：首先我们在页面上放置一个 <code>canvas</code> 标签和一个 <code>video</code> 标签。画布和视频画面的同步都是通过中间的 JS 逻辑层来控制的。JS 首先会读取视频标签返回的每一帧数据，然后将每一帧画面的像素数据传递给 Wasm 进行处理，接下来再将处理好的帧画面数据渲染到画布上，这样应用的整个生命周期就构建完成了。</p>\n<p><img src=\"3.png\" alt></p>\n<h4 id=\"1、画布视频同步：\"><a href=\"#1、画布视频同步：\" class=\"headerlink\" title=\"1、画布视频同步：\"></a>1、画布视频同步：</h4><p>首先，我们要实现的是将 <code>video</code> 标签的画面实时地显示在画布上。这部分的代码如下所示：</p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;SimpleDIP&lt;/title&gt;\n    &lt;style&gt;\n        #video {\n            display: none;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;canvas id=&quot;canvas&quot;&gt;\n    &lt;video id=&quot;video&quot; loop=&quot;true&quot; autoplay=&quot;&quot; src=&quot;media/scenery.mp4&quot; type=&quot;video/mp4&quot;&gt;\n&lt;/body&gt;\n&lt;script&gt;\n  var video = document.getElementById(&quot;video&quot;);\n  var canvas = document.getElementById(&quot;canvas&quot;);\n  // 获得画布的绘制上下文；\n  var context = canvas.getContext(&quot;2d&quot;);\n  // 当视频的第一帧完全载入时触发回调；\n  video.addEventListener(&quot;loadeddata&quot;, function() {\n    // 设置画布的大小；\n    canvas.setAttribute(&quot;height&quot;, video.videoHeight);\n    canvas.setAttribute(&quot;width&quot;, video.videoWidth);\n    // 获得画布的舞台（可绘制区域）大小；\n    clientx = canvas.clientWidth;\n    clienty = canvas.clientHeight;\n    // 开始绘制；\n    draw();\n  });\n\n  function draw() {\n    // 从画布的左上角开始绘制当前视频的第一帧；\n    context.drawImage(video, 0, 0);\n    // 获得当前帧画面的 ImageData 对象；\n    pixels = context.getImageData(0, 0, video.videoWidth, video.videoHeight);\n\n    // 调用 Wasm 模块处理该帧像素；\n    // ... \n\n    // 将之前获得 ImageData 对象绘制到画布上；\n    context.putImageData(pixels, 0, 0);\n    // 逐帧绘制（通常60帧每秒）；\n    requestAnimationFrame(draw);\n  }\n&lt;/script&gt;\n&lt;/html&gt;\n</code></pre>\n<p>这部分代码很简单，这里首先根据视频大小来初始化对应大小的画布，接下来通过画布提供的 <code>drawImage</code> 方法来将当前的视频播放帧绘制到画布上，然后再从绘制好的画布上提取像素矩阵。</p>\n<h4 id=\"2、WebAssembly-模块代码：\"><a href=\"#2、WebAssembly-模块代码：\" class=\"headerlink\" title=\"2、WebAssembly 模块代码：\"></a>2、WebAssembly 模块代码：</h4><p>接下来我们要完成的是 WebAssembly 模块的 C/C++ 代码部分，这部分代码如下所示。算法的具体流程来自 Github 的开源项目。我们需要注意的是要为导出的方法添加 Emscripten 编译器后端对应的宏以保证该方法不会被编译器清除（DCE）。</p>\n<pre><code class=\"c\">// program.cpp\n\n#include &lt;emscripten/emscripten.h&gt;\n#include &lt;math.h&gt;\n\nextern &quot;C&quot; {\n  void EMSCRIPTEN_KEEPALIVE convFilter (float* data, int width, int height, float* kern, int kWidth, int kHeight, float divisor, float bias, int count) {\n    float r, g, b;\n    int yy, xx, imageOffset, kernelOffset, pix; \n    int kCenterY = floor(kHeight / 2);\n    int kCenterX = floor(kWidth / 2);\n    for (int i = 0; i &lt; count; ++i) {\n      for (int y = kCenterY; y &lt; height - kCenterY; ++y) {\n        for (int x = kCenterX; x &lt; width - kCenterX; ++x) {\n          r = 0;\n          g = 0;\n          b = 0;\n          for (int ky = 0; ky &lt; kHeight; ++ky) {\n            for (int kx = 0; kx &lt; kWidth; ++kx) {\n              imageOffset = (width * (y - kCenterY + ky) + (x - kCenterX + kx)) * 4;\n              kernelOffset = kWidth * ky + kx;\n              // 对当前像素点进行卷积操作；\n              r += data[imageOffset + 0] * kern[kernelOffset];\n              g += data[imageOffset + 1] * kern[kernelOffset];\n              b += data[imageOffset + 2] * kern[kernelOffset];\n            }\n          }\n          pix = (width * y + x) * 4;\n          data[pix + 0] =  ((r / divisor)&gt;255.0) ? 255.0 : ((r / divisor)&lt;0.0) ? 0.0 : r / divisor;\n          data[pix + 1] =  ((g / divisor)&gt;255.0) ? 255.0 : ((g / divisor)&lt;0.0) ? 0.0 : g / divisor;\n          data[pix + 2] =  ((b / divisor)&gt;255.0) ? 255.0 : ((b / divisor)&lt;0.0) ? 0.0 : b / divisor;\n        }\n      }\n    }\n  }\n}\n</code></pre>\n<p>代码写好后，我们可以使用 Emscripten 的编译器前端工具 emcc 来编译 C++ 源码到对应的 Wast 二进制格式。命令如下所示：</p>\n<pre><code class=\"bash\">emcc -s WASM=1 -s ALLOW_MEMORY_GROWTH=1 -O3 -o program.js program.cpp\n</code></pre>\n<p>上述编译命令的使用方法与我们之前报告中的用法基本相同，其中新加入的 LOW_MEMORY_GROWTH 参数允许 Wasm 模块在使用时根据应用程序的使用情况自动扩大自身的可用内存。由于我们很难估计模块在处理帧数据时会消耗多少内存，因此无法在程序初始化时为模块创建固定大小的内存对象。在这里我们将内存大小管理完全交由应用自己进行控制。</p>\n<h4 id=\"3、Emscripten-Glue-连接应用：\"><a href=\"#3、Emscripten-Glue-连接应用：\" class=\"headerlink\" title=\"3、Emscripten Glue 连接应用：\"></a>3、Emscripten Glue 连接应用：</h4><p>接下来最后一步我们需要将 Wasm 模块和 JS 的逻辑层进行连接。在“连接”的过程中我们需要使用 Emscripten 为我们生成的的前端“胶水”工具。这部分 JS 逻辑层的代码我们单独放到一个文件中。代码如下所示：</p>\n<pre><code class=\"javascript\">// dip.js\n\nvar Module = {};\n\nfunction loadWASM() {\n  return new Promise((resolve, reject) =&gt; {\n    fetch(&quot;./program.wasm&quot;)\n      .then(response =&gt; response.arrayBuffer())\n      .then(buffer =&gt; {\n        // 初始化 Wasm 模块；\n        Module.wasmBinary = buffer;\n\n        // 加载 Emscripten &quot;胶水&quot;模块；\n        var script = document.createElement(&quot;script&quot;);\n        script.src = &quot;./program.js&quot;;\n        document.body.appendChild(script);\n\n        // 加载完成后初始化像素过滤方法；\n        window.onload = function() {\n          var filter = function(pixelData, width, height) {\n            // 设置卷积核；\n            var kernel = [[-1, -1, 1], [-1, 14, -1], [1, -1, -1]];\n            var divisor = 3;\n            const arLen = pixelData.length;\n            // \n            const memData = _malloc(arLen * Float32Array.BYTES_PER_ELEMENT);\n\n            // var memory = new Float32Array(Module.wasmMemory.buffer);\n            // memory.set(pixelData, memData / Float32Array.BYTES_PER_ELEMENT);\n            HEAPF32.set(pixelData, memData / Float32Array.BYTES_PER_ELEMENT);\n            const kerWidth = kernel[0].length;\n            const kerHeight = kernel.length;\n            const kerLen = kerWidth * kerHeight;\n            const flatKernel = kernel.reduce((acc, cur) =&gt; acc.concat(cur));\n            const memKernel = _malloc(kerLen * Float32Array.BYTES_PER_ELEMENT);\n            HEAPF32.set(flatKernel, memKernel / Float32Array.BYTES_PER_ELEMENT);\n            // 处理像素矩阵；\n            _convFilter(memData, width, height, memKernel, 3, 3, divisor, 0, 1);\n            const filtered = HEAPF32.subarray(memData / Float32Array.BYTES_PER_ELEMENT, memData / Float32Array.BYTES_PER_ELEMENT + arLen);\n            // 释放内存；\n            _free(memData);\n            _free(memKernel);\n            return filtered;\n          }\n          resolve(filter);\n        }\n      });\n  });\n}\n</code></pre>\n<p>在上述代码中，我们需要手动为像素矩阵分配内存。这里的 <code>_malloc</code> 和 <code>_free</code> 等方法都是由 Emscripten 工具链为我们提供的以用来在前端分配和释放内存的方法。代码中的 HEAPF32 是一个包含了 WebAssembly.Memoory 对象的 TypedArray 类型，我们可以直接使用它的 <code>set</code> 方法来将数据以“32位浮点”的类型写入到内存中。这里要注意线性内存地址是以1字节为单位的，1字节等于 4bytes，我们使用的 Float32Array 类型是以 32bytes 为单位，因此对应8字节偏移需要将新分配的内存地址除以8。如果不想使用 HEAPF32 来操作内存，我们也可以自己通过 TypedArray 进行封装，具体可以查看代码注释的两行。最后将上述 JS 文件起名为 ”dip.js“ 并插入到之前的超文本页面中，这里我们还需要在超文本页面中的脚本加入初始化 Wasm 模块和调用对应方法的逻辑，修改后的超文本页面代码如下所示：</p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;SimpleDIP&lt;/title&gt;\n    &lt;style&gt;\n        #video {\n            display: none;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;canvas id=&quot;canvas&quot;&gt;\n    &lt;video id=&quot;video&quot; loop=&quot;true&quot; autoplay=&quot;&quot; src=&quot;media/scenery.mp4&quot; type=&quot;video/mp4&quot;&gt;\n&lt;/body&gt;\n&lt;script src = &quot;./dip.js&quot; type = &quot;text/javascript&quot;&gt;&lt;/script&gt;\n&lt;script&gt;\n  loadWASM().then(filter =&gt; {\n    var video = document.getElementById(&quot;video&quot;);\n    var canvas = document.getElementById(&quot;canvas&quot;);\n    // 获得画布的绘制上下文；\n    var context = canvas.getContext(&quot;2d&quot;);\n    // 当视频的第一帧完全载入时触发回调；\n    video.addEventListener(&quot;loadeddata&quot;, function() {\n      // 设置画布的大小；\n      canvas.setAttribute(&quot;height&quot;, video.videoHeight);\n      canvas.setAttribute(&quot;width&quot;, video.videoWidth);\n      // 获得画布的舞台（可绘制区域）大小；\n      clientx = canvas.clientWidth;\n      clienty = canvas.clientHeight;\n      // 开始绘制；\n      draw();\n    });\n\n    function draw() {\n      // 从画布的左上角开始绘制当前视频的第一帧；\n      context.drawImage(video, 0, 0);\n      // 获得当前帧画面的 ImageData 对象；\n      pixels = context.getImageData(0, 0, video.videoWidth, video.videoHeight);\n      pixels.data.set(filter(pixels.data, clientx, clienty));\n      // 将之前获得 ImageData 对象绘制到画布上；\n      context.putImageData(pixels, 0, 0);\n      // 逐帧绘制（通常60帧每秒）；\n      requestAnimationFrame(draw);\n    }\n  });\n&lt;/script&gt;\n&lt;/html&gt;\n</code></pre>\n<p>至此，这个简单的 DIP 应用便完成了。</p>\n"},{"title":"WebAssembly 尝试研究报告 - 错误处理","intro":"前三篇报告分别从代码实践、底层基本原理等方面浅显地讨论了 WebAssembly 的相关特性。从本篇报告开始，我们将正式从 W3C 的标准 Web API 开始入手，深入细节来了解关于 WebAssembly 的更多特性。（由于当前标准变化较快，本文所叙述的内容不一定在未来仍然适用）。","comments":1,"date":"2017-06-13T15:41:10.000Z","_content":"\n前三篇报告分别从代码实践、底层基本原理等方面浅显地讨论了 WebAssembly 的相关特性。从本篇报告开始，我们将正式从 W3C 的标准 Web API 开始入手，深入细节来了解关于 WebAssembly 的更多特性。（由于当前标准变化较快，本文所叙述的内容不一定在未来仍然适用）。\n\nWebAssembly 在其浏览器的 JavaScript API 中规定了三种错误类型：\n\n \n```javascript\nWebAssembly.CompileError // 表示 WebAssembly 在解码或验证期间发生的错误；\nWebAssembly.LinkError    // 表示 WebAssembly 在模块实例化时发生的错误；\nWebAssembly.RuntimeError // 表示 WebAssembly 模块本身抛出的一个错误；\n```\n\n上述三种类型的错误可以发生在 WebAssembly 模块的加载，实例化和代码执行过程中。接下来我们将手动的在 C/C++ 代码中创建一个 Runtime Trap，并在 WebAssembly 运行时触发该异常，最后在 JS 层面将该异常捕获。为了实验的方便性，我们直接采用 WasmFiddle 来编译执行我们的代码。\n\n \n```c\nint division(int a, int b) { \n  return a / b;\n}\n```\n\nC/C++ 部分的代码很简单，我们用最常见的“用 0 作除数”这个运行时异常来进行测试。在 C 代码中我们声明了一个 `division` 函数，预留的两个参数用来在 JS 层去填充除数和被除数。\n\n \n```javascript\ntry {\n  var wasmModule = new WebAssembly.Module(wasmCode);\n  var wasmInstance = new WebAssembly.Instance(wasmModule, wasmImports);\n  wasmInstance.exports.division(0, 0);\n} catch(e) {\n  console.log(e instanceof WebAssembly.RuntimeError);  // true；\n  console.log(e.message);                              // \"divide by zero\"；\n  console.log(e.name);                                 // \"RuntimeError\"；\n  console.log(e.fileName);                             // undefined；\n  console.log(e.lineNumber);                           // undefined；\n  console.log(e.columnNumber);                         // undefined；\n  console.log(e.stack);                                // undefined；\n  console.dir(e);\n}\n```\n\n在 JS 层面，我们进行 WebAssembly 模块的加载和初始化，通过实例化导出 `division` 方法，并传入参数进行方法调用。整个 WebAssembly 模块的加载和实例化以及函数执行的过程我们用一个 `try...catch` 将其进行包裹。在异常处理部分我们打印出捕捉到异常对象的一些信息。\n\n最后经过实验发现，在最新的 Chrome(Version 59.0.3071.86 (Official Build) (64-bit)) 中并没有完全实现 WebAssembly Error 对象的全部属性。在这些属性中，**fileName**、**lineNumber**、**columnNumber** 以及 **stack** 都还没有完全的实现标准化。这三种类型的 WebAssembly 错误对应的 JS 错误对象都包含相同的构造函数和属性。比如，`WebAssembly.RuntimeError` 的构造函数如下所示，其中的第二和第三个参数同样还没有被标准化。\n\n \n```javascript\nnew WebAssembly.RuntimeError(message, fileName, lineNumber);\n```\n\n每当 WebAssembly 模块抛出一个异常时，由于当前的 WebAssembly 模块暂时还无法自己处理该异常，因此该异常会被传播到最近的非 WebAssembly 模块调用者（这里指浏览器或 JS）身上，最后在 JS 层面被处理。如果 WebAssembly 模块通过 `import` 虚拟指令在其内部调用了一个 JS 函数，而该函数出现了异常，则该异常同样会通过 WebAssembly 激活并被传递到最近的非 WebAssembly 模块调用者身上。\n","source":"_posts/WebAssembly-尝试研究报告-错误处理.md","raw":"---\ntitle: WebAssembly 尝试研究报告 - 错误处理\nintro: 前三篇报告分别从代码实践、底层基本原理等方面浅显地讨论了 WebAssembly 的相关特性。从本篇报告开始，我们将正式从 W3C 的标准 Web API 开始入手，深入细节来了解关于 WebAssembly 的更多特性。（由于当前标准变化较快，本文所叙述的内容不一定在未来仍然适用）。\ncomments: true\ndate: 2017-06-13 23:41:10\ntags:\n- WebAssembly\n---\n\n前三篇报告分别从代码实践、底层基本原理等方面浅显地讨论了 WebAssembly 的相关特性。从本篇报告开始，我们将正式从 W3C 的标准 Web API 开始入手，深入细节来了解关于 WebAssembly 的更多特性。（由于当前标准变化较快，本文所叙述的内容不一定在未来仍然适用）。\n\nWebAssembly 在其浏览器的 JavaScript API 中规定了三种错误类型：\n\n \n```javascript\nWebAssembly.CompileError // 表示 WebAssembly 在解码或验证期间发生的错误；\nWebAssembly.LinkError    // 表示 WebAssembly 在模块实例化时发生的错误；\nWebAssembly.RuntimeError // 表示 WebAssembly 模块本身抛出的一个错误；\n```\n\n上述三种类型的错误可以发生在 WebAssembly 模块的加载，实例化和代码执行过程中。接下来我们将手动的在 C/C++ 代码中创建一个 Runtime Trap，并在 WebAssembly 运行时触发该异常，最后在 JS 层面将该异常捕获。为了实验的方便性，我们直接采用 WasmFiddle 来编译执行我们的代码。\n\n \n```c\nint division(int a, int b) { \n  return a / b;\n}\n```\n\nC/C++ 部分的代码很简单，我们用最常见的“用 0 作除数”这个运行时异常来进行测试。在 C 代码中我们声明了一个 `division` 函数，预留的两个参数用来在 JS 层去填充除数和被除数。\n\n \n```javascript\ntry {\n  var wasmModule = new WebAssembly.Module(wasmCode);\n  var wasmInstance = new WebAssembly.Instance(wasmModule, wasmImports);\n  wasmInstance.exports.division(0, 0);\n} catch(e) {\n  console.log(e instanceof WebAssembly.RuntimeError);  // true；\n  console.log(e.message);                              // \"divide by zero\"；\n  console.log(e.name);                                 // \"RuntimeError\"；\n  console.log(e.fileName);                             // undefined；\n  console.log(e.lineNumber);                           // undefined；\n  console.log(e.columnNumber);                         // undefined；\n  console.log(e.stack);                                // undefined；\n  console.dir(e);\n}\n```\n\n在 JS 层面，我们进行 WebAssembly 模块的加载和初始化，通过实例化导出 `division` 方法，并传入参数进行方法调用。整个 WebAssembly 模块的加载和实例化以及函数执行的过程我们用一个 `try...catch` 将其进行包裹。在异常处理部分我们打印出捕捉到异常对象的一些信息。\n\n最后经过实验发现，在最新的 Chrome(Version 59.0.3071.86 (Official Build) (64-bit)) 中并没有完全实现 WebAssembly Error 对象的全部属性。在这些属性中，**fileName**、**lineNumber**、**columnNumber** 以及 **stack** 都还没有完全的实现标准化。这三种类型的 WebAssembly 错误对应的 JS 错误对象都包含相同的构造函数和属性。比如，`WebAssembly.RuntimeError` 的构造函数如下所示，其中的第二和第三个参数同样还没有被标准化。\n\n \n```javascript\nnew WebAssembly.RuntimeError(message, fileName, lineNumber);\n```\n\n每当 WebAssembly 模块抛出一个异常时，由于当前的 WebAssembly 模块暂时还无法自己处理该异常，因此该异常会被传播到最近的非 WebAssembly 模块调用者（这里指浏览器或 JS）身上，最后在 JS 层面被处理。如果 WebAssembly 模块通过 `import` 虚拟指令在其内部调用了一个 JS 函数，而该函数出现了异常，则该异常同样会通过 WebAssembly 激活并被传递到最近的非 WebAssembly 模块调用者身上。\n","slug":"WebAssembly-尝试研究报告-错误处理","published":1,"updated":"2019-02-19T07:34:28.810Z","layout":"post","photos":[],"link":"","_id":"cjsqwhta0003vknp2qtcm6nzb","content":"<p>前三篇报告分别从代码实践、底层基本原理等方面浅显地讨论了 WebAssembly 的相关特性。从本篇报告开始，我们将正式从 W3C 的标准 Web API 开始入手，深入细节来了解关于 WebAssembly 的更多特性。（由于当前标准变化较快，本文所叙述的内容不一定在未来仍然适用）。</p>\n<p>WebAssembly 在其浏览器的 JavaScript API 中规定了三种错误类型：</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\">WebAssembly<span class=\"token punctuation\">.</span>CompileError <span class=\"token comment\" spellcheck=\"true\">// 表示 WebAssembly 在解码或验证期间发生的错误；</span>\nWebAssembly<span class=\"token punctuation\">.</span>LinkError    <span class=\"token comment\" spellcheck=\"true\">// 表示 WebAssembly 在模块实例化时发生的错误；</span>\nWebAssembly<span class=\"token punctuation\">.</span>RuntimeError <span class=\"token comment\" spellcheck=\"true\">// 表示 WebAssembly 模块本身抛出的一个错误；</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>上述三种类型的错误可以发生在 WebAssembly 模块的加载，实例化和代码执行过程中。接下来我们将手动的在 C/C++ 代码中创建一个 Runtime Trap，并在 WebAssembly 运行时触发该异常，最后在 JS 层面将该异常捕获。为了实验的方便性，我们直接采用 WasmFiddle 来编译执行我们的代码。</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">division</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n  <span class=\"token keyword\">return</span> a <span class=\"token operator\">/</span> b<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>C/C++ 部分的代码很简单，我们用最常见的“用 0 作除数”这个运行时异常来进行测试。在 C 代码中我们声明了一个 <code>division</code> 函数，预留的两个参数用来在 JS 层去填充除数和被除数。</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> wasmModule <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">WebAssembly<span class=\"token punctuation\">.</span>Module</span><span class=\"token punctuation\">(</span>wasmCode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> wasmInstance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">WebAssembly<span class=\"token punctuation\">.</span>Instance</span><span class=\"token punctuation\">(</span>wasmModule<span class=\"token punctuation\">,</span> wasmImports<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  wasmInstance<span class=\"token punctuation\">.</span>exports<span class=\"token punctuation\">.</span><span class=\"token function\">division</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>e <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">WebAssembly<span class=\"token punctuation\">.</span>RuntimeError</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// true；</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>message<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                              <span class=\"token comment\" spellcheck=\"true\">// \"divide by zero\"；</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                                 <span class=\"token comment\" spellcheck=\"true\">// \"RuntimeError\"；</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>fileName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                             <span class=\"token comment\" spellcheck=\"true\">// undefined；</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>lineNumber<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                           <span class=\"token comment\" spellcheck=\"true\">// undefined；</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>columnNumber<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                         <span class=\"token comment\" spellcheck=\"true\">// undefined；</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>stack<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                                <span class=\"token comment\" spellcheck=\"true\">// undefined；</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">dir</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>在 JS 层面，我们进行 WebAssembly 模块的加载和初始化，通过实例化导出 <code>division</code> 方法，并传入参数进行方法调用。整个 WebAssembly 模块的加载和实例化以及函数执行的过程我们用一个 <code>try...catch</code> 将其进行包裹。在异常处理部分我们打印出捕捉到异常对象的一些信息。</p>\n<p>最后经过实验发现，在最新的 Chrome(Version 59.0.3071.86 (Official Build) (64-bit)) 中并没有完全实现 WebAssembly Error 对象的全部属性。在这些属性中，<strong>fileName</strong>、<strong>lineNumber</strong>、<strong>columnNumber</strong> 以及 <strong>stack</strong> 都还没有完全的实现标准化。这三种类型的 WebAssembly 错误对应的 JS 错误对象都包含相同的构造函数和属性。比如，<code>WebAssembly.RuntimeError</code> 的构造函数如下所示，其中的第二和第三个参数同样还没有被标准化。</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">new</span> <span class=\"token class-name\">WebAssembly<span class=\"token punctuation\">.</span>RuntimeError</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">,</span> fileName<span class=\"token punctuation\">,</span> lineNumber<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>每当 WebAssembly 模块抛出一个异常时，由于当前的 WebAssembly 模块暂时还无法自己处理该异常，因此该异常会被传播到最近的非 WebAssembly 模块调用者（这里指浏览器或 JS）身上，最后在 JS 层面被处理。如果 WebAssembly 模块通过 <code>import</code> 虚拟指令在其内部调用了一个 JS 函数，而该函数出现了异常，则该异常同样会通过 WebAssembly 激活并被传递到最近的非 WebAssembly 模块调用者身上。</p>\n","site":{"data":{}},"id":"cc024fd78b2243b0974b79a69f18b389","excerpt":"","more":"<p>前三篇报告分别从代码实践、底层基本原理等方面浅显地讨论了 WebAssembly 的相关特性。从本篇报告开始，我们将正式从 W3C 的标准 Web API 开始入手，深入细节来了解关于 WebAssembly 的更多特性。（由于当前标准变化较快，本文所叙述的内容不一定在未来仍然适用）。</p>\n<p>WebAssembly 在其浏览器的 JavaScript API 中规定了三种错误类型：</p>\n<pre><code class=\"javascript\">WebAssembly.CompileError // 表示 WebAssembly 在解码或验证期间发生的错误；\nWebAssembly.LinkError    // 表示 WebAssembly 在模块实例化时发生的错误；\nWebAssembly.RuntimeError // 表示 WebAssembly 模块本身抛出的一个错误；\n</code></pre>\n<p>上述三种类型的错误可以发生在 WebAssembly 模块的加载，实例化和代码执行过程中。接下来我们将手动的在 C/C++ 代码中创建一个 Runtime Trap，并在 WebAssembly 运行时触发该异常，最后在 JS 层面将该异常捕获。为了实验的方便性，我们直接采用 WasmFiddle 来编译执行我们的代码。</p>\n<pre><code class=\"c\">int division(int a, int b) { \n  return a / b;\n}\n</code></pre>\n<p>C/C++ 部分的代码很简单，我们用最常见的“用 0 作除数”这个运行时异常来进行测试。在 C 代码中我们声明了一个 <code>division</code> 函数，预留的两个参数用来在 JS 层去填充除数和被除数。</p>\n<pre><code class=\"javascript\">try {\n  var wasmModule = new WebAssembly.Module(wasmCode);\n  var wasmInstance = new WebAssembly.Instance(wasmModule, wasmImports);\n  wasmInstance.exports.division(0, 0);\n} catch(e) {\n  console.log(e instanceof WebAssembly.RuntimeError);  // true；\n  console.log(e.message);                              // &quot;divide by zero&quot;；\n  console.log(e.name);                                 // &quot;RuntimeError&quot;；\n  console.log(e.fileName);                             // undefined；\n  console.log(e.lineNumber);                           // undefined；\n  console.log(e.columnNumber);                         // undefined；\n  console.log(e.stack);                                // undefined；\n  console.dir(e);\n}\n</code></pre>\n<p>在 JS 层面，我们进行 WebAssembly 模块的加载和初始化，通过实例化导出 <code>division</code> 方法，并传入参数进行方法调用。整个 WebAssembly 模块的加载和实例化以及函数执行的过程我们用一个 <code>try...catch</code> 将其进行包裹。在异常处理部分我们打印出捕捉到异常对象的一些信息。</p>\n<p>最后经过实验发现，在最新的 Chrome(Version 59.0.3071.86 (Official Build) (64-bit)) 中并没有完全实现 WebAssembly Error 对象的全部属性。在这些属性中，<strong>fileName</strong>、<strong>lineNumber</strong>、<strong>columnNumber</strong> 以及 <strong>stack</strong> 都还没有完全的实现标准化。这三种类型的 WebAssembly 错误对应的 JS 错误对象都包含相同的构造函数和属性。比如，<code>WebAssembly.RuntimeError</code> 的构造函数如下所示，其中的第二和第三个参数同样还没有被标准化。</p>\n<pre><code class=\"javascript\">new WebAssembly.RuntimeError(message, fileName, lineNumber);\n</code></pre>\n<p>每当 WebAssembly 模块抛出一个异常时，由于当前的 WebAssembly 模块暂时还无法自己处理该异常，因此该异常会被传播到最近的非 WebAssembly 模块调用者（这里指浏览器或 JS）身上，最后在 JS 层面被处理。如果 WebAssembly 模块通过 <code>import</code> 虚拟指令在其内部调用了一个 JS 函数，而该函数出现了异常，则该异常同样会通过 WebAssembly 激活并被传递到最近的非 WebAssembly 模块调用者身上。</p>\n"},{"title":"V8 内存优化之 Ignition 解释器","intro":"由于 V8 的 \"full-codegen\" 基线编译器在解析 AST 之后生成的机器码十分冗长，因此会大量占用 V8 的堆内存。V8 为了减少生成的机器码以缓解内存压力，尝试了大量“延迟解析和编译（Lazy parsing and compiling）”的工作。比如对于一段代码，如果这段代码中的函数没有在初始化时被调用，则该调用过程将会被“延迟”进行，直到第一次函数调用时再编译该函数对应的代码。","comments":1,"date":"2017-09-07T10:16:40.000Z","_content":"\n由于 V8 的 \"full-codegen\" 基线编译器在解析 AST 之后生成的机器码十分冗长，因此会大量占用 V8 的堆内存。V8 为了减少生成的机器码以缓解内存压力，尝试了大量“延迟解析和编译（Lazy parsing and compiling）”的工作。比如对于一段代码，如果这段代码中的函数没有在初始化时被调用，则该调用过程将会被“延迟”进行，直到第一次函数调用时再编译该函数对应的代码。\n\n但这样并没有解决实际的问题。没有在初始化时被编译运行的代码会在再次被调用时又进行一次编译过程（Parsing 生成 AST），这显然是没有必要的。Ignition 取代了直接使用 \"full-codegen\" 的方式。Ignition 使用低层次的比特码（Bytecode）作为自己的输出，相比 \"full-codegen\" 生成的机器码，比特码具有更高的信息密度。相较于机器码，比特码属于更高层次的代码，因此经过 Ignition 产生比特码的过程十分迅速。更可观的是，比特码可以直接加载到 TurboFan 的图生成器中转换为优化后的机器码，从而省去了再次 Parsing 的过程。\n\n![](1.png)\n\n从上述图片中可以看到，在 V8 没有引入 Ignition 之前，对于 hot 和 non-hot 类型的代码要分别做两次 Parsing 的过程。hot 的代码在经过 Parsing 后会通过 TurboFan 或者 CrankShaft 进行优化，之后生成优化后的代码。\n\n![](2.png)\n\n\n在最理想的方式中，我们已经去掉了 \"full-codegen\" 的过程，直接使用比特码作为连接到优化编译器的输入。但事实上，由于只有 TurboFan 支持直接从 Ignition 的比特码进行优化，处在同样位置的 CrankShaft 仍然需要一个前置的 Parser 来生成 AST，当 CrankShaft 需要进行去优化的过程（JIT 的特性，优化编译器通常是尝试的去进行优化，如果优化失败会进行去优化，则回退到之前的流程）时，只能反向回退到 \"full-codegen\" 生成的机器码，这就导致了实际上现在的 V8 优化 Pipeline 中的 \"full-codegen\" 并没有被完全移除。另一方面，由于 TurboFan 的性能并没有达到预期，因此这里的 CrankShaft 也不能被完全移除，因此实际上的 Pipeline 如下图所示。\n\n![](3.png)\n\n\n关于 Ignition 生成的比特码结构如下所示。Ignition 本身是一种基于累加器的寄存器型解释器，关于比特码的执行流程可以参考**[这篇文章](https://medium.com/dailyjs/understanding-v8s-bytecode-317d46c94775)**。\n\n![](4.png)\n\n\n* **full-codegen**：快速生成机器码，并不进行类型检查，通过 Inline Cache 的方式来收集类型相关的信息；\n* **TurboFan／CrankShaft**：优化 hot 代码，通过之前保存的 Inline Cache 来进一步分析代码的优化方案，通过“类型特化”等方式大幅度提升代码性能；\n\n","source":"_posts/V8-内存优化之-Ignition-解释器.md","raw":"---\ntitle: V8 内存优化之 Ignition 解释器\nintro: 由于 V8 的 \"full-codegen\" 基线编译器在解析 AST 之后生成的机器码十分冗长，因此会大量占用 V8 的堆内存。V8 为了减少生成的机器码以缓解内存压力，尝试了大量“延迟解析和编译（Lazy parsing and compiling）”的工作。比如对于一段代码，如果这段代码中的函数没有在初始化时被调用，则该调用过程将会被“延迟”进行，直到第一次函数调用时再编译该函数对应的代码。\ncomments: true\ndate: 2017-09-07 18:16:40\ntags:\n- V8\n---\n\n由于 V8 的 \"full-codegen\" 基线编译器在解析 AST 之后生成的机器码十分冗长，因此会大量占用 V8 的堆内存。V8 为了减少生成的机器码以缓解内存压力，尝试了大量“延迟解析和编译（Lazy parsing and compiling）”的工作。比如对于一段代码，如果这段代码中的函数没有在初始化时被调用，则该调用过程将会被“延迟”进行，直到第一次函数调用时再编译该函数对应的代码。\n\n但这样并没有解决实际的问题。没有在初始化时被编译运行的代码会在再次被调用时又进行一次编译过程（Parsing 生成 AST），这显然是没有必要的。Ignition 取代了直接使用 \"full-codegen\" 的方式。Ignition 使用低层次的比特码（Bytecode）作为自己的输出，相比 \"full-codegen\" 生成的机器码，比特码具有更高的信息密度。相较于机器码，比特码属于更高层次的代码，因此经过 Ignition 产生比特码的过程十分迅速。更可观的是，比特码可以直接加载到 TurboFan 的图生成器中转换为优化后的机器码，从而省去了再次 Parsing 的过程。\n\n![](1.png)\n\n从上述图片中可以看到，在 V8 没有引入 Ignition 之前，对于 hot 和 non-hot 类型的代码要分别做两次 Parsing 的过程。hot 的代码在经过 Parsing 后会通过 TurboFan 或者 CrankShaft 进行优化，之后生成优化后的代码。\n\n![](2.png)\n\n\n在最理想的方式中，我们已经去掉了 \"full-codegen\" 的过程，直接使用比特码作为连接到优化编译器的输入。但事实上，由于只有 TurboFan 支持直接从 Ignition 的比特码进行优化，处在同样位置的 CrankShaft 仍然需要一个前置的 Parser 来生成 AST，当 CrankShaft 需要进行去优化的过程（JIT 的特性，优化编译器通常是尝试的去进行优化，如果优化失败会进行去优化，则回退到之前的流程）时，只能反向回退到 \"full-codegen\" 生成的机器码，这就导致了实际上现在的 V8 优化 Pipeline 中的 \"full-codegen\" 并没有被完全移除。另一方面，由于 TurboFan 的性能并没有达到预期，因此这里的 CrankShaft 也不能被完全移除，因此实际上的 Pipeline 如下图所示。\n\n![](3.png)\n\n\n关于 Ignition 生成的比特码结构如下所示。Ignition 本身是一种基于累加器的寄存器型解释器，关于比特码的执行流程可以参考**[这篇文章](https://medium.com/dailyjs/understanding-v8s-bytecode-317d46c94775)**。\n\n![](4.png)\n\n\n* **full-codegen**：快速生成机器码，并不进行类型检查，通过 Inline Cache 的方式来收集类型相关的信息；\n* **TurboFan／CrankShaft**：优化 hot 代码，通过之前保存的 Inline Cache 来进一步分析代码的优化方案，通过“类型特化”等方式大幅度提升代码性能；\n\n","slug":"V8-内存优化之-Ignition-解释器","published":1,"updated":"2019-02-19T10:41:13.512Z","layout":"post","photos":[],"link":"","_id":"cjsqwhta0003yknp2i4pgxrlt","content":"<p>由于 V8 的 “full-codegen” 基线编译器在解析 AST 之后生成的机器码十分冗长，因此会大量占用 V8 的堆内存。V8 为了减少生成的机器码以缓解内存压力，尝试了大量“延迟解析和编译（Lazy parsing and compiling）”的工作。比如对于一段代码，如果这段代码中的函数没有在初始化时被调用，则该调用过程将会被“延迟”进行，直到第一次函数调用时再编译该函数对应的代码。</p>\n<p>但这样并没有解决实际的问题。没有在初始化时被编译运行的代码会在再次被调用时又进行一次编译过程（Parsing 生成 AST），这显然是没有必要的。Ignition 取代了直接使用 “full-codegen” 的方式。Ignition 使用低层次的比特码（Bytecode）作为自己的输出，相比 “full-codegen” 生成的机器码，比特码具有更高的信息密度。相较于机器码，比特码属于更高层次的代码，因此经过 Ignition 产生比特码的过程十分迅速。更可观的是，比特码可以直接加载到 TurboFan 的图生成器中转换为优化后的机器码，从而省去了再次 Parsing 的过程。</p>\n<p><img src=\"1.png\" alt></p>\n<p>从上述图片中可以看到，在 V8 没有引入 Ignition 之前，对于 hot 和 non-hot 类型的代码要分别做两次 Parsing 的过程。hot 的代码在经过 Parsing 后会通过 TurboFan 或者 CrankShaft 进行优化，之后生成优化后的代码。</p>\n<p><img src=\"2.png\" alt></p>\n<p>在最理想的方式中，我们已经去掉了 “full-codegen” 的过程，直接使用比特码作为连接到优化编译器的输入。但事实上，由于只有 TurboFan 支持直接从 Ignition 的比特码进行优化，处在同样位置的 CrankShaft 仍然需要一个前置的 Parser 来生成 AST，当 CrankShaft 需要进行去优化的过程（JIT 的特性，优化编译器通常是尝试的去进行优化，如果优化失败会进行去优化，则回退到之前的流程）时，只能反向回退到 “full-codegen” 生成的机器码，这就导致了实际上现在的 V8 优化 Pipeline 中的 “full-codegen” 并没有被完全移除。另一方面，由于 TurboFan 的性能并没有达到预期，因此这里的 CrankShaft 也不能被完全移除，因此实际上的 Pipeline 如下图所示。</p>\n<p><img src=\"3.png\" alt></p>\n<p>关于 Ignition 生成的比特码结构如下所示。Ignition 本身是一种基于累加器的寄存器型解释器，关于比特码的执行流程可以参考<strong><a href=\"https://medium.com/dailyjs/understanding-v8s-bytecode-317d46c94775\" target=\"_blank\" rel=\"noopener\">这篇文章</a></strong>。</p>\n<p><img src=\"4.png\" alt></p>\n<ul>\n<li><strong>full-codegen</strong>：快速生成机器码，并不进行类型检查，通过 Inline Cache 的方式来收集类型相关的信息；</li>\n<li><strong>TurboFan／CrankShaft</strong>：优化 hot 代码，通过之前保存的 Inline Cache 来进一步分析代码的优化方案，通过“类型特化”等方式大幅度提升代码性能；</li>\n</ul>\n","site":{"data":{}},"id":"409cb3e4964cb0d205cd120357bc4d08","excerpt":"","more":"<p>由于 V8 的 “full-codegen” 基线编译器在解析 AST 之后生成的机器码十分冗长，因此会大量占用 V8 的堆内存。V8 为了减少生成的机器码以缓解内存压力，尝试了大量“延迟解析和编译（Lazy parsing and compiling）”的工作。比如对于一段代码，如果这段代码中的函数没有在初始化时被调用，则该调用过程将会被“延迟”进行，直到第一次函数调用时再编译该函数对应的代码。</p>\n<p>但这样并没有解决实际的问题。没有在初始化时被编译运行的代码会在再次被调用时又进行一次编译过程（Parsing 生成 AST），这显然是没有必要的。Ignition 取代了直接使用 “full-codegen” 的方式。Ignition 使用低层次的比特码（Bytecode）作为自己的输出，相比 “full-codegen” 生成的机器码，比特码具有更高的信息密度。相较于机器码，比特码属于更高层次的代码，因此经过 Ignition 产生比特码的过程十分迅速。更可观的是，比特码可以直接加载到 TurboFan 的图生成器中转换为优化后的机器码，从而省去了再次 Parsing 的过程。</p>\n<p><img src=\"1.png\" alt></p>\n<p>从上述图片中可以看到，在 V8 没有引入 Ignition 之前，对于 hot 和 non-hot 类型的代码要分别做两次 Parsing 的过程。hot 的代码在经过 Parsing 后会通过 TurboFan 或者 CrankShaft 进行优化，之后生成优化后的代码。</p>\n<p><img src=\"2.png\" alt></p>\n<p>在最理想的方式中，我们已经去掉了 “full-codegen” 的过程，直接使用比特码作为连接到优化编译器的输入。但事实上，由于只有 TurboFan 支持直接从 Ignition 的比特码进行优化，处在同样位置的 CrankShaft 仍然需要一个前置的 Parser 来生成 AST，当 CrankShaft 需要进行去优化的过程（JIT 的特性，优化编译器通常是尝试的去进行优化，如果优化失败会进行去优化，则回退到之前的流程）时，只能反向回退到 “full-codegen” 生成的机器码，这就导致了实际上现在的 V8 优化 Pipeline 中的 “full-codegen” 并没有被完全移除。另一方面，由于 TurboFan 的性能并没有达到预期，因此这里的 CrankShaft 也不能被完全移除，因此实际上的 Pipeline 如下图所示。</p>\n<p><img src=\"3.png\" alt></p>\n<p>关于 Ignition 生成的比特码结构如下所示。Ignition 本身是一种基于累加器的寄存器型解释器，关于比特码的执行流程可以参考<strong><a href=\"https://medium.com/dailyjs/understanding-v8s-bytecode-317d46c94775\" target=\"_blank\" rel=\"noopener\">这篇文章</a></strong>。</p>\n<p><img src=\"4.png\" alt></p>\n<ul>\n<li><strong>full-codegen</strong>：快速生成机器码，并不进行类型检查，通过 Inline Cache 的方式来收集类型相关的信息；</li>\n<li><strong>TurboFan／CrankShaft</strong>：优化 hot 代码，通过之前保存的 Inline Cache 来进一步分析代码的优化方案，通过“类型特化”等方式大幅度提升代码性能；</li>\n</ul>\n"},{"title":"Web 新时代与挑战","intro":"一般来说，一项新技术是否会随着时代的推进而被快速地迭代和发展，要看这项技术所应用在的实际业务场景中是否有相应的技术需求，毕竟没有任何技术是会被凭空创造出来的。技术决定了业务需求的多样性，而业务需求的多样性又推动着技术不断向前发展，两者相辅相成最终才能推动行业整体的发展和进步。","comments":1,"date":"2017-12-17T12:32:08.000Z","_content":"\n一般来说，一项新技术是否会随着时代的推进而被快速地迭代和发展，要看这项技术所应用在的实际业务场景中是否有相应的技术需求，毕竟没有任何技术是会被凭空创造出来的。技术决定了业务需求的多样性，而业务需求的多样性又推动着技术不断向前发展，两者相辅相成最终才能推动行业整体的发展和进步。 \n\n自1991年 HTTP 协议和 HTML 超文本标记语言这两种核心的Web技术诞生以来，Web 开发技术领域便开始不断地发生着翻天覆地的变化。如下图给出的 Web 技术发展史所示，从1991年到2002年的这十年里，Web 技术的发展过程还是比较缓和和稳定的。在这十年的时间里，首先是 NetScape、Opera 和 Internet Explorer（IE）三大浏览器开始逐渐走入人们的视野。一些用于构建更丰富Web应用的基础性技术开始逐渐涌现，比如 Flash 技术从1996年开始可以被应用在浏览器端，这使得传统的Web应用中可以嵌入包含丰富多媒体信息的 Flash 应用，这一发展也使得 Web 应用的交互性和动态性大大的增强。Flash 技术的出现催生了一批以提供视频播放、视频发布和视频分享服务为主的视频服务平台的出现，另一方面同时也推动了基于 Flash 的 Web 页游行业的发展。 \n\n![](1.png)\n\n自2002年开始，Web 技术的发展便到了其整个发展历程的“下半场”。从2003年开始一直到2012年的这将近十年的时间里，新型 Web 技术的出现逐渐呈现出了爆炸式的增长。首先是 Chrome、Firefox 和 Safari 这三种为推动 Web 技术后来的爆炸式发展作出了巨大贡献的浏览器开始出现，各大浏览器厂商对其产品的版本更新迭代速度也开始加快。Web 技术的发展从2008年开始进入了一个“爆炸式”的快速发展阶段，各种各样的新型 Web 浏览器特性和新的 Web 标准以及 ECMAScript 标准如“雨后春笋”般开始涌现出来。XMLHTTPRequest2 技术为 Web 应用的数据传输提供了更方便和高效的传输方式；WebRTC 技术为 Web 应用的实时在线视频／语音直播提供了底层的基础技术解决方案；WebGL 技术为 Web 应用提供了一种可以通过 JavaScript 来操作 Web 版本 OpenGL 的特性，基于 WebGL 暴露出的 JavaScript 接口，我们可以在 Web 网页上高效地绘制3D动画和模型，为在 Web 网页上运行大型 3D 网络游戏提供了可能；IndexedDB 技术为前端应用存储结构化数据并且对数据进行高性能的数据检索提供了支持。除此之外还有很多的 Web 相关技术被实现和标准化，这些技术都无疑大大地拓宽了 Web 应用所能覆盖到的应用领域和场景。也正是自2008年的 HTML5 标准和2009年的 CSS3 标准出现之后，Flash 多媒体应用技术在 Web 开发领域逐渐开始走向了下坡路，直至最后被其他技术取代。由此也可见 Web 领域的技术迭代与更替速度之快。 \n\n![](2.png)\n\nJavaScript 作为一门用于开发 Web 端应用的编程语言从1997年发展至今，其所能应用的领域已经不仅仅局限在最原始的基于浏览器的 Web 端应用开发上了。包括 Node.js 在内的等一系列新出现的 JavaScript 运行时环境已经把 JavaScript 的应用场景从前端应用的开发带到了服务端应用的开发。 \n\n基于 Chrome V8 引擎构建的 Node.js 和 Fib.js 等 JavaScript 运行时环境和框架为后端服务器应用的开发提供了“非阻塞的异步 IO”和“基于事件模型”等新特性。这些新特性可以让我们以开发传统前端 Web 应用的思路来开发服务器端应用。不仅如此，基于 Node.js 开发出来的各种服务端应用框架更是极大的提高了我们开发后端应用的效率。这些框架在一些必要的业务流程上已经为我们做了足够多的封装和优化，这使得我们可以更多的去关注业务逻辑代码上的实现，而不是一些底层细节架构上的事情。但事情并没有这么完美，就拿 Node.js 为例，由于 Node.js 本身是基于 V8 实现的，而 V8 本身所负责的一个最重要的功能就是对 JavaScript 代码进行解析和优化，然后将这些优化后的代码编译成机器码最后运行。因此，无论 Node.js 对 V8 上层的 JavaScript 代码进行了何种系统底层调用流程上的优化，如果最后在 V8 解析和执行 JavaScript 代码时的速度很慢，那么整个应用的运行效率必然会大打折扣。总的来说，Chrome V8、JavaScriptCore 和 SpiderMonkey 等 JavaScript 引擎对 JavaScript 代码的解析和执行效率高低，直接决定了这些基于 JavaScript 开发的前端和服务器端应用的运行流畅程度，进而也直接影响了最前端的产品用户体验。 \n\n除此之外，变得日益复杂和庞大的 Web 前端应用也带来了更多对 JavaScript 语言性能上的挑战。比如基于 Web 端的视频处理软件、基于 Web 端的大型 3D 游戏、基于 Web 端的在线机器学习（深度学习）训练平台等。这些应用无一例外都需要消耗浏览器大量的计算资源，因此 JavaScript 引擎对 JavaScript 代码的执行效率也直接决定了这些应用能否被流畅地运行。不仅如此，我们都知道通过 JavaScript 来移动或修改页面上的 DOM 节点所付出的成本是巨大的，随着传统Web页面的交互设计变得越来越复杂，这种成本损耗所带来的问题可能会被逐渐放大，这也是我们在未来将要面对的问题 。 \n","source":"_posts/Web-新时代与挑战.md","raw":"---\ntitle: Web 新时代与挑战\nintro: 一般来说，一项新技术是否会随着时代的推进而被快速地迭代和发展，要看这项技术所应用在的实际业务场景中是否有相应的技术需求，毕竟没有任何技术是会被凭空创造出来的。技术决定了业务需求的多样性，而业务需求的多样性又推动着技术不断向前发展，两者相辅相成最终才能推动行业整体的发展和进步。\ncomments: true\ndate: 2017-12-17 20:32:08\ntags:\n- 日记\n---\n\n一般来说，一项新技术是否会随着时代的推进而被快速地迭代和发展，要看这项技术所应用在的实际业务场景中是否有相应的技术需求，毕竟没有任何技术是会被凭空创造出来的。技术决定了业务需求的多样性，而业务需求的多样性又推动着技术不断向前发展，两者相辅相成最终才能推动行业整体的发展和进步。 \n\n自1991年 HTTP 协议和 HTML 超文本标记语言这两种核心的Web技术诞生以来，Web 开发技术领域便开始不断地发生着翻天覆地的变化。如下图给出的 Web 技术发展史所示，从1991年到2002年的这十年里，Web 技术的发展过程还是比较缓和和稳定的。在这十年的时间里，首先是 NetScape、Opera 和 Internet Explorer（IE）三大浏览器开始逐渐走入人们的视野。一些用于构建更丰富Web应用的基础性技术开始逐渐涌现，比如 Flash 技术从1996年开始可以被应用在浏览器端，这使得传统的Web应用中可以嵌入包含丰富多媒体信息的 Flash 应用，这一发展也使得 Web 应用的交互性和动态性大大的增强。Flash 技术的出现催生了一批以提供视频播放、视频发布和视频分享服务为主的视频服务平台的出现，另一方面同时也推动了基于 Flash 的 Web 页游行业的发展。 \n\n![](1.png)\n\n自2002年开始，Web 技术的发展便到了其整个发展历程的“下半场”。从2003年开始一直到2012年的这将近十年的时间里，新型 Web 技术的出现逐渐呈现出了爆炸式的增长。首先是 Chrome、Firefox 和 Safari 这三种为推动 Web 技术后来的爆炸式发展作出了巨大贡献的浏览器开始出现，各大浏览器厂商对其产品的版本更新迭代速度也开始加快。Web 技术的发展从2008年开始进入了一个“爆炸式”的快速发展阶段，各种各样的新型 Web 浏览器特性和新的 Web 标准以及 ECMAScript 标准如“雨后春笋”般开始涌现出来。XMLHTTPRequest2 技术为 Web 应用的数据传输提供了更方便和高效的传输方式；WebRTC 技术为 Web 应用的实时在线视频／语音直播提供了底层的基础技术解决方案；WebGL 技术为 Web 应用提供了一种可以通过 JavaScript 来操作 Web 版本 OpenGL 的特性，基于 WebGL 暴露出的 JavaScript 接口，我们可以在 Web 网页上高效地绘制3D动画和模型，为在 Web 网页上运行大型 3D 网络游戏提供了可能；IndexedDB 技术为前端应用存储结构化数据并且对数据进行高性能的数据检索提供了支持。除此之外还有很多的 Web 相关技术被实现和标准化，这些技术都无疑大大地拓宽了 Web 应用所能覆盖到的应用领域和场景。也正是自2008年的 HTML5 标准和2009年的 CSS3 标准出现之后，Flash 多媒体应用技术在 Web 开发领域逐渐开始走向了下坡路，直至最后被其他技术取代。由此也可见 Web 领域的技术迭代与更替速度之快。 \n\n![](2.png)\n\nJavaScript 作为一门用于开发 Web 端应用的编程语言从1997年发展至今，其所能应用的领域已经不仅仅局限在最原始的基于浏览器的 Web 端应用开发上了。包括 Node.js 在内的等一系列新出现的 JavaScript 运行时环境已经把 JavaScript 的应用场景从前端应用的开发带到了服务端应用的开发。 \n\n基于 Chrome V8 引擎构建的 Node.js 和 Fib.js 等 JavaScript 运行时环境和框架为后端服务器应用的开发提供了“非阻塞的异步 IO”和“基于事件模型”等新特性。这些新特性可以让我们以开发传统前端 Web 应用的思路来开发服务器端应用。不仅如此，基于 Node.js 开发出来的各种服务端应用框架更是极大的提高了我们开发后端应用的效率。这些框架在一些必要的业务流程上已经为我们做了足够多的封装和优化，这使得我们可以更多的去关注业务逻辑代码上的实现，而不是一些底层细节架构上的事情。但事情并没有这么完美，就拿 Node.js 为例，由于 Node.js 本身是基于 V8 实现的，而 V8 本身所负责的一个最重要的功能就是对 JavaScript 代码进行解析和优化，然后将这些优化后的代码编译成机器码最后运行。因此，无论 Node.js 对 V8 上层的 JavaScript 代码进行了何种系统底层调用流程上的优化，如果最后在 V8 解析和执行 JavaScript 代码时的速度很慢，那么整个应用的运行效率必然会大打折扣。总的来说，Chrome V8、JavaScriptCore 和 SpiderMonkey 等 JavaScript 引擎对 JavaScript 代码的解析和执行效率高低，直接决定了这些基于 JavaScript 开发的前端和服务器端应用的运行流畅程度，进而也直接影响了最前端的产品用户体验。 \n\n除此之外，变得日益复杂和庞大的 Web 前端应用也带来了更多对 JavaScript 语言性能上的挑战。比如基于 Web 端的视频处理软件、基于 Web 端的大型 3D 游戏、基于 Web 端的在线机器学习（深度学习）训练平台等。这些应用无一例外都需要消耗浏览器大量的计算资源，因此 JavaScript 引擎对 JavaScript 代码的执行效率也直接决定了这些应用能否被流畅地运行。不仅如此，我们都知道通过 JavaScript 来移动或修改页面上的 DOM 节点所付出的成本是巨大的，随着传统Web页面的交互设计变得越来越复杂，这种成本损耗所带来的问题可能会被逐渐放大，这也是我们在未来将要面对的问题 。 \n","slug":"Web-新时代与挑战","published":1,"updated":"2019-02-20T06:51:32.691Z","layout":"post","photos":[],"link":"","_id":"cjsqwhta10040knp255rftjdu","content":"<p>一般来说，一项新技术是否会随着时代的推进而被快速地迭代和发展，要看这项技术所应用在的实际业务场景中是否有相应的技术需求，毕竟没有任何技术是会被凭空创造出来的。技术决定了业务需求的多样性，而业务需求的多样性又推动着技术不断向前发展，两者相辅相成最终才能推动行业整体的发展和进步。 </p>\n<p>自1991年 HTTP 协议和 HTML 超文本标记语言这两种核心的Web技术诞生以来，Web 开发技术领域便开始不断地发生着翻天覆地的变化。如下图给出的 Web 技术发展史所示，从1991年到2002年的这十年里，Web 技术的发展过程还是比较缓和和稳定的。在这十年的时间里，首先是 NetScape、Opera 和 Internet Explorer（IE）三大浏览器开始逐渐走入人们的视野。一些用于构建更丰富Web应用的基础性技术开始逐渐涌现，比如 Flash 技术从1996年开始可以被应用在浏览器端，这使得传统的Web应用中可以嵌入包含丰富多媒体信息的 Flash 应用，这一发展也使得 Web 应用的交互性和动态性大大的增强。Flash 技术的出现催生了一批以提供视频播放、视频发布和视频分享服务为主的视频服务平台的出现，另一方面同时也推动了基于 Flash 的 Web 页游行业的发展。 </p>\n<p><img src=\"1.png\" alt></p>\n<p>自2002年开始，Web 技术的发展便到了其整个发展历程的“下半场”。从2003年开始一直到2012年的这将近十年的时间里，新型 Web 技术的出现逐渐呈现出了爆炸式的增长。首先是 Chrome、Firefox 和 Safari 这三种为推动 Web 技术后来的爆炸式发展作出了巨大贡献的浏览器开始出现，各大浏览器厂商对其产品的版本更新迭代速度也开始加快。Web 技术的发展从2008年开始进入了一个“爆炸式”的快速发展阶段，各种各样的新型 Web 浏览器特性和新的 Web 标准以及 ECMAScript 标准如“雨后春笋”般开始涌现出来。XMLHTTPRequest2 技术为 Web 应用的数据传输提供了更方便和高效的传输方式；WebRTC 技术为 Web 应用的实时在线视频／语音直播提供了底层的基础技术解决方案；WebGL 技术为 Web 应用提供了一种可以通过 JavaScript 来操作 Web 版本 OpenGL 的特性，基于 WebGL 暴露出的 JavaScript 接口，我们可以在 Web 网页上高效地绘制3D动画和模型，为在 Web 网页上运行大型 3D 网络游戏提供了可能；IndexedDB 技术为前端应用存储结构化数据并且对数据进行高性能的数据检索提供了支持。除此之外还有很多的 Web 相关技术被实现和标准化，这些技术都无疑大大地拓宽了 Web 应用所能覆盖到的应用领域和场景。也正是自2008年的 HTML5 标准和2009年的 CSS3 标准出现之后，Flash 多媒体应用技术在 Web 开发领域逐渐开始走向了下坡路，直至最后被其他技术取代。由此也可见 Web 领域的技术迭代与更替速度之快。 </p>\n<p><img src=\"2.png\" alt></p>\n<p>JavaScript 作为一门用于开发 Web 端应用的编程语言从1997年发展至今，其所能应用的领域已经不仅仅局限在最原始的基于浏览器的 Web 端应用开发上了。包括 Node.js 在内的等一系列新出现的 JavaScript 运行时环境已经把 JavaScript 的应用场景从前端应用的开发带到了服务端应用的开发。 </p>\n<p>基于 Chrome V8 引擎构建的 Node.js 和 Fib.js 等 JavaScript 运行时环境和框架为后端服务器应用的开发提供了“非阻塞的异步 IO”和“基于事件模型”等新特性。这些新特性可以让我们以开发传统前端 Web 应用的思路来开发服务器端应用。不仅如此，基于 Node.js 开发出来的各种服务端应用框架更是极大的提高了我们开发后端应用的效率。这些框架在一些必要的业务流程上已经为我们做了足够多的封装和优化，这使得我们可以更多的去关注业务逻辑代码上的实现，而不是一些底层细节架构上的事情。但事情并没有这么完美，就拿 Node.js 为例，由于 Node.js 本身是基于 V8 实现的，而 V8 本身所负责的一个最重要的功能就是对 JavaScript 代码进行解析和优化，然后将这些优化后的代码编译成机器码最后运行。因此，无论 Node.js 对 V8 上层的 JavaScript 代码进行了何种系统底层调用流程上的优化，如果最后在 V8 解析和执行 JavaScript 代码时的速度很慢，那么整个应用的运行效率必然会大打折扣。总的来说，Chrome V8、JavaScriptCore 和 SpiderMonkey 等 JavaScript 引擎对 JavaScript 代码的解析和执行效率高低，直接决定了这些基于 JavaScript 开发的前端和服务器端应用的运行流畅程度，进而也直接影响了最前端的产品用户体验。 </p>\n<p>除此之外，变得日益复杂和庞大的 Web 前端应用也带来了更多对 JavaScript 语言性能上的挑战。比如基于 Web 端的视频处理软件、基于 Web 端的大型 3D 游戏、基于 Web 端的在线机器学习（深度学习）训练平台等。这些应用无一例外都需要消耗浏览器大量的计算资源，因此 JavaScript 引擎对 JavaScript 代码的执行效率也直接决定了这些应用能否被流畅地运行。不仅如此，我们都知道通过 JavaScript 来移动或修改页面上的 DOM 节点所付出的成本是巨大的，随着传统Web页面的交互设计变得越来越复杂，这种成本损耗所带来的问题可能会被逐渐放大，这也是我们在未来将要面对的问题 。 </p>\n","site":{"data":{}},"id":"05fc9ba4a8201be732d4dbb230aa52f6","excerpt":"","more":"<p>一般来说，一项新技术是否会随着时代的推进而被快速地迭代和发展，要看这项技术所应用在的实际业务场景中是否有相应的技术需求，毕竟没有任何技术是会被凭空创造出来的。技术决定了业务需求的多样性，而业务需求的多样性又推动着技术不断向前发展，两者相辅相成最终才能推动行业整体的发展和进步。 </p>\n<p>自1991年 HTTP 协议和 HTML 超文本标记语言这两种核心的Web技术诞生以来，Web 开发技术领域便开始不断地发生着翻天覆地的变化。如下图给出的 Web 技术发展史所示，从1991年到2002年的这十年里，Web 技术的发展过程还是比较缓和和稳定的。在这十年的时间里，首先是 NetScape、Opera 和 Internet Explorer（IE）三大浏览器开始逐渐走入人们的视野。一些用于构建更丰富Web应用的基础性技术开始逐渐涌现，比如 Flash 技术从1996年开始可以被应用在浏览器端，这使得传统的Web应用中可以嵌入包含丰富多媒体信息的 Flash 应用，这一发展也使得 Web 应用的交互性和动态性大大的增强。Flash 技术的出现催生了一批以提供视频播放、视频发布和视频分享服务为主的视频服务平台的出现，另一方面同时也推动了基于 Flash 的 Web 页游行业的发展。 </p>\n<p><img src=\"1.png\" alt></p>\n<p>自2002年开始，Web 技术的发展便到了其整个发展历程的“下半场”。从2003年开始一直到2012年的这将近十年的时间里，新型 Web 技术的出现逐渐呈现出了爆炸式的增长。首先是 Chrome、Firefox 和 Safari 这三种为推动 Web 技术后来的爆炸式发展作出了巨大贡献的浏览器开始出现，各大浏览器厂商对其产品的版本更新迭代速度也开始加快。Web 技术的发展从2008年开始进入了一个“爆炸式”的快速发展阶段，各种各样的新型 Web 浏览器特性和新的 Web 标准以及 ECMAScript 标准如“雨后春笋”般开始涌现出来。XMLHTTPRequest2 技术为 Web 应用的数据传输提供了更方便和高效的传输方式；WebRTC 技术为 Web 应用的实时在线视频／语音直播提供了底层的基础技术解决方案；WebGL 技术为 Web 应用提供了一种可以通过 JavaScript 来操作 Web 版本 OpenGL 的特性，基于 WebGL 暴露出的 JavaScript 接口，我们可以在 Web 网页上高效地绘制3D动画和模型，为在 Web 网页上运行大型 3D 网络游戏提供了可能；IndexedDB 技术为前端应用存储结构化数据并且对数据进行高性能的数据检索提供了支持。除此之外还有很多的 Web 相关技术被实现和标准化，这些技术都无疑大大地拓宽了 Web 应用所能覆盖到的应用领域和场景。也正是自2008年的 HTML5 标准和2009年的 CSS3 标准出现之后，Flash 多媒体应用技术在 Web 开发领域逐渐开始走向了下坡路，直至最后被其他技术取代。由此也可见 Web 领域的技术迭代与更替速度之快。 </p>\n<p><img src=\"2.png\" alt></p>\n<p>JavaScript 作为一门用于开发 Web 端应用的编程语言从1997年发展至今，其所能应用的领域已经不仅仅局限在最原始的基于浏览器的 Web 端应用开发上了。包括 Node.js 在内的等一系列新出现的 JavaScript 运行时环境已经把 JavaScript 的应用场景从前端应用的开发带到了服务端应用的开发。 </p>\n<p>基于 Chrome V8 引擎构建的 Node.js 和 Fib.js 等 JavaScript 运行时环境和框架为后端服务器应用的开发提供了“非阻塞的异步 IO”和“基于事件模型”等新特性。这些新特性可以让我们以开发传统前端 Web 应用的思路来开发服务器端应用。不仅如此，基于 Node.js 开发出来的各种服务端应用框架更是极大的提高了我们开发后端应用的效率。这些框架在一些必要的业务流程上已经为我们做了足够多的封装和优化，这使得我们可以更多的去关注业务逻辑代码上的实现，而不是一些底层细节架构上的事情。但事情并没有这么完美，就拿 Node.js 为例，由于 Node.js 本身是基于 V8 实现的，而 V8 本身所负责的一个最重要的功能就是对 JavaScript 代码进行解析和优化，然后将这些优化后的代码编译成机器码最后运行。因此，无论 Node.js 对 V8 上层的 JavaScript 代码进行了何种系统底层调用流程上的优化，如果最后在 V8 解析和执行 JavaScript 代码时的速度很慢，那么整个应用的运行效率必然会大打折扣。总的来说，Chrome V8、JavaScriptCore 和 SpiderMonkey 等 JavaScript 引擎对 JavaScript 代码的解析和执行效率高低，直接决定了这些基于 JavaScript 开发的前端和服务器端应用的运行流畅程度，进而也直接影响了最前端的产品用户体验。 </p>\n<p>除此之外，变得日益复杂和庞大的 Web 前端应用也带来了更多对 JavaScript 语言性能上的挑战。比如基于 Web 端的视频处理软件、基于 Web 端的大型 3D 游戏、基于 Web 端的在线机器学习（深度学习）训练平台等。这些应用无一例外都需要消耗浏览器大量的计算资源，因此 JavaScript 引擎对 JavaScript 代码的执行效率也直接决定了这些应用能否被流畅地运行。不仅如此，我们都知道通过 JavaScript 来移动或修改页面上的 DOM 节点所付出的成本是巨大的，随着传统Web页面的交互设计变得越来越复杂，这种成本损耗所带来的问题可能会被逐渐放大，这也是我们在未来将要面对的问题 。 </p>\n"},{"title":"WebAssembly 尝试研究报告 - API 之初始化、内存和表的分配","intro":"本篇报告我们会花一点时间来详细了解下 WebAssembly JS API 的特性和使用方法。随着 WebAssembly MVP 版本标准的发布，与其对应的 Web API 也有了相应的改动和部分标准化特性。本次报告主要研究 WebAssembly 模块的初始化、内存分配、表分配等相关内容。","comments":1,"date":"2017-06-14T09:46:46.000Z","_content":"\n本篇报告我们会花一点时间来详细了解下 WebAssembly JS API 的特性和使用方法。随着 WebAssembly MVP 版本标准的发布，与其对应的 Web API 也有了相应的改动和部分标准化特性。本次报告主要研究 WebAssembly 模块的初始化、内存分配、表分配等相关内容。\n\n#### 一、加载和初始化：\n\n在浏览器提供的 JavaScript 对象中，WebAssembly 是一个包含所有与 WebAssembly 相关功能的命名空间对象（同 Math 对象一样），因此它并没有构造函数。WebAssembly 包含的一些方法和对象用来加载和初始化 WebAssembly 模块，相关的方法对象列出如下：\n\n \n```javascript\n// 方法；\nWebAssembly.compile();      // 用来从二进制代码编译出一个 WebAssembly.Module 对象；\nWebAssembly.instantiate();  // 初始化一个 WebAssembly.Module 对象，同时传递需要的初始化参数；\nWebAssembly.validate();     // 用来验证对应的二进制代码是否是来自一个完整的 Wasm 模块； \n// 对象（构造函数）；\nWebAssembly.Module();       // WebAssembly.Module 对象的构造函数；\nWebAssembly.Instance();     // WebAssembly.Instance 对象的构造函数；\n```\n\n我们直接通过具体的例子来了解上述几个 API 的使用方法，该例子对应的 C/C++ 代码如下所示。代码很简单，一个预置函数 `print_number` 和一个调用了预置函数的加法函数 `add`，我们只需要在 JS 层初始化 Wasm 模块的时传递一个 `print_number` 函数实体即可。\n\n \n```c\nint print_number (int i);\n\nint add (int a, int b) { \n  print_number(a + b);\n  return a + b;\n}\n```\n\n第一种初始化方式如下代码所示。我们均使用 WebAssembly 对象上的异步方法来进行 Wasm 模块的加载和初始化。整个初始化一共分为三个步骤：**验证，编译，实例化**。不论是通过 WebAssembly 对象的方法还是单独使用 WebAssembly 下各个对象的构造函数来初始化，其整体流程都是一样的。主要区别只是**同步方式**和**异步方式**两种不同的策略而已。\n\n \n```javascript\nvar importObject = {\n  env: {\n    print_number: function(number) {\n      console.log(number);\n    }\n  }\n}\n\nif (WebAssembly.validate(wasmCode)) {\n  WebAssembly.compile(wasmCode).then(module => {\n    WebAssembly.instantiate(module, importObject).then(instance => {\n      var add = instance.exports.add;  // 导出的函数；\n      var memory = instance.exports.memory;   // 获得内存对象；\n      console.log(memory instanceof WebAssembly.Memory);\n      console.log(add(1, 2));\n    });\n  });\n}\n```\n\n第二种初始化使用 WebAssembly 提供的多种构造函数进行同步化的初始化过程，具体代码如下所示。\n\n \n```javascript\nvar importObject = {\n  env: {\n    print_number: function(number) {\n      console.log(number);\n    }\n  }\n}\n\nif (WebAssembly.validate(wasmCode)) {\n  var module = WebAssembly.Module(wasmCode);\n  var instance = WebAssembly.Instance(module, importObject);\n  var add = instance.exports.add;\n  var memory = instance.exports.memory;\n  console.log(memory instanceof WebAssembly.Memory);\n  console.log(add(1, 2));\n}\n```\n\n第三种初始化方式同第一种十分相似，不同的是我们在这里没有首先使用 `WebAssembly.compile` 来编译 Wasm 的二进制代码，而是直接使用 `WebAssembly.instantiate` 对 Wasm 的二进制代码进行了实例化，这便是 `WebAssembly.instantiate` 的第二种使用场景。在第一种方法中，我们在初始化的过程中会产生一个中间对象即 WebAssembly.Module 对象，在这个对象中保存了已经编译好的无状态 WebAssembly 代码，这些代码可以通过 Web Workers 高效的传递给子 Worker 进行使用，或者将其存储在本地的 IndexedDB 当中（最新标准已无法存储），当有需要时可以从本地 DB 中取出多次的进行再实例化（Worker 传递和本地数据存储的相关内容我们会在下一篇报告中讲述）。因此相对来说，第三种初始化方法更适合用于不需要本地存储情况下的快速 WebAssembly 实例化。具体代码如下所示。\n\n \n```javascript\nvar importObject = {\n  env: {\n    print_number: function(number) {\n      console.log(number);\n    }\n  }\n}\n\nif (WebAssembly.validate(wasmCode)) {\n  // 第一个参数直接使用 wasmCode 二进制代码，而非 WebAssembly.Module 对象；\n  WebAssembly.instantiate(wasmCode, importObject).then(result => {\n    var instance = result.instance;\n    var add = instance.exports.add;\n    var memory = instance.exports.memory;\n    console.log(memory instanceof WebAssembly.Memory);\n    console.log(add(1, 2));\n  });\n}\n```\n\n除此之外，WebAssembly.Module 还有两个比较常用的静态方法 `imports` 和 `exports`，可以通过传入一个 WebAssembly.Module 对象来获得该 Wasm 模块的导出接口和需要导入的函数占位符，代码如下。\n\n \n```javascript\nvar wasmModule = new WebAssembly.Module(wasmCode);\nconsole.log(WebAssembly.Module.imports(wasmModule));\nconsole.log(WebAssembly.Module.exports(wasmModule));\n```\n\n#### 二、内存分配：\n\n我们可以在 JS 层为 Wasm 模块手动分配固定大小的内存块供 Wasm 模块来使用，这样做的好处是我们可以使用 JS 在模块编译之前或获取并创建内存的初始内容。为了实现让 Wasm 模块使用我们从 JS 初始化的内存，我们需要手动修改 Wast 文本中的内容。Wast 是 Wasm 模块的可读文本格式，我们首先将编写好的 C/C++ 源码编译成 Wast 可读文本，然后将代码中的内存使用方式改成使用外部引入的内存，最后再通过 WABT 提供的工具将其继续编译成 Wasm 二进制模块格式。Wast 文本中修改内存使用方式的部分示例代码如下，其他代码可以在 [Github](https://github.com/Becavalier/WasmPlay/tree/master/WebAssembly.Memory) 上查阅。关于 Wast 文本的基本语法可以参考 MDN 上的[相关文档](https://developer.mozilla.org/zh-CN/docs/WebAssembly/Understanding_the_text_format)。\n\n \n```wat\n;; 修改前；\n(module\n  (table 0 anyfunc)\n  (memory $0 1)\n  (export \"memory\" (memory $0))\n  (export \"plus\" (func $plus))\n  ...\n)\n```\n\n \n```wat\n;; 修改后；\n(module\n  (import \"env\" \"memory\" (memory $0 1))\n  (table 0 anyfunc)\n  (export \"memory\" (memory $0))\n  (export \"plus\" (func $plus))\n  ... \n)\n```\n\n对应的，我们需要在 JS 中初始化一个内存对象。Wasm 模块使用的所有内存大小都是以“页”作为单位的，默认的一页大小为 64KB，在传递内存对象到 Wasm 模块时至少要保证该内存对象的大小大于等于一页。部分 JS 代码如下所示。\n\n \n```javascript\nvar memory = new WebAssembly.Memory({initial: 2, maximum: 100});\n  var importObject = {\n    env: {\n      memory: memory\n    }\n  } \n)\n```\n\n`WebAssembly.Memory` 构造函数的参数为一个内存对象描述符。其中 `initial` 参数表示该内存对象的初始化大小（以页为单位），`maximum` 参数表示该内存块的最大可用大小（以页为单位）。\n\n#### 三、表分配：\n\nWebAssembly 中的 Table 主要用来存储动态函数的引用。现在来看，Table 的一个主要应用场景是可以在 Wasm 模块之间进行动态链接。也就是说我们可以通过 Table 和 Memory 的共享来使两个 Module 之间通过 Table 进行“交互”。一个简单的使用了 Table 的 Wasm 模块其可读文本代码如下所示。其中第一部分代码指定了该 Table 的大小为2，即最多只能存储两个函数引用。普通函数的声明部分没有任何变化。接下来在元素段中我们为该 Table 分配了两个函数引用，元素段中的代码是 Table 结构的主要初始化过程。由于在调用 Table 中函数时要保证调用函数的函数签名和索引同时正确，该函数才可以被正常调用。\n\n \n```wat\n(module\n  (table 2 anyfunc)                        ;; 指定 Table 大小；\n  (func $f1 (result i32)\n    i32.const 42)\n  (func $f2 (result i32)\n    i32.const 13)\n  (elem (i32.const 0) $f1 $f2)             ;; 元素段，为 Table 分配函数引用 $f1 和 $f2，表空间的起始地址偏移为0；\n  (type $return_i32 (func (result i32)))   ;; 定义函数签名，即 $return_i32 类型为一个返回值为 i32 类型的函数；\n  (func (export \"callByIndex\") (param $i i32) (result i32)\n    get_local $i                           ;; 参数入执行栈；\n    call_indirect $return_i32)             ;; 执行 Table 中索引为 $i 的函数，并且验证签名类型为 $return_i32； \n)\n```\n\n接下来我们来看怎样通过 Table 在两个不同的 Wasm 模块之间进行“通信”。通过同一个 Memory 和 Table 进行初始化的 Wasm 模块便可以共享同一个 Linear Memory 段和同一个 Table，由于 Table 中存储了不同模块不同方法的引用，因此我们便可以通过“间接调用表方法”的方式来达到模块间相互调用其内部暴露方法的目的（跟一个桌面应用的所有 DLL 动态链接库共享同一个进程内存地址一样），首先来看第一个模块的内部结构，如下所示。\n\n \n```wat\n(module\n  (import \"js\" \"memory\" (memory 1))        ;; 使用导入的内存；\n  (import \"js\" \"table\" (table 1 anyfunc))  ;; 使用导入的 Table；\n  (elem (i32.const 0) $shared0func)        ;; 初始化 Table，索引0处放入函数 $shared0func；\n  (func $shared0func (result i32)\n   i32.const 0                             ;; 常量0入执行栈；\n   i32.load)                               ;; 取出执行栈的第一个值作为参数，取出该参数对应内存位置的值；\n)\n```\n\n接下来是第二个模块的内部结构。\n\n \n```wat\n(module\n  (import \"js\" \"memory\" (memory 1))        ;; 使用导入的内存（与第一个模块一样）；\n  (import \"js\" \"table\" (table 1 anyfunc))  ;; 使用导入的 Table（与第一个模块一样）；\n  (type $void_to_i32 (func (result i32)))  \n  (func (export “doIt”) (result i32)\n   i32.const 0                             ;; 常量0入执行栈；\n   i32.const 42                            ;; 常量42入执行栈；\n   i32.store                               ;; 取出执行栈的前两个值作为参数，将常量42存储内存偏移为0的位置；\n   i32.const 0                             ;; 常量0入执行栈；\n   call_indirect $void_to_i32)             ;; 调用 Table 中索引位置为0的函数，并且函数签名中返回值的类型是 i32；\n)\n```\n\n这里要注意的是 Wasm 独有的执行栈与线性内存分离的设计，使得所有的操作数都会被事先放到执行栈中。操作符直接从执行栈中取出对应个数的操作数。这种分离结构也有利于 Wasm 的代码执行安全，保证运行过程中的数据不会被篡改。Wasm 模块间的动态链接过程大致如下图所示。\n\n![](1.png)\n\n当然 Table 的用途不止是可以用来做模块之间的动态链接，还可以做重载函数在 JS 端的调用容器。这些特性我们会在 Post-MVP 阶段再仔细进行研究。\n","source":"_posts/WebAssembly-尝试研究报告-API-之初始化、内存和表的分配.md","raw":"---\ntitle: WebAssembly 尝试研究报告 - API 之初始化、内存和表的分配\nintro: 本篇报告我们会花一点时间来详细了解下 WebAssembly JS API 的特性和使用方法。随着 WebAssembly MVP 版本标准的发布，与其对应的 Web API 也有了相应的改动和部分标准化特性。本次报告主要研究 WebAssembly 模块的初始化、内存分配、表分配等相关内容。\ncomments: true\ndate: 2017-06-14 17:46:46\ntags:\n- WebAssembly\n---\n\n本篇报告我们会花一点时间来详细了解下 WebAssembly JS API 的特性和使用方法。随着 WebAssembly MVP 版本标准的发布，与其对应的 Web API 也有了相应的改动和部分标准化特性。本次报告主要研究 WebAssembly 模块的初始化、内存分配、表分配等相关内容。\n\n#### 一、加载和初始化：\n\n在浏览器提供的 JavaScript 对象中，WebAssembly 是一个包含所有与 WebAssembly 相关功能的命名空间对象（同 Math 对象一样），因此它并没有构造函数。WebAssembly 包含的一些方法和对象用来加载和初始化 WebAssembly 模块，相关的方法对象列出如下：\n\n \n```javascript\n// 方法；\nWebAssembly.compile();      // 用来从二进制代码编译出一个 WebAssembly.Module 对象；\nWebAssembly.instantiate();  // 初始化一个 WebAssembly.Module 对象，同时传递需要的初始化参数；\nWebAssembly.validate();     // 用来验证对应的二进制代码是否是来自一个完整的 Wasm 模块； \n// 对象（构造函数）；\nWebAssembly.Module();       // WebAssembly.Module 对象的构造函数；\nWebAssembly.Instance();     // WebAssembly.Instance 对象的构造函数；\n```\n\n我们直接通过具体的例子来了解上述几个 API 的使用方法，该例子对应的 C/C++ 代码如下所示。代码很简单，一个预置函数 `print_number` 和一个调用了预置函数的加法函数 `add`，我们只需要在 JS 层初始化 Wasm 模块的时传递一个 `print_number` 函数实体即可。\n\n \n```c\nint print_number (int i);\n\nint add (int a, int b) { \n  print_number(a + b);\n  return a + b;\n}\n```\n\n第一种初始化方式如下代码所示。我们均使用 WebAssembly 对象上的异步方法来进行 Wasm 模块的加载和初始化。整个初始化一共分为三个步骤：**验证，编译，实例化**。不论是通过 WebAssembly 对象的方法还是单独使用 WebAssembly 下各个对象的构造函数来初始化，其整体流程都是一样的。主要区别只是**同步方式**和**异步方式**两种不同的策略而已。\n\n \n```javascript\nvar importObject = {\n  env: {\n    print_number: function(number) {\n      console.log(number);\n    }\n  }\n}\n\nif (WebAssembly.validate(wasmCode)) {\n  WebAssembly.compile(wasmCode).then(module => {\n    WebAssembly.instantiate(module, importObject).then(instance => {\n      var add = instance.exports.add;  // 导出的函数；\n      var memory = instance.exports.memory;   // 获得内存对象；\n      console.log(memory instanceof WebAssembly.Memory);\n      console.log(add(1, 2));\n    });\n  });\n}\n```\n\n第二种初始化使用 WebAssembly 提供的多种构造函数进行同步化的初始化过程，具体代码如下所示。\n\n \n```javascript\nvar importObject = {\n  env: {\n    print_number: function(number) {\n      console.log(number);\n    }\n  }\n}\n\nif (WebAssembly.validate(wasmCode)) {\n  var module = WebAssembly.Module(wasmCode);\n  var instance = WebAssembly.Instance(module, importObject);\n  var add = instance.exports.add;\n  var memory = instance.exports.memory;\n  console.log(memory instanceof WebAssembly.Memory);\n  console.log(add(1, 2));\n}\n```\n\n第三种初始化方式同第一种十分相似，不同的是我们在这里没有首先使用 `WebAssembly.compile` 来编译 Wasm 的二进制代码，而是直接使用 `WebAssembly.instantiate` 对 Wasm 的二进制代码进行了实例化，这便是 `WebAssembly.instantiate` 的第二种使用场景。在第一种方法中，我们在初始化的过程中会产生一个中间对象即 WebAssembly.Module 对象，在这个对象中保存了已经编译好的无状态 WebAssembly 代码，这些代码可以通过 Web Workers 高效的传递给子 Worker 进行使用，或者将其存储在本地的 IndexedDB 当中（最新标准已无法存储），当有需要时可以从本地 DB 中取出多次的进行再实例化（Worker 传递和本地数据存储的相关内容我们会在下一篇报告中讲述）。因此相对来说，第三种初始化方法更适合用于不需要本地存储情况下的快速 WebAssembly 实例化。具体代码如下所示。\n\n \n```javascript\nvar importObject = {\n  env: {\n    print_number: function(number) {\n      console.log(number);\n    }\n  }\n}\n\nif (WebAssembly.validate(wasmCode)) {\n  // 第一个参数直接使用 wasmCode 二进制代码，而非 WebAssembly.Module 对象；\n  WebAssembly.instantiate(wasmCode, importObject).then(result => {\n    var instance = result.instance;\n    var add = instance.exports.add;\n    var memory = instance.exports.memory;\n    console.log(memory instanceof WebAssembly.Memory);\n    console.log(add(1, 2));\n  });\n}\n```\n\n除此之外，WebAssembly.Module 还有两个比较常用的静态方法 `imports` 和 `exports`，可以通过传入一个 WebAssembly.Module 对象来获得该 Wasm 模块的导出接口和需要导入的函数占位符，代码如下。\n\n \n```javascript\nvar wasmModule = new WebAssembly.Module(wasmCode);\nconsole.log(WebAssembly.Module.imports(wasmModule));\nconsole.log(WebAssembly.Module.exports(wasmModule));\n```\n\n#### 二、内存分配：\n\n我们可以在 JS 层为 Wasm 模块手动分配固定大小的内存块供 Wasm 模块来使用，这样做的好处是我们可以使用 JS 在模块编译之前或获取并创建内存的初始内容。为了实现让 Wasm 模块使用我们从 JS 初始化的内存，我们需要手动修改 Wast 文本中的内容。Wast 是 Wasm 模块的可读文本格式，我们首先将编写好的 C/C++ 源码编译成 Wast 可读文本，然后将代码中的内存使用方式改成使用外部引入的内存，最后再通过 WABT 提供的工具将其继续编译成 Wasm 二进制模块格式。Wast 文本中修改内存使用方式的部分示例代码如下，其他代码可以在 [Github](https://github.com/Becavalier/WasmPlay/tree/master/WebAssembly.Memory) 上查阅。关于 Wast 文本的基本语法可以参考 MDN 上的[相关文档](https://developer.mozilla.org/zh-CN/docs/WebAssembly/Understanding_the_text_format)。\n\n \n```wat\n;; 修改前；\n(module\n  (table 0 anyfunc)\n  (memory $0 1)\n  (export \"memory\" (memory $0))\n  (export \"plus\" (func $plus))\n  ...\n)\n```\n\n \n```wat\n;; 修改后；\n(module\n  (import \"env\" \"memory\" (memory $0 1))\n  (table 0 anyfunc)\n  (export \"memory\" (memory $0))\n  (export \"plus\" (func $plus))\n  ... \n)\n```\n\n对应的，我们需要在 JS 中初始化一个内存对象。Wasm 模块使用的所有内存大小都是以“页”作为单位的，默认的一页大小为 64KB，在传递内存对象到 Wasm 模块时至少要保证该内存对象的大小大于等于一页。部分 JS 代码如下所示。\n\n \n```javascript\nvar memory = new WebAssembly.Memory({initial: 2, maximum: 100});\n  var importObject = {\n    env: {\n      memory: memory\n    }\n  } \n)\n```\n\n`WebAssembly.Memory` 构造函数的参数为一个内存对象描述符。其中 `initial` 参数表示该内存对象的初始化大小（以页为单位），`maximum` 参数表示该内存块的最大可用大小（以页为单位）。\n\n#### 三、表分配：\n\nWebAssembly 中的 Table 主要用来存储动态函数的引用。现在来看，Table 的一个主要应用场景是可以在 Wasm 模块之间进行动态链接。也就是说我们可以通过 Table 和 Memory 的共享来使两个 Module 之间通过 Table 进行“交互”。一个简单的使用了 Table 的 Wasm 模块其可读文本代码如下所示。其中第一部分代码指定了该 Table 的大小为2，即最多只能存储两个函数引用。普通函数的声明部分没有任何变化。接下来在元素段中我们为该 Table 分配了两个函数引用，元素段中的代码是 Table 结构的主要初始化过程。由于在调用 Table 中函数时要保证调用函数的函数签名和索引同时正确，该函数才可以被正常调用。\n\n \n```wat\n(module\n  (table 2 anyfunc)                        ;; 指定 Table 大小；\n  (func $f1 (result i32)\n    i32.const 42)\n  (func $f2 (result i32)\n    i32.const 13)\n  (elem (i32.const 0) $f1 $f2)             ;; 元素段，为 Table 分配函数引用 $f1 和 $f2，表空间的起始地址偏移为0；\n  (type $return_i32 (func (result i32)))   ;; 定义函数签名，即 $return_i32 类型为一个返回值为 i32 类型的函数；\n  (func (export \"callByIndex\") (param $i i32) (result i32)\n    get_local $i                           ;; 参数入执行栈；\n    call_indirect $return_i32)             ;; 执行 Table 中索引为 $i 的函数，并且验证签名类型为 $return_i32； \n)\n```\n\n接下来我们来看怎样通过 Table 在两个不同的 Wasm 模块之间进行“通信”。通过同一个 Memory 和 Table 进行初始化的 Wasm 模块便可以共享同一个 Linear Memory 段和同一个 Table，由于 Table 中存储了不同模块不同方法的引用，因此我们便可以通过“间接调用表方法”的方式来达到模块间相互调用其内部暴露方法的目的（跟一个桌面应用的所有 DLL 动态链接库共享同一个进程内存地址一样），首先来看第一个模块的内部结构，如下所示。\n\n \n```wat\n(module\n  (import \"js\" \"memory\" (memory 1))        ;; 使用导入的内存；\n  (import \"js\" \"table\" (table 1 anyfunc))  ;; 使用导入的 Table；\n  (elem (i32.const 0) $shared0func)        ;; 初始化 Table，索引0处放入函数 $shared0func；\n  (func $shared0func (result i32)\n   i32.const 0                             ;; 常量0入执行栈；\n   i32.load)                               ;; 取出执行栈的第一个值作为参数，取出该参数对应内存位置的值；\n)\n```\n\n接下来是第二个模块的内部结构。\n\n \n```wat\n(module\n  (import \"js\" \"memory\" (memory 1))        ;; 使用导入的内存（与第一个模块一样）；\n  (import \"js\" \"table\" (table 1 anyfunc))  ;; 使用导入的 Table（与第一个模块一样）；\n  (type $void_to_i32 (func (result i32)))  \n  (func (export “doIt”) (result i32)\n   i32.const 0                             ;; 常量0入执行栈；\n   i32.const 42                            ;; 常量42入执行栈；\n   i32.store                               ;; 取出执行栈的前两个值作为参数，将常量42存储内存偏移为0的位置；\n   i32.const 0                             ;; 常量0入执行栈；\n   call_indirect $void_to_i32)             ;; 调用 Table 中索引位置为0的函数，并且函数签名中返回值的类型是 i32；\n)\n```\n\n这里要注意的是 Wasm 独有的执行栈与线性内存分离的设计，使得所有的操作数都会被事先放到执行栈中。操作符直接从执行栈中取出对应个数的操作数。这种分离结构也有利于 Wasm 的代码执行安全，保证运行过程中的数据不会被篡改。Wasm 模块间的动态链接过程大致如下图所示。\n\n![](1.png)\n\n当然 Table 的用途不止是可以用来做模块之间的动态链接，还可以做重载函数在 JS 端的调用容器。这些特性我们会在 Post-MVP 阶段再仔细进行研究。\n","slug":"WebAssembly-尝试研究报告-API-之初始化、内存和表的分配","published":1,"updated":"2019-02-19T08:35:01.629Z","layout":"post","photos":[],"link":"","_id":"cjsqwhta20043knp2grd6jmak","content":"<p>本篇报告我们会花一点时间来详细了解下 WebAssembly JS API 的特性和使用方法。随着 WebAssembly MVP 版本标准的发布，与其对应的 Web API 也有了相应的改动和部分标准化特性。本次报告主要研究 WebAssembly 模块的初始化、内存分配、表分配等相关内容。</p>\n<h4 id=\"一、加载和初始化：\"><a href=\"#一、加载和初始化：\" class=\"headerlink\" title=\"一、加载和初始化：\"></a>一、加载和初始化：</h4><p>在浏览器提供的 JavaScript 对象中，WebAssembly 是一个包含所有与 WebAssembly 相关功能的命名空间对象（同 Math 对象一样），因此它并没有构造函数。WebAssembly 包含的一些方法和对象用来加载和初始化 WebAssembly 模块，相关的方法对象列出如下：</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">// 方法；</span>\nWebAssembly<span class=\"token punctuation\">.</span><span class=\"token function\">compile</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>      <span class=\"token comment\" spellcheck=\"true\">// 用来从二进制代码编译出一个 WebAssembly.Module 对象；</span>\nWebAssembly<span class=\"token punctuation\">.</span><span class=\"token function\">instantiate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 初始化一个 WebAssembly.Module 对象，同时传递需要的初始化参数；</span>\nWebAssembly<span class=\"token punctuation\">.</span><span class=\"token function\">validate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\" spellcheck=\"true\">// 用来验证对应的二进制代码是否是来自一个完整的 Wasm 模块； </span>\n<span class=\"token comment\" spellcheck=\"true\">// 对象（构造函数）；</span>\nWebAssembly<span class=\"token punctuation\">.</span><span class=\"token function\">Module</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>       <span class=\"token comment\" spellcheck=\"true\">// WebAssembly.Module 对象的构造函数；</span>\nWebAssembly<span class=\"token punctuation\">.</span><span class=\"token function\">Instance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\" spellcheck=\"true\">// WebAssembly.Instance 对象的构造函数；</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>我们直接通过具体的例子来了解上述几个 API 的使用方法，该例子对应的 C/C++ 代码如下所示。代码很简单，一个预置函数 <code>print_number</code> 和一个调用了预置函数的加法函数 <code>add</code>，我们只需要在 JS 层初始化 Wasm 模块的时传递一个 <code>print_number</code> 函数实体即可。</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">print_number</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">add</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n  <span class=\"token function\">print_number</span><span class=\"token punctuation\">(</span>a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>第一种初始化方式如下代码所示。我们均使用 WebAssembly 对象上的异步方法来进行 Wasm 模块的加载和初始化。整个初始化一共分为三个步骤：<strong>验证，编译，实例化</strong>。不论是通过 WebAssembly 对象的方法还是单独使用 WebAssembly 下各个对象的构造函数来初始化，其整体流程都是一样的。主要区别只是<strong>同步方式</strong>和<strong>异步方式</strong>两种不同的策略而已。</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> importObject <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  env<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    print_number<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>number<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>number<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>WebAssembly<span class=\"token punctuation\">.</span><span class=\"token function\">validate</span><span class=\"token punctuation\">(</span>wasmCode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  WebAssembly<span class=\"token punctuation\">.</span><span class=\"token function\">compile</span><span class=\"token punctuation\">(</span>wasmCode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>module <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    WebAssembly<span class=\"token punctuation\">.</span><span class=\"token function\">instantiate</span><span class=\"token punctuation\">(</span>module<span class=\"token punctuation\">,</span> importObject<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>instance <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">var</span> add <span class=\"token operator\">=</span> instance<span class=\"token punctuation\">.</span>exports<span class=\"token punctuation\">.</span>add<span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 导出的函数；</span>\n      <span class=\"token keyword\">var</span> memory <span class=\"token operator\">=</span> instance<span class=\"token punctuation\">.</span>exports<span class=\"token punctuation\">.</span>memory<span class=\"token punctuation\">;</span>   <span class=\"token comment\" spellcheck=\"true\">// 获得内存对象；</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>memory <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">WebAssembly<span class=\"token punctuation\">.</span>Memory</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>第二种初始化使用 WebAssembly 提供的多种构造函数进行同步化的初始化过程，具体代码如下所示。</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> importObject <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  env<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    print_number<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>number<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>number<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>WebAssembly<span class=\"token punctuation\">.</span><span class=\"token function\">validate</span><span class=\"token punctuation\">(</span>wasmCode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> module <span class=\"token operator\">=</span> WebAssembly<span class=\"token punctuation\">.</span><span class=\"token function\">Module</span><span class=\"token punctuation\">(</span>wasmCode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> instance <span class=\"token operator\">=</span> WebAssembly<span class=\"token punctuation\">.</span><span class=\"token function\">Instance</span><span class=\"token punctuation\">(</span>module<span class=\"token punctuation\">,</span> importObject<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> add <span class=\"token operator\">=</span> instance<span class=\"token punctuation\">.</span>exports<span class=\"token punctuation\">.</span>add<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> memory <span class=\"token operator\">=</span> instance<span class=\"token punctuation\">.</span>exports<span class=\"token punctuation\">.</span>memory<span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>memory <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">WebAssembly<span class=\"token punctuation\">.</span>Memory</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>第三种初始化方式同第一种十分相似，不同的是我们在这里没有首先使用 <code>WebAssembly.compile</code> 来编译 Wasm 的二进制代码，而是直接使用 <code>WebAssembly.instantiate</code> 对 Wasm 的二进制代码进行了实例化，这便是 <code>WebAssembly.instantiate</code> 的第二种使用场景。在第一种方法中，我们在初始化的过程中会产生一个中间对象即 WebAssembly.Module 对象，在这个对象中保存了已经编译好的无状态 WebAssembly 代码，这些代码可以通过 Web Workers 高效的传递给子 Worker 进行使用，或者将其存储在本地的 IndexedDB 当中（最新标准已无法存储），当有需要时可以从本地 DB 中取出多次的进行再实例化（Worker 传递和本地数据存储的相关内容我们会在下一篇报告中讲述）。因此相对来说，第三种初始化方法更适合用于不需要本地存储情况下的快速 WebAssembly 实例化。具体代码如下所示。</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> importObject <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  env<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    print_number<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>number<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>number<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>WebAssembly<span class=\"token punctuation\">.</span><span class=\"token function\">validate</span><span class=\"token punctuation\">(</span>wasmCode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 第一个参数直接使用 wasmCode 二进制代码，而非 WebAssembly.Module 对象；</span>\n  WebAssembly<span class=\"token punctuation\">.</span><span class=\"token function\">instantiate</span><span class=\"token punctuation\">(</span>wasmCode<span class=\"token punctuation\">,</span> importObject<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>result <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> instance <span class=\"token operator\">=</span> result<span class=\"token punctuation\">.</span>instance<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> add <span class=\"token operator\">=</span> instance<span class=\"token punctuation\">.</span>exports<span class=\"token punctuation\">.</span>add<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> memory <span class=\"token operator\">=</span> instance<span class=\"token punctuation\">.</span>exports<span class=\"token punctuation\">.</span>memory<span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>memory <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">WebAssembly<span class=\"token punctuation\">.</span>Memory</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>除此之外，WebAssembly.Module 还有两个比较常用的静态方法 <code>imports</code> 和 <code>exports</code>，可以通过传入一个 WebAssembly.Module 对象来获得该 Wasm 模块的导出接口和需要导入的函数占位符，代码如下。</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> wasmModule <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">WebAssembly<span class=\"token punctuation\">.</span>Module</span><span class=\"token punctuation\">(</span>wasmCode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>WebAssembly<span class=\"token punctuation\">.</span>Module<span class=\"token punctuation\">.</span><span class=\"token function\">imports</span><span class=\"token punctuation\">(</span>wasmModule<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>WebAssembly<span class=\"token punctuation\">.</span>Module<span class=\"token punctuation\">.</span><span class=\"token function\">exports</span><span class=\"token punctuation\">(</span>wasmModule<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"二、内存分配：\"><a href=\"#二、内存分配：\" class=\"headerlink\" title=\"二、内存分配：\"></a>二、内存分配：</h4><p>我们可以在 JS 层为 Wasm 模块手动分配固定大小的内存块供 Wasm 模块来使用，这样做的好处是我们可以使用 JS 在模块编译之前或获取并创建内存的初始内容。为了实现让 Wasm 模块使用我们从 JS 初始化的内存，我们需要手动修改 Wast 文本中的内容。Wast 是 Wasm 模块的可读文本格式，我们首先将编写好的 C/C++ 源码编译成 Wast 可读文本，然后将代码中的内存使用方式改成使用外部引入的内存，最后再通过 WABT 提供的工具将其继续编译成 Wasm 二进制模块格式。Wast 文本中修改内存使用方式的部分示例代码如下，其他代码可以在 <a href=\"https://github.com/Becavalier/WasmPlay/tree/master/WebAssembly.Memory\" target=\"_blank\" rel=\"noopener\">Github</a> 上查阅。关于 Wast 文本的基本语法可以参考 MDN 上的<a href=\"https://developer.mozilla.org/zh-CN/docs/WebAssembly/Understanding_the_text_format\" target=\"_blank\" rel=\"noopener\">相关文档</a>。</p>\n<pre class=\"line-numbers language-wat\"><code class=\"language-wat\">;; 修改前；\n(module\n  (table 0 anyfunc)\n  (memory $0 1)\n  (export \"memory\" (memory $0))\n  (export \"plus\" (func $plus))\n  ...\n)\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-wat\"><code class=\"language-wat\">;; 修改后；\n(module\n  (import \"env\" \"memory\" (memory $0 1))\n  (table 0 anyfunc)\n  (export \"memory\" (memory $0))\n  (export \"plus\" (func $plus))\n  ... \n)\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>对应的，我们需要在 JS 中初始化一个内存对象。Wasm 模块使用的所有内存大小都是以“页”作为单位的，默认的一页大小为 64KB，在传递内存对象到 Wasm 模块时至少要保证该内存对象的大小大于等于一页。部分 JS 代码如下所示。</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> memory <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">WebAssembly<span class=\"token punctuation\">.</span>Memory</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>initial<span class=\"token punctuation\">:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> maximum<span class=\"token punctuation\">:</span> <span class=\"token number\">100</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> importObject <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    env<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n      memory<span class=\"token punctuation\">:</span> memory\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span> \n<span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><code>WebAssembly.Memory</code> 构造函数的参数为一个内存对象描述符。其中 <code>initial</code> 参数表示该内存对象的初始化大小（以页为单位），<code>maximum</code> 参数表示该内存块的最大可用大小（以页为单位）。</p>\n<h4 id=\"三、表分配：\"><a href=\"#三、表分配：\" class=\"headerlink\" title=\"三、表分配：\"></a>三、表分配：</h4><p>WebAssembly 中的 Table 主要用来存储动态函数的引用。现在来看，Table 的一个主要应用场景是可以在 Wasm 模块之间进行动态链接。也就是说我们可以通过 Table 和 Memory 的共享来使两个 Module 之间通过 Table 进行“交互”。一个简单的使用了 Table 的 Wasm 模块其可读文本代码如下所示。其中第一部分代码指定了该 Table 的大小为2，即最多只能存储两个函数引用。普通函数的声明部分没有任何变化。接下来在元素段中我们为该 Table 分配了两个函数引用，元素段中的代码是 Table 结构的主要初始化过程。由于在调用 Table 中函数时要保证调用函数的函数签名和索引同时正确，该函数才可以被正常调用。</p>\n<pre class=\"line-numbers language-wat\"><code class=\"language-wat\">(module\n  (table 2 anyfunc)                        ;; 指定 Table 大小；\n  (func $f1 (result i32)\n    i32.const 42)\n  (func $f2 (result i32)\n    i32.const 13)\n  (elem (i32.const 0) $f1 $f2)             ;; 元素段，为 Table 分配函数引用 $f1 和 $f2，表空间的起始地址偏移为0；\n  (type $return_i32 (func (result i32)))   ;; 定义函数签名，即 $return_i32 类型为一个返回值为 i32 类型的函数；\n  (func (export \"callByIndex\") (param $i i32) (result i32)\n    get_local $i                           ;; 参数入执行栈；\n    call_indirect $return_i32)             ;; 执行 Table 中索引为 $i 的函数，并且验证签名类型为 $return_i32； \n)\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>接下来我们来看怎样通过 Table 在两个不同的 Wasm 模块之间进行“通信”。通过同一个 Memory 和 Table 进行初始化的 Wasm 模块便可以共享同一个 Linear Memory 段和同一个 Table，由于 Table 中存储了不同模块不同方法的引用，因此我们便可以通过“间接调用表方法”的方式来达到模块间相互调用其内部暴露方法的目的（跟一个桌面应用的所有 DLL 动态链接库共享同一个进程内存地址一样），首先来看第一个模块的内部结构，如下所示。</p>\n<pre class=\"line-numbers language-wat\"><code class=\"language-wat\">(module\n  (import \"js\" \"memory\" (memory 1))        ;; 使用导入的内存；\n  (import \"js\" \"table\" (table 1 anyfunc))  ;; 使用导入的 Table；\n  (elem (i32.const 0) $shared0func)        ;; 初始化 Table，索引0处放入函数 $shared0func；\n  (func $shared0func (result i32)\n   i32.const 0                             ;; 常量0入执行栈；\n   i32.load)                               ;; 取出执行栈的第一个值作为参数，取出该参数对应内存位置的值；\n)\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>接下来是第二个模块的内部结构。</p>\n<pre class=\"line-numbers language-wat\"><code class=\"language-wat\">(module\n  (import \"js\" \"memory\" (memory 1))        ;; 使用导入的内存（与第一个模块一样）；\n  (import \"js\" \"table\" (table 1 anyfunc))  ;; 使用导入的 Table（与第一个模块一样）；\n  (type $void_to_i32 (func (result i32)))  \n  (func (export “doIt”) (result i32)\n   i32.const 0                             ;; 常量0入执行栈；\n   i32.const 42                            ;; 常量42入执行栈；\n   i32.store                               ;; 取出执行栈的前两个值作为参数，将常量42存储内存偏移为0的位置；\n   i32.const 0                             ;; 常量0入执行栈；\n   call_indirect $void_to_i32)             ;; 调用 Table 中索引位置为0的函数，并且函数签名中返回值的类型是 i32；\n)\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这里要注意的是 Wasm 独有的执行栈与线性内存分离的设计，使得所有的操作数都会被事先放到执行栈中。操作符直接从执行栈中取出对应个数的操作数。这种分离结构也有利于 Wasm 的代码执行安全，保证运行过程中的数据不会被篡改。Wasm 模块间的动态链接过程大致如下图所示。</p>\n<p><img src=\"1.png\" alt></p>\n<p>当然 Table 的用途不止是可以用来做模块之间的动态链接，还可以做重载函数在 JS 端的调用容器。这些特性我们会在 Post-MVP 阶段再仔细进行研究。</p>\n","site":{"data":{}},"id":"6af206554a5993464f55e01191943be9","excerpt":"","more":"<p>本篇报告我们会花一点时间来详细了解下 WebAssembly JS API 的特性和使用方法。随着 WebAssembly MVP 版本标准的发布，与其对应的 Web API 也有了相应的改动和部分标准化特性。本次报告主要研究 WebAssembly 模块的初始化、内存分配、表分配等相关内容。</p>\n<h4 id=\"一、加载和初始化：\"><a href=\"#一、加载和初始化：\" class=\"headerlink\" title=\"一、加载和初始化：\"></a>一、加载和初始化：</h4><p>在浏览器提供的 JavaScript 对象中，WebAssembly 是一个包含所有与 WebAssembly 相关功能的命名空间对象（同 Math 对象一样），因此它并没有构造函数。WebAssembly 包含的一些方法和对象用来加载和初始化 WebAssembly 模块，相关的方法对象列出如下：</p>\n<pre><code class=\"javascript\">// 方法；\nWebAssembly.compile();      // 用来从二进制代码编译出一个 WebAssembly.Module 对象；\nWebAssembly.instantiate();  // 初始化一个 WebAssembly.Module 对象，同时传递需要的初始化参数；\nWebAssembly.validate();     // 用来验证对应的二进制代码是否是来自一个完整的 Wasm 模块； \n// 对象（构造函数）；\nWebAssembly.Module();       // WebAssembly.Module 对象的构造函数；\nWebAssembly.Instance();     // WebAssembly.Instance 对象的构造函数；\n</code></pre>\n<p>我们直接通过具体的例子来了解上述几个 API 的使用方法，该例子对应的 C/C++ 代码如下所示。代码很简单，一个预置函数 <code>print_number</code> 和一个调用了预置函数的加法函数 <code>add</code>，我们只需要在 JS 层初始化 Wasm 模块的时传递一个 <code>print_number</code> 函数实体即可。</p>\n<pre><code class=\"c\">int print_number (int i);\n\nint add (int a, int b) { \n  print_number(a + b);\n  return a + b;\n}\n</code></pre>\n<p>第一种初始化方式如下代码所示。我们均使用 WebAssembly 对象上的异步方法来进行 Wasm 模块的加载和初始化。整个初始化一共分为三个步骤：<strong>验证，编译，实例化</strong>。不论是通过 WebAssembly 对象的方法还是单独使用 WebAssembly 下各个对象的构造函数来初始化，其整体流程都是一样的。主要区别只是<strong>同步方式</strong>和<strong>异步方式</strong>两种不同的策略而已。</p>\n<pre><code class=\"javascript\">var importObject = {\n  env: {\n    print_number: function(number) {\n      console.log(number);\n    }\n  }\n}\n\nif (WebAssembly.validate(wasmCode)) {\n  WebAssembly.compile(wasmCode).then(module =&gt; {\n    WebAssembly.instantiate(module, importObject).then(instance =&gt; {\n      var add = instance.exports.add;  // 导出的函数；\n      var memory = instance.exports.memory;   // 获得内存对象；\n      console.log(memory instanceof WebAssembly.Memory);\n      console.log(add(1, 2));\n    });\n  });\n}\n</code></pre>\n<p>第二种初始化使用 WebAssembly 提供的多种构造函数进行同步化的初始化过程，具体代码如下所示。</p>\n<pre><code class=\"javascript\">var importObject = {\n  env: {\n    print_number: function(number) {\n      console.log(number);\n    }\n  }\n}\n\nif (WebAssembly.validate(wasmCode)) {\n  var module = WebAssembly.Module(wasmCode);\n  var instance = WebAssembly.Instance(module, importObject);\n  var add = instance.exports.add;\n  var memory = instance.exports.memory;\n  console.log(memory instanceof WebAssembly.Memory);\n  console.log(add(1, 2));\n}\n</code></pre>\n<p>第三种初始化方式同第一种十分相似，不同的是我们在这里没有首先使用 <code>WebAssembly.compile</code> 来编译 Wasm 的二进制代码，而是直接使用 <code>WebAssembly.instantiate</code> 对 Wasm 的二进制代码进行了实例化，这便是 <code>WebAssembly.instantiate</code> 的第二种使用场景。在第一种方法中，我们在初始化的过程中会产生一个中间对象即 WebAssembly.Module 对象，在这个对象中保存了已经编译好的无状态 WebAssembly 代码，这些代码可以通过 Web Workers 高效的传递给子 Worker 进行使用，或者将其存储在本地的 IndexedDB 当中（最新标准已无法存储），当有需要时可以从本地 DB 中取出多次的进行再实例化（Worker 传递和本地数据存储的相关内容我们会在下一篇报告中讲述）。因此相对来说，第三种初始化方法更适合用于不需要本地存储情况下的快速 WebAssembly 实例化。具体代码如下所示。</p>\n<pre><code class=\"javascript\">var importObject = {\n  env: {\n    print_number: function(number) {\n      console.log(number);\n    }\n  }\n}\n\nif (WebAssembly.validate(wasmCode)) {\n  // 第一个参数直接使用 wasmCode 二进制代码，而非 WebAssembly.Module 对象；\n  WebAssembly.instantiate(wasmCode, importObject).then(result =&gt; {\n    var instance = result.instance;\n    var add = instance.exports.add;\n    var memory = instance.exports.memory;\n    console.log(memory instanceof WebAssembly.Memory);\n    console.log(add(1, 2));\n  });\n}\n</code></pre>\n<p>除此之外，WebAssembly.Module 还有两个比较常用的静态方法 <code>imports</code> 和 <code>exports</code>，可以通过传入一个 WebAssembly.Module 对象来获得该 Wasm 模块的导出接口和需要导入的函数占位符，代码如下。</p>\n<pre><code class=\"javascript\">var wasmModule = new WebAssembly.Module(wasmCode);\nconsole.log(WebAssembly.Module.imports(wasmModule));\nconsole.log(WebAssembly.Module.exports(wasmModule));\n</code></pre>\n<h4 id=\"二、内存分配：\"><a href=\"#二、内存分配：\" class=\"headerlink\" title=\"二、内存分配：\"></a>二、内存分配：</h4><p>我们可以在 JS 层为 Wasm 模块手动分配固定大小的内存块供 Wasm 模块来使用，这样做的好处是我们可以使用 JS 在模块编译之前或获取并创建内存的初始内容。为了实现让 Wasm 模块使用我们从 JS 初始化的内存，我们需要手动修改 Wast 文本中的内容。Wast 是 Wasm 模块的可读文本格式，我们首先将编写好的 C/C++ 源码编译成 Wast 可读文本，然后将代码中的内存使用方式改成使用外部引入的内存，最后再通过 WABT 提供的工具将其继续编译成 Wasm 二进制模块格式。Wast 文本中修改内存使用方式的部分示例代码如下，其他代码可以在 <a href=\"https://github.com/Becavalier/WasmPlay/tree/master/WebAssembly.Memory\" target=\"_blank\" rel=\"noopener\">Github</a> 上查阅。关于 Wast 文本的基本语法可以参考 MDN 上的<a href=\"https://developer.mozilla.org/zh-CN/docs/WebAssembly/Understanding_the_text_format\" target=\"_blank\" rel=\"noopener\">相关文档</a>。</p>\n<pre><code class=\"wat\">;; 修改前；\n(module\n  (table 0 anyfunc)\n  (memory $0 1)\n  (export &quot;memory&quot; (memory $0))\n  (export &quot;plus&quot; (func $plus))\n  ...\n)\n</code></pre>\n<pre><code class=\"wat\">;; 修改后；\n(module\n  (import &quot;env&quot; &quot;memory&quot; (memory $0 1))\n  (table 0 anyfunc)\n  (export &quot;memory&quot; (memory $0))\n  (export &quot;plus&quot; (func $plus))\n  ... \n)\n</code></pre>\n<p>对应的，我们需要在 JS 中初始化一个内存对象。Wasm 模块使用的所有内存大小都是以“页”作为单位的，默认的一页大小为 64KB，在传递内存对象到 Wasm 模块时至少要保证该内存对象的大小大于等于一页。部分 JS 代码如下所示。</p>\n<pre><code class=\"javascript\">var memory = new WebAssembly.Memory({initial: 2, maximum: 100});\n  var importObject = {\n    env: {\n      memory: memory\n    }\n  } \n)\n</code></pre>\n<p><code>WebAssembly.Memory</code> 构造函数的参数为一个内存对象描述符。其中 <code>initial</code> 参数表示该内存对象的初始化大小（以页为单位），<code>maximum</code> 参数表示该内存块的最大可用大小（以页为单位）。</p>\n<h4 id=\"三、表分配：\"><a href=\"#三、表分配：\" class=\"headerlink\" title=\"三、表分配：\"></a>三、表分配：</h4><p>WebAssembly 中的 Table 主要用来存储动态函数的引用。现在来看，Table 的一个主要应用场景是可以在 Wasm 模块之间进行动态链接。也就是说我们可以通过 Table 和 Memory 的共享来使两个 Module 之间通过 Table 进行“交互”。一个简单的使用了 Table 的 Wasm 模块其可读文本代码如下所示。其中第一部分代码指定了该 Table 的大小为2，即最多只能存储两个函数引用。普通函数的声明部分没有任何变化。接下来在元素段中我们为该 Table 分配了两个函数引用，元素段中的代码是 Table 结构的主要初始化过程。由于在调用 Table 中函数时要保证调用函数的函数签名和索引同时正确，该函数才可以被正常调用。</p>\n<pre><code class=\"wat\">(module\n  (table 2 anyfunc)                        ;; 指定 Table 大小；\n  (func $f1 (result i32)\n    i32.const 42)\n  (func $f2 (result i32)\n    i32.const 13)\n  (elem (i32.const 0) $f1 $f2)             ;; 元素段，为 Table 分配函数引用 $f1 和 $f2，表空间的起始地址偏移为0；\n  (type $return_i32 (func (result i32)))   ;; 定义函数签名，即 $return_i32 类型为一个返回值为 i32 类型的函数；\n  (func (export &quot;callByIndex&quot;) (param $i i32) (result i32)\n    get_local $i                           ;; 参数入执行栈；\n    call_indirect $return_i32)             ;; 执行 Table 中索引为 $i 的函数，并且验证签名类型为 $return_i32； \n)\n</code></pre>\n<p>接下来我们来看怎样通过 Table 在两个不同的 Wasm 模块之间进行“通信”。通过同一个 Memory 和 Table 进行初始化的 Wasm 模块便可以共享同一个 Linear Memory 段和同一个 Table，由于 Table 中存储了不同模块不同方法的引用，因此我们便可以通过“间接调用表方法”的方式来达到模块间相互调用其内部暴露方法的目的（跟一个桌面应用的所有 DLL 动态链接库共享同一个进程内存地址一样），首先来看第一个模块的内部结构，如下所示。</p>\n<pre><code class=\"wat\">(module\n  (import &quot;js&quot; &quot;memory&quot; (memory 1))        ;; 使用导入的内存；\n  (import &quot;js&quot; &quot;table&quot; (table 1 anyfunc))  ;; 使用导入的 Table；\n  (elem (i32.const 0) $shared0func)        ;; 初始化 Table，索引0处放入函数 $shared0func；\n  (func $shared0func (result i32)\n   i32.const 0                             ;; 常量0入执行栈；\n   i32.load)                               ;; 取出执行栈的第一个值作为参数，取出该参数对应内存位置的值；\n)\n</code></pre>\n<p>接下来是第二个模块的内部结构。</p>\n<pre><code class=\"wat\">(module\n  (import &quot;js&quot; &quot;memory&quot; (memory 1))        ;; 使用导入的内存（与第一个模块一样）；\n  (import &quot;js&quot; &quot;table&quot; (table 1 anyfunc))  ;; 使用导入的 Table（与第一个模块一样）；\n  (type $void_to_i32 (func (result i32)))  \n  (func (export “doIt”) (result i32)\n   i32.const 0                             ;; 常量0入执行栈；\n   i32.const 42                            ;; 常量42入执行栈；\n   i32.store                               ;; 取出执行栈的前两个值作为参数，将常量42存储内存偏移为0的位置；\n   i32.const 0                             ;; 常量0入执行栈；\n   call_indirect $void_to_i32)             ;; 调用 Table 中索引位置为0的函数，并且函数签名中返回值的类型是 i32；\n)\n</code></pre>\n<p>这里要注意的是 Wasm 独有的执行栈与线性内存分离的设计，使得所有的操作数都会被事先放到执行栈中。操作符直接从执行栈中取出对应个数的操作数。这种分离结构也有利于 Wasm 的代码执行安全，保证运行过程中的数据不会被篡改。Wasm 模块间的动态链接过程大致如下图所示。</p>\n<p><img src=\"1.png\" alt></p>\n<p>当然 Table 的用途不止是可以用来做模块之间的动态链接，还可以做重载函数在 JS 端的调用容器。这些特性我们会在 Post-MVP 阶段再仔细进行研究。</p>\n"},{"title":"WebAssembly 尝试研究报告（三）","intro":"在前两次的研究报告，我们中主要介绍了 WebAssembly 在代码方面的应用与编译运行的基本流程。抛开复杂的开发编译工具链，我们来看一看 WebAssembly 底层的实现机制和原理。在编译器层面，WebAssembly 到底做了哪些事情，提供了怎样的优化？这些优化是怎样作用于实际的代码中的？让我们一起来研究一下。","comments":1,"date":"2017-06-11T03:29:52.000Z","_content":"\n在前两次的研究报告，我们中主要介绍了 WebAssembly 在代码方面的应用与编译运行的基本流程。抛开复杂的开发编译工具链，我们来看一看 WebAssembly 底层的实现机制和原理。在编译器层面，WebAssembly 到底做了哪些事情，提供了怎样的优化？这些优化是怎样作用于实际的代码中的？让我们一起来研究一下。\n\n“WebAssembly 是一种全新的二进制代码格式，我们可以把类似 C/C++ 等静态类型语言的源代码编译成 WebAssembly 格式，以便将其运行在浏览器环境当中。”这段话是官方对 WebAssembly 的解释，我在这里将它翻译过来。接下来我们会针对这段话展开深入的分析，从编译器底层、编程语言等方面来探讨 WebAssembly 的秘密。\n\n首先，我们要知道静态类型语言和动态类型语言的区别。动态类型语言是指在代码运行期间检查数据类型的语言，用这类语言编程，在编写代码时不会给变量指定类型，而是在解释运行到该句代码时通过一系列的上下文判断来推断得出该变量的实际数据类型。而静态类型语言正好相反，这类语言需要在运行前进行编译时检查变量的类型。解释器和编译器，解释器的启动和执行速度较快，但由于解释器是采用“逐行”的方式来解释运行代码，因此在遇到类似循环等操作时，同一段代码在每次运行前都需要进行解释，大大降低了程序运行的性能。编译器则正好相反，在代码运行前，编译器需要一段时间来对代码进行编译，但在编译过程中可以对源代码的结构进行优化。为了解决解释器的低效问题，包括 V8 在内的众多优秀的 JS 引擎开始把静态编译器纳入自身的引擎系统中，这便形成了一套全新的编译器架构 - JIT 编译器模式。\n\nJIT 编译器的核心优化机制是 PGO（Profile Guided Optimization）。PGO 的基本原理是：在解释器解释运行代码期间会根据每行代码的执行次数不同，分别为每行代码做不同的标记（warm / hot）。warm 代表该行代码运行次数较多，而 hot 则表示该行代码在单位时间内运行的次数比 warm 更多。如果一段代码被标记为 warm，那么 JIT 就会把该段代码送到基线编译器（Baseline Compiler）去进行编译。由于基线编译器只能在短时间内进行局部的优化，因此被标记为 hot 的代码段随后还会被送到“优化编译器”进行再次的优化。在 V8 中，所有被标记的代码都会首先送到 “full-codegen” 基线编译器进行优化，被标记为 hot 甚至是 very hot 的代码段会被送到 “Crankshaft” 或者 “Turbofan” 优化编译器进行再次的优化。编译器在编译对应代码段时还会在本地存储已编译好的版本，这样下次再遇到同样的代码段便可以直接使用，省去了重新编译的时间。\n\n#### 1. 传统 JS 引擎的工作流程：\n\n \n```javascript\nfunction add(a, b) {\n  return a + b;\n}\n```\n\n对于上述给出的这段简短的 JS 代码，引擎在遇到加号 “+” 运算符时，并不是直接将两个变量的值相加。由于我们在程序运行前无法判断加号运算符两侧传入变量值的实际类型，因此也就无法判断是应该将两个变量的值当作数值(整型、浮点型)相加还是应该当作字符串进行拼接，甚至是当作对象来进行处理。JS 引擎会根据 ECMAScript 的标准来对加号运算符进行一系列判断才能够得到最后的运算结果。对应加号运算符的 ECMAScript 标准如下图所示（图片来自 Google IO 2017）：\n\n![](1.png)\n\n可以看到，传统的 JS 引擎在解析代码时会经过复杂的类型判断过程才能得到最终的计算结果，而这使得动态语言的代码执行效率被大大降低。\n\n![](2.png)\n\n我们以 V8 的 Pipeline 结构来讲解 JS 引擎处理代码的基本过程。首先，JS 引擎会分析源代码的结构并生成一个 AST（抽象语法树），该 AST 展示了源程序的逻辑结构在内存中的抽象表现形式。接下来，AST 经过一个 “full-codegen” 全代码编译器前端被直接编译成了未经优化的中间表示层（IR）代码。在得到了 IR 代码后，V8 的优化编译器 “TurboFan” 会继续分析 JS 源码来找出那些运行速度较慢的源码并再次对它们进行优化。这个过程结束之后，再将经过处理的 IR（Intermediate Representation） 层代码经过一个编译器后端重新生成优化后的机器码。\n\n在基于 ASM.js 的优化流程中，最后生成的 ASM.js 代码属于 JS 的一个子集，因此最后被 JS 引擎解释时同样还需要经过分析代码、生成 AST 和重新优化等过程，而这些过程都是需要消耗 CPU 资源的，因此这种优化只能在某种程度上改善性能。而 WebAssembly 则直接从一个编译器后端进行加载，省去了所有编译器前端包括代码分析、生成 AST 、代码编译和优化在内的一系列过程。因此相较于 ASM.js 可以大大提高代码的执行效率。\n\n另一方面，对于实现同样功能的一段 C/C++ 代码，WebAssembly 二进制格式的体积会比压缩后的 ASM.js 体积小很多。WebAssembly 在浏览器中会运行在自己独立的沙盒环境当中，因此也无需担心内存数据泄露等安全性问题。\n\n![](3.png)\n\n接下来我们来看一下 WebAssembly 的内存模型。WebAssembly 代码对应的程序会被运行在一块连续的内存上，但其执行堆栈却完全从 WebAssembly 程序的内存段中独立出来，在执行堆栈中存储着 WebAssembly 程序当前需要用到的变量的值。由于执行堆栈的分离使得我们无法通过读取或改变 WebAssembly 程序所在内存段数据来改变各个变量的值，而这为 WebAssembly 的安全性提供了保障。\n","source":"_posts/WebAssembly-尝试研究报告（三）.md","raw":"---\ntitle: WebAssembly 尝试研究报告（三）\nintro: 在前两次的研究报告，我们中主要介绍了 WebAssembly 在代码方面的应用与编译运行的基本流程。抛开复杂的开发编译工具链，我们来看一看 WebAssembly 底层的实现机制和原理。在编译器层面，WebAssembly 到底做了哪些事情，提供了怎样的优化？这些优化是怎样作用于实际的代码中的？让我们一起来研究一下。\ncomments: true\ndate: 2017-06-11 11:29:52\ntags:\n- WebAssembly\n---\n\n在前两次的研究报告，我们中主要介绍了 WebAssembly 在代码方面的应用与编译运行的基本流程。抛开复杂的开发编译工具链，我们来看一看 WebAssembly 底层的实现机制和原理。在编译器层面，WebAssembly 到底做了哪些事情，提供了怎样的优化？这些优化是怎样作用于实际的代码中的？让我们一起来研究一下。\n\n“WebAssembly 是一种全新的二进制代码格式，我们可以把类似 C/C++ 等静态类型语言的源代码编译成 WebAssembly 格式，以便将其运行在浏览器环境当中。”这段话是官方对 WebAssembly 的解释，我在这里将它翻译过来。接下来我们会针对这段话展开深入的分析，从编译器底层、编程语言等方面来探讨 WebAssembly 的秘密。\n\n首先，我们要知道静态类型语言和动态类型语言的区别。动态类型语言是指在代码运行期间检查数据类型的语言，用这类语言编程，在编写代码时不会给变量指定类型，而是在解释运行到该句代码时通过一系列的上下文判断来推断得出该变量的实际数据类型。而静态类型语言正好相反，这类语言需要在运行前进行编译时检查变量的类型。解释器和编译器，解释器的启动和执行速度较快，但由于解释器是采用“逐行”的方式来解释运行代码，因此在遇到类似循环等操作时，同一段代码在每次运行前都需要进行解释，大大降低了程序运行的性能。编译器则正好相反，在代码运行前，编译器需要一段时间来对代码进行编译，但在编译过程中可以对源代码的结构进行优化。为了解决解释器的低效问题，包括 V8 在内的众多优秀的 JS 引擎开始把静态编译器纳入自身的引擎系统中，这便形成了一套全新的编译器架构 - JIT 编译器模式。\n\nJIT 编译器的核心优化机制是 PGO（Profile Guided Optimization）。PGO 的基本原理是：在解释器解释运行代码期间会根据每行代码的执行次数不同，分别为每行代码做不同的标记（warm / hot）。warm 代表该行代码运行次数较多，而 hot 则表示该行代码在单位时间内运行的次数比 warm 更多。如果一段代码被标记为 warm，那么 JIT 就会把该段代码送到基线编译器（Baseline Compiler）去进行编译。由于基线编译器只能在短时间内进行局部的优化，因此被标记为 hot 的代码段随后还会被送到“优化编译器”进行再次的优化。在 V8 中，所有被标记的代码都会首先送到 “full-codegen” 基线编译器进行优化，被标记为 hot 甚至是 very hot 的代码段会被送到 “Crankshaft” 或者 “Turbofan” 优化编译器进行再次的优化。编译器在编译对应代码段时还会在本地存储已编译好的版本，这样下次再遇到同样的代码段便可以直接使用，省去了重新编译的时间。\n\n#### 1. 传统 JS 引擎的工作流程：\n\n \n```javascript\nfunction add(a, b) {\n  return a + b;\n}\n```\n\n对于上述给出的这段简短的 JS 代码，引擎在遇到加号 “+” 运算符时，并不是直接将两个变量的值相加。由于我们在程序运行前无法判断加号运算符两侧传入变量值的实际类型，因此也就无法判断是应该将两个变量的值当作数值(整型、浮点型)相加还是应该当作字符串进行拼接，甚至是当作对象来进行处理。JS 引擎会根据 ECMAScript 的标准来对加号运算符进行一系列判断才能够得到最后的运算结果。对应加号运算符的 ECMAScript 标准如下图所示（图片来自 Google IO 2017）：\n\n![](1.png)\n\n可以看到，传统的 JS 引擎在解析代码时会经过复杂的类型判断过程才能得到最终的计算结果，而这使得动态语言的代码执行效率被大大降低。\n\n![](2.png)\n\n我们以 V8 的 Pipeline 结构来讲解 JS 引擎处理代码的基本过程。首先，JS 引擎会分析源代码的结构并生成一个 AST（抽象语法树），该 AST 展示了源程序的逻辑结构在内存中的抽象表现形式。接下来，AST 经过一个 “full-codegen” 全代码编译器前端被直接编译成了未经优化的中间表示层（IR）代码。在得到了 IR 代码后，V8 的优化编译器 “TurboFan” 会继续分析 JS 源码来找出那些运行速度较慢的源码并再次对它们进行优化。这个过程结束之后，再将经过处理的 IR（Intermediate Representation） 层代码经过一个编译器后端重新生成优化后的机器码。\n\n在基于 ASM.js 的优化流程中，最后生成的 ASM.js 代码属于 JS 的一个子集，因此最后被 JS 引擎解释时同样还需要经过分析代码、生成 AST 和重新优化等过程，而这些过程都是需要消耗 CPU 资源的，因此这种优化只能在某种程度上改善性能。而 WebAssembly 则直接从一个编译器后端进行加载，省去了所有编译器前端包括代码分析、生成 AST 、代码编译和优化在内的一系列过程。因此相较于 ASM.js 可以大大提高代码的执行效率。\n\n另一方面，对于实现同样功能的一段 C/C++ 代码，WebAssembly 二进制格式的体积会比压缩后的 ASM.js 体积小很多。WebAssembly 在浏览器中会运行在自己独立的沙盒环境当中，因此也无需担心内存数据泄露等安全性问题。\n\n![](3.png)\n\n接下来我们来看一下 WebAssembly 的内存模型。WebAssembly 代码对应的程序会被运行在一块连续的内存上，但其执行堆栈却完全从 WebAssembly 程序的内存段中独立出来，在执行堆栈中存储着 WebAssembly 程序当前需要用到的变量的值。由于执行堆栈的分离使得我们无法通过读取或改变 WebAssembly 程序所在内存段数据来改变各个变量的值，而这为 WebAssembly 的安全性提供了保障。\n","slug":"WebAssembly-尝试研究报告（三）","published":1,"updated":"2019-02-19T06:37:26.142Z","layout":"post","photos":[],"link":"","_id":"cjsqwhta30045knp2vmo9vocz","content":"<p>在前两次的研究报告，我们中主要介绍了 WebAssembly 在代码方面的应用与编译运行的基本流程。抛开复杂的开发编译工具链，我们来看一看 WebAssembly 底层的实现机制和原理。在编译器层面，WebAssembly 到底做了哪些事情，提供了怎样的优化？这些优化是怎样作用于实际的代码中的？让我们一起来研究一下。</p>\n<p>“WebAssembly 是一种全新的二进制代码格式，我们可以把类似 C/C++ 等静态类型语言的源代码编译成 WebAssembly 格式，以便将其运行在浏览器环境当中。”这段话是官方对 WebAssembly 的解释，我在这里将它翻译过来。接下来我们会针对这段话展开深入的分析，从编译器底层、编程语言等方面来探讨 WebAssembly 的秘密。</p>\n<p>首先，我们要知道静态类型语言和动态类型语言的区别。动态类型语言是指在代码运行期间检查数据类型的语言，用这类语言编程，在编写代码时不会给变量指定类型，而是在解释运行到该句代码时通过一系列的上下文判断来推断得出该变量的实际数据类型。而静态类型语言正好相反，这类语言需要在运行前进行编译时检查变量的类型。解释器和编译器，解释器的启动和执行速度较快，但由于解释器是采用“逐行”的方式来解释运行代码，因此在遇到类似循环等操作时，同一段代码在每次运行前都需要进行解释，大大降低了程序运行的性能。编译器则正好相反，在代码运行前，编译器需要一段时间来对代码进行编译，但在编译过程中可以对源代码的结构进行优化。为了解决解释器的低效问题，包括 V8 在内的众多优秀的 JS 引擎开始把静态编译器纳入自身的引擎系统中，这便形成了一套全新的编译器架构 - JIT 编译器模式。</p>\n<p>JIT 编译器的核心优化机制是 PGO（Profile Guided Optimization）。PGO 的基本原理是：在解释器解释运行代码期间会根据每行代码的执行次数不同，分别为每行代码做不同的标记（warm / hot）。warm 代表该行代码运行次数较多，而 hot 则表示该行代码在单位时间内运行的次数比 warm 更多。如果一段代码被标记为 warm，那么 JIT 就会把该段代码送到基线编译器（Baseline Compiler）去进行编译。由于基线编译器只能在短时间内进行局部的优化，因此被标记为 hot 的代码段随后还会被送到“优化编译器”进行再次的优化。在 V8 中，所有被标记的代码都会首先送到 “full-codegen” 基线编译器进行优化，被标记为 hot 甚至是 very hot 的代码段会被送到 “Crankshaft” 或者 “Turbofan” 优化编译器进行再次的优化。编译器在编译对应代码段时还会在本地存储已编译好的版本，这样下次再遇到同样的代码段便可以直接使用，省去了重新编译的时间。</p>\n<h4 id=\"1-传统-JS-引擎的工作流程：\"><a href=\"#1-传统-JS-引擎的工作流程：\" class=\"headerlink\" title=\"1. 传统 JS 引擎的工作流程：\"></a>1. 传统 JS 引擎的工作流程：</h4><pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>对于上述给出的这段简短的 JS 代码，引擎在遇到加号 “+” 运算符时，并不是直接将两个变量的值相加。由于我们在程序运行前无法判断加号运算符两侧传入变量值的实际类型，因此也就无法判断是应该将两个变量的值当作数值(整型、浮点型)相加还是应该当作字符串进行拼接，甚至是当作对象来进行处理。JS 引擎会根据 ECMAScript 的标准来对加号运算符进行一系列判断才能够得到最后的运算结果。对应加号运算符的 ECMAScript 标准如下图所示（图片来自 Google IO 2017）：</p>\n<p><img src=\"1.png\" alt></p>\n<p>可以看到，传统的 JS 引擎在解析代码时会经过复杂的类型判断过程才能得到最终的计算结果，而这使得动态语言的代码执行效率被大大降低。</p>\n<p><img src=\"2.png\" alt></p>\n<p>我们以 V8 的 Pipeline 结构来讲解 JS 引擎处理代码的基本过程。首先，JS 引擎会分析源代码的结构并生成一个 AST（抽象语法树），该 AST 展示了源程序的逻辑结构在内存中的抽象表现形式。接下来，AST 经过一个 “full-codegen” 全代码编译器前端被直接编译成了未经优化的中间表示层（IR）代码。在得到了 IR 代码后，V8 的优化编译器 “TurboFan” 会继续分析 JS 源码来找出那些运行速度较慢的源码并再次对它们进行优化。这个过程结束之后，再将经过处理的 IR（Intermediate Representation） 层代码经过一个编译器后端重新生成优化后的机器码。</p>\n<p>在基于 ASM.js 的优化流程中，最后生成的 ASM.js 代码属于 JS 的一个子集，因此最后被 JS 引擎解释时同样还需要经过分析代码、生成 AST 和重新优化等过程，而这些过程都是需要消耗 CPU 资源的，因此这种优化只能在某种程度上改善性能。而 WebAssembly 则直接从一个编译器后端进行加载，省去了所有编译器前端包括代码分析、生成 AST 、代码编译和优化在内的一系列过程。因此相较于 ASM.js 可以大大提高代码的执行效率。</p>\n<p>另一方面，对于实现同样功能的一段 C/C++ 代码，WebAssembly 二进制格式的体积会比压缩后的 ASM.js 体积小很多。WebAssembly 在浏览器中会运行在自己独立的沙盒环境当中，因此也无需担心内存数据泄露等安全性问题。</p>\n<p><img src=\"3.png\" alt></p>\n<p>接下来我们来看一下 WebAssembly 的内存模型。WebAssembly 代码对应的程序会被运行在一块连续的内存上，但其执行堆栈却完全从 WebAssembly 程序的内存段中独立出来，在执行堆栈中存储着 WebAssembly 程序当前需要用到的变量的值。由于执行堆栈的分离使得我们无法通过读取或改变 WebAssembly 程序所在内存段数据来改变各个变量的值，而这为 WebAssembly 的安全性提供了保障。</p>\n","site":{"data":{}},"id":"a04d237af01c30f7779586ac3bbfedf7","excerpt":"","more":"<p>在前两次的研究报告，我们中主要介绍了 WebAssembly 在代码方面的应用与编译运行的基本流程。抛开复杂的开发编译工具链，我们来看一看 WebAssembly 底层的实现机制和原理。在编译器层面，WebAssembly 到底做了哪些事情，提供了怎样的优化？这些优化是怎样作用于实际的代码中的？让我们一起来研究一下。</p>\n<p>“WebAssembly 是一种全新的二进制代码格式，我们可以把类似 C/C++ 等静态类型语言的源代码编译成 WebAssembly 格式，以便将其运行在浏览器环境当中。”这段话是官方对 WebAssembly 的解释，我在这里将它翻译过来。接下来我们会针对这段话展开深入的分析，从编译器底层、编程语言等方面来探讨 WebAssembly 的秘密。</p>\n<p>首先，我们要知道静态类型语言和动态类型语言的区别。动态类型语言是指在代码运行期间检查数据类型的语言，用这类语言编程，在编写代码时不会给变量指定类型，而是在解释运行到该句代码时通过一系列的上下文判断来推断得出该变量的实际数据类型。而静态类型语言正好相反，这类语言需要在运行前进行编译时检查变量的类型。解释器和编译器，解释器的启动和执行速度较快，但由于解释器是采用“逐行”的方式来解释运行代码，因此在遇到类似循环等操作时，同一段代码在每次运行前都需要进行解释，大大降低了程序运行的性能。编译器则正好相反，在代码运行前，编译器需要一段时间来对代码进行编译，但在编译过程中可以对源代码的结构进行优化。为了解决解释器的低效问题，包括 V8 在内的众多优秀的 JS 引擎开始把静态编译器纳入自身的引擎系统中，这便形成了一套全新的编译器架构 - JIT 编译器模式。</p>\n<p>JIT 编译器的核心优化机制是 PGO（Profile Guided Optimization）。PGO 的基本原理是：在解释器解释运行代码期间会根据每行代码的执行次数不同，分别为每行代码做不同的标记（warm / hot）。warm 代表该行代码运行次数较多，而 hot 则表示该行代码在单位时间内运行的次数比 warm 更多。如果一段代码被标记为 warm，那么 JIT 就会把该段代码送到基线编译器（Baseline Compiler）去进行编译。由于基线编译器只能在短时间内进行局部的优化，因此被标记为 hot 的代码段随后还会被送到“优化编译器”进行再次的优化。在 V8 中，所有被标记的代码都会首先送到 “full-codegen” 基线编译器进行优化，被标记为 hot 甚至是 very hot 的代码段会被送到 “Crankshaft” 或者 “Turbofan” 优化编译器进行再次的优化。编译器在编译对应代码段时还会在本地存储已编译好的版本，这样下次再遇到同样的代码段便可以直接使用，省去了重新编译的时间。</p>\n<h4 id=\"1-传统-JS-引擎的工作流程：\"><a href=\"#1-传统-JS-引擎的工作流程：\" class=\"headerlink\" title=\"1. 传统 JS 引擎的工作流程：\"></a>1. 传统 JS 引擎的工作流程：</h4><pre><code class=\"javascript\">function add(a, b) {\n  return a + b;\n}\n</code></pre>\n<p>对于上述给出的这段简短的 JS 代码，引擎在遇到加号 “+” 运算符时，并不是直接将两个变量的值相加。由于我们在程序运行前无法判断加号运算符两侧传入变量值的实际类型，因此也就无法判断是应该将两个变量的值当作数值(整型、浮点型)相加还是应该当作字符串进行拼接，甚至是当作对象来进行处理。JS 引擎会根据 ECMAScript 的标准来对加号运算符进行一系列判断才能够得到最后的运算结果。对应加号运算符的 ECMAScript 标准如下图所示（图片来自 Google IO 2017）：</p>\n<p><img src=\"1.png\" alt></p>\n<p>可以看到，传统的 JS 引擎在解析代码时会经过复杂的类型判断过程才能得到最终的计算结果，而这使得动态语言的代码执行效率被大大降低。</p>\n<p><img src=\"2.png\" alt></p>\n<p>我们以 V8 的 Pipeline 结构来讲解 JS 引擎处理代码的基本过程。首先，JS 引擎会分析源代码的结构并生成一个 AST（抽象语法树），该 AST 展示了源程序的逻辑结构在内存中的抽象表现形式。接下来，AST 经过一个 “full-codegen” 全代码编译器前端被直接编译成了未经优化的中间表示层（IR）代码。在得到了 IR 代码后，V8 的优化编译器 “TurboFan” 会继续分析 JS 源码来找出那些运行速度较慢的源码并再次对它们进行优化。这个过程结束之后，再将经过处理的 IR（Intermediate Representation） 层代码经过一个编译器后端重新生成优化后的机器码。</p>\n<p>在基于 ASM.js 的优化流程中，最后生成的 ASM.js 代码属于 JS 的一个子集，因此最后被 JS 引擎解释时同样还需要经过分析代码、生成 AST 和重新优化等过程，而这些过程都是需要消耗 CPU 资源的，因此这种优化只能在某种程度上改善性能。而 WebAssembly 则直接从一个编译器后端进行加载，省去了所有编译器前端包括代码分析、生成 AST 、代码编译和优化在内的一系列过程。因此相较于 ASM.js 可以大大提高代码的执行效率。</p>\n<p>另一方面，对于实现同样功能的一段 C/C++ 代码，WebAssembly 二进制格式的体积会比压缩后的 ASM.js 体积小很多。WebAssembly 在浏览器中会运行在自己独立的沙盒环境当中，因此也无需担心内存数据泄露等安全性问题。</p>\n<p><img src=\"3.png\" alt></p>\n<p>接下来我们来看一下 WebAssembly 的内存模型。WebAssembly 代码对应的程序会被运行在一块连续的内存上，但其执行堆栈却完全从 WebAssembly 程序的内存段中独立出来，在执行堆栈中存储着 WebAssembly 程序当前需要用到的变量的值。由于执行堆栈的分离使得我们无法通过读取或改变 WebAssembly 程序所在内存段数据来改变各个变量的值，而这为 WebAssembly 的安全性提供了保障。</p>\n"},{"title":"WebAssembly 尝试研究报告 - 本地存储与转移","intro":"为了提升 WebAssembly 应用的初期模块加载效率和整体使用体验，我们可以将已经编译好的 WebAssembly 模块存储在本地的 IndexedDB 数据库当中，当下一次用到该模块时可以直接从本地读取并实例化，减少了再次从网络传输和编译的时间。同样我们也可以将 WebAssembly 部分的代码逻辑放到 Worker 线程中运行，这样可以使 WebAssembly 模块的密集运算不影响到主线程的正常工作，本次我们来讨论上述这些事情。","comments":1,"date":"2017-06-16T01:57:50.000Z","_content":"\n为了提升 WebAssembly 应用的初期模块加载效率和整体使用体验，我们可以将已经编译好的 WebAssembly 模块存储在本地的 IndexedDB 数据库当中，当下一次用到该模块时可以直接从本地读取并实例化，减少了再次从网络传输和编译的时间。同样我们也可以将 WebAssembly 部分的代码逻辑放到 Worker 线程中运行，这样可以使 WebAssembly 模块的密集运算不影响到主线程的正常工作，本次我们来讨论上述这些事情。\n\n\n#### 1、本地缓存：\nIndexedDB 是一个运行在浏览器上的事务型数据库系统，我们可以在 IndexedDB 中读取本地的结构化数据，当然这也包括我们之前使用到的 WebAssembly.Module 对象。整体思路是：我们通过远程获取 WebAssembly 模块的 URL 作为模块在本地数据库的索引，如果 URL 改变（比如版本更新）则重新从远程获取 WebAssembly 模块，并更新本地数据库中存储的静态模块内容。否则，直接从本地读取已经编译好的模块对象。\n\n上述功能的完整代码如下：\n\n \n```javascript\n// 1. +++ fetchAndInstantiate() +++ //\n// 从指定 URL 获取一个 Wasm 模块并返回一个实例；\nfunction fetchAndInstantiate(url, importObject) {\n  return fetch(url).then(response =>\n    response.arrayBuffer()\n  ).then(bytes =>\n    WebAssembly.instantiate(bytes, importObject)\n  ).then(results =>\n    results.instance\n  );\n}\n\n// 2. +++ instantiateCachedURL() +++ //\nfunction instantiateCachedURL(dbVersion, url, importObject) {\n  // 指定 IndexedDB 的数据库名和表名；\n  const dbName = 'wasm-cache';\n  const storeName = 'wasm-cache';\n\n  function openDatabase() {\n    return new Promise((resolve, reject) => {\n      var request = indexedDB.open(dbName, dbVersion);\n      request.onerror = reject.bind(null, 'Error opening wasm cache database');\n      request.onsuccess = () => { resolve(request.result) };\n      request.onupgradeneeded = event => {\n        var db = request.result;\n        // 如果已经存在对应的表则删除并更新；\n        if (db.objectStoreNames.contains(storeName)) {\n            console.log(`Clearing out version ${event.oldVersion} wasm cache`);\n            db.deleteObjectStore(storeName);\n        }\n        console.log(`Creating version ${event.newVersion} wasm cache`);\n        db.createObjectStore(storeName)\n      };\n    });\n  }\n  \n  // 通过 URL 来查询指定的 Wasm 模块；\n  function lookupInDatabase(db) {\n    return new Promise((resolve, reject) => {\n      var store = db.transaction([storeName]).objectStore(storeName);\n      var request = store.get(url);\n      request.onerror = reject.bind(null, `Error getting wasm module ${url}`);\n      request.onsuccess = event => {\n        if (request.result)\n          resolve(request.result);\n        else\n          reject(`Module ${url} was not found in wasm cache`);\n      }\n    });\n  }\n\n  // 以 URL 为 key 将编译好的模块存储到本地数据库中；\n  function storeInDatabase(db, module) {\n    var store = db.transaction([storeName], 'readwrite').objectStore(storeName);\n    var request = store.put(module, url);\n    request.onerror = err => { console.log(`Failed to store in wasm cache: ${err}`) };\n    request.onsuccess = err => { console.log(`Successfully stored ${url} in wasm cache`) };\n  }\n\n  function fetchAndInstantiate() {\n    return fetch(url).then(response =>\n      response.arrayBuffer()\n    ).then(buffer =>\n      WebAssembly.instantiate(buffer, importObject)\n    )\n  }\n\n  // 主要业务逻辑；\n  return openDatabase().then(db => {\n    // 查找模块；\n    return lookupInDatabase(db).then(module => {\n      console.log(`Found ${url} in wasm cache`);\n      // 查到直接返回实例化后的模块；\n      return WebAssembly.instantiate(module, importObject);\n    }, errMsg => {\n      console.log(errMsg);\n      // 没有查到则直接从远程重新拉取；\n      return fetchAndInstantiate().then(results => {\n        // 拉取后更新本地缓存；\n        storeInDatabase(db, results.module);\n        return results.instance;\n      });\n    })\n  },\n  errMsg => {\n    console.log(errMsg);\n    // 如果本地数据不可用，直接从远程拉取；\n    return fetchAndInstantiate().then(results =>\n      results.instance\n    );\n  });\n}\n```\n\n#### 2、Worker 线程：\n\n将 WebAssembly 模块运行在非主线程的工作线程中可以减少密集计算带来的对主线程的压力。\n\n首先是主线程部分代码：\n \n```javascript\nvar worker = new Worker('js/wasm-worker.js');\nworker.postMessage({\n  data: WemAssembly.Module(wasmCode);\n});\n```\n\n\n接下来是工作线程的代码：\n \n```javascript\nvar importObject = {\n  imports: {\n    imported_func: function(arg) {\n      console.log(arg);\n    }\n  }\n};\n\nonmessage = function(e) {\n  console.log('module received from main thread');\n  var mod = e.data;\n\n  WebAssembly.instantiate(mod, importObject).then(function(instance) {\n    instance.exports.exported_func();\n  });\n\n  var exports = WebAssembly.Module.exports(mod);\n  console.log(exports[0]);\n};\n```\n","source":"_posts/WebAssembly-尝试研究报告-本地存储与转移.md","raw":"---\ntitle: WebAssembly 尝试研究报告 - 本地存储与转移\nintro: 为了提升 WebAssembly 应用的初期模块加载效率和整体使用体验，我们可以将已经编译好的 WebAssembly 模块存储在本地的 IndexedDB 数据库当中，当下一次用到该模块时可以直接从本地读取并实例化，减少了再次从网络传输和编译的时间。同样我们也可以将 WebAssembly 部分的代码逻辑放到 Worker 线程中运行，这样可以使 WebAssembly 模块的密集运算不影响到主线程的正常工作，本次我们来讨论上述这些事情。\ncomments: true\ndate: 2017-06-16 09:57:50\ntags:\n- WebAssembly\n---\n\n为了提升 WebAssembly 应用的初期模块加载效率和整体使用体验，我们可以将已经编译好的 WebAssembly 模块存储在本地的 IndexedDB 数据库当中，当下一次用到该模块时可以直接从本地读取并实例化，减少了再次从网络传输和编译的时间。同样我们也可以将 WebAssembly 部分的代码逻辑放到 Worker 线程中运行，这样可以使 WebAssembly 模块的密集运算不影响到主线程的正常工作，本次我们来讨论上述这些事情。\n\n\n#### 1、本地缓存：\nIndexedDB 是一个运行在浏览器上的事务型数据库系统，我们可以在 IndexedDB 中读取本地的结构化数据，当然这也包括我们之前使用到的 WebAssembly.Module 对象。整体思路是：我们通过远程获取 WebAssembly 模块的 URL 作为模块在本地数据库的索引，如果 URL 改变（比如版本更新）则重新从远程获取 WebAssembly 模块，并更新本地数据库中存储的静态模块内容。否则，直接从本地读取已经编译好的模块对象。\n\n上述功能的完整代码如下：\n\n \n```javascript\n// 1. +++ fetchAndInstantiate() +++ //\n// 从指定 URL 获取一个 Wasm 模块并返回一个实例；\nfunction fetchAndInstantiate(url, importObject) {\n  return fetch(url).then(response =>\n    response.arrayBuffer()\n  ).then(bytes =>\n    WebAssembly.instantiate(bytes, importObject)\n  ).then(results =>\n    results.instance\n  );\n}\n\n// 2. +++ instantiateCachedURL() +++ //\nfunction instantiateCachedURL(dbVersion, url, importObject) {\n  // 指定 IndexedDB 的数据库名和表名；\n  const dbName = 'wasm-cache';\n  const storeName = 'wasm-cache';\n\n  function openDatabase() {\n    return new Promise((resolve, reject) => {\n      var request = indexedDB.open(dbName, dbVersion);\n      request.onerror = reject.bind(null, 'Error opening wasm cache database');\n      request.onsuccess = () => { resolve(request.result) };\n      request.onupgradeneeded = event => {\n        var db = request.result;\n        // 如果已经存在对应的表则删除并更新；\n        if (db.objectStoreNames.contains(storeName)) {\n            console.log(`Clearing out version ${event.oldVersion} wasm cache`);\n            db.deleteObjectStore(storeName);\n        }\n        console.log(`Creating version ${event.newVersion} wasm cache`);\n        db.createObjectStore(storeName)\n      };\n    });\n  }\n  \n  // 通过 URL 来查询指定的 Wasm 模块；\n  function lookupInDatabase(db) {\n    return new Promise((resolve, reject) => {\n      var store = db.transaction([storeName]).objectStore(storeName);\n      var request = store.get(url);\n      request.onerror = reject.bind(null, `Error getting wasm module ${url}`);\n      request.onsuccess = event => {\n        if (request.result)\n          resolve(request.result);\n        else\n          reject(`Module ${url} was not found in wasm cache`);\n      }\n    });\n  }\n\n  // 以 URL 为 key 将编译好的模块存储到本地数据库中；\n  function storeInDatabase(db, module) {\n    var store = db.transaction([storeName], 'readwrite').objectStore(storeName);\n    var request = store.put(module, url);\n    request.onerror = err => { console.log(`Failed to store in wasm cache: ${err}`) };\n    request.onsuccess = err => { console.log(`Successfully stored ${url} in wasm cache`) };\n  }\n\n  function fetchAndInstantiate() {\n    return fetch(url).then(response =>\n      response.arrayBuffer()\n    ).then(buffer =>\n      WebAssembly.instantiate(buffer, importObject)\n    )\n  }\n\n  // 主要业务逻辑；\n  return openDatabase().then(db => {\n    // 查找模块；\n    return lookupInDatabase(db).then(module => {\n      console.log(`Found ${url} in wasm cache`);\n      // 查到直接返回实例化后的模块；\n      return WebAssembly.instantiate(module, importObject);\n    }, errMsg => {\n      console.log(errMsg);\n      // 没有查到则直接从远程重新拉取；\n      return fetchAndInstantiate().then(results => {\n        // 拉取后更新本地缓存；\n        storeInDatabase(db, results.module);\n        return results.instance;\n      });\n    })\n  },\n  errMsg => {\n    console.log(errMsg);\n    // 如果本地数据不可用，直接从远程拉取；\n    return fetchAndInstantiate().then(results =>\n      results.instance\n    );\n  });\n}\n```\n\n#### 2、Worker 线程：\n\n将 WebAssembly 模块运行在非主线程的工作线程中可以减少密集计算带来的对主线程的压力。\n\n首先是主线程部分代码：\n \n```javascript\nvar worker = new Worker('js/wasm-worker.js');\nworker.postMessage({\n  data: WemAssembly.Module(wasmCode);\n});\n```\n\n\n接下来是工作线程的代码：\n \n```javascript\nvar importObject = {\n  imports: {\n    imported_func: function(arg) {\n      console.log(arg);\n    }\n  }\n};\n\nonmessage = function(e) {\n  console.log('module received from main thread');\n  var mod = e.data;\n\n  WebAssembly.instantiate(mod, importObject).then(function(instance) {\n    instance.exports.exported_func();\n  });\n\n  var exports = WebAssembly.Module.exports(mod);\n  console.log(exports[0]);\n};\n```\n","slug":"WebAssembly-尝试研究报告-本地存储与转移","published":1,"updated":"2019-02-19T08:39:48.142Z","layout":"post","photos":[],"link":"","_id":"cjsqwhta50047knp2jy4j8mvo","content":"<p>为了提升 WebAssembly 应用的初期模块加载效率和整体使用体验，我们可以将已经编译好的 WebAssembly 模块存储在本地的 IndexedDB 数据库当中，当下一次用到该模块时可以直接从本地读取并实例化，减少了再次从网络传输和编译的时间。同样我们也可以将 WebAssembly 部分的代码逻辑放到 Worker 线程中运行，这样可以使 WebAssembly 模块的密集运算不影响到主线程的正常工作，本次我们来讨论上述这些事情。</p>\n<h4 id=\"1、本地缓存：\"><a href=\"#1、本地缓存：\" class=\"headerlink\" title=\"1、本地缓存：\"></a>1、本地缓存：</h4><p>IndexedDB 是一个运行在浏览器上的事务型数据库系统，我们可以在 IndexedDB 中读取本地的结构化数据，当然这也包括我们之前使用到的 WebAssembly.Module 对象。整体思路是：我们通过远程获取 WebAssembly 模块的 URL 作为模块在本地数据库的索引，如果 URL 改变（比如版本更新）则重新从远程获取 WebAssembly 模块，并更新本地数据库中存储的静态模块内容。否则，直接从本地读取已经编译好的模块对象。</p>\n<p>上述功能的完整代码如下：</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">// 1. +++ fetchAndInstantiate() +++ //</span>\n<span class=\"token comment\" spellcheck=\"true\">// 从指定 URL 获取一个 Wasm 模块并返回一个实例；</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">fetchAndInstantiate</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">,</span> importObject<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>response <span class=\"token operator\">=</span><span class=\"token operator\">></span>\n    response<span class=\"token punctuation\">.</span><span class=\"token function\">arrayBuffer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>bytes <span class=\"token operator\">=</span><span class=\"token operator\">></span>\n    WebAssembly<span class=\"token punctuation\">.</span><span class=\"token function\">instantiate</span><span class=\"token punctuation\">(</span>bytes<span class=\"token punctuation\">,</span> importObject<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>results <span class=\"token operator\">=</span><span class=\"token operator\">></span>\n    results<span class=\"token punctuation\">.</span>instance\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 2. +++ instantiateCachedURL() +++ //</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">instantiateCachedURL</span><span class=\"token punctuation\">(</span>dbVersion<span class=\"token punctuation\">,</span> url<span class=\"token punctuation\">,</span> importObject<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 指定 IndexedDB 的数据库名和表名；</span>\n  <span class=\"token keyword\">const</span> dbName <span class=\"token operator\">=</span> <span class=\"token string\">'wasm-cache'</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> storeName <span class=\"token operator\">=</span> <span class=\"token string\">'wasm-cache'</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">function</span> <span class=\"token function\">openDatabase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">var</span> request <span class=\"token operator\">=</span> indexedDB<span class=\"token punctuation\">.</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span>dbName<span class=\"token punctuation\">,</span> dbVersion<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      request<span class=\"token punctuation\">.</span>onerror <span class=\"token operator\">=</span> reject<span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Error opening wasm cache database'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      request<span class=\"token punctuation\">.</span>onsuccess <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span> <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">.</span>result<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n      request<span class=\"token punctuation\">.</span>onupgradeneeded <span class=\"token operator\">=</span> event <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">var</span> db <span class=\"token operator\">=</span> request<span class=\"token punctuation\">.</span>result<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 如果已经存在对应的表则删除并更新；</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>db<span class=\"token punctuation\">.</span>objectStoreNames<span class=\"token punctuation\">.</span><span class=\"token function\">contains</span><span class=\"token punctuation\">(</span>storeName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`Clearing out version </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>event<span class=\"token punctuation\">.</span>oldVersion<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"> wasm cache`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            db<span class=\"token punctuation\">.</span><span class=\"token function\">deleteObjectStore</span><span class=\"token punctuation\">(</span>storeName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`Creating version </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>event<span class=\"token punctuation\">.</span>newVersion<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"> wasm cache`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        db<span class=\"token punctuation\">.</span><span class=\"token function\">createObjectStore</span><span class=\"token punctuation\">(</span>storeName<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// 通过 URL 来查询指定的 Wasm 模块；</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">lookupInDatabase</span><span class=\"token punctuation\">(</span>db<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">var</span> store <span class=\"token operator\">=</span> db<span class=\"token punctuation\">.</span><span class=\"token function\">transaction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>storeName<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">objectStore</span><span class=\"token punctuation\">(</span>storeName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">var</span> request <span class=\"token operator\">=</span> store<span class=\"token punctuation\">.</span><span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      request<span class=\"token punctuation\">.</span>onerror <span class=\"token operator\">=</span> reject<span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token template-string\"><span class=\"token string\">`Error getting wasm module </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>url<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      request<span class=\"token punctuation\">.</span>onsuccess <span class=\"token operator\">=</span> event <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">.</span>result<span class=\"token punctuation\">)</span>\n          <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">.</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span>\n          <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`Module </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>url<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"> was not found in wasm cache`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// 以 URL 为 key 将编译好的模块存储到本地数据库中；</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">storeInDatabase</span><span class=\"token punctuation\">(</span>db<span class=\"token punctuation\">,</span> module<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> store <span class=\"token operator\">=</span> db<span class=\"token punctuation\">.</span><span class=\"token function\">transaction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>storeName<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'readwrite'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">objectStore</span><span class=\"token punctuation\">(</span>storeName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> request <span class=\"token operator\">=</span> store<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>module<span class=\"token punctuation\">,</span> url<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    request<span class=\"token punctuation\">.</span>onerror <span class=\"token operator\">=</span> err <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`Failed to store in wasm cache: </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>err<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    request<span class=\"token punctuation\">.</span>onsuccess <span class=\"token operator\">=</span> err <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`Successfully stored </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>url<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"> in wasm cache`</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">function</span> <span class=\"token function\">fetchAndInstantiate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>response <span class=\"token operator\">=</span><span class=\"token operator\">></span>\n      response<span class=\"token punctuation\">.</span><span class=\"token function\">arrayBuffer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>buffer <span class=\"token operator\">=</span><span class=\"token operator\">></span>\n      WebAssembly<span class=\"token punctuation\">.</span><span class=\"token function\">instantiate</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">,</span> importObject<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// 主要业务逻辑；</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">openDatabase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>db <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 查找模块；</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">lookupInDatabase</span><span class=\"token punctuation\">(</span>db<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>module <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`Found </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>url<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"> in wasm cache`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 查到直接返回实例化后的模块；</span>\n      <span class=\"token keyword\">return</span> WebAssembly<span class=\"token punctuation\">.</span><span class=\"token function\">instantiate</span><span class=\"token punctuation\">(</span>module<span class=\"token punctuation\">,</span> importObject<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> errMsg <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>errMsg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 没有查到则直接从远程重新拉取；</span>\n      <span class=\"token keyword\">return</span> <span class=\"token function\">fetchAndInstantiate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>results <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 拉取后更新本地缓存；</span>\n        <span class=\"token function\">storeInDatabase</span><span class=\"token punctuation\">(</span>db<span class=\"token punctuation\">,</span> results<span class=\"token punctuation\">.</span>module<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> results<span class=\"token punctuation\">.</span>instance<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  errMsg <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>errMsg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 如果本地数据不可用，直接从远程拉取；</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">fetchAndInstantiate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>results <span class=\"token operator\">=</span><span class=\"token operator\">></span>\n      results<span class=\"token punctuation\">.</span>instance\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"2、Worker-线程：\"><a href=\"#2、Worker-线程：\" class=\"headerlink\" title=\"2、Worker 线程：\"></a>2、Worker 线程：</h4><p>将 WebAssembly 模块运行在非主线程的工作线程中可以减少密集计算带来的对主线程的压力。</p>\n<p>首先是主线程部分代码：</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> worker <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Worker</span><span class=\"token punctuation\">(</span><span class=\"token string\">'js/wasm-worker.js'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nworker<span class=\"token punctuation\">.</span><span class=\"token function\">postMessage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  data<span class=\"token punctuation\">:</span> WemAssembly<span class=\"token punctuation\">.</span><span class=\"token function\">Module</span><span class=\"token punctuation\">(</span>wasmCode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>接下来是工作线程的代码：</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> importObject <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  imports<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    imported_func<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nonmessage <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'module received from main thread'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> mod <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">;</span>\n\n  WebAssembly<span class=\"token punctuation\">.</span><span class=\"token function\">instantiate</span><span class=\"token punctuation\">(</span>mod<span class=\"token punctuation\">,</span> importObject<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>instance<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    instance<span class=\"token punctuation\">.</span>exports<span class=\"token punctuation\">.</span><span class=\"token function\">exported_func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">var</span> exports <span class=\"token operator\">=</span> WebAssembly<span class=\"token punctuation\">.</span>Module<span class=\"token punctuation\">.</span><span class=\"token function\">exports</span><span class=\"token punctuation\">(</span>mod<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>exports<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"id":"12e6e25d900b59e5b25a8d9810124f91","excerpt":"","more":"<p>为了提升 WebAssembly 应用的初期模块加载效率和整体使用体验，我们可以将已经编译好的 WebAssembly 模块存储在本地的 IndexedDB 数据库当中，当下一次用到该模块时可以直接从本地读取并实例化，减少了再次从网络传输和编译的时间。同样我们也可以将 WebAssembly 部分的代码逻辑放到 Worker 线程中运行，这样可以使 WebAssembly 模块的密集运算不影响到主线程的正常工作，本次我们来讨论上述这些事情。</p>\n<h4 id=\"1、本地缓存：\"><a href=\"#1、本地缓存：\" class=\"headerlink\" title=\"1、本地缓存：\"></a>1、本地缓存：</h4><p>IndexedDB 是一个运行在浏览器上的事务型数据库系统，我们可以在 IndexedDB 中读取本地的结构化数据，当然这也包括我们之前使用到的 WebAssembly.Module 对象。整体思路是：我们通过远程获取 WebAssembly 模块的 URL 作为模块在本地数据库的索引，如果 URL 改变（比如版本更新）则重新从远程获取 WebAssembly 模块，并更新本地数据库中存储的静态模块内容。否则，直接从本地读取已经编译好的模块对象。</p>\n<p>上述功能的完整代码如下：</p>\n<pre><code class=\"javascript\">// 1. +++ fetchAndInstantiate() +++ //\n// 从指定 URL 获取一个 Wasm 模块并返回一个实例；\nfunction fetchAndInstantiate(url, importObject) {\n  return fetch(url).then(response =&gt;\n    response.arrayBuffer()\n  ).then(bytes =&gt;\n    WebAssembly.instantiate(bytes, importObject)\n  ).then(results =&gt;\n    results.instance\n  );\n}\n\n// 2. +++ instantiateCachedURL() +++ //\nfunction instantiateCachedURL(dbVersion, url, importObject) {\n  // 指定 IndexedDB 的数据库名和表名；\n  const dbName = &#39;wasm-cache&#39;;\n  const storeName = &#39;wasm-cache&#39;;\n\n  function openDatabase() {\n    return new Promise((resolve, reject) =&gt; {\n      var request = indexedDB.open(dbName, dbVersion);\n      request.onerror = reject.bind(null, &#39;Error opening wasm cache database&#39;);\n      request.onsuccess = () =&gt; { resolve(request.result) };\n      request.onupgradeneeded = event =&gt; {\n        var db = request.result;\n        // 如果已经存在对应的表则删除并更新；\n        if (db.objectStoreNames.contains(storeName)) {\n            console.log(`Clearing out version ${event.oldVersion} wasm cache`);\n            db.deleteObjectStore(storeName);\n        }\n        console.log(`Creating version ${event.newVersion} wasm cache`);\n        db.createObjectStore(storeName)\n      };\n    });\n  }\n\n  // 通过 URL 来查询指定的 Wasm 模块；\n  function lookupInDatabase(db) {\n    return new Promise((resolve, reject) =&gt; {\n      var store = db.transaction([storeName]).objectStore(storeName);\n      var request = store.get(url);\n      request.onerror = reject.bind(null, `Error getting wasm module ${url}`);\n      request.onsuccess = event =&gt; {\n        if (request.result)\n          resolve(request.result);\n        else\n          reject(`Module ${url} was not found in wasm cache`);\n      }\n    });\n  }\n\n  // 以 URL 为 key 将编译好的模块存储到本地数据库中；\n  function storeInDatabase(db, module) {\n    var store = db.transaction([storeName], &#39;readwrite&#39;).objectStore(storeName);\n    var request = store.put(module, url);\n    request.onerror = err =&gt; { console.log(`Failed to store in wasm cache: ${err}`) };\n    request.onsuccess = err =&gt; { console.log(`Successfully stored ${url} in wasm cache`) };\n  }\n\n  function fetchAndInstantiate() {\n    return fetch(url).then(response =&gt;\n      response.arrayBuffer()\n    ).then(buffer =&gt;\n      WebAssembly.instantiate(buffer, importObject)\n    )\n  }\n\n  // 主要业务逻辑；\n  return openDatabase().then(db =&gt; {\n    // 查找模块；\n    return lookupInDatabase(db).then(module =&gt; {\n      console.log(`Found ${url} in wasm cache`);\n      // 查到直接返回实例化后的模块；\n      return WebAssembly.instantiate(module, importObject);\n    }, errMsg =&gt; {\n      console.log(errMsg);\n      // 没有查到则直接从远程重新拉取；\n      return fetchAndInstantiate().then(results =&gt; {\n        // 拉取后更新本地缓存；\n        storeInDatabase(db, results.module);\n        return results.instance;\n      });\n    })\n  },\n  errMsg =&gt; {\n    console.log(errMsg);\n    // 如果本地数据不可用，直接从远程拉取；\n    return fetchAndInstantiate().then(results =&gt;\n      results.instance\n    );\n  });\n}\n</code></pre>\n<h4 id=\"2、Worker-线程：\"><a href=\"#2、Worker-线程：\" class=\"headerlink\" title=\"2、Worker 线程：\"></a>2、Worker 线程：</h4><p>将 WebAssembly 模块运行在非主线程的工作线程中可以减少密集计算带来的对主线程的压力。</p>\n<p>首先是主线程部分代码：</p>\n<pre><code class=\"javascript\">var worker = new Worker(&#39;js/wasm-worker.js&#39;);\nworker.postMessage({\n  data: WemAssembly.Module(wasmCode);\n});\n</code></pre>\n<p>接下来是工作线程的代码：</p>\n<pre><code class=\"javascript\">var importObject = {\n  imports: {\n    imported_func: function(arg) {\n      console.log(arg);\n    }\n  }\n};\n\nonmessage = function(e) {\n  console.log(&#39;module received from main thread&#39;);\n  var mod = e.data;\n\n  WebAssembly.instantiate(mod, importObject).then(function(instance) {\n    instance.exports.exported_func();\n  });\n\n  var exports = WebAssembly.Module.exports(mod);\n  console.log(exports[0]);\n};\n</code></pre>\n"},{"title":"WebAssembly 尝试研究报告（一）","intro":"自 WebAssembly 技术从 2016 年出现开始，便一直受到各方的关注。从宏观上来看，使用该技术我们可以通过把 Web 端的复杂运算逻辑放在 C/C++ 代码实现，并且通过 WebAssembly 提供的 JavaScript 接口来与 C/C++ 代码进行交互，进而达到提升 Web 应用运行性能的目的。该技术的 MVP 标准版本刚发布不久，与 DOM 操作相关功能特性的实现还有待后续标准的进一步完善。","comments":1,"date":"2017-06-09T03:55:00.000Z","_content":"\n自 WebAssembly 技术从 2016 年出现开始，便一直受到各方的关注。从宏观上来看，使用该技术我们可以通过把 Web 端的复杂运算逻辑放在 C/C++ 代码实现，并且通过 WebAssembly 提供的 JavaScript 接口来与 C/C++ 代码进行交互，进而达到提升 Web 应用运行性能的目的。该技术的 MVP 标准版本刚发布不久，与 DOM 操作相关功能特性的实现还有待后续标准的进一步完善。\n\n为了迎接 WebAssembly 的怀抱，Chrome 也决定不再支持 PNaCI，并开始全面支持 WebAssembly。毕竟 PNaCI 曾经受到了 Mozilla 的批评，公开指责其违背了“坚持开放和接受 Web 标准”的原则。现在 WebAssembly 已经成为了新的 Web 标准，旨在为了改进 JavaScript 的性能作出贡献。\n\n#### 一、开发环境搭建：\n\n1. 可以通过 WebAssembly 官方提供的[开发者文档](http://webassembly.org/getting-started/developers-guide/)来选择基于 **Emscripten** 工具链进行开发：\n2. 可以通过 **[WasmFiddle](https://wasdk.github.io/WasmFiddle/)** 进行在线的实时开发、调试和运行；\n3. 安装独立的 cmake、gcc、clang、llvm、s2wasm、wast2wasm 等编译器和相关环境；\n\n#### 二、开发工具：\n\n对于非线上的开发模式，Windows 平台需要安装 Visual Studio；Mac 平台需要安装 XCode。线上模式只需要一个文本编辑器即可。\n\n#### 三、发展历史：\n\nJavaScript 引擎的运行经历了遍历 AST、字节码解释器等“原始”阶段，由于需要将每条源代码“翻译”成相应的机器码再执行，同时引擎不会保存“翻译”后的机器码，使得解释执行的速度很慢。接下来 Google 发布了 V8 引擎，由于采用了 JIT 技术，在执行时可以将 JavaScript 代码编译成更高效的机器代码并将热代码保存，下次再次执行同一代码段时便无需再次编译，这使得 JavaScript 语言获得了几十倍的性能提升。但是由于 JS 本身的弱类型，导致引擎在解析同一段代码时会有不同的结果，因此大量的 CPU 资源被浪费在数据类型的判断上。微软开发的 TypeScript 采用了强类型的方式扩展了 JS 的语法特性，从语言层面解决了引擎在判断变量类型上的资源浪费问题。\n\n我们不想去创造一门新的强类型语言来代替 JS，那么有没有办法把现有的静态强类型语言“翻译”到 JS 呢？最早的尝试可以追溯到 95 年的 NPAPI 项目，但更为人所知的应该当属 13 年发布的 ASM.js。ASM.js 是一种 JS 的中间语言，其本质也是基于 JS 的语法，只不过是被特别优化过的。我们可以通过 Emscripten 将 C/C++ 代码传入 LLVM，再将 LLVM 产生的字节码编译成 ASM.js 代码，由于 ASM.js 本身的优化机制限制，导致 ASM.js 本质上只能够处理和优化数值类型。所有的 ASM.js 代码都已经被高度优化，所有的变量类型明确，所有的外部数据都在堆中进行存储和优化，甚至可以直接将 ASM.js 编译成底层的汇编代码而不需要特殊的处理。\n\n但这就可以了吗？看上去不错，通过 ASM.js 我们可以直接用 C/C++ 来编写高性能的 Web 应用，但其缺点也是明显的：编译后的 JS 文件过大，跨浏览器支持不佳等。WebAssembly 为了解决这个问题而诞生了。Wasm 不是一种新的编程语言，而是一种新的字节码格式，这个格式适合将 C/C++ 程序编译到 Web 上来运行，同时又满足了平台无关、高效、轻量等特性。Wasm 可以直接被 JS 引擎加载和执行，省去了从 JS 到 Bytecode，从 Bytecode 再到机器码的转换时间，因此十分高效。Wasm 的文本格式 Wast 包含了一个基于 “S 表达式”的 AST 描述文本，在这个文件中我们可以清楚的看到该 Wasm 模块的导出函数内存分配情况。WebAssembly 的二进制模块格式 Wasm 可以直接通过 JS 引擎提供的 WebAssembly 接口进行调用。\n\n#### 四、编译流程：\n\n从 C/C++ 编译到 JS 的流程都大致相同，如果开发流程基于 Em​scripten 工具链，整个编译环境的大致流程如下图所示（转载）：\n\n![](1.png)\n\n**emcc** 是 Emscripten 的编译器前端，其本身和 \bGCC 十分相似。emcc 使用 Clang 将 C/C++ 代码转换为 LLVM（源自于底层虚拟机 Low Level Virtual Machine）字节码，使用 Fastcomp（Emscripten 的编译器核心，一个 LLVM 后端）把字节码再编译成 JavaScript 并直接在浏览器中运行。无论是从 ASM.js 到 WebAssembly 二进制代码还是从 Wast 到 Wasm，都可以很方便的通过现有的工具链进行编译和转换。\n\n#### 五、本地实验：\n\n我们分别通过使用原生 JS 的排序方法和基于 C/C++ 实现的 Wasm 版本排序方法来对比两种实现的性能差别。\n\n**实验流程：**实验数据采用随机生成的含有 100 个随机数的数组，通过比较对该数组进行 1e6 次排序所花费的时间来比较两种方式的性能差异。\n\n**实验细节：**JS 采用 `Array.prototype.sort` 方法进行排序，Wasm 采用 C/C++ 实现的快排方法进行排序。\n\n**1. JavaScript 端排序测试：**\n\n \n ```javascript\nconsole.time(\"JS-Native\");\nfor (let j = 0; j < 1000000; j++) {\n  let arr = [];\n  for (let i = 0; i < 100; i++) { \n    arr.push(Math.round(Math.random() * 100));\n  }\n  arr.sort((a, b) => {\n    return a - b;\n  });\n}\nconsole.timeEnd(\"JS-Native\");\n```\n\n上述代码为 JS 侧的数组排序代码。下面给出的 C/C++ 数组排序代码我们采用快排的思路来编写。基于 WebAssembly 的开发主要分为两个部分：第一部分为 C/C++ 部分的主要业务处理逻辑，同时设置一些需要在 JS 层面调用的“预置接口”；第二部分是在 JS 层面进行 Wasm 模块的加载与实例化，同时需要进行填充内存数据、导入预置函数等操作。\n\n**2. Wasm 端排序测试：**\n\n \n```c\n// 定义数组大小；\n#define N 100\n\n// 预置函数，暴露给 JS 进行处理；\nvoid print(int* offset, int length);\n\nint array[N];\n// 返回数组在内存中的偏移地址；\nint* getArrayOffset() {\n  return array;\n}\n\nvoid swap (int *a, int *b) {  \n  int temp;  \n\n  temp = *a;  \n  *a = *b;  \n  *b = temp;  \n\n  return;  \n}  \n// 快排实现；\nvoid quicksort(int array[], int maxlen, int begin, int end) {  \n  int i, j;  \n\n  if (begin < end) {  \n    i = begin + 1;\n    j = end;      \n        \n    while (i < j) {  \n      if(array[i] > array[begin]) {  \n        swap(&array[i], &array[j]); \n        j--;  \n      } else {  \n        i++;   \n      } \n    }  \n\n    if (array[i] >= array[begin]) {  \n      i--;  \n    }  \n\n    swap(&array[begin], &array[i]);  \n      \n    quicksort(array, maxlen, begin, i);  \n    quicksort(array, maxlen, j, end);  \n  }  \n}  \n\nvoid test () {\n  quicksort(array, N, 0, N - 1);\n  // print(array, N);\n}\n```\n\n上面给出的 C/C++ 端的处理函数主要做了几件事情：\n\n1. 暴露了一个方法外壳给 JS 来处理；\n2. 提供一个函数用于获得数组在内存中的偏移地址；\n3. 核心业务处理逻辑的函数；\n4. 一个主函数用于在 JS 中调用；\n\n接下来处理 JS 端的 Wasm 接口和数据的填充过程。\n\n \n```javascript\n// 将 JS 生成的数组数据填充到指定的内存中；\nfunction importArrayToBuffer (memory, array, offset) {\n  const importBuffer = new Uint32Array(memory.buffer, offset, array.lenth);\n  for (let i = 0; i < array.length; i++) {\n    importBuffer[i] = array[i];\n  }\n}\n\nlet memory;\n// 通过浏览器提供的 WebAssembly 接口来加载一个 Wasm 模块；\nWebAssembly.compile(wasmCode).then(module => WebAssembly.instantiate(module, {\n  env: {\n    // 填充预置函数的主体；\n    print (offset, len) {\n      let strBuffer = new Uint32Array(memory.buffer, offset, len);\n      console.log(strBuffer);\n    }\n  }\n})).then(instance => {\n  let exports = instance.exports;\n  memory = exports.memory;\n  console.time(\"WASM\");\n  // 开始测试；\n  for (let j = 0; j < 1000000; j++) {\n    let arr = [];\n    for (let i = 0; i < 100; i++) { \n      arr.push(Math.round(Math.random() * 100));\n    }\n    // console.log(\"[Generated Array] \", arr);\n    // 填充数据到指定内存段；\n    importArrayToBuffer(memory, arr, exports.getArrayOffset());\n    // 调用 C/C++ 暴露的逻辑处理函数；\n    exports.test();\n  }\n  console.timeEnd(\"WASM\");\n});\n```\n\n\n**3. JS 端快排测试：**\n\n为了增强对照实验的准确性，我们又追加了纯 JS 实现的快排来作为第三种对照组实验。实验代码如下：\n\n \n```javascript\n// 快排实现； \nfunction quicksort(array, maxlen, begin, end) {  \n  let i, j;  \n  \n  if (begin < end) {  \n    i = begin + 1;\n    j = end;      \n        \n    while (i < j){  \n      if (array[i] > array[begin]) {  \n        let temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    \n        j--;  \n      } else {  \n        i++;   \n      } \n    }  \n\n    if (array[i] >= array[begin]) {  \n      i--;  \n    }  \n  \n    let temp = array[begin];\n    array[begin] = array[i];\n    array[i] = temp;\n      \n    quicksort(array, maxlen, begin, i);  \n    quicksort(array, maxlen, j, end);  \n  }  \n}  \n\nfunction main () {\n  console.time(\"JS-Quick\");\n  for (let j = 0; j < 1000000; j++) {\n    let array = [];\n    for (let i = 0; i < 100; i++) { \n      array.push(Math.round(Math.random() * 100));\n    }\n    quicksort(array, array.length, 0, array.length - 1);\n  }\n  console.timeEnd(\"JS-Quick\");\n}\n```\n\n\n在**一百万次**对随机生成的含有**100个数字**的数组进行排序所花费的时间：\n\n* **JS-Native：** 11308.10498046875ms\n* **WASM：** 7366.18310546875ms\n* **JS-QUICK：** 38611.242919921875ms\n\nWebAssembly 以十分明显的优势胜出。总的来看，从 JS 向固定的内存地址段进行数据填充的过程其实可以有很大的优化空间，比如将业务需要进行处理的数据一次性全部写入内存来代替分次的写入。C/C++ 方面可以对数据结构进行更加灵活的处理，比如在某些情况下使用“链表”等数据结构来大幅度改善程序的运行效率等。\n\n为了更加精准的对 WASM 进行性能评估，我们又追加了不同数组大小的实验样本来作为参照，具体评估结果如下图所示（Mac OS, Chrome Version 58.0.3029.110 (64-bit)）：\n\n![](2.png)\n","source":"_posts/WebAssembly-尝试研究报告（一）.md","raw":"---\ntitle: WebAssembly 尝试研究报告（一）\nintro: 自 WebAssembly 技术从 2016 年出现开始，便一直受到各方的关注。从宏观上来看，使用该技术我们可以通过把 Web 端的复杂运算逻辑放在 C/C++ 代码实现，并且通过 WebAssembly 提供的 JavaScript 接口来与 C/C++ 代码进行交互，进而达到提升 Web 应用运行性能的目的。该技术的 MVP 标准版本刚发布不久，与 DOM 操作相关功能特性的实现还有待后续标准的进一步完善。\ncomments: true\ndate: 2017-06-09 11:55:00\ntags:\n- WebAssembly\n---\n\n自 WebAssembly 技术从 2016 年出现开始，便一直受到各方的关注。从宏观上来看，使用该技术我们可以通过把 Web 端的复杂运算逻辑放在 C/C++ 代码实现，并且通过 WebAssembly 提供的 JavaScript 接口来与 C/C++ 代码进行交互，进而达到提升 Web 应用运行性能的目的。该技术的 MVP 标准版本刚发布不久，与 DOM 操作相关功能特性的实现还有待后续标准的进一步完善。\n\n为了迎接 WebAssembly 的怀抱，Chrome 也决定不再支持 PNaCI，并开始全面支持 WebAssembly。毕竟 PNaCI 曾经受到了 Mozilla 的批评，公开指责其违背了“坚持开放和接受 Web 标准”的原则。现在 WebAssembly 已经成为了新的 Web 标准，旨在为了改进 JavaScript 的性能作出贡献。\n\n#### 一、开发环境搭建：\n\n1. 可以通过 WebAssembly 官方提供的[开发者文档](http://webassembly.org/getting-started/developers-guide/)来选择基于 **Emscripten** 工具链进行开发：\n2. 可以通过 **[WasmFiddle](https://wasdk.github.io/WasmFiddle/)** 进行在线的实时开发、调试和运行；\n3. 安装独立的 cmake、gcc、clang、llvm、s2wasm、wast2wasm 等编译器和相关环境；\n\n#### 二、开发工具：\n\n对于非线上的开发模式，Windows 平台需要安装 Visual Studio；Mac 平台需要安装 XCode。线上模式只需要一个文本编辑器即可。\n\n#### 三、发展历史：\n\nJavaScript 引擎的运行经历了遍历 AST、字节码解释器等“原始”阶段，由于需要将每条源代码“翻译”成相应的机器码再执行，同时引擎不会保存“翻译”后的机器码，使得解释执行的速度很慢。接下来 Google 发布了 V8 引擎，由于采用了 JIT 技术，在执行时可以将 JavaScript 代码编译成更高效的机器代码并将热代码保存，下次再次执行同一代码段时便无需再次编译，这使得 JavaScript 语言获得了几十倍的性能提升。但是由于 JS 本身的弱类型，导致引擎在解析同一段代码时会有不同的结果，因此大量的 CPU 资源被浪费在数据类型的判断上。微软开发的 TypeScript 采用了强类型的方式扩展了 JS 的语法特性，从语言层面解决了引擎在判断变量类型上的资源浪费问题。\n\n我们不想去创造一门新的强类型语言来代替 JS，那么有没有办法把现有的静态强类型语言“翻译”到 JS 呢？最早的尝试可以追溯到 95 年的 NPAPI 项目，但更为人所知的应该当属 13 年发布的 ASM.js。ASM.js 是一种 JS 的中间语言，其本质也是基于 JS 的语法，只不过是被特别优化过的。我们可以通过 Emscripten 将 C/C++ 代码传入 LLVM，再将 LLVM 产生的字节码编译成 ASM.js 代码，由于 ASM.js 本身的优化机制限制，导致 ASM.js 本质上只能够处理和优化数值类型。所有的 ASM.js 代码都已经被高度优化，所有的变量类型明确，所有的外部数据都在堆中进行存储和优化，甚至可以直接将 ASM.js 编译成底层的汇编代码而不需要特殊的处理。\n\n但这就可以了吗？看上去不错，通过 ASM.js 我们可以直接用 C/C++ 来编写高性能的 Web 应用，但其缺点也是明显的：编译后的 JS 文件过大，跨浏览器支持不佳等。WebAssembly 为了解决这个问题而诞生了。Wasm 不是一种新的编程语言，而是一种新的字节码格式，这个格式适合将 C/C++ 程序编译到 Web 上来运行，同时又满足了平台无关、高效、轻量等特性。Wasm 可以直接被 JS 引擎加载和执行，省去了从 JS 到 Bytecode，从 Bytecode 再到机器码的转换时间，因此十分高效。Wasm 的文本格式 Wast 包含了一个基于 “S 表达式”的 AST 描述文本，在这个文件中我们可以清楚的看到该 Wasm 模块的导出函数内存分配情况。WebAssembly 的二进制模块格式 Wasm 可以直接通过 JS 引擎提供的 WebAssembly 接口进行调用。\n\n#### 四、编译流程：\n\n从 C/C++ 编译到 JS 的流程都大致相同，如果开发流程基于 Em​scripten 工具链，整个编译环境的大致流程如下图所示（转载）：\n\n![](1.png)\n\n**emcc** 是 Emscripten 的编译器前端，其本身和 \bGCC 十分相似。emcc 使用 Clang 将 C/C++ 代码转换为 LLVM（源自于底层虚拟机 Low Level Virtual Machine）字节码，使用 Fastcomp（Emscripten 的编译器核心，一个 LLVM 后端）把字节码再编译成 JavaScript 并直接在浏览器中运行。无论是从 ASM.js 到 WebAssembly 二进制代码还是从 Wast 到 Wasm，都可以很方便的通过现有的工具链进行编译和转换。\n\n#### 五、本地实验：\n\n我们分别通过使用原生 JS 的排序方法和基于 C/C++ 实现的 Wasm 版本排序方法来对比两种实现的性能差别。\n\n**实验流程：**实验数据采用随机生成的含有 100 个随机数的数组，通过比较对该数组进行 1e6 次排序所花费的时间来比较两种方式的性能差异。\n\n**实验细节：**JS 采用 `Array.prototype.sort` 方法进行排序，Wasm 采用 C/C++ 实现的快排方法进行排序。\n\n**1. JavaScript 端排序测试：**\n\n \n ```javascript\nconsole.time(\"JS-Native\");\nfor (let j = 0; j < 1000000; j++) {\n  let arr = [];\n  for (let i = 0; i < 100; i++) { \n    arr.push(Math.round(Math.random() * 100));\n  }\n  arr.sort((a, b) => {\n    return a - b;\n  });\n}\nconsole.timeEnd(\"JS-Native\");\n```\n\n上述代码为 JS 侧的数组排序代码。下面给出的 C/C++ 数组排序代码我们采用快排的思路来编写。基于 WebAssembly 的开发主要分为两个部分：第一部分为 C/C++ 部分的主要业务处理逻辑，同时设置一些需要在 JS 层面调用的“预置接口”；第二部分是在 JS 层面进行 Wasm 模块的加载与实例化，同时需要进行填充内存数据、导入预置函数等操作。\n\n**2. Wasm 端排序测试：**\n\n \n```c\n// 定义数组大小；\n#define N 100\n\n// 预置函数，暴露给 JS 进行处理；\nvoid print(int* offset, int length);\n\nint array[N];\n// 返回数组在内存中的偏移地址；\nint* getArrayOffset() {\n  return array;\n}\n\nvoid swap (int *a, int *b) {  \n  int temp;  \n\n  temp = *a;  \n  *a = *b;  \n  *b = temp;  \n\n  return;  \n}  \n// 快排实现；\nvoid quicksort(int array[], int maxlen, int begin, int end) {  \n  int i, j;  \n\n  if (begin < end) {  \n    i = begin + 1;\n    j = end;      \n        \n    while (i < j) {  \n      if(array[i] > array[begin]) {  \n        swap(&array[i], &array[j]); \n        j--;  \n      } else {  \n        i++;   \n      } \n    }  \n\n    if (array[i] >= array[begin]) {  \n      i--;  \n    }  \n\n    swap(&array[begin], &array[i]);  \n      \n    quicksort(array, maxlen, begin, i);  \n    quicksort(array, maxlen, j, end);  \n  }  \n}  \n\nvoid test () {\n  quicksort(array, N, 0, N - 1);\n  // print(array, N);\n}\n```\n\n上面给出的 C/C++ 端的处理函数主要做了几件事情：\n\n1. 暴露了一个方法外壳给 JS 来处理；\n2. 提供一个函数用于获得数组在内存中的偏移地址；\n3. 核心业务处理逻辑的函数；\n4. 一个主函数用于在 JS 中调用；\n\n接下来处理 JS 端的 Wasm 接口和数据的填充过程。\n\n \n```javascript\n// 将 JS 生成的数组数据填充到指定的内存中；\nfunction importArrayToBuffer (memory, array, offset) {\n  const importBuffer = new Uint32Array(memory.buffer, offset, array.lenth);\n  for (let i = 0; i < array.length; i++) {\n    importBuffer[i] = array[i];\n  }\n}\n\nlet memory;\n// 通过浏览器提供的 WebAssembly 接口来加载一个 Wasm 模块；\nWebAssembly.compile(wasmCode).then(module => WebAssembly.instantiate(module, {\n  env: {\n    // 填充预置函数的主体；\n    print (offset, len) {\n      let strBuffer = new Uint32Array(memory.buffer, offset, len);\n      console.log(strBuffer);\n    }\n  }\n})).then(instance => {\n  let exports = instance.exports;\n  memory = exports.memory;\n  console.time(\"WASM\");\n  // 开始测试；\n  for (let j = 0; j < 1000000; j++) {\n    let arr = [];\n    for (let i = 0; i < 100; i++) { \n      arr.push(Math.round(Math.random() * 100));\n    }\n    // console.log(\"[Generated Array] \", arr);\n    // 填充数据到指定内存段；\n    importArrayToBuffer(memory, arr, exports.getArrayOffset());\n    // 调用 C/C++ 暴露的逻辑处理函数；\n    exports.test();\n  }\n  console.timeEnd(\"WASM\");\n});\n```\n\n\n**3. JS 端快排测试：**\n\n为了增强对照实验的准确性，我们又追加了纯 JS 实现的快排来作为第三种对照组实验。实验代码如下：\n\n \n```javascript\n// 快排实现； \nfunction quicksort(array, maxlen, begin, end) {  \n  let i, j;  \n  \n  if (begin < end) {  \n    i = begin + 1;\n    j = end;      \n        \n    while (i < j){  \n      if (array[i] > array[begin]) {  \n        let temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    \n        j--;  \n      } else {  \n        i++;   \n      } \n    }  \n\n    if (array[i] >= array[begin]) {  \n      i--;  \n    }  \n  \n    let temp = array[begin];\n    array[begin] = array[i];\n    array[i] = temp;\n      \n    quicksort(array, maxlen, begin, i);  \n    quicksort(array, maxlen, j, end);  \n  }  \n}  \n\nfunction main () {\n  console.time(\"JS-Quick\");\n  for (let j = 0; j < 1000000; j++) {\n    let array = [];\n    for (let i = 0; i < 100; i++) { \n      array.push(Math.round(Math.random() * 100));\n    }\n    quicksort(array, array.length, 0, array.length - 1);\n  }\n  console.timeEnd(\"JS-Quick\");\n}\n```\n\n\n在**一百万次**对随机生成的含有**100个数字**的数组进行排序所花费的时间：\n\n* **JS-Native：** 11308.10498046875ms\n* **WASM：** 7366.18310546875ms\n* **JS-QUICK：** 38611.242919921875ms\n\nWebAssembly 以十分明显的优势胜出。总的来看，从 JS 向固定的内存地址段进行数据填充的过程其实可以有很大的优化空间，比如将业务需要进行处理的数据一次性全部写入内存来代替分次的写入。C/C++ 方面可以对数据结构进行更加灵活的处理，比如在某些情况下使用“链表”等数据结构来大幅度改善程序的运行效率等。\n\n为了更加精准的对 WASM 进行性能评估，我们又追加了不同数组大小的实验样本来作为参照，具体评估结果如下图所示（Mac OS, Chrome Version 58.0.3029.110 (64-bit)）：\n\n![](2.png)\n","slug":"WebAssembly-尝试研究报告（一）","published":1,"updated":"2019-02-19T03:36:26.890Z","layout":"post","photos":[],"link":"","_id":"cjsqwhta60049knp2s4jwt3gn","content":"<p>自 WebAssembly 技术从 2016 年出现开始，便一直受到各方的关注。从宏观上来看，使用该技术我们可以通过把 Web 端的复杂运算逻辑放在 C/C++ 代码实现，并且通过 WebAssembly 提供的 JavaScript 接口来与 C/C++ 代码进行交互，进而达到提升 Web 应用运行性能的目的。该技术的 MVP 标准版本刚发布不久，与 DOM 操作相关功能特性的实现还有待后续标准的进一步完善。</p>\n<p>为了迎接 WebAssembly 的怀抱，Chrome 也决定不再支持 PNaCI，并开始全面支持 WebAssembly。毕竟 PNaCI 曾经受到了 Mozilla 的批评，公开指责其违背了“坚持开放和接受 Web 标准”的原则。现在 WebAssembly 已经成为了新的 Web 标准，旨在为了改进 JavaScript 的性能作出贡献。</p>\n<h4 id=\"一、开发环境搭建：\"><a href=\"#一、开发环境搭建：\" class=\"headerlink\" title=\"一、开发环境搭建：\"></a>一、开发环境搭建：</h4><ol>\n<li>可以通过 WebAssembly 官方提供的<a href=\"http://webassembly.org/getting-started/developers-guide/\" target=\"_blank\" rel=\"noopener\">开发者文档</a>来选择基于 <strong>Emscripten</strong> 工具链进行开发：</li>\n<li>可以通过 <strong><a href=\"https://wasdk.github.io/WasmFiddle/\" target=\"_blank\" rel=\"noopener\">WasmFiddle</a></strong> 进行在线的实时开发、调试和运行；</li>\n<li>安装独立的 cmake、gcc、clang、llvm、s2wasm、wast2wasm 等编译器和相关环境；</li>\n</ol>\n<h4 id=\"二、开发工具：\"><a href=\"#二、开发工具：\" class=\"headerlink\" title=\"二、开发工具：\"></a>二、开发工具：</h4><p>对于非线上的开发模式，Windows 平台需要安装 Visual Studio；Mac 平台需要安装 XCode。线上模式只需要一个文本编辑器即可。</p>\n<h4 id=\"三、发展历史：\"><a href=\"#三、发展历史：\" class=\"headerlink\" title=\"三、发展历史：\"></a>三、发展历史：</h4><p>JavaScript 引擎的运行经历了遍历 AST、字节码解释器等“原始”阶段，由于需要将每条源代码“翻译”成相应的机器码再执行，同时引擎不会保存“翻译”后的机器码，使得解释执行的速度很慢。接下来 Google 发布了 V8 引擎，由于采用了 JIT 技术，在执行时可以将 JavaScript 代码编译成更高效的机器代码并将热代码保存，下次再次执行同一代码段时便无需再次编译，这使得 JavaScript 语言获得了几十倍的性能提升。但是由于 JS 本身的弱类型，导致引擎在解析同一段代码时会有不同的结果，因此大量的 CPU 资源被浪费在数据类型的判断上。微软开发的 TypeScript 采用了强类型的方式扩展了 JS 的语法特性，从语言层面解决了引擎在判断变量类型上的资源浪费问题。</p>\n<p>我们不想去创造一门新的强类型语言来代替 JS，那么有没有办法把现有的静态强类型语言“翻译”到 JS 呢？最早的尝试可以追溯到 95 年的 NPAPI 项目，但更为人所知的应该当属 13 年发布的 ASM.js。ASM.js 是一种 JS 的中间语言，其本质也是基于 JS 的语法，只不过是被特别优化过的。我们可以通过 Emscripten 将 C/C++ 代码传入 LLVM，再将 LLVM 产生的字节码编译成 ASM.js 代码，由于 ASM.js 本身的优化机制限制，导致 ASM.js 本质上只能够处理和优化数值类型。所有的 ASM.js 代码都已经被高度优化，所有的变量类型明确，所有的外部数据都在堆中进行存储和优化，甚至可以直接将 ASM.js 编译成底层的汇编代码而不需要特殊的处理。</p>\n<p>但这就可以了吗？看上去不错，通过 ASM.js 我们可以直接用 C/C++ 来编写高性能的 Web 应用，但其缺点也是明显的：编译后的 JS 文件过大，跨浏览器支持不佳等。WebAssembly 为了解决这个问题而诞生了。Wasm 不是一种新的编程语言，而是一种新的字节码格式，这个格式适合将 C/C++ 程序编译到 Web 上来运行，同时又满足了平台无关、高效、轻量等特性。Wasm 可以直接被 JS 引擎加载和执行，省去了从 JS 到 Bytecode，从 Bytecode 再到机器码的转换时间，因此十分高效。Wasm 的文本格式 Wast 包含了一个基于 “S 表达式”的 AST 描述文本，在这个文件中我们可以清楚的看到该 Wasm 模块的导出函数内存分配情况。WebAssembly 的二进制模块格式 Wasm 可以直接通过 JS 引擎提供的 WebAssembly 接口进行调用。</p>\n<h4 id=\"四、编译流程：\"><a href=\"#四、编译流程：\" class=\"headerlink\" title=\"四、编译流程：\"></a>四、编译流程：</h4><p>从 C/C++ 编译到 JS 的流程都大致相同，如果开发流程基于 Em​scripten 工具链，整个编译环境的大致流程如下图所示（转载）：</p>\n<p><img src=\"1.png\" alt></p>\n<p><strong>emcc</strong> 是 Emscripten 的编译器前端，其本身和 \bGCC 十分相似。emcc 使用 Clang 将 C/C++ 代码转换为 LLVM（源自于底层虚拟机 Low Level Virtual Machine）字节码，使用 Fastcomp（Emscripten 的编译器核心，一个 LLVM 后端）把字节码再编译成 JavaScript 并直接在浏览器中运行。无论是从 ASM.js 到 WebAssembly 二进制代码还是从 Wast 到 Wasm，都可以很方便的通过现有的工具链进行编译和转换。</p>\n<h4 id=\"五、本地实验：\"><a href=\"#五、本地实验：\" class=\"headerlink\" title=\"五、本地实验：\"></a>五、本地实验：</h4><p>我们分别通过使用原生 JS 的排序方法和基于 C/C++ 实现的 Wasm 版本排序方法来对比两种实现的性能差别。</p>\n<p><strong>实验流程：</strong>实验数据采用随机生成的含有 100 个随机数的数组，通过比较对该数组进行 1e6 次排序所花费的时间来比较两种方式的性能差异。</p>\n<p><strong>实验细节：</strong>JS 采用 <code>Array.prototype.sort</code> 方法进行排序，Wasm 采用 C/C++ 实现的快排方法进行排序。</p>\n<p><strong>1. JavaScript 端排序测试：</strong></p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\">console<span class=\"token punctuation\">.</span><span class=\"token function\">time</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"JS-Native\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> <span class=\"token number\">1000000</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n    arr<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">round</span><span class=\"token punctuation\">(</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  arr<span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> a <span class=\"token operator\">-</span> b<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">timeEnd</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"JS-Native\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>上述代码为 JS 侧的数组排序代码。下面给出的 C/C++ 数组排序代码我们采用快排的思路来编写。基于 WebAssembly 的开发主要分为两个部分：第一部分为 C/C++ 部分的主要业务处理逻辑，同时设置一些需要在 JS 层面调用的“预置接口”；第二部分是在 JS 层面进行 Wasm 模块的加载与实例化，同时需要进行填充内存数据、导入预置函数等操作。</p>\n<p><strong>2. Wasm 端排序测试：</strong></p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token comment\" spellcheck=\"true\">// 定义数组大小；</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> N 100</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 预置函数，暴露给 JS 进行处理；</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span> offset<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> array<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// 返回数组在内存中的偏移地址；</span>\n<span class=\"token keyword\">int</span><span class=\"token operator\">*</span> <span class=\"token function\">getArrayOffset</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> array<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">swap</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n  <span class=\"token keyword\">int</span> temp<span class=\"token punctuation\">;</span>  \n\n  temp <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>a<span class=\"token punctuation\">;</span>  \n  <span class=\"token operator\">*</span>a <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>b<span class=\"token punctuation\">;</span>  \n  <span class=\"token operator\">*</span>b <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span>  \n\n  <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>  \n<span class=\"token punctuation\">}</span>  \n<span class=\"token comment\" spellcheck=\"true\">// 快排实现；</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">quicksort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> array<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> maxlen<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> begin<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> end<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n  <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">;</span>  \n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>begin <span class=\"token operator\">&lt;</span> end<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n    i <span class=\"token operator\">=</span> begin <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    j <span class=\"token operator\">=</span> end<span class=\"token punctuation\">;</span>      \n\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;</span> j<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n      <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> array<span class=\"token punctuation\">[</span>begin<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n        <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>array<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>array<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n        j<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>  \n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>  \n        i<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>   \n      <span class=\"token punctuation\">}</span> \n    <span class=\"token punctuation\">}</span>  \n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">>=</span> array<span class=\"token punctuation\">[</span>begin<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n      i<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>  \n    <span class=\"token punctuation\">}</span>  \n\n    <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>array<span class=\"token punctuation\">[</span>begin<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>array<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n\n    <span class=\"token function\">quicksort</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">,</span> maxlen<span class=\"token punctuation\">,</span> begin<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n    <span class=\"token function\">quicksort</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">,</span> maxlen<span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">,</span> end<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n  <span class=\"token punctuation\">}</span>  \n<span class=\"token punctuation\">}</span>  \n\n<span class=\"token keyword\">void</span> <span class=\"token function\">test</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">quicksort</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">,</span> N<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> N <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\" spellcheck=\"true\">// print(array, N);</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>上面给出的 C/C++ 端的处理函数主要做了几件事情：</p>\n<ol>\n<li>暴露了一个方法外壳给 JS 来处理；</li>\n<li>提供一个函数用于获得数组在内存中的偏移地址；</li>\n<li>核心业务处理逻辑的函数；</li>\n<li>一个主函数用于在 JS 中调用；</li>\n</ol>\n<p>接下来处理 JS 端的 Wasm 接口和数据的填充过程。</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">// 将 JS 生成的数组数据填充到指定的内存中；</span>\n<span class=\"token keyword\">function</span> importArrayToBuffer <span class=\"token punctuation\">(</span>memory<span class=\"token punctuation\">,</span> array<span class=\"token punctuation\">,</span> offset<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> importBuffer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Uint32Array</span><span class=\"token punctuation\">(</span>memory<span class=\"token punctuation\">.</span>buffer<span class=\"token punctuation\">,</span> offset<span class=\"token punctuation\">,</span> array<span class=\"token punctuation\">.</span>lenth<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> array<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    importBuffer<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> array<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> memory<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// 通过浏览器提供的 WebAssembly 接口来加载一个 Wasm 模块；</span>\nWebAssembly<span class=\"token punctuation\">.</span><span class=\"token function\">compile</span><span class=\"token punctuation\">(</span>wasmCode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>module <span class=\"token operator\">=</span><span class=\"token operator\">></span> WebAssembly<span class=\"token punctuation\">.</span><span class=\"token function\">instantiate</span><span class=\"token punctuation\">(</span>module<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n  env<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 填充预置函数的主体；</span>\n    print <span class=\"token punctuation\">(</span>offset<span class=\"token punctuation\">,</span> len<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">let</span> strBuffer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Uint32Array</span><span class=\"token punctuation\">(</span>memory<span class=\"token punctuation\">.</span>buffer<span class=\"token punctuation\">,</span> offset<span class=\"token punctuation\">,</span> len<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>strBuffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>instance <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> exports <span class=\"token operator\">=</span> instance<span class=\"token punctuation\">.</span>exports<span class=\"token punctuation\">;</span>\n  memory <span class=\"token operator\">=</span> exports<span class=\"token punctuation\">.</span>memory<span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">time</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"WASM\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 开始测试；</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> <span class=\"token number\">1000000</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n      arr<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">round</span><span class=\"token punctuation\">(</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// console.log(\"[Generated Array] \", arr);</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 填充数据到指定内存段；</span>\n    <span class=\"token function\">importArrayToBuffer</span><span class=\"token punctuation\">(</span>memory<span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">,</span> exports<span class=\"token punctuation\">.</span><span class=\"token function\">getArrayOffset</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 调用 C/C++ 暴露的逻辑处理函数；</span>\n    exports<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">timeEnd</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"WASM\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>3. JS 端快排测试：</strong></p>\n<p>为了增强对照实验的准确性，我们又追加了纯 JS 实现的快排来作为第三种对照组实验。实验代码如下：</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">// 快排实现； </span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">quicksort</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">,</span> maxlen<span class=\"token punctuation\">,</span> begin<span class=\"token punctuation\">,</span> end<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n  <span class=\"token keyword\">let</span> i<span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">;</span>  \n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>begin <span class=\"token operator\">&lt;</span> end<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n    i <span class=\"token operator\">=</span> begin <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    j <span class=\"token operator\">=</span> end<span class=\"token punctuation\">;</span>      \n\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;</span> j<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>  \n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> array<span class=\"token punctuation\">[</span>begin<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n        <span class=\"token keyword\">let</span> temp <span class=\"token operator\">=</span> array<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        array<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> array<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        array<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span>\n\n        j<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>  \n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>  \n        i<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>   \n      <span class=\"token punctuation\">}</span> \n    <span class=\"token punctuation\">}</span>  \n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">>=</span> array<span class=\"token punctuation\">[</span>begin<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n      i<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>  \n    <span class=\"token punctuation\">}</span>  \n\n    <span class=\"token keyword\">let</span> temp <span class=\"token operator\">=</span> array<span class=\"token punctuation\">[</span>begin<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    array<span class=\"token punctuation\">[</span>begin<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> array<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    array<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">quicksort</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">,</span> maxlen<span class=\"token punctuation\">,</span> begin<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n    <span class=\"token function\">quicksort</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">,</span> maxlen<span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">,</span> end<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n  <span class=\"token punctuation\">}</span>  \n<span class=\"token punctuation\">}</span>  \n\n<span class=\"token keyword\">function</span> main <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">time</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"JS-Quick\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> <span class=\"token number\">1000000</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> array <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n      array<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">round</span><span class=\"token punctuation\">(</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">quicksort</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">,</span> array<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> array<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">timeEnd</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"JS-Quick\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>在<strong>一百万次</strong>对随机生成的含有<strong>100个数字</strong>的数组进行排序所花费的时间：</p>\n<ul>\n<li><strong>JS-Native：</strong> 11308.10498046875ms</li>\n<li><strong>WASM：</strong> 7366.18310546875ms</li>\n<li><strong>JS-QUICK：</strong> 38611.242919921875ms</li>\n</ul>\n<p>WebAssembly 以十分明显的优势胜出。总的来看，从 JS 向固定的内存地址段进行数据填充的过程其实可以有很大的优化空间，比如将业务需要进行处理的数据一次性全部写入内存来代替分次的写入。C/C++ 方面可以对数据结构进行更加灵活的处理，比如在某些情况下使用“链表”等数据结构来大幅度改善程序的运行效率等。</p>\n<p>为了更加精准的对 WASM 进行性能评估，我们又追加了不同数组大小的实验样本来作为参照，具体评估结果如下图所示（Mac OS, Chrome Version 58.0.3029.110 (64-bit)）：</p>\n<p><img src=\"2.png\" alt></p>\n","site":{"data":{}},"id":"07a32f48da578060a0a7ff3a5a788c34","excerpt":"","more":"<p>自 WebAssembly 技术从 2016 年出现开始，便一直受到各方的关注。从宏观上来看，使用该技术我们可以通过把 Web 端的复杂运算逻辑放在 C/C++ 代码实现，并且通过 WebAssembly 提供的 JavaScript 接口来与 C/C++ 代码进行交互，进而达到提升 Web 应用运行性能的目的。该技术的 MVP 标准版本刚发布不久，与 DOM 操作相关功能特性的实现还有待后续标准的进一步完善。</p>\n<p>为了迎接 WebAssembly 的怀抱，Chrome 也决定不再支持 PNaCI，并开始全面支持 WebAssembly。毕竟 PNaCI 曾经受到了 Mozilla 的批评，公开指责其违背了“坚持开放和接受 Web 标准”的原则。现在 WebAssembly 已经成为了新的 Web 标准，旨在为了改进 JavaScript 的性能作出贡献。</p>\n<h4 id=\"一、开发环境搭建：\"><a href=\"#一、开发环境搭建：\" class=\"headerlink\" title=\"一、开发环境搭建：\"></a>一、开发环境搭建：</h4><ol>\n<li>可以通过 WebAssembly 官方提供的<a href=\"http://webassembly.org/getting-started/developers-guide/\" target=\"_blank\" rel=\"noopener\">开发者文档</a>来选择基于 <strong>Emscripten</strong> 工具链进行开发：</li>\n<li>可以通过 <strong><a href=\"https://wasdk.github.io/WasmFiddle/\" target=\"_blank\" rel=\"noopener\">WasmFiddle</a></strong> 进行在线的实时开发、调试和运行；</li>\n<li>安装独立的 cmake、gcc、clang、llvm、s2wasm、wast2wasm 等编译器和相关环境；</li>\n</ol>\n<h4 id=\"二、开发工具：\"><a href=\"#二、开发工具：\" class=\"headerlink\" title=\"二、开发工具：\"></a>二、开发工具：</h4><p>对于非线上的开发模式，Windows 平台需要安装 Visual Studio；Mac 平台需要安装 XCode。线上模式只需要一个文本编辑器即可。</p>\n<h4 id=\"三、发展历史：\"><a href=\"#三、发展历史：\" class=\"headerlink\" title=\"三、发展历史：\"></a>三、发展历史：</h4><p>JavaScript 引擎的运行经历了遍历 AST、字节码解释器等“原始”阶段，由于需要将每条源代码“翻译”成相应的机器码再执行，同时引擎不会保存“翻译”后的机器码，使得解释执行的速度很慢。接下来 Google 发布了 V8 引擎，由于采用了 JIT 技术，在执行时可以将 JavaScript 代码编译成更高效的机器代码并将热代码保存，下次再次执行同一代码段时便无需再次编译，这使得 JavaScript 语言获得了几十倍的性能提升。但是由于 JS 本身的弱类型，导致引擎在解析同一段代码时会有不同的结果，因此大量的 CPU 资源被浪费在数据类型的判断上。微软开发的 TypeScript 采用了强类型的方式扩展了 JS 的语法特性，从语言层面解决了引擎在判断变量类型上的资源浪费问题。</p>\n<p>我们不想去创造一门新的强类型语言来代替 JS，那么有没有办法把现有的静态强类型语言“翻译”到 JS 呢？最早的尝试可以追溯到 95 年的 NPAPI 项目，但更为人所知的应该当属 13 年发布的 ASM.js。ASM.js 是一种 JS 的中间语言，其本质也是基于 JS 的语法，只不过是被特别优化过的。我们可以通过 Emscripten 将 C/C++ 代码传入 LLVM，再将 LLVM 产生的字节码编译成 ASM.js 代码，由于 ASM.js 本身的优化机制限制，导致 ASM.js 本质上只能够处理和优化数值类型。所有的 ASM.js 代码都已经被高度优化，所有的变量类型明确，所有的外部数据都在堆中进行存储和优化，甚至可以直接将 ASM.js 编译成底层的汇编代码而不需要特殊的处理。</p>\n<p>但这就可以了吗？看上去不错，通过 ASM.js 我们可以直接用 C/C++ 来编写高性能的 Web 应用，但其缺点也是明显的：编译后的 JS 文件过大，跨浏览器支持不佳等。WebAssembly 为了解决这个问题而诞生了。Wasm 不是一种新的编程语言，而是一种新的字节码格式，这个格式适合将 C/C++ 程序编译到 Web 上来运行，同时又满足了平台无关、高效、轻量等特性。Wasm 可以直接被 JS 引擎加载和执行，省去了从 JS 到 Bytecode，从 Bytecode 再到机器码的转换时间，因此十分高效。Wasm 的文本格式 Wast 包含了一个基于 “S 表达式”的 AST 描述文本，在这个文件中我们可以清楚的看到该 Wasm 模块的导出函数内存分配情况。WebAssembly 的二进制模块格式 Wasm 可以直接通过 JS 引擎提供的 WebAssembly 接口进行调用。</p>\n<h4 id=\"四、编译流程：\"><a href=\"#四、编译流程：\" class=\"headerlink\" title=\"四、编译流程：\"></a>四、编译流程：</h4><p>从 C/C++ 编译到 JS 的流程都大致相同，如果开发流程基于 Em​scripten 工具链，整个编译环境的大致流程如下图所示（转载）：</p>\n<p><img src=\"1.png\" alt></p>\n<p><strong>emcc</strong> 是 Emscripten 的编译器前端，其本身和 \bGCC 十分相似。emcc 使用 Clang 将 C/C++ 代码转换为 LLVM（源自于底层虚拟机 Low Level Virtual Machine）字节码，使用 Fastcomp（Emscripten 的编译器核心，一个 LLVM 后端）把字节码再编译成 JavaScript 并直接在浏览器中运行。无论是从 ASM.js 到 WebAssembly 二进制代码还是从 Wast 到 Wasm，都可以很方便的通过现有的工具链进行编译和转换。</p>\n<h4 id=\"五、本地实验：\"><a href=\"#五、本地实验：\" class=\"headerlink\" title=\"五、本地实验：\"></a>五、本地实验：</h4><p>我们分别通过使用原生 JS 的排序方法和基于 C/C++ 实现的 Wasm 版本排序方法来对比两种实现的性能差别。</p>\n<p><strong>实验流程：</strong>实验数据采用随机生成的含有 100 个随机数的数组，通过比较对该数组进行 1e6 次排序所花费的时间来比较两种方式的性能差异。</p>\n<p><strong>实验细节：</strong>JS 采用 <code>Array.prototype.sort</code> 方法进行排序，Wasm 采用 C/C++ 实现的快排方法进行排序。</p>\n<p><strong>1. JavaScript 端排序测试：</strong></p>\n<pre><code class=\"javascript\">console.time(&quot;JS-Native&quot;);\nfor (let j = 0; j &lt; 1000000; j++) {\n  let arr = [];\n  for (let i = 0; i &lt; 100; i++) { \n    arr.push(Math.round(Math.random() * 100));\n  }\n  arr.sort((a, b) =&gt; {\n    return a - b;\n  });\n}\nconsole.timeEnd(&quot;JS-Native&quot;);\n</code></pre>\n<p>上述代码为 JS 侧的数组排序代码。下面给出的 C/C++ 数组排序代码我们采用快排的思路来编写。基于 WebAssembly 的开发主要分为两个部分：第一部分为 C/C++ 部分的主要业务处理逻辑，同时设置一些需要在 JS 层面调用的“预置接口”；第二部分是在 JS 层面进行 Wasm 模块的加载与实例化，同时需要进行填充内存数据、导入预置函数等操作。</p>\n<p><strong>2. Wasm 端排序测试：</strong></p>\n<pre><code class=\"c\">// 定义数组大小；\n#define N 100\n\n// 预置函数，暴露给 JS 进行处理；\nvoid print(int* offset, int length);\n\nint array[N];\n// 返回数组在内存中的偏移地址；\nint* getArrayOffset() {\n  return array;\n}\n\nvoid swap (int *a, int *b) {  \n  int temp;  \n\n  temp = *a;  \n  *a = *b;  \n  *b = temp;  \n\n  return;  \n}  \n// 快排实现；\nvoid quicksort(int array[], int maxlen, int begin, int end) {  \n  int i, j;  \n\n  if (begin &lt; end) {  \n    i = begin + 1;\n    j = end;      \n\n    while (i &lt; j) {  \n      if(array[i] &gt; array[begin]) {  \n        swap(&amp;array[i], &amp;array[j]); \n        j--;  \n      } else {  \n        i++;   \n      } \n    }  \n\n    if (array[i] &gt;= array[begin]) {  \n      i--;  \n    }  \n\n    swap(&amp;array[begin], &amp;array[i]);  \n\n    quicksort(array, maxlen, begin, i);  \n    quicksort(array, maxlen, j, end);  \n  }  \n}  \n\nvoid test () {\n  quicksort(array, N, 0, N - 1);\n  // print(array, N);\n}\n</code></pre>\n<p>上面给出的 C/C++ 端的处理函数主要做了几件事情：</p>\n<ol>\n<li>暴露了一个方法外壳给 JS 来处理；</li>\n<li>提供一个函数用于获得数组在内存中的偏移地址；</li>\n<li>核心业务处理逻辑的函数；</li>\n<li>一个主函数用于在 JS 中调用；</li>\n</ol>\n<p>接下来处理 JS 端的 Wasm 接口和数据的填充过程。</p>\n<pre><code class=\"javascript\">// 将 JS 生成的数组数据填充到指定的内存中；\nfunction importArrayToBuffer (memory, array, offset) {\n  const importBuffer = new Uint32Array(memory.buffer, offset, array.lenth);\n  for (let i = 0; i &lt; array.length; i++) {\n    importBuffer[i] = array[i];\n  }\n}\n\nlet memory;\n// 通过浏览器提供的 WebAssembly 接口来加载一个 Wasm 模块；\nWebAssembly.compile(wasmCode).then(module =&gt; WebAssembly.instantiate(module, {\n  env: {\n    // 填充预置函数的主体；\n    print (offset, len) {\n      let strBuffer = new Uint32Array(memory.buffer, offset, len);\n      console.log(strBuffer);\n    }\n  }\n})).then(instance =&gt; {\n  let exports = instance.exports;\n  memory = exports.memory;\n  console.time(&quot;WASM&quot;);\n  // 开始测试；\n  for (let j = 0; j &lt; 1000000; j++) {\n    let arr = [];\n    for (let i = 0; i &lt; 100; i++) { \n      arr.push(Math.round(Math.random() * 100));\n    }\n    // console.log(&quot;[Generated Array] &quot;, arr);\n    // 填充数据到指定内存段；\n    importArrayToBuffer(memory, arr, exports.getArrayOffset());\n    // 调用 C/C++ 暴露的逻辑处理函数；\n    exports.test();\n  }\n  console.timeEnd(&quot;WASM&quot;);\n});\n</code></pre>\n<p><strong>3. JS 端快排测试：</strong></p>\n<p>为了增强对照实验的准确性，我们又追加了纯 JS 实现的快排来作为第三种对照组实验。实验代码如下：</p>\n<pre><code class=\"javascript\">// 快排实现； \nfunction quicksort(array, maxlen, begin, end) {  \n  let i, j;  \n\n  if (begin &lt; end) {  \n    i = begin + 1;\n    j = end;      \n\n    while (i &lt; j){  \n      if (array[i] &gt; array[begin]) {  \n        let temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n\n        j--;  \n      } else {  \n        i++;   \n      } \n    }  \n\n    if (array[i] &gt;= array[begin]) {  \n      i--;  \n    }  \n\n    let temp = array[begin];\n    array[begin] = array[i];\n    array[i] = temp;\n\n    quicksort(array, maxlen, begin, i);  \n    quicksort(array, maxlen, j, end);  \n  }  \n}  \n\nfunction main () {\n  console.time(&quot;JS-Quick&quot;);\n  for (let j = 0; j &lt; 1000000; j++) {\n    let array = [];\n    for (let i = 0; i &lt; 100; i++) { \n      array.push(Math.round(Math.random() * 100));\n    }\n    quicksort(array, array.length, 0, array.length - 1);\n  }\n  console.timeEnd(&quot;JS-Quick&quot;);\n}\n</code></pre>\n<p>在<strong>一百万次</strong>对随机生成的含有<strong>100个数字</strong>的数组进行排序所花费的时间：</p>\n<ul>\n<li><strong>JS-Native：</strong> 11308.10498046875ms</li>\n<li><strong>WASM：</strong> 7366.18310546875ms</li>\n<li><strong>JS-QUICK：</strong> 38611.242919921875ms</li>\n</ul>\n<p>WebAssembly 以十分明显的优势胜出。总的来看，从 JS 向固定的内存地址段进行数据填充的过程其实可以有很大的优化空间，比如将业务需要进行处理的数据一次性全部写入内存来代替分次的写入。C/C++ 方面可以对数据结构进行更加灵活的处理，比如在某些情况下使用“链表”等数据结构来大幅度改善程序的运行效率等。</p>\n<p>为了更加精准的对 WASM 进行性能评估，我们又追加了不同数组大小的实验样本来作为参照，具体评估结果如下图所示（Mac OS, Chrome Version 58.0.3029.110 (64-bit)）：</p>\n<p><img src=\"2.png\" alt></p>\n"},{"title":"WebAssembly 深入研究报告 - 安全性","intro":"每个 WebAssembly 模块都会在自己独立的沙盒环境中执行导出的函数和代码。这个独立的沙盒环境通过一些错误隔离技术将 Wasm 的运行环境从主机的运行时环境中隔离出来。不仅如此，每一个 Wasm 模块的运行也同样会首先遵循其所在平台环境的安全策略。比如运行在 Web 浏览器中则会遵循同源策略，而在非浏览器环境则一般会遵循 POSIX 安全模型。","comments":1,"date":"2017-06-28T09:12:35.000Z","_content":"\n每个 WebAssembly 模块都会在自己独立的沙盒环境中执行导出的函数和代码。这个独立的沙盒环境通过一些错误隔离技术将 Wasm 的运行环境从主机的运行时环境中隔离出来。不仅如此，每一个 Wasm 模块的运行也同样会首先遵循其所在平台环境的安全策略。比如运行在 Web 浏览器中则会遵循同源策略，而在非浏览器环境则一般会遵循 POSIX 安全模型。\n\n#### 一、开发者：\n\nWasm 通过减少其语义中较为危险的特性，并同时保持对 C/C++ 在语法上的最大兼容性来保证一个较高的安全性和可用性。模块必须在加载时声明所有可访问的方法和它们的相关函数签名类型，包括用到的动态链接函数。这样做的好处是可以在程序运行过程中隐式地通过 CFI 来检查应用程序是否被劫持。CFI 在运行时检测程序的控制转移是否在控制流图（CFG）中，以识别是否遭遇了攻击。具体作法是在控制流转移指令前插入检验代码，来判断目标地址的合法性。这种做法能够对控制流劫持攻击起到防御作用。同时，编译好的代码由于不可以被修改，也不会在运行时被观测到，因此可以完全避免受到控制流劫持攻击。下面给出一些规则。\n\n1. 函数调用必须指定与函数索引空间或表索引空间中的有效条目相对应的目标索引。函数索引空间索引所有导入和内部定义的函数，根据模块中的定义顺序（由二进制编码定义）分配递增的索引值。因此，索引空间的索引值从零开始，先索引导入的函数，接下来是模块中定义的函数。表索引空间与函数索引空间基本相似；\n2. 间接的函数调用需要在调用时指定目标函数的类型签名，两者必须要完全一致函数才可能被调用。详见文章：《WebAssembly 尝试研究报告 - API 之初始化、内存和表的分配》；\n\nC/C++ 中的所有变量都可以根据其作用域范围被“降级”为 WebAssembly 中对应的两种原始类型 — 局部变量和全局变量。局部变量有着固定的作用域，全局变量是有固定类型的值，并且通过索引进行存储。在默认情况下，局部变量被初始化为零并存储在受保护的调用栈中，全局变量位于全局索引空间中，可以从外部模块中导入。对于那些静态变量作用域不明确的局部变量（比如被用于取地址符的变量，或是以值传递的结构体类型）在编译时会被存储在线性内存上一个单独的用户可寻址堆栈中。这是一个独立的内存区域，它具有固定的最大地址空间，默认初始化情况下的大小为0。\n","source":"_posts/WebAssembly-深入研究报告-安全性.md","raw":"---\ntitle: WebAssembly 深入研究报告 - 安全性\nintro: 每个 WebAssembly 模块都会在自己独立的沙盒环境中执行导出的函数和代码。这个独立的沙盒环境通过一些错误隔离技术将 Wasm 的运行环境从主机的运行时环境中隔离出来。不仅如此，每一个 Wasm 模块的运行也同样会首先遵循其所在平台环境的安全策略。比如运行在 Web 浏览器中则会遵循同源策略，而在非浏览器环境则一般会遵循 POSIX 安全模型。\ncomments: true\ndate: 2017-06-28 17:12:35\ntags:\n- WebAssembly\n---\n\n每个 WebAssembly 模块都会在自己独立的沙盒环境中执行导出的函数和代码。这个独立的沙盒环境通过一些错误隔离技术将 Wasm 的运行环境从主机的运行时环境中隔离出来。不仅如此，每一个 Wasm 模块的运行也同样会首先遵循其所在平台环境的安全策略。比如运行在 Web 浏览器中则会遵循同源策略，而在非浏览器环境则一般会遵循 POSIX 安全模型。\n\n#### 一、开发者：\n\nWasm 通过减少其语义中较为危险的特性，并同时保持对 C/C++ 在语法上的最大兼容性来保证一个较高的安全性和可用性。模块必须在加载时声明所有可访问的方法和它们的相关函数签名类型，包括用到的动态链接函数。这样做的好处是可以在程序运行过程中隐式地通过 CFI 来检查应用程序是否被劫持。CFI 在运行时检测程序的控制转移是否在控制流图（CFG）中，以识别是否遭遇了攻击。具体作法是在控制流转移指令前插入检验代码，来判断目标地址的合法性。这种做法能够对控制流劫持攻击起到防御作用。同时，编译好的代码由于不可以被修改，也不会在运行时被观测到，因此可以完全避免受到控制流劫持攻击。下面给出一些规则。\n\n1. 函数调用必须指定与函数索引空间或表索引空间中的有效条目相对应的目标索引。函数索引空间索引所有导入和内部定义的函数，根据模块中的定义顺序（由二进制编码定义）分配递增的索引值。因此，索引空间的索引值从零开始，先索引导入的函数，接下来是模块中定义的函数。表索引空间与函数索引空间基本相似；\n2. 间接的函数调用需要在调用时指定目标函数的类型签名，两者必须要完全一致函数才可能被调用。详见文章：《WebAssembly 尝试研究报告 - API 之初始化、内存和表的分配》；\n\nC/C++ 中的所有变量都可以根据其作用域范围被“降级”为 WebAssembly 中对应的两种原始类型 — 局部变量和全局变量。局部变量有着固定的作用域，全局变量是有固定类型的值，并且通过索引进行存储。在默认情况下，局部变量被初始化为零并存储在受保护的调用栈中，全局变量位于全局索引空间中，可以从外部模块中导入。对于那些静态变量作用域不明确的局部变量（比如被用于取地址符的变量，或是以值传递的结构体类型）在编译时会被存储在线性内存上一个单独的用户可寻址堆栈中。这是一个独立的内存区域，它具有固定的最大地址空间，默认初始化情况下的大小为0。\n","slug":"WebAssembly-深入研究报告-安全性","published":1,"updated":"2019-02-19T09:34:08.195Z","layout":"post","photos":[],"link":"","_id":"cjsqwhta6004cknp2x2grqtxk","content":"<p>每个 WebAssembly 模块都会在自己独立的沙盒环境中执行导出的函数和代码。这个独立的沙盒环境通过一些错误隔离技术将 Wasm 的运行环境从主机的运行时环境中隔离出来。不仅如此，每一个 Wasm 模块的运行也同样会首先遵循其所在平台环境的安全策略。比如运行在 Web 浏览器中则会遵循同源策略，而在非浏览器环境则一般会遵循 POSIX 安全模型。</p>\n<h4 id=\"一、开发者：\"><a href=\"#一、开发者：\" class=\"headerlink\" title=\"一、开发者：\"></a>一、开发者：</h4><p>Wasm 通过减少其语义中较为危险的特性，并同时保持对 C/C++ 在语法上的最大兼容性来保证一个较高的安全性和可用性。模块必须在加载时声明所有可访问的方法和它们的相关函数签名类型，包括用到的动态链接函数。这样做的好处是可以在程序运行过程中隐式地通过 CFI 来检查应用程序是否被劫持。CFI 在运行时检测程序的控制转移是否在控制流图（CFG）中，以识别是否遭遇了攻击。具体作法是在控制流转移指令前插入检验代码，来判断目标地址的合法性。这种做法能够对控制流劫持攻击起到防御作用。同时，编译好的代码由于不可以被修改，也不会在运行时被观测到，因此可以完全避免受到控制流劫持攻击。下面给出一些规则。</p>\n<ol>\n<li>函数调用必须指定与函数索引空间或表索引空间中的有效条目相对应的目标索引。函数索引空间索引所有导入和内部定义的函数，根据模块中的定义顺序（由二进制编码定义）分配递增的索引值。因此，索引空间的索引值从零开始，先索引导入的函数，接下来是模块中定义的函数。表索引空间与函数索引空间基本相似；</li>\n<li>间接的函数调用需要在调用时指定目标函数的类型签名，两者必须要完全一致函数才可能被调用。详见文章：《WebAssembly 尝试研究报告 - API 之初始化、内存和表的分配》；</li>\n</ol>\n<p>C/C++ 中的所有变量都可以根据其作用域范围被“降级”为 WebAssembly 中对应的两种原始类型 — 局部变量和全局变量。局部变量有着固定的作用域，全局变量是有固定类型的值，并且通过索引进行存储。在默认情况下，局部变量被初始化为零并存储在受保护的调用栈中，全局变量位于全局索引空间中，可以从外部模块中导入。对于那些静态变量作用域不明确的局部变量（比如被用于取地址符的变量，或是以值传递的结构体类型）在编译时会被存储在线性内存上一个单独的用户可寻址堆栈中。这是一个独立的内存区域，它具有固定的最大地址空间，默认初始化情况下的大小为0。</p>\n","site":{"data":{}},"id":"2f1b7a7c3adf7b944e15ba639971e97c","excerpt":"","more":"<p>每个 WebAssembly 模块都会在自己独立的沙盒环境中执行导出的函数和代码。这个独立的沙盒环境通过一些错误隔离技术将 Wasm 的运行环境从主机的运行时环境中隔离出来。不仅如此，每一个 Wasm 模块的运行也同样会首先遵循其所在平台环境的安全策略。比如运行在 Web 浏览器中则会遵循同源策略，而在非浏览器环境则一般会遵循 POSIX 安全模型。</p>\n<h4 id=\"一、开发者：\"><a href=\"#一、开发者：\" class=\"headerlink\" title=\"一、开发者：\"></a>一、开发者：</h4><p>Wasm 通过减少其语义中较为危险的特性，并同时保持对 C/C++ 在语法上的最大兼容性来保证一个较高的安全性和可用性。模块必须在加载时声明所有可访问的方法和它们的相关函数签名类型，包括用到的动态链接函数。这样做的好处是可以在程序运行过程中隐式地通过 CFI 来检查应用程序是否被劫持。CFI 在运行时检测程序的控制转移是否在控制流图（CFG）中，以识别是否遭遇了攻击。具体作法是在控制流转移指令前插入检验代码，来判断目标地址的合法性。这种做法能够对控制流劫持攻击起到防御作用。同时，编译好的代码由于不可以被修改，也不会在运行时被观测到，因此可以完全避免受到控制流劫持攻击。下面给出一些规则。</p>\n<ol>\n<li>函数调用必须指定与函数索引空间或表索引空间中的有效条目相对应的目标索引。函数索引空间索引所有导入和内部定义的函数，根据模块中的定义顺序（由二进制编码定义）分配递增的索引值。因此，索引空间的索引值从零开始，先索引导入的函数，接下来是模块中定义的函数。表索引空间与函数索引空间基本相似；</li>\n<li>间接的函数调用需要在调用时指定目标函数的类型签名，两者必须要完全一致函数才可能被调用。详见文章：《WebAssembly 尝试研究报告 - API 之初始化、内存和表的分配》；</li>\n</ol>\n<p>C/C++ 中的所有变量都可以根据其作用域范围被“降级”为 WebAssembly 中对应的两种原始类型 — 局部变量和全局变量。局部变量有着固定的作用域，全局变量是有固定类型的值，并且通过索引进行存储。在默认情况下，局部变量被初始化为零并存储在受保护的调用栈中，全局变量位于全局索引空间中，可以从外部模块中导入。对于那些静态变量作用域不明确的局部变量（比如被用于取地址符的变量，或是以值传递的结构体类型）在编译时会被存储在线性内存上一个单独的用户可寻址堆栈中。这是一个独立的内存区域，它具有固定的最大地址空间，默认初始化情况下的大小为0。</p>\n"},{"title":"WebAssembly 尝试研究报告（二）","intro":"在上一篇报告中，我们尝试通过对比 JS 侧的原生排序方法和 Wasm 端使用 C/C++ 编写的排序方法两者对同一大小数组的排序结果，让我们对 Wasm 应用的运行效率有了一个初步的认识。为了进一步优化 Wasm 的排序方法，接下来我们将优化递归版本的快排，并且尝试通过 Emscripten 在本地编译我们的代码。","comments":1,"date":"2017-06-10T04:30:35.000Z","_content":"\n在上一篇报告中，我们尝试通过对比 JS 侧的原生排序方法和 Wasm 端使用 C/C++ 编写的排序方法两者对同一大小数组的排序结果，让我们对 Wasm 应用的运行效率有了一个初步的认识。为了进一步优化 Wasm 的排序方法，接下来我们将优化递归版本的快排，并且尝试通过 Emscripten 在本地编译我们的代码。\n\n非递归版快排的具体原理这里我们不细讲。为了实现非递归版快排，我们需要使用一个“栈”来作为数据的中转容器。这里先上 C/C++ 部分的代码实现：\n\n \n```c\n#include <emscripten/emscripten.h>\n#include <stack>\n\n// 定义数组大小；\n#define N 100\n\n// 防止 C++ 函数名被 Mangling；\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n    // 预置函数，暴露给 JS 进行处理；\n    extern void printStr(char* offset, int length);\n    extern void printInt(int number);\n    extern void printArr(int* offset, int length);\n\n    int array[N];\n    // 返回数组在内存中的偏移地址；\n    int* EMSCRIPTEN_KEEPALIVE getArrayOffset() {\n        return array;\n    }\n\n    void push2(std::stack<int> &stack, int left, int right) {\n        stack.push(right);\n        stack.push(left);\n    }\n\n    void quicksort(int sortArray[], int leftPart, int rightPart) {\n        std::stack<int> stack;\n        push2(stack, leftPart, rightPart);\n        int lwalker, rwalker, mid;\n\n        while (!stack.empty()) {\n            int left = stack.top(); stack.pop();\n            int right = stack.top(); stack.pop();\n            lwalker = left;\n            rwalker = right;\n            mid = sortArray[(lwalker + rwalker) / 2];\n\n            while (lwalker < rwalker) {\n                while(sortArray[lwalker] < mid) lwalker++;\n                while(sortArray[rwalker] > mid) rwalker--;\n\n                if (lwalker <= rwalker) {\n                    int tmp = sortArray[lwalker];\n                    sortArray[lwalker] = sortArray[rwalker];\n                    sortArray[rwalker] = tmp;\n                    lwalker++;\n                    rwalker--;\n                }\n            }\n\n            if (lwalker < right) push2(stack, lwalker, right);\n            if (rwalker > left) push2(stack, left, rwalker);\n        }\n    }\n\n    void EMSCRIPTEN_KEEPALIVE sort() {\n        quicksort(array, 0, N - 1);\n        // printArr(array, N);\n    }\n\n    void EMSCRIPTEN_KEEPALIVE test_printInt() {\n        printInt(N);\n    }\n\n    void EMSCRIPTEN_KEEPALIVE test_printStr() {\n        char str[] = \"test_printStr\";\n        printStr(str, 13);\n    }\n#ifdef __cplusplus\n}\n#endif\n```\n\n跟直接使用 WasmFiddle 不同，使用 Emscripten 来编译 C++ 到 Wasm 需要配合 Emscripten 对编译器的特殊优化和对应的宏来使用。为了实现非递归版本的快排算法，我们在这里使用了 C++ STL 库中提供的 `<stack>` 来作为栈容器。代码中的 `EMSCRIPTEN_KEEPALIVE` 宏用来强制编译器前端不对该方法使用 DCE，以防止代码在编译期间被清除。由于我们采用了 C++ 来编写此次实验的源码，因此在主体函数部分加上了 `extern \"C\" ` 防止 Mangling 带来的生成函数名不一致问题。\n\n由于现在的 Emscripten 还不支持 Standalone 版本的 WebAssembly，因此我们无法像之前一样使用浏览器提供的原生 Wasm API。前端部分的 JS 代码主要包含两个文件分别对应两个主要功能：\n\n1. 加载 Wasm 模块，并解析成字节码用于 Emscripten 前端全局的 Module 对象进行模块加载与实例化；\n2. 初始化一个 JS-Library，用于为 C++ 内的预置函数提供外部的函数实现；\n\n其中页面部分的代码如下所示：\n\n \n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title></title>\n</head>\n<body>\n\n<script>\n  // 初始化全局 Module，Emscripten 会自动为我们初始化；\n  var Module = {};\n\n  fetch(\"program.wasm\").then(response => response.arrayBuffer()).then((bytes) => {\n    // 填充主要数据；\n    Module.wasmBinary = bytes;\n    // 异步载入初始化脚本（该脚本文件是编译后自动生成的）；\n    var script = document.createElement(\"script\");\n    script.src = \"program.js\";\n    document.body.appendChild(script);\n  });\n\n  window.onload = function() {\n    // Module.ccall(\"test_printInt\");\n    // Module.ccall(\"test_printStr\");\n    // 获取数组偏移地址；\n    var arrayOffset = Module.ccall(\"getArrayOffset\", \"number\");\n\n    console.time(\"WASM-NO-RECURSION\");\n    var arr = [];\n    for (var j = 0; j < 1000000; j++) {\n      for (var i = 0; i < 100; i++) {\n        var number = Math.round(Math.random() * 100);\n        // arr.push(number); \n        // 在对应内存地址填充数据；\n        Module.setValue(arrayOffset + 4 * i, number, \"i32\");\n      }\n      /*\n      console.log(arr);\n      for (var i = 0; i < 100; i++) {\n        console.log(Module.getValue(arrayOffset + 4 * i, \"i32\"));\n      }\n      */\n      // 调用排序函数；\n      Module.ccall(\"sort\");\n    }\n    console.timeEnd(\"WASM-NO-RECURSION\");\n  }\n</script>\n</body>\n</html>\n```\n\n相对于之前使用浏览器提供的原生 Wasm API，这里我们需要使用 Emscripten 提供的 Module 全局对象上的方法来实现 C++ 函数的调用过程。同样的，对于指针的传递和内存数据的填充也是如此。下面给出 JS-Library 的代码，JS-Library 的代码需要单独放在一个 JS 文件里，文件名会在编译阶段以参数的形式传递给编译器。\n\n \n```javascript\nmergeInto(LibraryManager.library, {\n  printStr: function(offset, length) {\n    var str = \"\";\n    var arr = [];\n    for (var i = 0; i < length; i++) {\n      arr.push(Module.getValue(offset + i, \"i8\"));\n    }\n    console.log(new TextDecoder().decode(new Uint8Array(arr)));\n  },\n  printArr: function(offset, length) {\n    var str = \"\";\n    var arr = [];\n    for (var i = 0; i < length; i++) {\n      arr.push(Module.getValue(offset + 4 * i, \"i32\"));\n    }\n    console.log(arr);\n  },\n  printInt: function (int) {\n    console.log(int);\n  }\n});\n```\n\n这里需要注意在 `Module.getValue` 方法中需要指定的偏移为当前填充内存指针的偏移，需要根据填充的数据类型来决定偏移的单位大小（比如 int 类型一般为 4bytes，double 一般为 8bytes 等）。同时需要在最后一个参数中指定读取或者存储数据的长度，指针的偏移需要与数据长度匹配。\n\n在所有代码编写完毕之后，使用以下命令来编译代码：\n\n \n```bash\nemcc -s WASM=1 -O3 -o program.js program.cpp --js-library library.js\n```\n\n这里需要注意加入 `WASM=1` 参数来确保最后生成的代码是基于 Wasm 而不是 ASM.js 的。-03 代表编译器的优化程度，如果不使用该参数会导致 Wasm 在浏览器中运行时出现内存溢出的问题，原因暂时未知。\n\n在编译完成后 Emscripten 会自动生成一个 JS 文件和一个 Wasm 文件，JS 文件会自动初始化全局 Module，我们需要做的只是在初始化前获得 Wasm 的字节码并填充给 Module 对象，然后 Emscripten 会帮我们完成后续的加载工作。\n\n最后的测试结果，相比之前文章给出的实验数据并没有提高，反而效率更低、速度更慢了，具体原因还有待研究。Emscripten 工具链提供的功能远不止这么多，各种灵活的编译器参数和方法还需要进一步的实践和探索。\n\nBTW：这里主要使用了 BrowserSync 来作为本地服务器进行测试。可以直接通过 NPM 进行安装，开箱即用。\n","source":"_posts/WebAssembly-尝试研究报告（二）.md","raw":"---\ntitle: WebAssembly 尝试研究报告（二）\nintro: 在上一篇报告中，我们尝试通过对比 JS 侧的原生排序方法和 Wasm 端使用 C/C++ 编写的排序方法两者对同一大小数组的排序结果，让我们对 Wasm 应用的运行效率有了一个初步的认识。为了进一步优化 Wasm 的排序方法，接下来我们将优化递归版本的快排，并且尝试通过 Emscripten 在本地编译我们的代码。\ncomments: true\ndate: 2017-06-10 12:30:35\ntags:\n- WebAssembly\n---\n\n在上一篇报告中，我们尝试通过对比 JS 侧的原生排序方法和 Wasm 端使用 C/C++ 编写的排序方法两者对同一大小数组的排序结果，让我们对 Wasm 应用的运行效率有了一个初步的认识。为了进一步优化 Wasm 的排序方法，接下来我们将优化递归版本的快排，并且尝试通过 Emscripten 在本地编译我们的代码。\n\n非递归版快排的具体原理这里我们不细讲。为了实现非递归版快排，我们需要使用一个“栈”来作为数据的中转容器。这里先上 C/C++ 部分的代码实现：\n\n \n```c\n#include <emscripten/emscripten.h>\n#include <stack>\n\n// 定义数组大小；\n#define N 100\n\n// 防止 C++ 函数名被 Mangling；\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n    // 预置函数，暴露给 JS 进行处理；\n    extern void printStr(char* offset, int length);\n    extern void printInt(int number);\n    extern void printArr(int* offset, int length);\n\n    int array[N];\n    // 返回数组在内存中的偏移地址；\n    int* EMSCRIPTEN_KEEPALIVE getArrayOffset() {\n        return array;\n    }\n\n    void push2(std::stack<int> &stack, int left, int right) {\n        stack.push(right);\n        stack.push(left);\n    }\n\n    void quicksort(int sortArray[], int leftPart, int rightPart) {\n        std::stack<int> stack;\n        push2(stack, leftPart, rightPart);\n        int lwalker, rwalker, mid;\n\n        while (!stack.empty()) {\n            int left = stack.top(); stack.pop();\n            int right = stack.top(); stack.pop();\n            lwalker = left;\n            rwalker = right;\n            mid = sortArray[(lwalker + rwalker) / 2];\n\n            while (lwalker < rwalker) {\n                while(sortArray[lwalker] < mid) lwalker++;\n                while(sortArray[rwalker] > mid) rwalker--;\n\n                if (lwalker <= rwalker) {\n                    int tmp = sortArray[lwalker];\n                    sortArray[lwalker] = sortArray[rwalker];\n                    sortArray[rwalker] = tmp;\n                    lwalker++;\n                    rwalker--;\n                }\n            }\n\n            if (lwalker < right) push2(stack, lwalker, right);\n            if (rwalker > left) push2(stack, left, rwalker);\n        }\n    }\n\n    void EMSCRIPTEN_KEEPALIVE sort() {\n        quicksort(array, 0, N - 1);\n        // printArr(array, N);\n    }\n\n    void EMSCRIPTEN_KEEPALIVE test_printInt() {\n        printInt(N);\n    }\n\n    void EMSCRIPTEN_KEEPALIVE test_printStr() {\n        char str[] = \"test_printStr\";\n        printStr(str, 13);\n    }\n#ifdef __cplusplus\n}\n#endif\n```\n\n跟直接使用 WasmFiddle 不同，使用 Emscripten 来编译 C++ 到 Wasm 需要配合 Emscripten 对编译器的特殊优化和对应的宏来使用。为了实现非递归版本的快排算法，我们在这里使用了 C++ STL 库中提供的 `<stack>` 来作为栈容器。代码中的 `EMSCRIPTEN_KEEPALIVE` 宏用来强制编译器前端不对该方法使用 DCE，以防止代码在编译期间被清除。由于我们采用了 C++ 来编写此次实验的源码，因此在主体函数部分加上了 `extern \"C\" ` 防止 Mangling 带来的生成函数名不一致问题。\n\n由于现在的 Emscripten 还不支持 Standalone 版本的 WebAssembly，因此我们无法像之前一样使用浏览器提供的原生 Wasm API。前端部分的 JS 代码主要包含两个文件分别对应两个主要功能：\n\n1. 加载 Wasm 模块，并解析成字节码用于 Emscripten 前端全局的 Module 对象进行模块加载与实例化；\n2. 初始化一个 JS-Library，用于为 C++ 内的预置函数提供外部的函数实现；\n\n其中页面部分的代码如下所示：\n\n \n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title></title>\n</head>\n<body>\n\n<script>\n  // 初始化全局 Module，Emscripten 会自动为我们初始化；\n  var Module = {};\n\n  fetch(\"program.wasm\").then(response => response.arrayBuffer()).then((bytes) => {\n    // 填充主要数据；\n    Module.wasmBinary = bytes;\n    // 异步载入初始化脚本（该脚本文件是编译后自动生成的）；\n    var script = document.createElement(\"script\");\n    script.src = \"program.js\";\n    document.body.appendChild(script);\n  });\n\n  window.onload = function() {\n    // Module.ccall(\"test_printInt\");\n    // Module.ccall(\"test_printStr\");\n    // 获取数组偏移地址；\n    var arrayOffset = Module.ccall(\"getArrayOffset\", \"number\");\n\n    console.time(\"WASM-NO-RECURSION\");\n    var arr = [];\n    for (var j = 0; j < 1000000; j++) {\n      for (var i = 0; i < 100; i++) {\n        var number = Math.round(Math.random() * 100);\n        // arr.push(number); \n        // 在对应内存地址填充数据；\n        Module.setValue(arrayOffset + 4 * i, number, \"i32\");\n      }\n      /*\n      console.log(arr);\n      for (var i = 0; i < 100; i++) {\n        console.log(Module.getValue(arrayOffset + 4 * i, \"i32\"));\n      }\n      */\n      // 调用排序函数；\n      Module.ccall(\"sort\");\n    }\n    console.timeEnd(\"WASM-NO-RECURSION\");\n  }\n</script>\n</body>\n</html>\n```\n\n相对于之前使用浏览器提供的原生 Wasm API，这里我们需要使用 Emscripten 提供的 Module 全局对象上的方法来实现 C++ 函数的调用过程。同样的，对于指针的传递和内存数据的填充也是如此。下面给出 JS-Library 的代码，JS-Library 的代码需要单独放在一个 JS 文件里，文件名会在编译阶段以参数的形式传递给编译器。\n\n \n```javascript\nmergeInto(LibraryManager.library, {\n  printStr: function(offset, length) {\n    var str = \"\";\n    var arr = [];\n    for (var i = 0; i < length; i++) {\n      arr.push(Module.getValue(offset + i, \"i8\"));\n    }\n    console.log(new TextDecoder().decode(new Uint8Array(arr)));\n  },\n  printArr: function(offset, length) {\n    var str = \"\";\n    var arr = [];\n    for (var i = 0; i < length; i++) {\n      arr.push(Module.getValue(offset + 4 * i, \"i32\"));\n    }\n    console.log(arr);\n  },\n  printInt: function (int) {\n    console.log(int);\n  }\n});\n```\n\n这里需要注意在 `Module.getValue` 方法中需要指定的偏移为当前填充内存指针的偏移，需要根据填充的数据类型来决定偏移的单位大小（比如 int 类型一般为 4bytes，double 一般为 8bytes 等）。同时需要在最后一个参数中指定读取或者存储数据的长度，指针的偏移需要与数据长度匹配。\n\n在所有代码编写完毕之后，使用以下命令来编译代码：\n\n \n```bash\nemcc -s WASM=1 -O3 -o program.js program.cpp --js-library library.js\n```\n\n这里需要注意加入 `WASM=1` 参数来确保最后生成的代码是基于 Wasm 而不是 ASM.js 的。-03 代表编译器的优化程度，如果不使用该参数会导致 Wasm 在浏览器中运行时出现内存溢出的问题，原因暂时未知。\n\n在编译完成后 Emscripten 会自动生成一个 JS 文件和一个 Wasm 文件，JS 文件会自动初始化全局 Module，我们需要做的只是在初始化前获得 Wasm 的字节码并填充给 Module 对象，然后 Emscripten 会帮我们完成后续的加载工作。\n\n最后的测试结果，相比之前文章给出的实验数据并没有提高，反而效率更低、速度更慢了，具体原因还有待研究。Emscripten 工具链提供的功能远不止这么多，各种灵活的编译器参数和方法还需要进一步的实践和探索。\n\nBTW：这里主要使用了 BrowserSync 来作为本地服务器进行测试。可以直接通过 NPM 进行安装，开箱即用。\n","slug":"WebAssembly-尝试研究报告（二）","published":1,"updated":"2019-02-19T06:26:57.714Z","layout":"post","photos":[],"link":"","_id":"cjsqwhta7004dknp2lzbpfho8","content":"<p>在上一篇报告中，我们尝试通过对比 JS 侧的原生排序方法和 Wasm 端使用 C/C++ 编写的排序方法两者对同一大小数组的排序结果，让我们对 Wasm 应用的运行效率有了一个初步的认识。为了进一步优化 Wasm 的排序方法，接下来我们将优化递归版本的快排，并且尝试通过 Emscripten 在本地编译我们的代码。</p>\n<p>非递归版快排的具体原理这里我们不细讲。为了实现非递归版快排，我们需要使用一个“栈”来作为数据的中转容器。这里先上 C/C++ 部分的代码实现：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;emscripten/emscripten.h></span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stack></span></span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 定义数组大小；</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> N 100</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 防止 C++ 函数名被 Mangling；</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">ifdef</span> __cplusplus</span>\n<span class=\"token keyword\">extern</span> <span class=\"token string\">\"C\"</span> <span class=\"token punctuation\">{</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">endif</span></span>\n    <span class=\"token comment\" spellcheck=\"true\">// 预置函数，暴露给 JS 进行处理；</span>\n    <span class=\"token keyword\">extern</span> <span class=\"token keyword\">void</span> <span class=\"token function\">printStr</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span> offset<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">extern</span> <span class=\"token keyword\">void</span> <span class=\"token function\">printInt</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> number<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">extern</span> <span class=\"token keyword\">void</span> <span class=\"token function\">printArr</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span> offset<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> array<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 返回数组在内存中的偏移地址；</span>\n    <span class=\"token keyword\">int</span><span class=\"token operator\">*</span> EMSCRIPTEN_KEEPALIVE <span class=\"token function\">getArrayOffset</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> array<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">void</span> <span class=\"token function\">push2</span><span class=\"token punctuation\">(</span>std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>stack<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token operator\">&amp;</span>stack<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> left<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> right<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        stack<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        stack<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">void</span> <span class=\"token function\">quicksort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> sortArray<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> leftPart<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> rightPart<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>stack<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> stack<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">push2</span><span class=\"token punctuation\">(</span>stack<span class=\"token punctuation\">,</span> leftPart<span class=\"token punctuation\">,</span> rightPart<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> lwalker<span class=\"token punctuation\">,</span> rwalker<span class=\"token punctuation\">,</span> mid<span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>stack<span class=\"token punctuation\">.</span><span class=\"token function\">empty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> left <span class=\"token operator\">=</span> stack<span class=\"token punctuation\">.</span><span class=\"token function\">top</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> stack<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">int</span> right <span class=\"token operator\">=</span> stack<span class=\"token punctuation\">.</span><span class=\"token function\">top</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> stack<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            lwalker <span class=\"token operator\">=</span> left<span class=\"token punctuation\">;</span>\n            rwalker <span class=\"token operator\">=</span> right<span class=\"token punctuation\">;</span>\n            mid <span class=\"token operator\">=</span> sortArray<span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span>lwalker <span class=\"token operator\">+</span> rwalker<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>lwalker <span class=\"token operator\">&lt;</span> rwalker<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>sortArray<span class=\"token punctuation\">[</span>lwalker<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> mid<span class=\"token punctuation\">)</span> lwalker<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>sortArray<span class=\"token punctuation\">[</span>rwalker<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> mid<span class=\"token punctuation\">)</span> rwalker<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>lwalker <span class=\"token operator\">&lt;=</span> rwalker<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">int</span> tmp <span class=\"token operator\">=</span> sortArray<span class=\"token punctuation\">[</span>lwalker<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                    sortArray<span class=\"token punctuation\">[</span>lwalker<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> sortArray<span class=\"token punctuation\">[</span>rwalker<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                    sortArray<span class=\"token punctuation\">[</span>rwalker<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> tmp<span class=\"token punctuation\">;</span>\n                    lwalker<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n                    rwalker<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>lwalker <span class=\"token operator\">&lt;</span> right<span class=\"token punctuation\">)</span> <span class=\"token function\">push2</span><span class=\"token punctuation\">(</span>stack<span class=\"token punctuation\">,</span> lwalker<span class=\"token punctuation\">,</span> right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>rwalker <span class=\"token operator\">></span> left<span class=\"token punctuation\">)</span> <span class=\"token function\">push2</span><span class=\"token punctuation\">(</span>stack<span class=\"token punctuation\">,</span> left<span class=\"token punctuation\">,</span> rwalker<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">void</span> EMSCRIPTEN_KEEPALIVE <span class=\"token function\">sort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">quicksort</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> N <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// printArr(array, N);</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">void</span> EMSCRIPTEN_KEEPALIVE <span class=\"token function\">test_printInt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">printInt</span><span class=\"token punctuation\">(</span>N<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">void</span> EMSCRIPTEN_KEEPALIVE <span class=\"token function\">test_printStr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">char</span> str<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"test_printStr\"</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">printStr</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">,</span> <span class=\"token number\">13</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">ifdef</span> __cplusplus</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">endif</span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>跟直接使用 WasmFiddle 不同，使用 Emscripten 来编译 C++ 到 Wasm 需要配合 Emscripten 对编译器的特殊优化和对应的宏来使用。为了实现非递归版本的快排算法，我们在这里使用了 C++ STL 库中提供的 <code>&lt;stack&gt;</code> 来作为栈容器。代码中的 <code>EMSCRIPTEN_KEEPALIVE</code> 宏用来强制编译器前端不对该方法使用 DCE，以防止代码在编译期间被清除。由于我们采用了 C++ 来编写此次实验的源码，因此在主体函数部分加上了 <code>extern &quot;C&quot;</code> 防止 Mangling 带来的生成函数名不一致问题。</p>\n<p>由于现在的 Emscripten 还不支持 Standalone 版本的 WebAssembly，因此我们无法像之前一样使用浏览器提供的原生 Wasm API。前端部分的 JS 代码主要包含两个文件分别对应两个主要功能：</p>\n<ol>\n<li>加载 Wasm 模块，并解析成字节码用于 Emscripten 前端全局的 Module 对象进行模块加载与实例化；</li>\n<li>初始化一个 JS-Library，用于为 C++ 内的预置函数提供外部的函数实现；</li>\n</ol>\n<p>其中页面部分的代码如下所示：</p>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token doctype\">&lt;!DOCTYPE html></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>html</span> <span class=\"token attr-name\">lang</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>en<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>head</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>meta</span> <span class=\"token attr-name\">charset</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>UTF-8<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>title</span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>title</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>head</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>body</span><span class=\"token punctuation\">></span></span>\n\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span><span class=\"token punctuation\">></span></span><span class=\"token script language-javascript\">\n  <span class=\"token comment\" spellcheck=\"true\">// 初始化全局 Module，Emscripten 会自动为我们初始化；</span>\n  <span class=\"token keyword\">var</span> Module <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"program.wasm\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>response <span class=\"token operator\">=</span><span class=\"token operator\">></span> response<span class=\"token punctuation\">.</span><span class=\"token function\">arrayBuffer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>bytes<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 填充主要数据；</span>\n    Module<span class=\"token punctuation\">.</span>wasmBinary <span class=\"token operator\">=</span> bytes<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 异步载入初始化脚本（该脚本文件是编译后自动生成的）；</span>\n    <span class=\"token keyword\">var</span> script <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"script\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    script<span class=\"token punctuation\">.</span>src <span class=\"token operator\">=</span> <span class=\"token string\">\"program.js\"</span><span class=\"token punctuation\">;</span>\n    document<span class=\"token punctuation\">.</span>body<span class=\"token punctuation\">.</span><span class=\"token function\">appendChild</span><span class=\"token punctuation\">(</span>script<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  window<span class=\"token punctuation\">.</span>onload <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Module.ccall(\"test_printInt\");</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Module.ccall(\"test_printStr\");</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 获取数组偏移地址；</span>\n    <span class=\"token keyword\">var</span> arrayOffset <span class=\"token operator\">=</span> Module<span class=\"token punctuation\">.</span><span class=\"token function\">ccall</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"getArrayOffset\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"number\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">time</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"WASM-NO-RECURSION\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> <span class=\"token number\">1000000</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">var</span> number <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">round</span><span class=\"token punctuation\">(</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// arr.push(number); </span>\n        <span class=\"token comment\" spellcheck=\"true\">// 在对应内存地址填充数据；</span>\n        Module<span class=\"token punctuation\">.</span><span class=\"token function\">setValue</span><span class=\"token punctuation\">(</span>arrayOffset <span class=\"token operator\">+</span> <span class=\"token number\">4</span> <span class=\"token operator\">*</span> i<span class=\"token punctuation\">,</span> number<span class=\"token punctuation\">,</span> <span class=\"token string\">\"i32\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token comment\" spellcheck=\"true\">/*\n      console.log(arr);\n      for (var i = 0; i &lt; 100; i++) {\n        console.log(Module.getValue(arrayOffset + 4 * i, \"i32\"));\n      }\n      */</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 调用排序函数；</span>\n      Module<span class=\"token punctuation\">.</span><span class=\"token function\">ccall</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"sort\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">timeEnd</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"WASM-NO-RECURSION\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>body</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>html</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>相对于之前使用浏览器提供的原生 Wasm API，这里我们需要使用 Emscripten 提供的 Module 全局对象上的方法来实现 C++ 函数的调用过程。同样的，对于指针的传递和内存数据的填充也是如此。下面给出 JS-Library 的代码，JS-Library 的代码需要单独放在一个 JS 文件里，文件名会在编译阶段以参数的形式传递给编译器。</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">mergeInto</span><span class=\"token punctuation\">(</span>LibraryManager<span class=\"token punctuation\">.</span>library<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n  printStr<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>offset<span class=\"token punctuation\">,</span> length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> str <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      arr<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>Module<span class=\"token punctuation\">.</span><span class=\"token function\">getValue</span><span class=\"token punctuation\">(</span>offset <span class=\"token operator\">+</span> i<span class=\"token punctuation\">,</span> <span class=\"token string\">\"i8\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">TextDecoder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">decode</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Uint8Array</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  printArr<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>offset<span class=\"token punctuation\">,</span> length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> str <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      arr<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>Module<span class=\"token punctuation\">.</span><span class=\"token function\">getValue</span><span class=\"token punctuation\">(</span>offset <span class=\"token operator\">+</span> <span class=\"token number\">4</span> <span class=\"token operator\">*</span> i<span class=\"token punctuation\">,</span> <span class=\"token string\">\"i32\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  printInt<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>int<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>int<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这里需要注意在 <code>Module.getValue</code> 方法中需要指定的偏移为当前填充内存指针的偏移，需要根据填充的数据类型来决定偏移的单位大小（比如 int 类型一般为 4bytes，double 一般为 8bytes 等）。同时需要在最后一个参数中指定读取或者存储数据的长度，指针的偏移需要与数据长度匹配。</p>\n<p>在所有代码编写完毕之后，使用以下命令来编译代码：</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\">emcc -s WASM<span class=\"token operator\">=</span>1 -O3 -o program.js program.cpp --js-library library.js\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>这里需要注意加入 <code>WASM=1</code> 参数来确保最后生成的代码是基于 Wasm 而不是 ASM.js 的。-03 代表编译器的优化程度，如果不使用该参数会导致 Wasm 在浏览器中运行时出现内存溢出的问题，原因暂时未知。</p>\n<p>在编译完成后 Emscripten 会自动生成一个 JS 文件和一个 Wasm 文件，JS 文件会自动初始化全局 Module，我们需要做的只是在初始化前获得 Wasm 的字节码并填充给 Module 对象，然后 Emscripten 会帮我们完成后续的加载工作。</p>\n<p>最后的测试结果，相比之前文章给出的实验数据并没有提高，反而效率更低、速度更慢了，具体原因还有待研究。Emscripten 工具链提供的功能远不止这么多，各种灵活的编译器参数和方法还需要进一步的实践和探索。</p>\n<p>BTW：这里主要使用了 BrowserSync 来作为本地服务器进行测试。可以直接通过 NPM 进行安装，开箱即用。</p>\n","site":{"data":{}},"id":"62990b5cd159b075393ab046193d6de2","excerpt":"","more":"<p>在上一篇报告中，我们尝试通过对比 JS 侧的原生排序方法和 Wasm 端使用 C/C++ 编写的排序方法两者对同一大小数组的排序结果，让我们对 Wasm 应用的运行效率有了一个初步的认识。为了进一步优化 Wasm 的排序方法，接下来我们将优化递归版本的快排，并且尝试通过 Emscripten 在本地编译我们的代码。</p>\n<p>非递归版快排的具体原理这里我们不细讲。为了实现非递归版快排，我们需要使用一个“栈”来作为数据的中转容器。这里先上 C/C++ 部分的代码实现：</p>\n<pre><code class=\"c\">#include &lt;emscripten/emscripten.h&gt;\n#include &lt;stack&gt;\n\n// 定义数组大小；\n#define N 100\n\n// 防止 C++ 函数名被 Mangling；\n#ifdef __cplusplus\nextern &quot;C&quot; {\n#endif\n    // 预置函数，暴露给 JS 进行处理；\n    extern void printStr(char* offset, int length);\n    extern void printInt(int number);\n    extern void printArr(int* offset, int length);\n\n    int array[N];\n    // 返回数组在内存中的偏移地址；\n    int* EMSCRIPTEN_KEEPALIVE getArrayOffset() {\n        return array;\n    }\n\n    void push2(std::stack&lt;int&gt; &amp;stack, int left, int right) {\n        stack.push(right);\n        stack.push(left);\n    }\n\n    void quicksort(int sortArray[], int leftPart, int rightPart) {\n        std::stack&lt;int&gt; stack;\n        push2(stack, leftPart, rightPart);\n        int lwalker, rwalker, mid;\n\n        while (!stack.empty()) {\n            int left = stack.top(); stack.pop();\n            int right = stack.top(); stack.pop();\n            lwalker = left;\n            rwalker = right;\n            mid = sortArray[(lwalker + rwalker) / 2];\n\n            while (lwalker &lt; rwalker) {\n                while(sortArray[lwalker] &lt; mid) lwalker++;\n                while(sortArray[rwalker] &gt; mid) rwalker--;\n\n                if (lwalker &lt;= rwalker) {\n                    int tmp = sortArray[lwalker];\n                    sortArray[lwalker] = sortArray[rwalker];\n                    sortArray[rwalker] = tmp;\n                    lwalker++;\n                    rwalker--;\n                }\n            }\n\n            if (lwalker &lt; right) push2(stack, lwalker, right);\n            if (rwalker &gt; left) push2(stack, left, rwalker);\n        }\n    }\n\n    void EMSCRIPTEN_KEEPALIVE sort() {\n        quicksort(array, 0, N - 1);\n        // printArr(array, N);\n    }\n\n    void EMSCRIPTEN_KEEPALIVE test_printInt() {\n        printInt(N);\n    }\n\n    void EMSCRIPTEN_KEEPALIVE test_printStr() {\n        char str[] = &quot;test_printStr&quot;;\n        printStr(str, 13);\n    }\n#ifdef __cplusplus\n}\n#endif\n</code></pre>\n<p>跟直接使用 WasmFiddle 不同，使用 Emscripten 来编译 C++ 到 Wasm 需要配合 Emscripten 对编译器的特殊优化和对应的宏来使用。为了实现非递归版本的快排算法，我们在这里使用了 C++ STL 库中提供的 <code>&lt;stack&gt;</code> 来作为栈容器。代码中的 <code>EMSCRIPTEN_KEEPALIVE</code> 宏用来强制编译器前端不对该方法使用 DCE，以防止代码在编译期间被清除。由于我们采用了 C++ 来编写此次实验的源码，因此在主体函数部分加上了 <code>extern &quot;C&quot;</code> 防止 Mangling 带来的生成函数名不一致问题。</p>\n<p>由于现在的 Emscripten 还不支持 Standalone 版本的 WebAssembly，因此我们无法像之前一样使用浏览器提供的原生 Wasm API。前端部分的 JS 代码主要包含两个文件分别对应两个主要功能：</p>\n<ol>\n<li>加载 Wasm 模块，并解析成字节码用于 Emscripten 前端全局的 Module 对象进行模块加载与实例化；</li>\n<li>初始化一个 JS-Library，用于为 C++ 内的预置函数提供外部的函数实现；</li>\n</ol>\n<p>其中页面部分的代码如下所示：</p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n&lt;script&gt;\n  // 初始化全局 Module，Emscripten 会自动为我们初始化；\n  var Module = {};\n\n  fetch(&quot;program.wasm&quot;).then(response =&gt; response.arrayBuffer()).then((bytes) =&gt; {\n    // 填充主要数据；\n    Module.wasmBinary = bytes;\n    // 异步载入初始化脚本（该脚本文件是编译后自动生成的）；\n    var script = document.createElement(&quot;script&quot;);\n    script.src = &quot;program.js&quot;;\n    document.body.appendChild(script);\n  });\n\n  window.onload = function() {\n    // Module.ccall(&quot;test_printInt&quot;);\n    // Module.ccall(&quot;test_printStr&quot;);\n    // 获取数组偏移地址；\n    var arrayOffset = Module.ccall(&quot;getArrayOffset&quot;, &quot;number&quot;);\n\n    console.time(&quot;WASM-NO-RECURSION&quot;);\n    var arr = [];\n    for (var j = 0; j &lt; 1000000; j++) {\n      for (var i = 0; i &lt; 100; i++) {\n        var number = Math.round(Math.random() * 100);\n        // arr.push(number); \n        // 在对应内存地址填充数据；\n        Module.setValue(arrayOffset + 4 * i, number, &quot;i32&quot;);\n      }\n      /*\n      console.log(arr);\n      for (var i = 0; i &lt; 100; i++) {\n        console.log(Module.getValue(arrayOffset + 4 * i, &quot;i32&quot;));\n      }\n      */\n      // 调用排序函数；\n      Module.ccall(&quot;sort&quot;);\n    }\n    console.timeEnd(&quot;WASM-NO-RECURSION&quot;);\n  }\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>相对于之前使用浏览器提供的原生 Wasm API，这里我们需要使用 Emscripten 提供的 Module 全局对象上的方法来实现 C++ 函数的调用过程。同样的，对于指针的传递和内存数据的填充也是如此。下面给出 JS-Library 的代码，JS-Library 的代码需要单独放在一个 JS 文件里，文件名会在编译阶段以参数的形式传递给编译器。</p>\n<pre><code class=\"javascript\">mergeInto(LibraryManager.library, {\n  printStr: function(offset, length) {\n    var str = &quot;&quot;;\n    var arr = [];\n    for (var i = 0; i &lt; length; i++) {\n      arr.push(Module.getValue(offset + i, &quot;i8&quot;));\n    }\n    console.log(new TextDecoder().decode(new Uint8Array(arr)));\n  },\n  printArr: function(offset, length) {\n    var str = &quot;&quot;;\n    var arr = [];\n    for (var i = 0; i &lt; length; i++) {\n      arr.push(Module.getValue(offset + 4 * i, &quot;i32&quot;));\n    }\n    console.log(arr);\n  },\n  printInt: function (int) {\n    console.log(int);\n  }\n});\n</code></pre>\n<p>这里需要注意在 <code>Module.getValue</code> 方法中需要指定的偏移为当前填充内存指针的偏移，需要根据填充的数据类型来决定偏移的单位大小（比如 int 类型一般为 4bytes，double 一般为 8bytes 等）。同时需要在最后一个参数中指定读取或者存储数据的长度，指针的偏移需要与数据长度匹配。</p>\n<p>在所有代码编写完毕之后，使用以下命令来编译代码：</p>\n<pre><code class=\"bash\">emcc -s WASM=1 -O3 -o program.js program.cpp --js-library library.js\n</code></pre>\n<p>这里需要注意加入 <code>WASM=1</code> 参数来确保最后生成的代码是基于 Wasm 而不是 ASM.js 的。-03 代表编译器的优化程度，如果不使用该参数会导致 Wasm 在浏览器中运行时出现内存溢出的问题，原因暂时未知。</p>\n<p>在编译完成后 Emscripten 会自动生成一个 JS 文件和一个 Wasm 文件，JS 文件会自动初始化全局 Module，我们需要做的只是在初始化前获得 Wasm 的字节码并填充给 Module 对象，然后 Emscripten 会帮我们完成后续的加载工作。</p>\n<p>最后的测试结果，相比之前文章给出的实验数据并没有提高，反而效率更低、速度更慢了，具体原因还有待研究。Emscripten 工具链提供的功能远不止这么多，各种灵活的编译器参数和方法还需要进一步的实践和探索。</p>\n<p>BTW：这里主要使用了 BrowserSync 来作为本地服务器进行测试。可以直接通过 NPM 进行安装，开箱即用。</p>\n"},{"title":"WebAssembly 深入研究报告 - 二进制编码","intro":"本篇报告我们来看一下 WebAssembly 的二进制编码格式。为什么 Wasm 会选择设计一种新的二进制编码格式，而不直接使用 ASM.js 的 ASCII 文本格式？Wasm 的 OpCode 操作码格式是怎样的？Wasm 模块在内存中的格式，以及用于验证模块的魔术字符是什么？","comments":1,"date":"2017-06-20T15:14:21.000Z","_content":"\n本篇报告我们来看一下 WebAssembly 的二进制编码格式。为什么 Wasm 会选择设计一种新的二进制编码格式，而不直接使用 ASM.js 的 ASCII 文本格式？Wasm 的 OpCode 操作码格式是怎样的？Wasm 模块在内存中的格式，以及用于验证模块的魔术字符是什么？\n\n#### 1、二进制编码的数字类型：\n\n![](1.png)\n\n在 MVP 中用于编码 WebAssembly 二进制格式的数字类型有如下几种：整数类型 `uint8`、`uint16`、`uint32`，可以很直观的看出来这三种类型分别对应于无符号的8位、16位和32位整数。所有这几种整数类型在内存中都是以“小端字节序”的方式排列的，即低位字节排放在内存的低地址端，高位字节排放在内存的高地址端(如上图所示)。除了固定长度的整数外，Wasm 还支持基于小端字节序的 LEB128 可变长度编码，其无符号类型表示为`varuint1`、`varuint7`、`varuint32`，有符号类型表示为`varint7`、`varint32`、`varint64`。LEB128 编码以每7位为一个整体对一个二进制整数进行编码。首先将每7位组成一个字节，然后再根据是否还有后续字节，分别对该字节的最高位填入0或1，最后将这一系列的字节以小端字节序的方式存入内存。因此在解码 LEB128 编码的序列时要注意只有每个字节的最后7位才是有效数字。下面是一个无符号整数的 LEB128 编码例子。这几种数字编码类型都是用来编码 Wasm 原始二进制格式的。\n\n \n```text\n      10011000011101100101  In raw binary\n     010011000011101100101  Padded to a multiple of 7 bits\n 0100110  0001110  1100101  Split into 7-bit groups\n00100110 10001110 11100101  Add high 1 bits on all but last group to form bytes\n    0x26     0x8E     0xE5  In hexadecimal\n0xE5 0x8E 0x26              Output stream\n```\n\n#### 2、指令操作码（OpCode）：\n\n由于 MVP 的指令个数只有不到 256 个，因此 Wasm 的指令操作码现阶段全部编码为 1byte 的大小,在未来会通过增加 Pre-fixes 的方式来扩展更多的指令。OpCode 主要用在汇编程序解析汇编指令时，汇编程序会将对应的每条 ASM 指令转换成一个对应的 OpCode，以便计算机后续的指令执行。如下图所示是 PHP 中 OpCode 的组成格式（仅作为参考），每一个 OpCode 由六个数据域组成，并且其中只有 Code 域是必须存在的，其他均为可选域。\n\n![](2.png)\n\n#### 3、语言层次的类型：\n\n我们可以在 WebAssembly 的可读文本格式 Wast 文件中查看一个 Wasm 模块在内存中的逻辑表示，模块的逻辑使用 “S 表达式”进行表达。在 Wast 中可以看到很多常用的类型标识，如下所示的代码：\n\n\n```text\n(module\n  (import \"env\" \"printInt\" (func $printInt (param i32)))\n  (import \"env\" \"printFloat\" (func $printFloat (param f32)))\n  (import \"env\" \"print\" (func $print (param i32 i32)))\n\n  (memory $memory 1)\n  (data (i32.const 0) \"\")\n  (data (i32.const 1) \"Hello World!\")\n\n  (func $endl\n    (call $print (i32.const 0) (i32.const 1)))\n\n  (func $main\n    (call $printInt (i32.const 9))\n    (call $endl)\n    (call $printFloat (f32.const 6.28))\n    (call $endl)\n    (call $print (i32.const 1) (i32.const 12))\n    )\n\n  (export \"main\" (func $main))\n  (export \"memory\" (memory $memory))\n)\n```\n\n比如上述 S 表达式中出现的 `i32` 和 `f32`，分别代表 Wasm 模块中的一个32位整数和一个32位浮点数。`func` 代表一个函数类型等。所有语言层面的类型在模块的二进制代码中都以一个负的 varint7 值作为每种类型编码值的第一位作为区分字符，其中的一部分类型如下表所示。\n\n \n```text\n-0x01/0x7f  i32\n-0x02/0x7e  i64\n-0x03/0x7d  f32\n-0x04/0x7c  f64\n-0x10/0x70  anyfunc\n-0x20/0x60  func\n-0x40/0x40  block_type\n```\n\n#### 4、模块结构：\n\n \n```c\nint main() { \n    return 42;\n} \n```\n\n我们将如上所示的 C/C++ 源码编译成一个 Wasm 模块，该模块对应的二进制内容如下所示（以十六进制表示）：\n\n \n```text\n<span style=\"color:#FF0000;\">0061 736d</span> <span style=\"color:#FF8C00;\">0100</span> <span style=\"color:#FFA500;\">0000</span> <span style=\"color:#FFD700;\">01</span>85 8080 8000 0160\n0001 7f03 8280 8080 0001 0004 8480 8080\n0001 7000 0005 8380 8080 0001 0001 0681\n8080 8000 0007 9180 8080 0002 066d 656d\n6f72 7902 0004 6d61 696e 0000 0a8a 8080\n8000 0184 8080 8000 0041 2a0b \n```\n\n接下来我们来看下该 Wasm 模块的二进制编码格式。首先，模块由两个前置字段作为整个模块的起始字段。第一个字段的内容为 `0x6d736100`，是 Wasm 模块的魔术字符，如果将该字段的内容转换成 ASCII 码格式可以发现其内容是 “**(null)asm**”。第二个字段指定了该模块的版本号，内容为 `0x1`。由于 Wasm 对其二进制格式的编码采用了小端字节序的方式，因此我们可以看到上述二进制编码的前两个字节恰好是魔术字符的最后两个字节。浏览器在解析 Wasm 的二进制格式时会把先读到二进制代码放入内存的低位空间，后续读取到的代码放到高位空间。版本之后的内容是由一个个“段”组成的。每个段首先以一个7位的 varuint7 类型 ID 作为起始，接下是一个变长的 varuint32 数代表了当前段以字节为单位的大小。我们也可以使用 `hexdump` 来直观的查看一个 Wasm 二进制模块的结构，使用命令：`hexdump -C program.wasm`，结果显示如下。\n\n![](3.png)\n\n我们先根据每个 Section 的 ID 将整个模块的二进制代码分为如下所示的几个部分：\n\n \n```text\nSectionNamae   Seperator           PayloadSize  PayloadContent\nTpye           01 85 80 80 80 00   (5bytes)     01 60 00 01 7f\nFunction       03 82 80 80 80 00   (2bytes)     01 00\nTable          04 84 80 80 80 00   (4bytes)     01 70 00 00\nMemory         05 83 80 80 80 00   (3bytes)     01 00 01\nGlobal         06 81 80 80 80 00   (1bytes)     0\nExport         07 91 80 80 80 00   (17bytes)    02 06 6d 65 6d 6f 72 79 02 00 04 6d 61 69 6e 00 00\nCode           0a 8a 80 80 80 00   (10bytes)    01 84 80 80 80 00 00 41 2a 0b\n```\n\n通过上面给出的分类表我们可以看到，根据每个 Section 的头部特征我们可以将整个二进制代码分解为除“魔术字符”和“版本号”外的多个“段”，每个“段”都有自己对应的功能和结构。由于我们的代码中没有引入自定义“段”，因此这里列出的该模块内所有“段”的 ID 均不为0。这样每个“段”的内容均只包含三个字段部分：\"段ID\"、“段大小”以及“段内容”。在上面的表格中我将“段ID”和“段大小”两个字段的内容统一整合为一个 “Seperator” 字段。“Seperator” 字段的第一位代表了该“段”的类型，接下来的五位是一个 varuint32 类型，代表了该“段”内容部分的长度。比如第一个 Type “段”的“段大小”字段值为5，因此接下来的5个比特均为该“段”的“段内容”数据。\n\n每个不同类型的“段”所对应的“段内容”又对应着不同的子结构，这里我们将以 Export 和 Code 两个段结构为例来进行讲解，其他类型的段结构分析方式基本类似。\n\n\n![](4.png)\n\n\n如上图所示的 Export Section 的“段内容”结构。一个 Export Section 结构被分为两部分：第一部分为 Export Entity 的个数，第二部分为对应的 Export Entity 实体内容。我们可以根据上图将该 Wasm 模块的 Export Section 分为如下部分。该模块需要导出的对象有两个，每个导出对象的实体又分别对应着“域标志长度”、“域标示”、“域类型“和”域索引“。\n\n \n```text\nExport Entity 个数:        02 \n第一个 Export Entity 结构:  06 6d 65 6d 6f 72 79 02 00 \n第二个 Export Entity 结构:  04 6d 61 69 6e 00 00\n```\n\n接着我们对第一个 Export Entity 再进行分解，结果如下所示。该 Export Entity 的”域标志长度“为6，因此接下来的6个比特为该 Export Entity 的”域标志“，其内容对应的 ASCII 码为 ”memory“。域类型02代表着 Memory 类型。域索引值为0。以此类推，第二个 Export Entity 其实就是我们在 C/C++ 源码中导出的 main 函数，其”域标志“对应的 ASCII 码为 ”main“，域类型00代表着 Function 类型，域索引值为0。接下来我们再来看 Code Section 的结构。\n\n \n```text\n域标志的长度:    06\n域标示:         6d 65 6d 6f 72 79\n域类型:         02\n域索引:         00\n```\n\n![](5.png)\n\nCode Section 代表着导出函数的函数体内容，该“段”对应的函数个数要与 Function Section 相对应。可以看到在 Function Section 中得到的该模块的导出函数个数为1，因此对应的 Code Section 中只有一个函数体的内容。同时，Code Section 中的第 i 个函数体定义也要对应着 Type Section 中的第 i 个函数签名（Type Section 中定义了各个函数的函数、参数和返回值类型）。根据 Code Section 的结构我们得到如下分析结果。\n\n \n```text\n函数体的内容:   84 80 80 80 00 00 41 2a 0b\n函数体的大小:   84 80 80 80 00 \n本地变量个数:   00\n函数体的代码:   41 2a\n函数结束标志:   0b\n```\n\n![](6.png)\n\n\n其中的“函数体代码”便是我们在 main 函数中写的返回语句 `return 42`。其他部分可以根据上图给出的 Function Section 字段进行一一对应。再回过头来看，Type Section 的最后一个字段表示对应函数的返回值类型。这里可以看到该模块的唯一一个函数的返回值是 “7f” 类型。再结合我们之前讲过的 Wasm 模块在语言层面的类型可以知道这是一个 i32（32位整数）类型的值。\n","source":"_posts/WebAssembly-深入研究报告-二进制编码.md","raw":"---\ntitle: WebAssembly 深入研究报告 - 二进制编码\nintro: 本篇报告我们来看一下 WebAssembly 的二进制编码格式。为什么 Wasm 会选择设计一种新的二进制编码格式，而不直接使用 ASM.js 的 ASCII 文本格式？Wasm 的 OpCode 操作码格式是怎样的？Wasm 模块在内存中的格式，以及用于验证模块的魔术字符是什么？\ncomments: true\ndate: 2017-06-20 23:14:21\ntags:\n- WebAssembly\n---\n\n本篇报告我们来看一下 WebAssembly 的二进制编码格式。为什么 Wasm 会选择设计一种新的二进制编码格式，而不直接使用 ASM.js 的 ASCII 文本格式？Wasm 的 OpCode 操作码格式是怎样的？Wasm 模块在内存中的格式，以及用于验证模块的魔术字符是什么？\n\n#### 1、二进制编码的数字类型：\n\n![](1.png)\n\n在 MVP 中用于编码 WebAssembly 二进制格式的数字类型有如下几种：整数类型 `uint8`、`uint16`、`uint32`，可以很直观的看出来这三种类型分别对应于无符号的8位、16位和32位整数。所有这几种整数类型在内存中都是以“小端字节序”的方式排列的，即低位字节排放在内存的低地址端，高位字节排放在内存的高地址端(如上图所示)。除了固定长度的整数外，Wasm 还支持基于小端字节序的 LEB128 可变长度编码，其无符号类型表示为`varuint1`、`varuint7`、`varuint32`，有符号类型表示为`varint7`、`varint32`、`varint64`。LEB128 编码以每7位为一个整体对一个二进制整数进行编码。首先将每7位组成一个字节，然后再根据是否还有后续字节，分别对该字节的最高位填入0或1，最后将这一系列的字节以小端字节序的方式存入内存。因此在解码 LEB128 编码的序列时要注意只有每个字节的最后7位才是有效数字。下面是一个无符号整数的 LEB128 编码例子。这几种数字编码类型都是用来编码 Wasm 原始二进制格式的。\n\n \n```text\n      10011000011101100101  In raw binary\n     010011000011101100101  Padded to a multiple of 7 bits\n 0100110  0001110  1100101  Split into 7-bit groups\n00100110 10001110 11100101  Add high 1 bits on all but last group to form bytes\n    0x26     0x8E     0xE5  In hexadecimal\n0xE5 0x8E 0x26              Output stream\n```\n\n#### 2、指令操作码（OpCode）：\n\n由于 MVP 的指令个数只有不到 256 个，因此 Wasm 的指令操作码现阶段全部编码为 1byte 的大小,在未来会通过增加 Pre-fixes 的方式来扩展更多的指令。OpCode 主要用在汇编程序解析汇编指令时，汇编程序会将对应的每条 ASM 指令转换成一个对应的 OpCode，以便计算机后续的指令执行。如下图所示是 PHP 中 OpCode 的组成格式（仅作为参考），每一个 OpCode 由六个数据域组成，并且其中只有 Code 域是必须存在的，其他均为可选域。\n\n![](2.png)\n\n#### 3、语言层次的类型：\n\n我们可以在 WebAssembly 的可读文本格式 Wast 文件中查看一个 Wasm 模块在内存中的逻辑表示，模块的逻辑使用 “S 表达式”进行表达。在 Wast 中可以看到很多常用的类型标识，如下所示的代码：\n\n\n```text\n(module\n  (import \"env\" \"printInt\" (func $printInt (param i32)))\n  (import \"env\" \"printFloat\" (func $printFloat (param f32)))\n  (import \"env\" \"print\" (func $print (param i32 i32)))\n\n  (memory $memory 1)\n  (data (i32.const 0) \"\")\n  (data (i32.const 1) \"Hello World!\")\n\n  (func $endl\n    (call $print (i32.const 0) (i32.const 1)))\n\n  (func $main\n    (call $printInt (i32.const 9))\n    (call $endl)\n    (call $printFloat (f32.const 6.28))\n    (call $endl)\n    (call $print (i32.const 1) (i32.const 12))\n    )\n\n  (export \"main\" (func $main))\n  (export \"memory\" (memory $memory))\n)\n```\n\n比如上述 S 表达式中出现的 `i32` 和 `f32`，分别代表 Wasm 模块中的一个32位整数和一个32位浮点数。`func` 代表一个函数类型等。所有语言层面的类型在模块的二进制代码中都以一个负的 varint7 值作为每种类型编码值的第一位作为区分字符，其中的一部分类型如下表所示。\n\n \n```text\n-0x01/0x7f  i32\n-0x02/0x7e  i64\n-0x03/0x7d  f32\n-0x04/0x7c  f64\n-0x10/0x70  anyfunc\n-0x20/0x60  func\n-0x40/0x40  block_type\n```\n\n#### 4、模块结构：\n\n \n```c\nint main() { \n    return 42;\n} \n```\n\n我们将如上所示的 C/C++ 源码编译成一个 Wasm 模块，该模块对应的二进制内容如下所示（以十六进制表示）：\n\n \n```text\n<span style=\"color:#FF0000;\">0061 736d</span> <span style=\"color:#FF8C00;\">0100</span> <span style=\"color:#FFA500;\">0000</span> <span style=\"color:#FFD700;\">01</span>85 8080 8000 0160\n0001 7f03 8280 8080 0001 0004 8480 8080\n0001 7000 0005 8380 8080 0001 0001 0681\n8080 8000 0007 9180 8080 0002 066d 656d\n6f72 7902 0004 6d61 696e 0000 0a8a 8080\n8000 0184 8080 8000 0041 2a0b \n```\n\n接下来我们来看下该 Wasm 模块的二进制编码格式。首先，模块由两个前置字段作为整个模块的起始字段。第一个字段的内容为 `0x6d736100`，是 Wasm 模块的魔术字符，如果将该字段的内容转换成 ASCII 码格式可以发现其内容是 “**(null)asm**”。第二个字段指定了该模块的版本号，内容为 `0x1`。由于 Wasm 对其二进制格式的编码采用了小端字节序的方式，因此我们可以看到上述二进制编码的前两个字节恰好是魔术字符的最后两个字节。浏览器在解析 Wasm 的二进制格式时会把先读到二进制代码放入内存的低位空间，后续读取到的代码放到高位空间。版本之后的内容是由一个个“段”组成的。每个段首先以一个7位的 varuint7 类型 ID 作为起始，接下是一个变长的 varuint32 数代表了当前段以字节为单位的大小。我们也可以使用 `hexdump` 来直观的查看一个 Wasm 二进制模块的结构，使用命令：`hexdump -C program.wasm`，结果显示如下。\n\n![](3.png)\n\n我们先根据每个 Section 的 ID 将整个模块的二进制代码分为如下所示的几个部分：\n\n \n```text\nSectionNamae   Seperator           PayloadSize  PayloadContent\nTpye           01 85 80 80 80 00   (5bytes)     01 60 00 01 7f\nFunction       03 82 80 80 80 00   (2bytes)     01 00\nTable          04 84 80 80 80 00   (4bytes)     01 70 00 00\nMemory         05 83 80 80 80 00   (3bytes)     01 00 01\nGlobal         06 81 80 80 80 00   (1bytes)     0\nExport         07 91 80 80 80 00   (17bytes)    02 06 6d 65 6d 6f 72 79 02 00 04 6d 61 69 6e 00 00\nCode           0a 8a 80 80 80 00   (10bytes)    01 84 80 80 80 00 00 41 2a 0b\n```\n\n通过上面给出的分类表我们可以看到，根据每个 Section 的头部特征我们可以将整个二进制代码分解为除“魔术字符”和“版本号”外的多个“段”，每个“段”都有自己对应的功能和结构。由于我们的代码中没有引入自定义“段”，因此这里列出的该模块内所有“段”的 ID 均不为0。这样每个“段”的内容均只包含三个字段部分：\"段ID\"、“段大小”以及“段内容”。在上面的表格中我将“段ID”和“段大小”两个字段的内容统一整合为一个 “Seperator” 字段。“Seperator” 字段的第一位代表了该“段”的类型，接下来的五位是一个 varuint32 类型，代表了该“段”内容部分的长度。比如第一个 Type “段”的“段大小”字段值为5，因此接下来的5个比特均为该“段”的“段内容”数据。\n\n每个不同类型的“段”所对应的“段内容”又对应着不同的子结构，这里我们将以 Export 和 Code 两个段结构为例来进行讲解，其他类型的段结构分析方式基本类似。\n\n\n![](4.png)\n\n\n如上图所示的 Export Section 的“段内容”结构。一个 Export Section 结构被分为两部分：第一部分为 Export Entity 的个数，第二部分为对应的 Export Entity 实体内容。我们可以根据上图将该 Wasm 模块的 Export Section 分为如下部分。该模块需要导出的对象有两个，每个导出对象的实体又分别对应着“域标志长度”、“域标示”、“域类型“和”域索引“。\n\n \n```text\nExport Entity 个数:        02 \n第一个 Export Entity 结构:  06 6d 65 6d 6f 72 79 02 00 \n第二个 Export Entity 结构:  04 6d 61 69 6e 00 00\n```\n\n接着我们对第一个 Export Entity 再进行分解，结果如下所示。该 Export Entity 的”域标志长度“为6，因此接下来的6个比特为该 Export Entity 的”域标志“，其内容对应的 ASCII 码为 ”memory“。域类型02代表着 Memory 类型。域索引值为0。以此类推，第二个 Export Entity 其实就是我们在 C/C++ 源码中导出的 main 函数，其”域标志“对应的 ASCII 码为 ”main“，域类型00代表着 Function 类型，域索引值为0。接下来我们再来看 Code Section 的结构。\n\n \n```text\n域标志的长度:    06\n域标示:         6d 65 6d 6f 72 79\n域类型:         02\n域索引:         00\n```\n\n![](5.png)\n\nCode Section 代表着导出函数的函数体内容，该“段”对应的函数个数要与 Function Section 相对应。可以看到在 Function Section 中得到的该模块的导出函数个数为1，因此对应的 Code Section 中只有一个函数体的内容。同时，Code Section 中的第 i 个函数体定义也要对应着 Type Section 中的第 i 个函数签名（Type Section 中定义了各个函数的函数、参数和返回值类型）。根据 Code Section 的结构我们得到如下分析结果。\n\n \n```text\n函数体的内容:   84 80 80 80 00 00 41 2a 0b\n函数体的大小:   84 80 80 80 00 \n本地变量个数:   00\n函数体的代码:   41 2a\n函数结束标志:   0b\n```\n\n![](6.png)\n\n\n其中的“函数体代码”便是我们在 main 函数中写的返回语句 `return 42`。其他部分可以根据上图给出的 Function Section 字段进行一一对应。再回过头来看，Type Section 的最后一个字段表示对应函数的返回值类型。这里可以看到该模块的唯一一个函数的返回值是 “7f” 类型。再结合我们之前讲过的 Wasm 模块在语言层面的类型可以知道这是一个 i32（32位整数）类型的值。\n","slug":"WebAssembly-深入研究报告-二进制编码","published":1,"updated":"2019-02-19T09:27:48.034Z","layout":"post","photos":[],"link":"","_id":"cjsqwhta8004fknp2csi25llj","content":"<p>本篇报告我们来看一下 WebAssembly 的二进制编码格式。为什么 Wasm 会选择设计一种新的二进制编码格式，而不直接使用 ASM.js 的 ASCII 文本格式？Wasm 的 OpCode 操作码格式是怎样的？Wasm 模块在内存中的格式，以及用于验证模块的魔术字符是什么？</p>\n<h4 id=\"1、二进制编码的数字类型：\"><a href=\"#1、二进制编码的数字类型：\" class=\"headerlink\" title=\"1、二进制编码的数字类型：\"></a>1、二进制编码的数字类型：</h4><p><img src=\"1.png\" alt></p>\n<p>在 MVP 中用于编码 WebAssembly 二进制格式的数字类型有如下几种：整数类型 <code>uint8</code>、<code>uint16</code>、<code>uint32</code>，可以很直观的看出来这三种类型分别对应于无符号的8位、16位和32位整数。所有这几种整数类型在内存中都是以“小端字节序”的方式排列的，即低位字节排放在内存的低地址端，高位字节排放在内存的高地址端(如上图所示)。除了固定长度的整数外，Wasm 还支持基于小端字节序的 LEB128 可变长度编码，其无符号类型表示为<code>varuint1</code>、<code>varuint7</code>、<code>varuint32</code>，有符号类型表示为<code>varint7</code>、<code>varint32</code>、<code>varint64</code>。LEB128 编码以每7位为一个整体对一个二进制整数进行编码。首先将每7位组成一个字节，然后再根据是否还有后续字节，分别对该字节的最高位填入0或1，最后将这一系列的字节以小端字节序的方式存入内存。因此在解码 LEB128 编码的序列时要注意只有每个字节的最后7位才是有效数字。下面是一个无符号整数的 LEB128 编码例子。这几种数字编码类型都是用来编码 Wasm 原始二进制格式的。</p>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">      10011000011101100101  In raw binary\n     010011000011101100101  Padded to a multiple of 7 bits\n 0100110  0001110  1100101  Split into 7-bit groups\n00100110 10001110 11100101  Add high 1 bits on all but last group to form bytes\n    0x26     0x8E     0xE5  In hexadecimal\n0xE5 0x8E 0x26              Output stream\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"2、指令操作码（OpCode）：\"><a href=\"#2、指令操作码（OpCode）：\" class=\"headerlink\" title=\"2、指令操作码（OpCode）：\"></a>2、指令操作码（OpCode）：</h4><p>由于 MVP 的指令个数只有不到 256 个，因此 Wasm 的指令操作码现阶段全部编码为 1byte 的大小,在未来会通过增加 Pre-fixes 的方式来扩展更多的指令。OpCode 主要用在汇编程序解析汇编指令时，汇编程序会将对应的每条 ASM 指令转换成一个对应的 OpCode，以便计算机后续的指令执行。如下图所示是 PHP 中 OpCode 的组成格式（仅作为参考），每一个 OpCode 由六个数据域组成，并且其中只有 Code 域是必须存在的，其他均为可选域。</p>\n<p><img src=\"2.png\" alt></p>\n<h4 id=\"3、语言层次的类型：\"><a href=\"#3、语言层次的类型：\" class=\"headerlink\" title=\"3、语言层次的类型：\"></a>3、语言层次的类型：</h4><p>我们可以在 WebAssembly 的可读文本格式 Wast 文件中查看一个 Wasm 模块在内存中的逻辑表示，模块的逻辑使用 “S 表达式”进行表达。在 Wast 中可以看到很多常用的类型标识，如下所示的代码：</p>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">(module\n  (import \"env\" \"printInt\" (func $printInt (param i32)))\n  (import \"env\" \"printFloat\" (func $printFloat (param f32)))\n  (import \"env\" \"print\" (func $print (param i32 i32)))\n\n  (memory $memory 1)\n  (data (i32.const 0) \"\")\n  (data (i32.const 1) \"Hello World!\")\n\n  (func $endl\n    (call $print (i32.const 0) (i32.const 1)))\n\n  (func $main\n    (call $printInt (i32.const 9))\n    (call $endl)\n    (call $printFloat (f32.const 6.28))\n    (call $endl)\n    (call $print (i32.const 1) (i32.const 12))\n    )\n\n  (export \"main\" (func $main))\n  (export \"memory\" (memory $memory))\n)\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>比如上述 S 表达式中出现的 <code>i32</code> 和 <code>f32</code>，分别代表 Wasm 模块中的一个32位整数和一个32位浮点数。<code>func</code> 代表一个函数类型等。所有语言层面的类型在模块的二进制代码中都以一个负的 varint7 值作为每种类型编码值的第一位作为区分字符，其中的一部分类型如下表所示。</p>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">-0x01/0x7f  i32\n-0x02/0x7e  i64\n-0x03/0x7d  f32\n-0x04/0x7c  f64\n-0x10/0x70  anyfunc\n-0x20/0x60  func\n-0x40/0x40  block_type\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"4、模块结构：\"><a href=\"#4、模块结构：\" class=\"headerlink\" title=\"4、模块结构：\"></a>4、模块结构：</h4><pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n    <span class=\"token keyword\">return</span> <span class=\"token number\">42</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> \n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>我们将如上所示的 C/C++ 源码编译成一个 Wasm 模块，该模块对应的二进制内容如下所示（以十六进制表示）：</p>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\"><span style=\"color:#FF0000;\">0061 736d</span> <span style=\"color:#FF8C00;\">0100</span> <span style=\"color:#FFA500;\">0000</span> <span style=\"color:#FFD700;\">01</span>85 8080 8000 0160\n0001 7f03 8280 8080 0001 0004 8480 8080\n0001 7000 0005 8380 8080 0001 0001 0681\n8080 8000 0007 9180 8080 0002 066d 656d\n6f72 7902 0004 6d61 696e 0000 0a8a 8080\n8000 0184 8080 8000 0041 2a0b \n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>接下来我们来看下该 Wasm 模块的二进制编码格式。首先，模块由两个前置字段作为整个模块的起始字段。第一个字段的内容为 <code>0x6d736100</code>，是 Wasm 模块的魔术字符，如果将该字段的内容转换成 ASCII 码格式可以发现其内容是 “<strong>(null)asm</strong>”。第二个字段指定了该模块的版本号，内容为 <code>0x1</code>。由于 Wasm 对其二进制格式的编码采用了小端字节序的方式，因此我们可以看到上述二进制编码的前两个字节恰好是魔术字符的最后两个字节。浏览器在解析 Wasm 的二进制格式时会把先读到二进制代码放入内存的低位空间，后续读取到的代码放到高位空间。版本之后的内容是由一个个“段”组成的。每个段首先以一个7位的 varuint7 类型 ID 作为起始，接下是一个变长的 varuint32 数代表了当前段以字节为单位的大小。我们也可以使用 <code>hexdump</code> 来直观的查看一个 Wasm 二进制模块的结构，使用命令：<code>hexdump -C program.wasm</code>，结果显示如下。</p>\n<p><img src=\"3.png\" alt></p>\n<p>我们先根据每个 Section 的 ID 将整个模块的二进制代码分为如下所示的几个部分：</p>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">SectionNamae   Seperator           PayloadSize  PayloadContent\nTpye           01 85 80 80 80 00   (5bytes)     01 60 00 01 7f\nFunction       03 82 80 80 80 00   (2bytes)     01 00\nTable          04 84 80 80 80 00   (4bytes)     01 70 00 00\nMemory         05 83 80 80 80 00   (3bytes)     01 00 01\nGlobal         06 81 80 80 80 00   (1bytes)     0\nExport         07 91 80 80 80 00   (17bytes)    02 06 6d 65 6d 6f 72 79 02 00 04 6d 61 69 6e 00 00\nCode           0a 8a 80 80 80 00   (10bytes)    01 84 80 80 80 00 00 41 2a 0b\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>通过上面给出的分类表我们可以看到，根据每个 Section 的头部特征我们可以将整个二进制代码分解为除“魔术字符”和“版本号”外的多个“段”，每个“段”都有自己对应的功能和结构。由于我们的代码中没有引入自定义“段”，因此这里列出的该模块内所有“段”的 ID 均不为0。这样每个“段”的内容均只包含三个字段部分：”段ID”、“段大小”以及“段内容”。在上面的表格中我将“段ID”和“段大小”两个字段的内容统一整合为一个 “Seperator” 字段。“Seperator” 字段的第一位代表了该“段”的类型，接下来的五位是一个 varuint32 类型，代表了该“段”内容部分的长度。比如第一个 Type “段”的“段大小”字段值为5，因此接下来的5个比特均为该“段”的“段内容”数据。</p>\n<p>每个不同类型的“段”所对应的“段内容”又对应着不同的子结构，这里我们将以 Export 和 Code 两个段结构为例来进行讲解，其他类型的段结构分析方式基本类似。</p>\n<p><img src=\"4.png\" alt></p>\n<p>如上图所示的 Export Section 的“段内容”结构。一个 Export Section 结构被分为两部分：第一部分为 Export Entity 的个数，第二部分为对应的 Export Entity 实体内容。我们可以根据上图将该 Wasm 模块的 Export Section 分为如下部分。该模块需要导出的对象有两个，每个导出对象的实体又分别对应着“域标志长度”、“域标示”、“域类型“和”域索引“。</p>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">Export Entity 个数:        02 \n第一个 Export Entity 结构:  06 6d 65 6d 6f 72 79 02 00 \n第二个 Export Entity 结构:  04 6d 61 69 6e 00 00\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>接着我们对第一个 Export Entity 再进行分解，结果如下所示。该 Export Entity 的”域标志长度“为6，因此接下来的6个比特为该 Export Entity 的”域标志“，其内容对应的 ASCII 码为 ”memory“。域类型02代表着 Memory 类型。域索引值为0。以此类推，第二个 Export Entity 其实就是我们在 C/C++ 源码中导出的 main 函数，其”域标志“对应的 ASCII 码为 ”main“，域类型00代表着 Function 类型，域索引值为0。接下来我们再来看 Code Section 的结构。</p>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">域标志的长度:    06\n域标示:         6d 65 6d 6f 72 79\n域类型:         02\n域索引:         00\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p><img src=\"5.png\" alt></p>\n<p>Code Section 代表着导出函数的函数体内容，该“段”对应的函数个数要与 Function Section 相对应。可以看到在 Function Section 中得到的该模块的导出函数个数为1，因此对应的 Code Section 中只有一个函数体的内容。同时，Code Section 中的第 i 个函数体定义也要对应着 Type Section 中的第 i 个函数签名（Type Section 中定义了各个函数的函数、参数和返回值类型）。根据 Code Section 的结构我们得到如下分析结果。</p>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">函数体的内容:   84 80 80 80 00 00 41 2a 0b\n函数体的大小:   84 80 80 80 00 \n本地变量个数:   00\n函数体的代码:   41 2a\n函数结束标志:   0b\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><img src=\"6.png\" alt></p>\n<p>其中的“函数体代码”便是我们在 main 函数中写的返回语句 <code>return 42</code>。其他部分可以根据上图给出的 Function Section 字段进行一一对应。再回过头来看，Type Section 的最后一个字段表示对应函数的返回值类型。这里可以看到该模块的唯一一个函数的返回值是 “7f” 类型。再结合我们之前讲过的 Wasm 模块在语言层面的类型可以知道这是一个 i32（32位整数）类型的值。</p>\n","site":{"data":{}},"id":"1d3790e0e6fcc116350827dc3205e9f8","excerpt":"","more":"<p>本篇报告我们来看一下 WebAssembly 的二进制编码格式。为什么 Wasm 会选择设计一种新的二进制编码格式，而不直接使用 ASM.js 的 ASCII 文本格式？Wasm 的 OpCode 操作码格式是怎样的？Wasm 模块在内存中的格式，以及用于验证模块的魔术字符是什么？</p>\n<h4 id=\"1、二进制编码的数字类型：\"><a href=\"#1、二进制编码的数字类型：\" class=\"headerlink\" title=\"1、二进制编码的数字类型：\"></a>1、二进制编码的数字类型：</h4><p><img src=\"1.png\" alt></p>\n<p>在 MVP 中用于编码 WebAssembly 二进制格式的数字类型有如下几种：整数类型 <code>uint8</code>、<code>uint16</code>、<code>uint32</code>，可以很直观的看出来这三种类型分别对应于无符号的8位、16位和32位整数。所有这几种整数类型在内存中都是以“小端字节序”的方式排列的，即低位字节排放在内存的低地址端，高位字节排放在内存的高地址端(如上图所示)。除了固定长度的整数外，Wasm 还支持基于小端字节序的 LEB128 可变长度编码，其无符号类型表示为<code>varuint1</code>、<code>varuint7</code>、<code>varuint32</code>，有符号类型表示为<code>varint7</code>、<code>varint32</code>、<code>varint64</code>。LEB128 编码以每7位为一个整体对一个二进制整数进行编码。首先将每7位组成一个字节，然后再根据是否还有后续字节，分别对该字节的最高位填入0或1，最后将这一系列的字节以小端字节序的方式存入内存。因此在解码 LEB128 编码的序列时要注意只有每个字节的最后7位才是有效数字。下面是一个无符号整数的 LEB128 编码例子。这几种数字编码类型都是用来编码 Wasm 原始二进制格式的。</p>\n<pre><code class=\"text\">      10011000011101100101  In raw binary\n     010011000011101100101  Padded to a multiple of 7 bits\n 0100110  0001110  1100101  Split into 7-bit groups\n00100110 10001110 11100101  Add high 1 bits on all but last group to form bytes\n    0x26     0x8E     0xE5  In hexadecimal\n0xE5 0x8E 0x26              Output stream\n</code></pre>\n<h4 id=\"2、指令操作码（OpCode）：\"><a href=\"#2、指令操作码（OpCode）：\" class=\"headerlink\" title=\"2、指令操作码（OpCode）：\"></a>2、指令操作码（OpCode）：</h4><p>由于 MVP 的指令个数只有不到 256 个，因此 Wasm 的指令操作码现阶段全部编码为 1byte 的大小,在未来会通过增加 Pre-fixes 的方式来扩展更多的指令。OpCode 主要用在汇编程序解析汇编指令时，汇编程序会将对应的每条 ASM 指令转换成一个对应的 OpCode，以便计算机后续的指令执行。如下图所示是 PHP 中 OpCode 的组成格式（仅作为参考），每一个 OpCode 由六个数据域组成，并且其中只有 Code 域是必须存在的，其他均为可选域。</p>\n<p><img src=\"2.png\" alt></p>\n<h4 id=\"3、语言层次的类型：\"><a href=\"#3、语言层次的类型：\" class=\"headerlink\" title=\"3、语言层次的类型：\"></a>3、语言层次的类型：</h4><p>我们可以在 WebAssembly 的可读文本格式 Wast 文件中查看一个 Wasm 模块在内存中的逻辑表示，模块的逻辑使用 “S 表达式”进行表达。在 Wast 中可以看到很多常用的类型标识，如下所示的代码：</p>\n<pre><code class=\"text\">(module\n  (import &quot;env&quot; &quot;printInt&quot; (func $printInt (param i32)))\n  (import &quot;env&quot; &quot;printFloat&quot; (func $printFloat (param f32)))\n  (import &quot;env&quot; &quot;print&quot; (func $print (param i32 i32)))\n\n  (memory $memory 1)\n  (data (i32.const 0) &quot;&quot;)\n  (data (i32.const 1) &quot;Hello World!&quot;)\n\n  (func $endl\n    (call $print (i32.const 0) (i32.const 1)))\n\n  (func $main\n    (call $printInt (i32.const 9))\n    (call $endl)\n    (call $printFloat (f32.const 6.28))\n    (call $endl)\n    (call $print (i32.const 1) (i32.const 12))\n    )\n\n  (export &quot;main&quot; (func $main))\n  (export &quot;memory&quot; (memory $memory))\n)\n</code></pre>\n<p>比如上述 S 表达式中出现的 <code>i32</code> 和 <code>f32</code>，分别代表 Wasm 模块中的一个32位整数和一个32位浮点数。<code>func</code> 代表一个函数类型等。所有语言层面的类型在模块的二进制代码中都以一个负的 varint7 值作为每种类型编码值的第一位作为区分字符，其中的一部分类型如下表所示。</p>\n<pre><code class=\"text\">-0x01/0x7f  i32\n-0x02/0x7e  i64\n-0x03/0x7d  f32\n-0x04/0x7c  f64\n-0x10/0x70  anyfunc\n-0x20/0x60  func\n-0x40/0x40  block_type\n</code></pre>\n<h4 id=\"4、模块结构：\"><a href=\"#4、模块结构：\" class=\"headerlink\" title=\"4、模块结构：\"></a>4、模块结构：</h4><pre><code class=\"c\">int main() { \n    return 42;\n} \n</code></pre>\n<p>我们将如上所示的 C/C++ 源码编译成一个 Wasm 模块，该模块对应的二进制内容如下所示（以十六进制表示）：</p>\n<pre><code class=\"text\">&lt;span style=&quot;color:#FF0000;&quot;&gt;0061 736d&lt;/span&gt; &lt;span style=&quot;color:#FF8C00;&quot;&gt;0100&lt;/span&gt; &lt;span style=&quot;color:#FFA500;&quot;&gt;0000&lt;/span&gt; &lt;span style=&quot;color:#FFD700;&quot;&gt;01&lt;/span&gt;85 8080 8000 0160\n0001 7f03 8280 8080 0001 0004 8480 8080\n0001 7000 0005 8380 8080 0001 0001 0681\n8080 8000 0007 9180 8080 0002 066d 656d\n6f72 7902 0004 6d61 696e 0000 0a8a 8080\n8000 0184 8080 8000 0041 2a0b \n</code></pre>\n<p>接下来我们来看下该 Wasm 模块的二进制编码格式。首先，模块由两个前置字段作为整个模块的起始字段。第一个字段的内容为 <code>0x6d736100</code>，是 Wasm 模块的魔术字符，如果将该字段的内容转换成 ASCII 码格式可以发现其内容是 “<strong>(null)asm</strong>”。第二个字段指定了该模块的版本号，内容为 <code>0x1</code>。由于 Wasm 对其二进制格式的编码采用了小端字节序的方式，因此我们可以看到上述二进制编码的前两个字节恰好是魔术字符的最后两个字节。浏览器在解析 Wasm 的二进制格式时会把先读到二进制代码放入内存的低位空间，后续读取到的代码放到高位空间。版本之后的内容是由一个个“段”组成的。每个段首先以一个7位的 varuint7 类型 ID 作为起始，接下是一个变长的 varuint32 数代表了当前段以字节为单位的大小。我们也可以使用 <code>hexdump</code> 来直观的查看一个 Wasm 二进制模块的结构，使用命令：<code>hexdump -C program.wasm</code>，结果显示如下。</p>\n<p><img src=\"3.png\" alt></p>\n<p>我们先根据每个 Section 的 ID 将整个模块的二进制代码分为如下所示的几个部分：</p>\n<pre><code class=\"text\">SectionNamae   Seperator           PayloadSize  PayloadContent\nTpye           01 85 80 80 80 00   (5bytes)     01 60 00 01 7f\nFunction       03 82 80 80 80 00   (2bytes)     01 00\nTable          04 84 80 80 80 00   (4bytes)     01 70 00 00\nMemory         05 83 80 80 80 00   (3bytes)     01 00 01\nGlobal         06 81 80 80 80 00   (1bytes)     0\nExport         07 91 80 80 80 00   (17bytes)    02 06 6d 65 6d 6f 72 79 02 00 04 6d 61 69 6e 00 00\nCode           0a 8a 80 80 80 00   (10bytes)    01 84 80 80 80 00 00 41 2a 0b\n</code></pre>\n<p>通过上面给出的分类表我们可以看到，根据每个 Section 的头部特征我们可以将整个二进制代码分解为除“魔术字符”和“版本号”外的多个“段”，每个“段”都有自己对应的功能和结构。由于我们的代码中没有引入自定义“段”，因此这里列出的该模块内所有“段”的 ID 均不为0。这样每个“段”的内容均只包含三个字段部分：”段ID”、“段大小”以及“段内容”。在上面的表格中我将“段ID”和“段大小”两个字段的内容统一整合为一个 “Seperator” 字段。“Seperator” 字段的第一位代表了该“段”的类型，接下来的五位是一个 varuint32 类型，代表了该“段”内容部分的长度。比如第一个 Type “段”的“段大小”字段值为5，因此接下来的5个比特均为该“段”的“段内容”数据。</p>\n<p>每个不同类型的“段”所对应的“段内容”又对应着不同的子结构，这里我们将以 Export 和 Code 两个段结构为例来进行讲解，其他类型的段结构分析方式基本类似。</p>\n<p><img src=\"4.png\" alt></p>\n<p>如上图所示的 Export Section 的“段内容”结构。一个 Export Section 结构被分为两部分：第一部分为 Export Entity 的个数，第二部分为对应的 Export Entity 实体内容。我们可以根据上图将该 Wasm 模块的 Export Section 分为如下部分。该模块需要导出的对象有两个，每个导出对象的实体又分别对应着“域标志长度”、“域标示”、“域类型“和”域索引“。</p>\n<pre><code class=\"text\">Export Entity 个数:        02 \n第一个 Export Entity 结构:  06 6d 65 6d 6f 72 79 02 00 \n第二个 Export Entity 结构:  04 6d 61 69 6e 00 00\n</code></pre>\n<p>接着我们对第一个 Export Entity 再进行分解，结果如下所示。该 Export Entity 的”域标志长度“为6，因此接下来的6个比特为该 Export Entity 的”域标志“，其内容对应的 ASCII 码为 ”memory“。域类型02代表着 Memory 类型。域索引值为0。以此类推，第二个 Export Entity 其实就是我们在 C/C++ 源码中导出的 main 函数，其”域标志“对应的 ASCII 码为 ”main“，域类型00代表着 Function 类型，域索引值为0。接下来我们再来看 Code Section 的结构。</p>\n<pre><code class=\"text\">域标志的长度:    06\n域标示:         6d 65 6d 6f 72 79\n域类型:         02\n域索引:         00\n</code></pre>\n<p><img src=\"5.png\" alt></p>\n<p>Code Section 代表着导出函数的函数体内容，该“段”对应的函数个数要与 Function Section 相对应。可以看到在 Function Section 中得到的该模块的导出函数个数为1，因此对应的 Code Section 中只有一个函数体的内容。同时，Code Section 中的第 i 个函数体定义也要对应着 Type Section 中的第 i 个函数签名（Type Section 中定义了各个函数的函数、参数和返回值类型）。根据 Code Section 的结构我们得到如下分析结果。</p>\n<pre><code class=\"text\">函数体的内容:   84 80 80 80 00 00 41 2a 0b\n函数体的大小:   84 80 80 80 00 \n本地变量个数:   00\n函数体的代码:   41 2a\n函数结束标志:   0b\n</code></pre>\n<p><img src=\"6.png\" alt></p>\n<p>其中的“函数体代码”便是我们在 main 函数中写的返回语句 <code>return 42</code>。其他部分可以根据上图给出的 Function Section 字段进行一一对应。再回过头来看，Type Section 的最后一个字段表示对应函数的返回值类型。这里可以看到该模块的唯一一个函数的返回值是 “7f” 类型。再结合我们之前讲过的 Wasm 模块在语言层面的类型可以知道这是一个 i32（32位整数）类型的值。</p>\n"},{"title":"WebAssembly 深入研究报告 - 碎片知识","intro":"本文主要内容是对 WebAssembly 的一些碎片化的概念进行整合。同时还包括一些 Q&A 的问题与答案。WebAssembly 接下来主要会在多线程和垃圾回收两个方面进行更多的讨论和提案修改，而 GC 标准的确定又会为 Post-MVP 中的诸如 DOM 引用与操作等前端相关功能特性打下基础。","comments":1,"date":"2017-07-19T08:31:39.000Z","_content":"\n本文主要内容是对 WebAssembly 的一些碎片化的概念进行整合。同时还包括一些 Q&A 的问题与答案。WebAssembly 接下来主要会在多线程和垃圾回收两个方面进行更多的讨论和提案修改，而 GC 标准的确定又会为 Post-MVP 中的诸如 DOM 引用与操作等前端相关功能特性打下基础。\n\n#### 1、.wast 和 .wat 的区别？\n\n`.wast` 格式是 `.wat` 格式的一个“超集”。`.wast` 文本不仅可以包含模块定义的语法，同时还会包含一些用于代码测试的[语法扩展](https://github.com/WebAssembly/spec/tree/master/interpreter/#scripts)，比如“断言”等。但这些语法并不是官方定义的模块语法标准。因此在编写一个 WebAssembly 模块时尽量使用 `.wat` 作为模块的后缀名。而 `.wast` 一般用来作为测试脚本的格式。\n\n#### 2、f32/f64 的编码方式？\n\n给出如下语句：\n\n```c\ndouble x = 1;\n```\n\n对应的 Wat 可读文本代码：\n\n```wat\n(module\n  (table 0 anyfunc)\n  (memory $0 1)\n  (data (i32.const 16) \"/00/00/00/00/00/00/f0?\")\n  (export \"memory\" (memory $0))\n)\n```\n\nWebAssembly 使用 IEEE-754 编码来编码 f32/f64 数值。由于普通的 .wat 源码使用 ASCII 编码，因此对应的数据段 \"/00/00/00/00/00/00/f0?\" 转换为十六进制后其值为：“3FF0000000000000”，该值再经过 IEEE-754 编码的[解码](http://babbage.cs.qc.cuny.edu/IEEE-754/)后便可得到原始值“1”。\n","source":"_posts/WebAssembly-深入研究报告-碎片知识.md","raw":"---\ntitle: WebAssembly 深入研究报告 - 碎片知识\nintro: 本文主要内容是对 WebAssembly 的一些碎片化的概念进行整合。同时还包括一些 Q&A 的问题与答案。WebAssembly 接下来主要会在多线程和垃圾回收两个方面进行更多的讨论和提案修改，而 GC 标准的确定又会为 Post-MVP 中的诸如 DOM 引用与操作等前端相关功能特性打下基础。\ncomments: true\ndate: 2017-07-19 16:31:39\ntags:\n- WebAssembly\n---\n\n本文主要内容是对 WebAssembly 的一些碎片化的概念进行整合。同时还包括一些 Q&A 的问题与答案。WebAssembly 接下来主要会在多线程和垃圾回收两个方面进行更多的讨论和提案修改，而 GC 标准的确定又会为 Post-MVP 中的诸如 DOM 引用与操作等前端相关功能特性打下基础。\n\n#### 1、.wast 和 .wat 的区别？\n\n`.wast` 格式是 `.wat` 格式的一个“超集”。`.wast` 文本不仅可以包含模块定义的语法，同时还会包含一些用于代码测试的[语法扩展](https://github.com/WebAssembly/spec/tree/master/interpreter/#scripts)，比如“断言”等。但这些语法并不是官方定义的模块语法标准。因此在编写一个 WebAssembly 模块时尽量使用 `.wat` 作为模块的后缀名。而 `.wast` 一般用来作为测试脚本的格式。\n\n#### 2、f32/f64 的编码方式？\n\n给出如下语句：\n\n```c\ndouble x = 1;\n```\n\n对应的 Wat 可读文本代码：\n\n```wat\n(module\n  (table 0 anyfunc)\n  (memory $0 1)\n  (data (i32.const 16) \"/00/00/00/00/00/00/f0?\")\n  (export \"memory\" (memory $0))\n)\n```\n\nWebAssembly 使用 IEEE-754 编码来编码 f32/f64 数值。由于普通的 .wat 源码使用 ASCII 编码，因此对应的数据段 \"/00/00/00/00/00/00/f0?\" 转换为十六进制后其值为：“3FF0000000000000”，该值再经过 IEEE-754 编码的[解码](http://babbage.cs.qc.cuny.edu/IEEE-754/)后便可得到原始值“1”。\n","slug":"WebAssembly-深入研究报告-碎片知识","published":1,"updated":"2019-02-19T10:11:39.308Z","layout":"post","photos":[],"link":"","_id":"cjsqwhta8004hknp2jiv7htcn","content":"<p>本文主要内容是对 WebAssembly 的一些碎片化的概念进行整合。同时还包括一些 Q&amp;A 的问题与答案。WebAssembly 接下来主要会在多线程和垃圾回收两个方面进行更多的讨论和提案修改，而 GC 标准的确定又会为 Post-MVP 中的诸如 DOM 引用与操作等前端相关功能特性打下基础。</p>\n<h4 id=\"1、-wast-和-wat-的区别？\"><a href=\"#1、-wast-和-wat-的区别？\" class=\"headerlink\" title=\"1、.wast 和 .wat 的区别？\"></a>1、.wast 和 .wat 的区别？</h4><p><code>.wast</code> 格式是 <code>.wat</code> 格式的一个“超集”。<code>.wast</code> 文本不仅可以包含模块定义的语法，同时还会包含一些用于代码测试的<a href=\"https://github.com/WebAssembly/spec/tree/master/interpreter/#scripts\" target=\"_blank\" rel=\"noopener\">语法扩展</a>，比如“断言”等。但这些语法并不是官方定义的模块语法标准。因此在编写一个 WebAssembly 模块时尽量使用 <code>.wat</code> 作为模块的后缀名。而 <code>.wast</code> 一般用来作为测试脚本的格式。</p>\n<h4 id=\"2、f32-f64-的编码方式？\"><a href=\"#2、f32-f64-的编码方式？\" class=\"headerlink\" title=\"2、f32/f64 的编码方式？\"></a>2、f32/f64 的编码方式？</h4><p>给出如下语句：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">double</span> x <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>对应的 Wat 可读文本代码：</p>\n<pre class=\"line-numbers language-wat\"><code class=\"language-wat\">(module\n  (table 0 anyfunc)\n  (memory $0 1)\n  (data (i32.const 16) \"/00/00/00/00/00/00/f0?\")\n  (export \"memory\" (memory $0))\n)\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>WebAssembly 使用 IEEE-754 编码来编码 f32/f64 数值。由于普通的 .wat 源码使用 ASCII 编码，因此对应的数据段 “/00/00/00/00/00/00/f0?” 转换为十六进制后其值为：“3FF0000000000000”，该值再经过 IEEE-754 编码的<a href=\"http://babbage.cs.qc.cuny.edu/IEEE-754/\" target=\"_blank\" rel=\"noopener\">解码</a>后便可得到原始值“1”。</p>\n","site":{"data":{}},"id":"5d554a788de996ed9c8ca035c3ce5e9b","excerpt":"","more":"<p>本文主要内容是对 WebAssembly 的一些碎片化的概念进行整合。同时还包括一些 Q&amp;A 的问题与答案。WebAssembly 接下来主要会在多线程和垃圾回收两个方面进行更多的讨论和提案修改，而 GC 标准的确定又会为 Post-MVP 中的诸如 DOM 引用与操作等前端相关功能特性打下基础。</p>\n<h4 id=\"1、-wast-和-wat-的区别？\"><a href=\"#1、-wast-和-wat-的区别？\" class=\"headerlink\" title=\"1、.wast 和 .wat 的区别？\"></a>1、.wast 和 .wat 的区别？</h4><p><code>.wast</code> 格式是 <code>.wat</code> 格式的一个“超集”。<code>.wast</code> 文本不仅可以包含模块定义的语法，同时还会包含一些用于代码测试的<a href=\"https://github.com/WebAssembly/spec/tree/master/interpreter/#scripts\" target=\"_blank\" rel=\"noopener\">语法扩展</a>，比如“断言”等。但这些语法并不是官方定义的模块语法标准。因此在编写一个 WebAssembly 模块时尽量使用 <code>.wat</code> 作为模块的后缀名。而 <code>.wast</code> 一般用来作为测试脚本的格式。</p>\n<h4 id=\"2、f32-f64-的编码方式？\"><a href=\"#2、f32-f64-的编码方式？\" class=\"headerlink\" title=\"2、f32/f64 的编码方式？\"></a>2、f32/f64 的编码方式？</h4><p>给出如下语句：</p>\n<pre><code class=\"c\">double x = 1;\n</code></pre>\n<p>对应的 Wat 可读文本代码：</p>\n<pre><code class=\"wat\">(module\n  (table 0 anyfunc)\n  (memory $0 1)\n  (data (i32.const 16) &quot;/00/00/00/00/00/00/f0?&quot;)\n  (export &quot;memory&quot; (memory $0))\n)\n</code></pre>\n<p>WebAssembly 使用 IEEE-754 编码来编码 f32/f64 数值。由于普通的 .wat 源码使用 ASCII 编码，因此对应的数据段 “/00/00/00/00/00/00/f0?” 转换为十六进制后其值为：“3FF0000000000000”，该值再经过 IEEE-754 编码的<a href=\"http://babbage.cs.qc.cuny.edu/IEEE-754/\" target=\"_blank\" rel=\"noopener\">解码</a>后便可得到原始值“1”。</p>\n"},{"title":"Zoomage.js 正式版 V1.0.0 核心原理介绍","intro":"经过了几周时间的思考和实践，Zoomage.js 的正式版本（V1.0.0）今天终于发布了。在这个正式版本中，我们加入了对图片的“平移”、“旋转”、“缩放”三种手势动作的完整支持。同时对缩放的\"边界缓动\"效果进行了调整，使整个缩放动作更加缓和，自然和流畅。基于两套不同的动作处理方案为浏览器兼容性带来了保障。本文将简单介绍这几个功能的实现要点。","comments":1,"date":"2016-09-16T06:47:54.000Z","_content":"\n经过了几周时间的思考和实践，Zoomage.js 的正式版本（V1.0.0）今天终于发布了。在这个正式版本中，我们加入了对图片的“**平移**”、“**旋转**”、“**缩放**”三种手势动作的完整支持。同时对缩放的\"边界缓动\"效果进行了调整，使整个缩放动作更加缓和，自然和流畅。基于两套不同的动作处理方案为浏览器兼容性带来了保障。本文将简单介绍这几个功能的实现要点。\n\n> [Zoomage.js - Github Repository](https://github.com/Becavalier/Zoomage.js)\n\n#### 一、支持动作：\n\n1. 双击缩放：\n\n![](https://github.com/Becavalier/Zoomage.js/raw/master/images/preview-dbclick.gif?raw=true)\n\n2. 双指手势缩放：\n\n![](https://github.com/Becavalier/Zoomage.js/raw/master/images/preview-zoom.gif?raw=true)\n\n3. 单指手势拖拽：\n\n![](https://github.com/Becavalier/Zoomage.js/raw/master/images/preview-drag.gif?raw=true)\n\n4. 双指手势旋转：\n\n![](https://github.com/Becavalier/Zoomage.js/raw/master/images/preview-rotate.gif?raw=true)\n\n#### 二、核心原理：\n\n对于 DOM 元素的“平移”，“缩放”和“旋转”这三种类型的基本动作，我们在 Zoomage.js 中使用了两套不同的方案来实现。第一种方案是基于 Canvas 对象的 `drawImage` 方法来实现的；第二种则是基于 CSS3 的 `transform` 属性来实现的。\n\n这两种方法有各的优点和缺点。首先，使用 Canvas 对象可以让我们不用再去考虑当图像处在绘图边界时的情况（即图像不会脱离 Canvas 绘图区域）。当图像处于 “Offscreen Canvas” 区域时会被 Canvas 自动隐藏，这也正是我们需要达到的效果。但对于使用 \"transform\" 方案时，绘图边界的情况则需要另行处理，在正常情况图片超过 \"transform\" 容器时是不会被隐藏的。\n\n另一方面，在使用 Canvas 方案时对图像的旋转操作会出现特殊情况，Canvas 本身并不能只对其上绘制的图像进行旋转，所以只能将整个 Canvas 画布进行旋转来模拟图像旋转的效果，但是这样带来的问题是当 Canvas 画布和画布容器由于旋转导致不再重合时，“Offscreen Canvas” 区域的图像便不能被清除，这样最终导致图像的移动轨迹全部留在了屏幕上。而使用 \"transform\" 便不用考虑类似 Canvas 的重绘问题，只需要考虑如何计算元素的移动轨迹即可，这也是相对于 Canvas 方案，\"transform\" 所独有的优点。因此，当用户选择开启图像旋转支持时，Zoomage.js 会自动使用 \"transform\" 方案来支持图像的旋转操作。\n\n另一个需要解决的问题是如何对用户的触摸操作进行精准的手势识别。HTML5 自带了 \"touchstart\"，\"touchmove\"，\"touchend\" 三个触摸监听的方法，所有的手势识别过程均需要在这里完成。通过上述三个的监听事件中 Event 对象的 \"touches\" 和 \"targetTouches\" 数组我们可以获得当前触摸在屏幕上的触摸点数量，以及每一个触摸点的具体坐标。那么通过这些坐标我们便不难判断出用户的三种基本手势动作：一个点的位移变化控制拖拽，两个点的距离变化控制缩放，两个点组成的向量相对于 X/Y 轴的夹角变化来控制旋转。\n","source":"_posts/Zoomage-js-正式版-V1-0-0-核心原理介绍.md","raw":"---\ntitle: Zoomage.js 正式版 V1.0.0 核心原理介绍\nintro: 经过了几周时间的思考和实践，Zoomage.js 的正式版本（V1.0.0）今天终于发布了。在这个正式版本中，我们加入了对图片的“平移”、“旋转”、“缩放”三种手势动作的完整支持。同时对缩放的\"边界缓动\"效果进行了调整，使整个缩放动作更加缓和，自然和流畅。基于两套不同的动作处理方案为浏览器兼容性带来了保障。本文将简单介绍这几个功能的实现要点。\ncomments: true\ndate: 2016-09-16 14:47:54\ntags:\n- JavaScript\n- Library\n---\n\n经过了几周时间的思考和实践，Zoomage.js 的正式版本（V1.0.0）今天终于发布了。在这个正式版本中，我们加入了对图片的“**平移**”、“**旋转**”、“**缩放**”三种手势动作的完整支持。同时对缩放的\"边界缓动\"效果进行了调整，使整个缩放动作更加缓和，自然和流畅。基于两套不同的动作处理方案为浏览器兼容性带来了保障。本文将简单介绍这几个功能的实现要点。\n\n> [Zoomage.js - Github Repository](https://github.com/Becavalier/Zoomage.js)\n\n#### 一、支持动作：\n\n1. 双击缩放：\n\n![](https://github.com/Becavalier/Zoomage.js/raw/master/images/preview-dbclick.gif?raw=true)\n\n2. 双指手势缩放：\n\n![](https://github.com/Becavalier/Zoomage.js/raw/master/images/preview-zoom.gif?raw=true)\n\n3. 单指手势拖拽：\n\n![](https://github.com/Becavalier/Zoomage.js/raw/master/images/preview-drag.gif?raw=true)\n\n4. 双指手势旋转：\n\n![](https://github.com/Becavalier/Zoomage.js/raw/master/images/preview-rotate.gif?raw=true)\n\n#### 二、核心原理：\n\n对于 DOM 元素的“平移”，“缩放”和“旋转”这三种类型的基本动作，我们在 Zoomage.js 中使用了两套不同的方案来实现。第一种方案是基于 Canvas 对象的 `drawImage` 方法来实现的；第二种则是基于 CSS3 的 `transform` 属性来实现的。\n\n这两种方法有各的优点和缺点。首先，使用 Canvas 对象可以让我们不用再去考虑当图像处在绘图边界时的情况（即图像不会脱离 Canvas 绘图区域）。当图像处于 “Offscreen Canvas” 区域时会被 Canvas 自动隐藏，这也正是我们需要达到的效果。但对于使用 \"transform\" 方案时，绘图边界的情况则需要另行处理，在正常情况图片超过 \"transform\" 容器时是不会被隐藏的。\n\n另一方面，在使用 Canvas 方案时对图像的旋转操作会出现特殊情况，Canvas 本身并不能只对其上绘制的图像进行旋转，所以只能将整个 Canvas 画布进行旋转来模拟图像旋转的效果，但是这样带来的问题是当 Canvas 画布和画布容器由于旋转导致不再重合时，“Offscreen Canvas” 区域的图像便不能被清除，这样最终导致图像的移动轨迹全部留在了屏幕上。而使用 \"transform\" 便不用考虑类似 Canvas 的重绘问题，只需要考虑如何计算元素的移动轨迹即可，这也是相对于 Canvas 方案，\"transform\" 所独有的优点。因此，当用户选择开启图像旋转支持时，Zoomage.js 会自动使用 \"transform\" 方案来支持图像的旋转操作。\n\n另一个需要解决的问题是如何对用户的触摸操作进行精准的手势识别。HTML5 自带了 \"touchstart\"，\"touchmove\"，\"touchend\" 三个触摸监听的方法，所有的手势识别过程均需要在这里完成。通过上述三个的监听事件中 Event 对象的 \"touches\" 和 \"targetTouches\" 数组我们可以获得当前触摸在屏幕上的触摸点数量，以及每一个触摸点的具体坐标。那么通过这些坐标我们便不难判断出用户的三种基本手势动作：一个点的位移变化控制拖拽，两个点的距离变化控制缩放，两个点组成的向量相对于 X/Y 轴的夹角变化来控制旋转。\n","slug":"Zoomage-js-正式版-V1-0-0-核心原理介绍","published":1,"updated":"2019-02-10T02:39:47.846Z","layout":"post","photos":[],"link":"","_id":"cjsqwhta9004kknp2x6w6bxwi","content":"<p>经过了几周时间的思考和实践，Zoomage.js 的正式版本（V1.0.0）今天终于发布了。在这个正式版本中，我们加入了对图片的“<strong>平移</strong>”、“<strong>旋转</strong>”、“<strong>缩放</strong>”三种手势动作的完整支持。同时对缩放的”边界缓动”效果进行了调整，使整个缩放动作更加缓和，自然和流畅。基于两套不同的动作处理方案为浏览器兼容性带来了保障。本文将简单介绍这几个功能的实现要点。</p>\n<blockquote>\n<p><a href=\"https://github.com/Becavalier/Zoomage.js\" target=\"_blank\" rel=\"noopener\">Zoomage.js - Github Repository</a></p>\n</blockquote>\n<h4 id=\"一、支持动作：\"><a href=\"#一、支持动作：\" class=\"headerlink\" title=\"一、支持动作：\"></a>一、支持动作：</h4><ol>\n<li>双击缩放：</li>\n</ol>\n<p><img src=\"https://github.com/Becavalier/Zoomage.js/raw/master/images/preview-dbclick.gif?raw=true\" alt></p>\n<ol start=\"2\">\n<li>双指手势缩放：</li>\n</ol>\n<p><img src=\"https://github.com/Becavalier/Zoomage.js/raw/master/images/preview-zoom.gif?raw=true\" alt></p>\n<ol start=\"3\">\n<li>单指手势拖拽：</li>\n</ol>\n<p><img src=\"https://github.com/Becavalier/Zoomage.js/raw/master/images/preview-drag.gif?raw=true\" alt></p>\n<ol start=\"4\">\n<li>双指手势旋转：</li>\n</ol>\n<p><img src=\"https://github.com/Becavalier/Zoomage.js/raw/master/images/preview-rotate.gif?raw=true\" alt></p>\n<h4 id=\"二、核心原理：\"><a href=\"#二、核心原理：\" class=\"headerlink\" title=\"二、核心原理：\"></a>二、核心原理：</h4><p>对于 DOM 元素的“平移”，“缩放”和“旋转”这三种类型的基本动作，我们在 Zoomage.js 中使用了两套不同的方案来实现。第一种方案是基于 Canvas 对象的 <code>drawImage</code> 方法来实现的；第二种则是基于 CSS3 的 <code>transform</code> 属性来实现的。</p>\n<p>这两种方法有各的优点和缺点。首先，使用 Canvas 对象可以让我们不用再去考虑当图像处在绘图边界时的情况（即图像不会脱离 Canvas 绘图区域）。当图像处于 “Offscreen Canvas” 区域时会被 Canvas 自动隐藏，这也正是我们需要达到的效果。但对于使用 “transform” 方案时，绘图边界的情况则需要另行处理，在正常情况图片超过 “transform” 容器时是不会被隐藏的。</p>\n<p>另一方面，在使用 Canvas 方案时对图像的旋转操作会出现特殊情况，Canvas 本身并不能只对其上绘制的图像进行旋转，所以只能将整个 Canvas 画布进行旋转来模拟图像旋转的效果，但是这样带来的问题是当 Canvas 画布和画布容器由于旋转导致不再重合时，“Offscreen Canvas” 区域的图像便不能被清除，这样最终导致图像的移动轨迹全部留在了屏幕上。而使用 “transform” 便不用考虑类似 Canvas 的重绘问题，只需要考虑如何计算元素的移动轨迹即可，这也是相对于 Canvas 方案，”transform” 所独有的优点。因此，当用户选择开启图像旋转支持时，Zoomage.js 会自动使用 “transform” 方案来支持图像的旋转操作。</p>\n<p>另一个需要解决的问题是如何对用户的触摸操作进行精准的手势识别。HTML5 自带了 “touchstart”，”touchmove”，”touchend” 三个触摸监听的方法，所有的手势识别过程均需要在这里完成。通过上述三个的监听事件中 Event 对象的 “touches” 和 “targetTouches” 数组我们可以获得当前触摸在屏幕上的触摸点数量，以及每一个触摸点的具体坐标。那么通过这些坐标我们便不难判断出用户的三种基本手势动作：一个点的位移变化控制拖拽，两个点的距离变化控制缩放，两个点组成的向量相对于 X/Y 轴的夹角变化来控制旋转。</p>\n","site":{"data":{}},"id":"8155c6e6dd17603dc70d766cca63e74b","excerpt":"","more":"<p>经过了几周时间的思考和实践，Zoomage.js 的正式版本（V1.0.0）今天终于发布了。在这个正式版本中，我们加入了对图片的“<strong>平移</strong>”、“<strong>旋转</strong>”、“<strong>缩放</strong>”三种手势动作的完整支持。同时对缩放的”边界缓动”效果进行了调整，使整个缩放动作更加缓和，自然和流畅。基于两套不同的动作处理方案为浏览器兼容性带来了保障。本文将简单介绍这几个功能的实现要点。</p>\n<blockquote>\n<p><a href=\"https://github.com/Becavalier/Zoomage.js\" target=\"_blank\" rel=\"noopener\">Zoomage.js - Github Repository</a></p>\n</blockquote>\n<h4 id=\"一、支持动作：\"><a href=\"#一、支持动作：\" class=\"headerlink\" title=\"一、支持动作：\"></a>一、支持动作：</h4><ol>\n<li>双击缩放：</li>\n</ol>\n<p><img src=\"https://github.com/Becavalier/Zoomage.js/raw/master/images/preview-dbclick.gif?raw=true\" alt></p>\n<ol start=\"2\">\n<li>双指手势缩放：</li>\n</ol>\n<p><img src=\"https://github.com/Becavalier/Zoomage.js/raw/master/images/preview-zoom.gif?raw=true\" alt></p>\n<ol start=\"3\">\n<li>单指手势拖拽：</li>\n</ol>\n<p><img src=\"https://github.com/Becavalier/Zoomage.js/raw/master/images/preview-drag.gif?raw=true\" alt></p>\n<ol start=\"4\">\n<li>双指手势旋转：</li>\n</ol>\n<p><img src=\"https://github.com/Becavalier/Zoomage.js/raw/master/images/preview-rotate.gif?raw=true\" alt></p>\n<h4 id=\"二、核心原理：\"><a href=\"#二、核心原理：\" class=\"headerlink\" title=\"二、核心原理：\"></a>二、核心原理：</h4><p>对于 DOM 元素的“平移”，“缩放”和“旋转”这三种类型的基本动作，我们在 Zoomage.js 中使用了两套不同的方案来实现。第一种方案是基于 Canvas 对象的 <code>drawImage</code> 方法来实现的；第二种则是基于 CSS3 的 <code>transform</code> 属性来实现的。</p>\n<p>这两种方法有各的优点和缺点。首先，使用 Canvas 对象可以让我们不用再去考虑当图像处在绘图边界时的情况（即图像不会脱离 Canvas 绘图区域）。当图像处于 “Offscreen Canvas” 区域时会被 Canvas 自动隐藏，这也正是我们需要达到的效果。但对于使用 “transform” 方案时，绘图边界的情况则需要另行处理，在正常情况图片超过 “transform” 容器时是不会被隐藏的。</p>\n<p>另一方面，在使用 Canvas 方案时对图像的旋转操作会出现特殊情况，Canvas 本身并不能只对其上绘制的图像进行旋转，所以只能将整个 Canvas 画布进行旋转来模拟图像旋转的效果，但是这样带来的问题是当 Canvas 画布和画布容器由于旋转导致不再重合时，“Offscreen Canvas” 区域的图像便不能被清除，这样最终导致图像的移动轨迹全部留在了屏幕上。而使用 “transform” 便不用考虑类似 Canvas 的重绘问题，只需要考虑如何计算元素的移动轨迹即可，这也是相对于 Canvas 方案，”transform” 所独有的优点。因此，当用户选择开启图像旋转支持时，Zoomage.js 会自动使用 “transform” 方案来支持图像的旋转操作。</p>\n<p>另一个需要解决的问题是如何对用户的触摸操作进行精准的手势识别。HTML5 自带了 “touchstart”，”touchmove”，”touchend” 三个触摸监听的方法，所有的手势识别过程均需要在这里完成。通过上述三个的监听事件中 Event 对象的 “touches” 和 “targetTouches” 数组我们可以获得当前触摸在屏幕上的触摸点数量，以及每一个触摸点的具体坐标。那么通过这些坐标我们便不难判断出用户的三种基本手势动作：一个点的位移变化控制拖拽，两个点的距离变化控制缩放，两个点组成的向量相对于 X/Y 轴的夹角变化来控制旋转。</p>\n"},{"title":"event.target 与 event.srcElement","intro":"window.event 是标准的 window 对象，它包含着事件发生时的状态，所以只在事件的发生过程中才会起作用。而在 window.event 对象中有一个名为 srcElement 的属性，代表着事件发生的源，即代表着事件发生时的 DOM 对象。","comments":1,"date":"2015-02-13T13:06:41.000Z","_content":"\n`window.event` 是标准的 `window` 对象，它包含着事件发生时的状态，所以只在事件的发生过程中才会起作用。而在 `window.event` 对象中有一个名为 `srcElement` 的属性，代表着事件发生的源，即代表着事件发生时的 DOM 对象。而 `target` 属性是从哪里来的呢？其实，`srcElement` 是 IE 浏览器中的原生属性，而 `target` 则是 Firefox 浏览器中的原生属性，两者的功能基本上是一样的。但是，在 IE 中却没有 `target` 属性，同样在 Firefox 中却没有 `srcElement` 属性。\n\n在现在这个浏览器种类越来越多的时代，如何对这些对象和属性、方法进行统一，一直是一个让人头疼的问题。`window.evnet` 在前端开发中是一个经常使用的对象，它对于通过事件发生的相对位置来寻找元素有着很重要的作用，但属性名的不统一让前端开发变得越来越棘手。\n\n所以为了使前端开发中的 `window.evnet.target` 属性和 `window.evnet.srcElement` 属性达到统一，我们可以在使用前定义一个可以统一获得此属性的函数，在函数中“和谐”掉多浏览器带来的差异化问题。示例代码如下：\n\n```javascript\nfunction getEventObj() {\n  obj = event.srcElement ? event.srcElement : event.target;\n  return obj;\n}\n```\n\n这样便可以在使用 `srcElement` 或 `target` 属性之前通过函数进行自动选择，以便解决多浏览器带来的兼容性问题。\n","source":"_posts/event-target-与-event-srcElement.md","raw":"---\ntitle: event.target 与 event.srcElement\nintro: window.event 是标准的 window 对象，它包含着事件发生时的状态，所以只在事件的发生过程中才会起作用。而在 window.event 对象中有一个名为 srcElement 的属性，代表着事件发生的源，即代表着事件发生时的 DOM 对象。\ncomments: true\ndate: 2015-02-13 21:06:41\ntags:\n- JavaScript\n---\n\n`window.event` 是标准的 `window` 对象，它包含着事件发生时的状态，所以只在事件的发生过程中才会起作用。而在 `window.event` 对象中有一个名为 `srcElement` 的属性，代表着事件发生的源，即代表着事件发生时的 DOM 对象。而 `target` 属性是从哪里来的呢？其实，`srcElement` 是 IE 浏览器中的原生属性，而 `target` 则是 Firefox 浏览器中的原生属性，两者的功能基本上是一样的。但是，在 IE 中却没有 `target` 属性，同样在 Firefox 中却没有 `srcElement` 属性。\n\n在现在这个浏览器种类越来越多的时代，如何对这些对象和属性、方法进行统一，一直是一个让人头疼的问题。`window.evnet` 在前端开发中是一个经常使用的对象，它对于通过事件发生的相对位置来寻找元素有着很重要的作用，但属性名的不统一让前端开发变得越来越棘手。\n\n所以为了使前端开发中的 `window.evnet.target` 属性和 `window.evnet.srcElement` 属性达到统一，我们可以在使用前定义一个可以统一获得此属性的函数，在函数中“和谐”掉多浏览器带来的差异化问题。示例代码如下：\n\n```javascript\nfunction getEventObj() {\n  obj = event.srcElement ? event.srcElement : event.target;\n  return obj;\n}\n```\n\n这样便可以在使用 `srcElement` 或 `target` 属性之前通过函数进行自动选择，以便解决多浏览器带来的兼容性问题。\n","slug":"event-target-与-event-srcElement","published":1,"updated":"2019-02-04T07:19:56.226Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtaa004lknp2r95kzexx","content":"<p><code>window.event</code> 是标准的 <code>window</code> 对象，它包含着事件发生时的状态，所以只在事件的发生过程中才会起作用。而在 <code>window.event</code> 对象中有一个名为 <code>srcElement</code> 的属性，代表着事件发生的源，即代表着事件发生时的 DOM 对象。而 <code>target</code> 属性是从哪里来的呢？其实，<code>srcElement</code> 是 IE 浏览器中的原生属性，而 <code>target</code> 则是 Firefox 浏览器中的原生属性，两者的功能基本上是一样的。但是，在 IE 中却没有 <code>target</code> 属性，同样在 Firefox 中却没有 <code>srcElement</code> 属性。</p>\n<p>在现在这个浏览器种类越来越多的时代，如何对这些对象和属性、方法进行统一，一直是一个让人头疼的问题。<code>window.evnet</code> 在前端开发中是一个经常使用的对象，它对于通过事件发生的相对位置来寻找元素有着很重要的作用，但属性名的不统一让前端开发变得越来越棘手。</p>\n<p>所以为了使前端开发中的 <code>window.evnet.target</code> 属性和 <code>window.evnet.srcElement</code> 属性达到统一，我们可以在使用前定义一个可以统一获得此属性的函数，在函数中“和谐”掉多浏览器带来的差异化问题。示例代码如下：</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">getEventObj</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  obj <span class=\"token operator\">=</span> event<span class=\"token punctuation\">.</span>srcElement <span class=\"token operator\">?</span> event<span class=\"token punctuation\">.</span>srcElement <span class=\"token punctuation\">:</span> event<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> obj<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这样便可以在使用 <code>srcElement</code> 或 <code>target</code> 属性之前通过函数进行自动选择，以便解决多浏览器带来的兼容性问题。</p>\n","site":{"data":{}},"id":"50fbbb4e77d69b6d17757cbe72fb0c9a","excerpt":"","more":"<p><code>window.event</code> 是标准的 <code>window</code> 对象，它包含着事件发生时的状态，所以只在事件的发生过程中才会起作用。而在 <code>window.event</code> 对象中有一个名为 <code>srcElement</code> 的属性，代表着事件发生的源，即代表着事件发生时的 DOM 对象。而 <code>target</code> 属性是从哪里来的呢？其实，<code>srcElement</code> 是 IE 浏览器中的原生属性，而 <code>target</code> 则是 Firefox 浏览器中的原生属性，两者的功能基本上是一样的。但是，在 IE 中却没有 <code>target</code> 属性，同样在 Firefox 中却没有 <code>srcElement</code> 属性。</p>\n<p>在现在这个浏览器种类越来越多的时代，如何对这些对象和属性、方法进行统一，一直是一个让人头疼的问题。<code>window.evnet</code> 在前端开发中是一个经常使用的对象，它对于通过事件发生的相对位置来寻找元素有着很重要的作用，但属性名的不统一让前端开发变得越来越棘手。</p>\n<p>所以为了使前端开发中的 <code>window.evnet.target</code> 属性和 <code>window.evnet.srcElement</code> 属性达到统一，我们可以在使用前定义一个可以统一获得此属性的函数，在函数中“和谐”掉多浏览器带来的差异化问题。示例代码如下：</p>\n<pre><code class=\"javascript\">function getEventObj() {\n  obj = event.srcElement ? event.srcElement : event.target;\n  return obj;\n}\n</code></pre>\n<p>这样便可以在使用 <code>srcElement</code> 或 <code>target</code> 属性之前通过函数进行自动选择，以便解决多浏览器带来的兼容性问题。</p>\n"},{"title":"RSS 概述","intro":"今天我们来聊聊常用的网络应用之 RSS。RSS 的中文名称叫“简易信息聚合”，其在网站中的主要作用我理解为：RSS 可以用于快速浏览网站的最近更新资源，并且将更新的资源描述及链接发送给搜索引擎以便搜索引擎能够及时收录。RSS 同时也是基于XML语言的通用 Web 应用，有很多大型企业的网站都在应用这种技术来快速的分享自己网站的最新信息。用户也可以通过订阅这些网站的 RSS 来及时获得网站资源的更新通知，并通过 RSS 提供的链接了解网站发布的最新信息的详细内容。","comments":1,"date":"2015-01-04T14:08:40.000Z","_content":"\n今天我们来聊聊常用的网络应用之 RSS。RSS 的中文名称叫“简易信息聚合”，其在网站中的主要作用我理解为：RSS 可以用于快速浏览网站的最近更新资源，并且将更新的资源描述及链接发送给搜索引擎以便搜索引擎能够及时收录。RSS 同时也是基于 XML 语言的通用 Web 应用，有很多大型企业的网站都在应用这种技术来快速地分享自己网站的最新信息。用户也可以通过订阅这些网站的 RSS 来及时获得网站资源的更新通知，并通过 RSS 提供的链接了解网站发布的最新信息的详细内容。\n\n由于 RSS 是基于 XML 的，所以 RSS 有着自己标准的 XML 标签和格式，这些规定好的标签和格式也有利于统一的 RSS 阅读器来获得并解析和阅读 RSS 源的内容。其实 RSS 应用本身就是一个 XML 文件，不过这个文件一般通过 Web 后端语言查询数据库资源并根据一定 CSS 样式和 RSS 的规则和格式来生成。\n\n使用 RSS 相对于网页浏览的优点：\n\n1. 浏览 RSS 源可以去掉网站中的图片等装饰性元素，直接查看文章的概要和标题，在最短的时间获得最多的信息；\n2. 通过 RSS 阅读器可以订阅多个网站的 RSS 源，即可以在不打开网站的情况下快速浏览多个网站的最新信息；\n3. 使用 RSS 阅读器可以选择自己喜好的 RSS 源进行订阅，更加自由，开放；\n4. 相对于网站来说，拥有 RSS 源可以利于用户获取信息，同时也利于搜索引擎的收录与抓取；\n\n除此之外，我们也要了解一下 RSS 的大致历史。RSS 的实用思想起源于1995年苹果公司技术人员开放的测试内容框架(MCF)。1999年，网景公司开发了 RSS 的第一个版本 RSS-0.91，而2.0的版本则是由 Dave Winer 在2003年发布的。不幸的是，RSS 规格的作者 **[Aaron Swartz](http://baike.baidu.com/view/7854319.htm)** 于2013年1月11日在纽约市自杀，终年26岁。\n","source":"_posts/RSS-概述.md","raw":"---\ntitle: RSS 概述\nintro: 今天我们来聊聊常用的网络应用之 RSS。RSS 的中文名称叫“简易信息聚合”，其在网站中的主要作用我理解为：RSS 可以用于快速浏览网站的最近更新资源，并且将更新的资源描述及链接发送给搜索引擎以便搜索引擎能够及时收录。RSS 同时也是基于XML语言的通用 Web 应用，有很多大型企业的网站都在应用这种技术来快速的分享自己网站的最新信息。用户也可以通过订阅这些网站的 RSS 来及时获得网站资源的更新通知，并通过 RSS 提供的链接了解网站发布的最新信息的详细内容。\ncomments: true\ndate: 2015-01-04 22:08:40\ntags:\n- Web\n---\n\n今天我们来聊聊常用的网络应用之 RSS。RSS 的中文名称叫“简易信息聚合”，其在网站中的主要作用我理解为：RSS 可以用于快速浏览网站的最近更新资源，并且将更新的资源描述及链接发送给搜索引擎以便搜索引擎能够及时收录。RSS 同时也是基于 XML 语言的通用 Web 应用，有很多大型企业的网站都在应用这种技术来快速地分享自己网站的最新信息。用户也可以通过订阅这些网站的 RSS 来及时获得网站资源的更新通知，并通过 RSS 提供的链接了解网站发布的最新信息的详细内容。\n\n由于 RSS 是基于 XML 的，所以 RSS 有着自己标准的 XML 标签和格式，这些规定好的标签和格式也有利于统一的 RSS 阅读器来获得并解析和阅读 RSS 源的内容。其实 RSS 应用本身就是一个 XML 文件，不过这个文件一般通过 Web 后端语言查询数据库资源并根据一定 CSS 样式和 RSS 的规则和格式来生成。\n\n使用 RSS 相对于网页浏览的优点：\n\n1. 浏览 RSS 源可以去掉网站中的图片等装饰性元素，直接查看文章的概要和标题，在最短的时间获得最多的信息；\n2. 通过 RSS 阅读器可以订阅多个网站的 RSS 源，即可以在不打开网站的情况下快速浏览多个网站的最新信息；\n3. 使用 RSS 阅读器可以选择自己喜好的 RSS 源进行订阅，更加自由，开放；\n4. 相对于网站来说，拥有 RSS 源可以利于用户获取信息，同时也利于搜索引擎的收录与抓取；\n\n除此之外，我们也要了解一下 RSS 的大致历史。RSS 的实用思想起源于1995年苹果公司技术人员开放的测试内容框架(MCF)。1999年，网景公司开发了 RSS 的第一个版本 RSS-0.91，而2.0的版本则是由 Dave Winer 在2003年发布的。不幸的是，RSS 规格的作者 **[Aaron Swartz](http://baike.baidu.com/view/7854319.htm)** 于2013年1月11日在纽约市自杀，终年26岁。\n","slug":"RSS-概述","published":1,"updated":"2019-02-04T04:43:26.074Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtab004nknp27m7ao82q","content":"<p>今天我们来聊聊常用的网络应用之 RSS。RSS 的中文名称叫“简易信息聚合”，其在网站中的主要作用我理解为：RSS 可以用于快速浏览网站的最近更新资源，并且将更新的资源描述及链接发送给搜索引擎以便搜索引擎能够及时收录。RSS 同时也是基于 XML 语言的通用 Web 应用，有很多大型企业的网站都在应用这种技术来快速地分享自己网站的最新信息。用户也可以通过订阅这些网站的 RSS 来及时获得网站资源的更新通知，并通过 RSS 提供的链接了解网站发布的最新信息的详细内容。</p>\n<p>由于 RSS 是基于 XML 的，所以 RSS 有着自己标准的 XML 标签和格式，这些规定好的标签和格式也有利于统一的 RSS 阅读器来获得并解析和阅读 RSS 源的内容。其实 RSS 应用本身就是一个 XML 文件，不过这个文件一般通过 Web 后端语言查询数据库资源并根据一定 CSS 样式和 RSS 的规则和格式来生成。</p>\n<p>使用 RSS 相对于网页浏览的优点：</p>\n<ol>\n<li>浏览 RSS 源可以去掉网站中的图片等装饰性元素，直接查看文章的概要和标题，在最短的时间获得最多的信息；</li>\n<li>通过 RSS 阅读器可以订阅多个网站的 RSS 源，即可以在不打开网站的情况下快速浏览多个网站的最新信息；</li>\n<li>使用 RSS 阅读器可以选择自己喜好的 RSS 源进行订阅，更加自由，开放；</li>\n<li>相对于网站来说，拥有 RSS 源可以利于用户获取信息，同时也利于搜索引擎的收录与抓取；</li>\n</ol>\n<p>除此之外，我们也要了解一下 RSS 的大致历史。RSS 的实用思想起源于1995年苹果公司技术人员开放的测试内容框架(MCF)。1999年，网景公司开发了 RSS 的第一个版本 RSS-0.91，而2.0的版本则是由 Dave Winer 在2003年发布的。不幸的是，RSS 规格的作者 <strong><a href=\"http://baike.baidu.com/view/7854319.htm\" target=\"_blank\" rel=\"noopener\">Aaron Swartz</a></strong> 于2013年1月11日在纽约市自杀，终年26岁。</p>\n","site":{"data":{}},"id":"5e8926eef4e852733feaefb9f8d97b96","excerpt":"","more":"<p>今天我们来聊聊常用的网络应用之 RSS。RSS 的中文名称叫“简易信息聚合”，其在网站中的主要作用我理解为：RSS 可以用于快速浏览网站的最近更新资源，并且将更新的资源描述及链接发送给搜索引擎以便搜索引擎能够及时收录。RSS 同时也是基于 XML 语言的通用 Web 应用，有很多大型企业的网站都在应用这种技术来快速地分享自己网站的最新信息。用户也可以通过订阅这些网站的 RSS 来及时获得网站资源的更新通知，并通过 RSS 提供的链接了解网站发布的最新信息的详细内容。</p>\n<p>由于 RSS 是基于 XML 的，所以 RSS 有着自己标准的 XML 标签和格式，这些规定好的标签和格式也有利于统一的 RSS 阅读器来获得并解析和阅读 RSS 源的内容。其实 RSS 应用本身就是一个 XML 文件，不过这个文件一般通过 Web 后端语言查询数据库资源并根据一定 CSS 样式和 RSS 的规则和格式来生成。</p>\n<p>使用 RSS 相对于网页浏览的优点：</p>\n<ol>\n<li>浏览 RSS 源可以去掉网站中的图片等装饰性元素，直接查看文章的概要和标题，在最短的时间获得最多的信息；</li>\n<li>通过 RSS 阅读器可以订阅多个网站的 RSS 源，即可以在不打开网站的情况下快速浏览多个网站的最新信息；</li>\n<li>使用 RSS 阅读器可以选择自己喜好的 RSS 源进行订阅，更加自由，开放；</li>\n<li>相对于网站来说，拥有 RSS 源可以利于用户获取信息，同时也利于搜索引擎的收录与抓取；</li>\n</ol>\n<p>除此之外，我们也要了解一下 RSS 的大致历史。RSS 的实用思想起源于1995年苹果公司技术人员开放的测试内容框架(MCF)。1999年，网景公司开发了 RSS 的第一个版本 RSS-0.91，而2.0的版本则是由 Dave Winer 在2003年发布的。不幸的是，RSS 规格的作者 <strong><a href=\"http://baike.baidu.com/view/7854319.htm\" target=\"_blank\" rel=\"noopener\">Aaron Swartz</a></strong> 于2013年1月11日在纽约市自杀，终年26岁。</p>\n"},{"title":"“函数柯里化”常见使用场景记录","intro":"这里记录一下前端常用的“函数柯里化”使用场景。总的来说，柯里化常常用来进行函数的“延迟计算”与“参数复用”，甚至在某些场合需要动态创建函数的情况下，都可以使用函数的“柯里化”。","comments":1,"date":"2017-05-08T02:02:26.000Z","_content":"\n\n这里记录一下前端常用的“函数柯里化”使用场景。总的来说，柯里化常常用来进行函数的“延迟计算”与“参数复用”，甚至在某些场合需要动态创建函数的情况下，都可以使用函数的“柯里化”。\n\n\n#### 1、浏览器事件绑定函数：\n\n属于延迟计算类型，第一次计算为判断浏览器支持类型，然后返回一个函数用来后续的计算过程。因此第一次的计算可以被复用，不需要再次调用。\n\n```javascript\nvar addEvent = (function() {\n  if (window.addEventListener) {\n    return function(el, sType, fn, capture) {\n      el.addEventListener(sType, function(e) {\n        fn.call(el, e);\n      }, (capture));\n    };\n  } else if (window.attachEvent) {\n    return function(el, sType, fn, capture) {\n      el.attachEvent(\"on\" + sType, function(e) {\n        fn.call(el, e);\n      });\n    };\n  }\n})();\n```\n\n\n\n#### 2、增量处理函数：\n\n属于参数复用和延迟计算的混合。`fn` 作为 Handler 会在最后接收到所有传入过的参数，然后做统一的处理。`_args` 由于闭包会保存所有已传入过的参数。\n\n```javascript\nvar currying = function(fn) {\n  var _args = [];\n  return function() {\n    if (arguments.length === 0) {\n      return fn.apply(this, _args);\n    }\n    Array.prototype.push.apply(_args, [].slice.call(arguments));\n    return arguments.callee;\n  }\n};\n```\n","source":"_posts/“函数柯里化”常见使用场景记录.md","raw":"---\ntitle: “函数柯里化”常见使用场景记录\nintro: 这里记录一下前端常用的“函数柯里化”使用场景。总的来说，柯里化常常用来进行函数的“延迟计算”与“参数复用”，甚至在某些场合需要动态创建函数的情况下，都可以使用函数的“柯里化”。\ncomments: true\ndate: 2017-05-08 10:02:26\ntags:\n- 柯里化\n- JavaScript\n---\n\n\n这里记录一下前端常用的“函数柯里化”使用场景。总的来说，柯里化常常用来进行函数的“延迟计算”与“参数复用”，甚至在某些场合需要动态创建函数的情况下，都可以使用函数的“柯里化”。\n\n\n#### 1、浏览器事件绑定函数：\n\n属于延迟计算类型，第一次计算为判断浏览器支持类型，然后返回一个函数用来后续的计算过程。因此第一次的计算可以被复用，不需要再次调用。\n\n```javascript\nvar addEvent = (function() {\n  if (window.addEventListener) {\n    return function(el, sType, fn, capture) {\n      el.addEventListener(sType, function(e) {\n        fn.call(el, e);\n      }, (capture));\n    };\n  } else if (window.attachEvent) {\n    return function(el, sType, fn, capture) {\n      el.attachEvent(\"on\" + sType, function(e) {\n        fn.call(el, e);\n      });\n    };\n  }\n})();\n```\n\n\n\n#### 2、增量处理函数：\n\n属于参数复用和延迟计算的混合。`fn` 作为 Handler 会在最后接收到所有传入过的参数，然后做统一的处理。`_args` 由于闭包会保存所有已传入过的参数。\n\n```javascript\nvar currying = function(fn) {\n  var _args = [];\n  return function() {\n    if (arguments.length === 0) {\n      return fn.apply(this, _args);\n    }\n    Array.prototype.push.apply(_args, [].slice.call(arguments));\n    return arguments.callee;\n  }\n};\n```\n","slug":"“函数柯里化”常见使用场景记录","published":1,"updated":"2019-02-18T01:47:02.547Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtac004pknp2glrz1lzk","content":"<p>这里记录一下前端常用的“函数柯里化”使用场景。总的来说，柯里化常常用来进行函数的“延迟计算”与“参数复用”，甚至在某些场合需要动态创建函数的情况下，都可以使用函数的“柯里化”。</p>\n<h4 id=\"1、浏览器事件绑定函数：\"><a href=\"#1、浏览器事件绑定函数：\" class=\"headerlink\" title=\"1、浏览器事件绑定函数：\"></a>1、浏览器事件绑定函数：</h4><p>属于延迟计算类型，第一次计算为判断浏览器支持类型，然后返回一个函数用来后续的计算过程。因此第一次的计算可以被复用，不需要再次调用。</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> addEvent <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">.</span>addEventListener<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>el<span class=\"token punctuation\">,</span> sType<span class=\"token punctuation\">,</span> fn<span class=\"token punctuation\">,</span> capture<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      el<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span>sType<span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        fn<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>el<span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>capture<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">.</span>attachEvent<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>el<span class=\"token punctuation\">,</span> sType<span class=\"token punctuation\">,</span> fn<span class=\"token punctuation\">,</span> capture<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      el<span class=\"token punctuation\">.</span><span class=\"token function\">attachEvent</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"on\"</span> <span class=\"token operator\">+</span> sType<span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        fn<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>el<span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"2、增量处理函数：\"><a href=\"#2、增量处理函数：\" class=\"headerlink\" title=\"2、增量处理函数：\"></a>2、增量处理函数：</h4><p>属于参数复用和延迟计算的混合。<code>fn</code> 作为 Handler 会在最后接收到所有传入过的参数，然后做统一的处理。<code>_args</code> 由于闭包会保存所有已传入过的参数。</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> currying <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> _args <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>arguments<span class=\"token punctuation\">.</span>length <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> fn<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> _args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    Array<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>push<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>_args<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>slice<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>arguments<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> arguments<span class=\"token punctuation\">.</span>callee<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"id":"9379698822313f52d4f8fbb0cf3329d9","excerpt":"","more":"<p>这里记录一下前端常用的“函数柯里化”使用场景。总的来说，柯里化常常用来进行函数的“延迟计算”与“参数复用”，甚至在某些场合需要动态创建函数的情况下，都可以使用函数的“柯里化”。</p>\n<h4 id=\"1、浏览器事件绑定函数：\"><a href=\"#1、浏览器事件绑定函数：\" class=\"headerlink\" title=\"1、浏览器事件绑定函数：\"></a>1、浏览器事件绑定函数：</h4><p>属于延迟计算类型，第一次计算为判断浏览器支持类型，然后返回一个函数用来后续的计算过程。因此第一次的计算可以被复用，不需要再次调用。</p>\n<pre><code class=\"javascript\">var addEvent = (function() {\n  if (window.addEventListener) {\n    return function(el, sType, fn, capture) {\n      el.addEventListener(sType, function(e) {\n        fn.call(el, e);\n      }, (capture));\n    };\n  } else if (window.attachEvent) {\n    return function(el, sType, fn, capture) {\n      el.attachEvent(&quot;on&quot; + sType, function(e) {\n        fn.call(el, e);\n      });\n    };\n  }\n})();\n</code></pre>\n<h4 id=\"2、增量处理函数：\"><a href=\"#2、增量处理函数：\" class=\"headerlink\" title=\"2、增量处理函数：\"></a>2、增量处理函数：</h4><p>属于参数复用和延迟计算的混合。<code>fn</code> 作为 Handler 会在最后接收到所有传入过的参数，然后做统一的处理。<code>_args</code> 由于闭包会保存所有已传入过的参数。</p>\n<pre><code class=\"javascript\">var currying = function(fn) {\n  var _args = [];\n  return function() {\n    if (arguments.length === 0) {\n      return fn.apply(this, _args);\n    }\n    Array.prototype.push.apply(_args, [].slice.call(arguments));\n    return arguments.callee;\n  }\n};\n</code></pre>\n"},{"title":"“增长黑客：创业公司的用户与收入增长秘籍” 读书笔记","intro":"《增长黑客：创业公司的用户与收入增长秘籍》读书笔记（2/20）。这里记录了一些在读书过程中提炼出我觉得有价值的观点，仅供参考。与其说本书是介绍“增长黑客”不如说是以“增长黑客”为视角来介绍针对创业中几个关键节点（AARRR）的案例和分析。前半部分干货还是有一些的，后半部分稍显不足。书中的案例主观分析只能用做参考，有一些营销技巧和产品准则倒是值得学习和借鉴。","comments":1,"date":"2019-01-05T01:20:25.000Z","_content":"\n《增长黑客：创业公司的用户与收入增长秘籍》读书笔记（2/20）。这里记录了一些在读书过程中提炼出我觉得有价值的观点，仅供参考。与其说本书是介绍“增长黑客”不如说是以“增长黑客”为视角来介绍针对创业中几个关键节点（AARRR）的案例和分析。前半部分干货还是有一些的，后半部分稍显不足。书中的案例主观分析只能用做参考，有一些营销技巧和产品准则倒是值得学习和借鉴。 \n\n* **AARRR 转化漏斗模型**：Acquisition、Activation、Retention、Revenue、Referral； \n* **互联网体验**：时间碎片化导致产品一定要内容专注、消息反馈即时、交互流畅、体验连续； \n* **确认产品核心数据指标**：一切用数据说话； \n* **互联网市场**：数据为依据、资源为根基、金钱为武器、人脉为引擎的有机系统； \n* **如何招聘增长黑客**：给定特定的场景和现象问其解决方案？以往接触的案例？ \n* **衡量创业需求**：不能主观臆测，谨防幸存者偏差（尤其在衡量潜在目标用户体量时）； \n* **兴趣创业的双面性**：利在于充满激情，弊在于容易靠主观臆测，脱离实际的目标群体需求； \n* **精益创业（MVP -> 用户反馈 -> 快速迭代）**：保持专注、持续交付，降低产品试错成本； \n* **平台试错**：前期可利用平台（如微信）本身所已有的分发途径和用户习惯来快速检验市场； \n* **MVP 产品必备模块**：反馈渠道、官方公告、自动提示升级； \n* **MVP 降级方案**：不要由于产品技术原因而导致第一批用户（通常具有好奇心或一定兴趣）的流失； \n* **炫耀性社交**：除完成基本功能外，所产生的带有“炫耀传播性”的附加性价值； \n* **第三方社交登录**：前期可以让用户迅速使用产品，并通过“分享”等社交方式来产生回流，享受社交红利； \n* **制造舆论**：利用用户的从众心理和饥饿营销，比如限量/排队注册、邀请制的优先注册权益； \n* **擅用 A/B 测**：保持单变量，对同一事物的不同类型进行测试，以筛选最优转化率；\n* **擅于诱导**：针对事物，让用户作出明确选择，这可以让处于中立状态的用户强制分流至多个确定状态； \n* **游戏化营销**：荣耀、目标、互动、惊喜； \n* **适当降级**：在特殊情况下（带宽、CPU 高峰期等）能够确保核心服务的完整可用性； \n* **第三方团队约束**：对于外包等第三方的约束不能太过讲究企业文化，而是需要完善的制度全方位考量； \n","source":"_posts/“增长黑客：创业公司的用户与收入增长秘籍” 读书笔记.md","raw":"---\ntitle: “增长黑客：创业公司的用户与收入增长秘籍” 读书笔记\nintro: 《增长黑客：创业公司的用户与收入增长秘籍》读书笔记（2/20）。这里记录了一些在读书过程中提炼出我觉得有价值的观点，仅供参考。与其说本书是介绍“增长黑客”不如说是以“增长黑客”为视角来介绍针对创业中几个关键节点（AARRR）的案例和分析。前半部分干货还是有一些的，后半部分稍显不足。书中的案例主观分析只能用做参考，有一些营销技巧和产品准则倒是值得学习和借鉴。 \ncomments: true\ndate: 2019-01-05 09:20:25\ntags:\n- 读书\n- 创业\n---\n\n《增长黑客：创业公司的用户与收入增长秘籍》读书笔记（2/20）。这里记录了一些在读书过程中提炼出我觉得有价值的观点，仅供参考。与其说本书是介绍“增长黑客”不如说是以“增长黑客”为视角来介绍针对创业中几个关键节点（AARRR）的案例和分析。前半部分干货还是有一些的，后半部分稍显不足。书中的案例主观分析只能用做参考，有一些营销技巧和产品准则倒是值得学习和借鉴。 \n\n* **AARRR 转化漏斗模型**：Acquisition、Activation、Retention、Revenue、Referral； \n* **互联网体验**：时间碎片化导致产品一定要内容专注、消息反馈即时、交互流畅、体验连续； \n* **确认产品核心数据指标**：一切用数据说话； \n* **互联网市场**：数据为依据、资源为根基、金钱为武器、人脉为引擎的有机系统； \n* **如何招聘增长黑客**：给定特定的场景和现象问其解决方案？以往接触的案例？ \n* **衡量创业需求**：不能主观臆测，谨防幸存者偏差（尤其在衡量潜在目标用户体量时）； \n* **兴趣创业的双面性**：利在于充满激情，弊在于容易靠主观臆测，脱离实际的目标群体需求； \n* **精益创业（MVP -> 用户反馈 -> 快速迭代）**：保持专注、持续交付，降低产品试错成本； \n* **平台试错**：前期可利用平台（如微信）本身所已有的分发途径和用户习惯来快速检验市场； \n* **MVP 产品必备模块**：反馈渠道、官方公告、自动提示升级； \n* **MVP 降级方案**：不要由于产品技术原因而导致第一批用户（通常具有好奇心或一定兴趣）的流失； \n* **炫耀性社交**：除完成基本功能外，所产生的带有“炫耀传播性”的附加性价值； \n* **第三方社交登录**：前期可以让用户迅速使用产品，并通过“分享”等社交方式来产生回流，享受社交红利； \n* **制造舆论**：利用用户的从众心理和饥饿营销，比如限量/排队注册、邀请制的优先注册权益； \n* **擅用 A/B 测**：保持单变量，对同一事物的不同类型进行测试，以筛选最优转化率；\n* **擅于诱导**：针对事物，让用户作出明确选择，这可以让处于中立状态的用户强制分流至多个确定状态； \n* **游戏化营销**：荣耀、目标、互动、惊喜； \n* **适当降级**：在特殊情况下（带宽、CPU 高峰期等）能够确保核心服务的完整可用性； \n* **第三方团队约束**：对于外包等第三方的约束不能太过讲究企业文化，而是需要完善的制度全方位考量； \n","slug":"“增长黑客：创业公司的用户与收入增长秘籍” 读书笔记","published":1,"updated":"2019-02-20T06:52:43.726Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtad004sknp2dwiqeau8","content":"<p>《增长黑客：创业公司的用户与收入增长秘籍》读书笔记（2/20）。这里记录了一些在读书过程中提炼出我觉得有价值的观点，仅供参考。与其说本书是介绍“增长黑客”不如说是以“增长黑客”为视角来介绍针对创业中几个关键节点（AARRR）的案例和分析。前半部分干货还是有一些的，后半部分稍显不足。书中的案例主观分析只能用做参考，有一些营销技巧和产品准则倒是值得学习和借鉴。 </p>\n<ul>\n<li><strong>AARRR 转化漏斗模型</strong>：Acquisition、Activation、Retention、Revenue、Referral； </li>\n<li><strong>互联网体验</strong>：时间碎片化导致产品一定要内容专注、消息反馈即时、交互流畅、体验连续； </li>\n<li><strong>确认产品核心数据指标</strong>：一切用数据说话； </li>\n<li><strong>互联网市场</strong>：数据为依据、资源为根基、金钱为武器、人脉为引擎的有机系统； </li>\n<li><strong>如何招聘增长黑客</strong>：给定特定的场景和现象问其解决方案？以往接触的案例？ </li>\n<li><strong>衡量创业需求</strong>：不能主观臆测，谨防幸存者偏差（尤其在衡量潜在目标用户体量时）； </li>\n<li><strong>兴趣创业的双面性</strong>：利在于充满激情，弊在于容易靠主观臆测，脱离实际的目标群体需求； </li>\n<li><strong>精益创业（MVP -&gt; 用户反馈 -&gt; 快速迭代）</strong>：保持专注、持续交付，降低产品试错成本； </li>\n<li><strong>平台试错</strong>：前期可利用平台（如微信）本身所已有的分发途径和用户习惯来快速检验市场； </li>\n<li><strong>MVP 产品必备模块</strong>：反馈渠道、官方公告、自动提示升级； </li>\n<li><strong>MVP 降级方案</strong>：不要由于产品技术原因而导致第一批用户（通常具有好奇心或一定兴趣）的流失； </li>\n<li><strong>炫耀性社交</strong>：除完成基本功能外，所产生的带有“炫耀传播性”的附加性价值； </li>\n<li><strong>第三方社交登录</strong>：前期可以让用户迅速使用产品，并通过“分享”等社交方式来产生回流，享受社交红利； </li>\n<li><strong>制造舆论</strong>：利用用户的从众心理和饥饿营销，比如限量/排队注册、邀请制的优先注册权益； </li>\n<li><strong>擅用 A/B 测</strong>：保持单变量，对同一事物的不同类型进行测试，以筛选最优转化率；</li>\n<li><strong>擅于诱导</strong>：针对事物，让用户作出明确选择，这可以让处于中立状态的用户强制分流至多个确定状态； </li>\n<li><strong>游戏化营销</strong>：荣耀、目标、互动、惊喜； </li>\n<li><strong>适当降级</strong>：在特殊情况下（带宽、CPU 高峰期等）能够确保核心服务的完整可用性； </li>\n<li><strong>第三方团队约束</strong>：对于外包等第三方的约束不能太过讲究企业文化，而是需要完善的制度全方位考量； </li>\n</ul>\n","site":{"data":{}},"id":"402d2453546e33b18f3e46918ac3556a","excerpt":"","more":"<p>《增长黑客：创业公司的用户与收入增长秘籍》读书笔记（2/20）。这里记录了一些在读书过程中提炼出我觉得有价值的观点，仅供参考。与其说本书是介绍“增长黑客”不如说是以“增长黑客”为视角来介绍针对创业中几个关键节点（AARRR）的案例和分析。前半部分干货还是有一些的，后半部分稍显不足。书中的案例主观分析只能用做参考，有一些营销技巧和产品准则倒是值得学习和借鉴。 </p>\n<ul>\n<li><strong>AARRR 转化漏斗模型</strong>：Acquisition、Activation、Retention、Revenue、Referral； </li>\n<li><strong>互联网体验</strong>：时间碎片化导致产品一定要内容专注、消息反馈即时、交互流畅、体验连续； </li>\n<li><strong>确认产品核心数据指标</strong>：一切用数据说话； </li>\n<li><strong>互联网市场</strong>：数据为依据、资源为根基、金钱为武器、人脉为引擎的有机系统； </li>\n<li><strong>如何招聘增长黑客</strong>：给定特定的场景和现象问其解决方案？以往接触的案例？ </li>\n<li><strong>衡量创业需求</strong>：不能主观臆测，谨防幸存者偏差（尤其在衡量潜在目标用户体量时）； </li>\n<li><strong>兴趣创业的双面性</strong>：利在于充满激情，弊在于容易靠主观臆测，脱离实际的目标群体需求； </li>\n<li><strong>精益创业（MVP -&gt; 用户反馈 -&gt; 快速迭代）</strong>：保持专注、持续交付，降低产品试错成本； </li>\n<li><strong>平台试错</strong>：前期可利用平台（如微信）本身所已有的分发途径和用户习惯来快速检验市场； </li>\n<li><strong>MVP 产品必备模块</strong>：反馈渠道、官方公告、自动提示升级； </li>\n<li><strong>MVP 降级方案</strong>：不要由于产品技术原因而导致第一批用户（通常具有好奇心或一定兴趣）的流失； </li>\n<li><strong>炫耀性社交</strong>：除完成基本功能外，所产生的带有“炫耀传播性”的附加性价值； </li>\n<li><strong>第三方社交登录</strong>：前期可以让用户迅速使用产品，并通过“分享”等社交方式来产生回流，享受社交红利； </li>\n<li><strong>制造舆论</strong>：利用用户的从众心理和饥饿营销，比如限量/排队注册、邀请制的优先注册权益； </li>\n<li><strong>擅用 A/B 测</strong>：保持单变量，对同一事物的不同类型进行测试，以筛选最优转化率；</li>\n<li><strong>擅于诱导</strong>：针对事物，让用户作出明确选择，这可以让处于中立状态的用户强制分流至多个确定状态； </li>\n<li><strong>游戏化营销</strong>：荣耀、目标、互动、惊喜； </li>\n<li><strong>适当降级</strong>：在特殊情况下（带宽、CPU 高峰期等）能够确保核心服务的完整可用性； </li>\n<li><strong>第三方团队约束</strong>：对于外包等第三方的约束不能太过讲究企业文化，而是需要完善的制度全方位考量； </li>\n</ul>\n"},{"title":"“大型网站技术架构”总结：二，网站的高性能架构","intro":"第二篇读书总结，主要围绕着如何从多个方面来进行“高性能网站架构”来展开，性能优化小到一行代码的重构，大到服务器集群的重新架构设计。怎样通过各项数据指标来监控网站的实时性能？只有找出网站的性能“弱点”，并以此作为目标来进行迭代式的优化，才能够逐渐将网站架构演进到一个高性能的水平。","comments":1,"date":"2017-04-30T03:02:23.000Z","_content":"\n\n第二篇读书总结，主要围绕着如何从多个方面来进行“高性能网站架构”来展开，性能优化小到一行代码的重构，大到服务器集群的重新架构设计。怎样通过各项数据指标来监控网站的实时性能？只有找出网站的性能“弱点”，并以此作为目标来进行迭代式的优化，才能够逐渐将网站架构演进到一个高性能的水平。\n\n#### 一、网站性能测试：\n\n网站的性能指标，既可以是开发人员客观的性能分析数据，测试指标。也可以是主观的终端用户体验感受。一般而言，我们用如下一些指标来衡定一个网站的性能水平：**响应时间、并发数量、吞吐量、性能计数器**。响应时间即从请求发出开始，到收到响应并解析成对应可视化结果所花费的时间；并发数指系统能够**同时**处理的请求数量。吞吐量是指**单位时间**内系统能够处理的请求数量，常用的单位为 TPS（每秒事务数）、HPS（每秒 HTTP 请求数）、QPS（每秒数据库查询数）；性能计数器为直观的数据指标，比如当前系统负载、对象与线程数、CPU / 内存使用率、磁盘与网络 IO 等。理想的系统负载应该对应为系统的 CPU 数量，因为系统负载指当前正在排队被 CPU 处理的进程数量。\n\n常见的测试方法分为：**性能测试、负载测试、压力测试**和**稳定性测试**。性能测试用来验证在资源可接受范围内，系统在一定压力下能否达到预期的性能指标。负载测试用来测试当系统资源满载时，系统能够达到的最大吞吐量。压力测试则是在超过系统安全负载时继续施加压力，测试直到系统奔溃所用时间的长短。而稳定性测试则是让系统在一定压力下运行一段时间，检测系统在不同时间点是否有资源的使用异常，以此来推断系统的稳定性。\n\n在性能测试和负载测试中，系统的 TPS 随着压力的增加，值会不断增高。而在压力测试下，由于此时系统资源早已耗尽，更多的压力只会拖垮 CPU 的性能，因此此时的系统 TPS 会随着压力的不断增加而逐渐降低。而系统的响应时间在所有测试中都是随着压力的增加而逐渐增加的，不过在压力测试中，每对系统施加单位的压力，系统的响应时间会成倍的疯狂增长。\n\n对于系统性能的优化，需要从一个请求出发，记录下请求达到每个关键节点（比如代理服务器，负载均衡服务器，应用服务器）的时间，分析哪段时间不合理，再通过分析监控数据来检测问题所在。\n\n#### 二、WEB 前端优化：\n\n**合并资源**、**分离静态资源到独立域名**（防止 Cookie 污染）、**浏览器本地缓存**、**服务器 GZip 压缩**、**CDN 加速**（ISP端）、**使用反向代理**（相当于 Gateway 主机，可缓存资源，还可以保护内部网络）等方式。\n\n#### 三、应用服务器优化：\n\n应用服务器主要用来处理系统业务，是整个网站架构中的核心，也是最复杂、变化最多的部分。常用的优化手段有：**使用分布式缓存**（网站优化第一定律：优先考虑使用缓存。缓存不适用于频繁修改的数据，不适用与没有热点访问的数据，并且容易产生“脏读”。系统的正常运行不应该依赖于缓存系统，初始的缓存系统可以先进行“**缓存预热**”，比如 Redis 在初始化时会从硬盘中读取数据放到内存。如果在日志中发现大量的无法命中缓存的请求，这可能是发生了“**缓存穿透**”，恶意用户持续高并发的访问系统不存在的资源，这些资源无法被缓存下来导致了穿透问题，一个简单的对策是将不存在的数据也缓存起来。常见的分布式缓存系统如 JBoss 和 Memcache；JBoss 的所有集群机器在数据改变时会在所有机器更新；而 Memcache 采用了 Leader 的方式，各个主机间不进行通信，因此**其线性伸缩不会影响缓存系统的性能**）。**使用共享队列**、**使用集群**、**代码优化**（采用多线程，线程数一般与 CPU 数量成正比，使用无状态对象或者加锁来防止一致性问题，数据连接、通信连接等资源复用）。\n\n#### 四、存储系统优化：\n\n使用 SSD 硬盘、使用 NoSQL 数据库（由于 LSM 树的数据更新速度较 B+ 树更快）、根据需求使用 RAID 磁盘阵列和 HDFS（RAID 可以在一定程度上改善磁盘的访问延迟同时增强可用性。但对于大量数据的存储需求，基于 MapReduce 可以进行并发任务处理的 HDFS 可能更加合适）。\n","source":"_posts/“大型网站技术架构”总结：二，网站的高性能架构.md","raw":"---\ntitle: “大型网站技术架构”总结：二，网站的高性能架构\nintro: 第二篇读书总结，主要围绕着如何从多个方面来进行“高性能网站架构”来展开，性能优化小到一行代码的重构，大到服务器集群的重新架构设计。怎样通过各项数据指标来监控网站的实时性能？只有找出网站的性能“弱点”，并以此作为目标来进行迭代式的优化，才能够逐渐将网站架构演进到一个高性能的水平。\ncomments: true\ndate: 2017-04-30 11:02:23\ntags:\n- 后端\n- 架构\n---\n\n\n第二篇读书总结，主要围绕着如何从多个方面来进行“高性能网站架构”来展开，性能优化小到一行代码的重构，大到服务器集群的重新架构设计。怎样通过各项数据指标来监控网站的实时性能？只有找出网站的性能“弱点”，并以此作为目标来进行迭代式的优化，才能够逐渐将网站架构演进到一个高性能的水平。\n\n#### 一、网站性能测试：\n\n网站的性能指标，既可以是开发人员客观的性能分析数据，测试指标。也可以是主观的终端用户体验感受。一般而言，我们用如下一些指标来衡定一个网站的性能水平：**响应时间、并发数量、吞吐量、性能计数器**。响应时间即从请求发出开始，到收到响应并解析成对应可视化结果所花费的时间；并发数指系统能够**同时**处理的请求数量。吞吐量是指**单位时间**内系统能够处理的请求数量，常用的单位为 TPS（每秒事务数）、HPS（每秒 HTTP 请求数）、QPS（每秒数据库查询数）；性能计数器为直观的数据指标，比如当前系统负载、对象与线程数、CPU / 内存使用率、磁盘与网络 IO 等。理想的系统负载应该对应为系统的 CPU 数量，因为系统负载指当前正在排队被 CPU 处理的进程数量。\n\n常见的测试方法分为：**性能测试、负载测试、压力测试**和**稳定性测试**。性能测试用来验证在资源可接受范围内，系统在一定压力下能否达到预期的性能指标。负载测试用来测试当系统资源满载时，系统能够达到的最大吞吐量。压力测试则是在超过系统安全负载时继续施加压力，测试直到系统奔溃所用时间的长短。而稳定性测试则是让系统在一定压力下运行一段时间，检测系统在不同时间点是否有资源的使用异常，以此来推断系统的稳定性。\n\n在性能测试和负载测试中，系统的 TPS 随着压力的增加，值会不断增高。而在压力测试下，由于此时系统资源早已耗尽，更多的压力只会拖垮 CPU 的性能，因此此时的系统 TPS 会随着压力的不断增加而逐渐降低。而系统的响应时间在所有测试中都是随着压力的增加而逐渐增加的，不过在压力测试中，每对系统施加单位的压力，系统的响应时间会成倍的疯狂增长。\n\n对于系统性能的优化，需要从一个请求出发，记录下请求达到每个关键节点（比如代理服务器，负载均衡服务器，应用服务器）的时间，分析哪段时间不合理，再通过分析监控数据来检测问题所在。\n\n#### 二、WEB 前端优化：\n\n**合并资源**、**分离静态资源到独立域名**（防止 Cookie 污染）、**浏览器本地缓存**、**服务器 GZip 压缩**、**CDN 加速**（ISP端）、**使用反向代理**（相当于 Gateway 主机，可缓存资源，还可以保护内部网络）等方式。\n\n#### 三、应用服务器优化：\n\n应用服务器主要用来处理系统业务，是整个网站架构中的核心，也是最复杂、变化最多的部分。常用的优化手段有：**使用分布式缓存**（网站优化第一定律：优先考虑使用缓存。缓存不适用于频繁修改的数据，不适用与没有热点访问的数据，并且容易产生“脏读”。系统的正常运行不应该依赖于缓存系统，初始的缓存系统可以先进行“**缓存预热**”，比如 Redis 在初始化时会从硬盘中读取数据放到内存。如果在日志中发现大量的无法命中缓存的请求，这可能是发生了“**缓存穿透**”，恶意用户持续高并发的访问系统不存在的资源，这些资源无法被缓存下来导致了穿透问题，一个简单的对策是将不存在的数据也缓存起来。常见的分布式缓存系统如 JBoss 和 Memcache；JBoss 的所有集群机器在数据改变时会在所有机器更新；而 Memcache 采用了 Leader 的方式，各个主机间不进行通信，因此**其线性伸缩不会影响缓存系统的性能**）。**使用共享队列**、**使用集群**、**代码优化**（采用多线程，线程数一般与 CPU 数量成正比，使用无状态对象或者加锁来防止一致性问题，数据连接、通信连接等资源复用）。\n\n#### 四、存储系统优化：\n\n使用 SSD 硬盘、使用 NoSQL 数据库（由于 LSM 树的数据更新速度较 B+ 树更快）、根据需求使用 RAID 磁盘阵列和 HDFS（RAID 可以在一定程度上改善磁盘的访问延迟同时增强可用性。但对于大量数据的存储需求，基于 MapReduce 可以进行并发任务处理的 HDFS 可能更加合适）。\n","slug":"“大型网站技术架构”总结：二，网站的高性能架构","published":1,"updated":"2019-02-17T15:22:40.990Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtae004uknp233ytkuxn","content":"<p>第二篇读书总结，主要围绕着如何从多个方面来进行“高性能网站架构”来展开，性能优化小到一行代码的重构，大到服务器集群的重新架构设计。怎样通过各项数据指标来监控网站的实时性能？只有找出网站的性能“弱点”，并以此作为目标来进行迭代式的优化，才能够逐渐将网站架构演进到一个高性能的水平。</p>\n<h4 id=\"一、网站性能测试：\"><a href=\"#一、网站性能测试：\" class=\"headerlink\" title=\"一、网站性能测试：\"></a>一、网站性能测试：</h4><p>网站的性能指标，既可以是开发人员客观的性能分析数据，测试指标。也可以是主观的终端用户体验感受。一般而言，我们用如下一些指标来衡定一个网站的性能水平：<strong>响应时间、并发数量、吞吐量、性能计数器</strong>。响应时间即从请求发出开始，到收到响应并解析成对应可视化结果所花费的时间；并发数指系统能够<strong>同时</strong>处理的请求数量。吞吐量是指<strong>单位时间</strong>内系统能够处理的请求数量，常用的单位为 TPS（每秒事务数）、HPS（每秒 HTTP 请求数）、QPS（每秒数据库查询数）；性能计数器为直观的数据指标，比如当前系统负载、对象与线程数、CPU / 内存使用率、磁盘与网络 IO 等。理想的系统负载应该对应为系统的 CPU 数量，因为系统负载指当前正在排队被 CPU 处理的进程数量。</p>\n<p>常见的测试方法分为：<strong>性能测试、负载测试、压力测试</strong>和<strong>稳定性测试</strong>。性能测试用来验证在资源可接受范围内，系统在一定压力下能否达到预期的性能指标。负载测试用来测试当系统资源满载时，系统能够达到的最大吞吐量。压力测试则是在超过系统安全负载时继续施加压力，测试直到系统奔溃所用时间的长短。而稳定性测试则是让系统在一定压力下运行一段时间，检测系统在不同时间点是否有资源的使用异常，以此来推断系统的稳定性。</p>\n<p>在性能测试和负载测试中，系统的 TPS 随着压力的增加，值会不断增高。而在压力测试下，由于此时系统资源早已耗尽，更多的压力只会拖垮 CPU 的性能，因此此时的系统 TPS 会随着压力的不断增加而逐渐降低。而系统的响应时间在所有测试中都是随着压力的增加而逐渐增加的，不过在压力测试中，每对系统施加单位的压力，系统的响应时间会成倍的疯狂增长。</p>\n<p>对于系统性能的优化，需要从一个请求出发，记录下请求达到每个关键节点（比如代理服务器，负载均衡服务器，应用服务器）的时间，分析哪段时间不合理，再通过分析监控数据来检测问题所在。</p>\n<h4 id=\"二、WEB-前端优化：\"><a href=\"#二、WEB-前端优化：\" class=\"headerlink\" title=\"二、WEB 前端优化：\"></a>二、WEB 前端优化：</h4><p><strong>合并资源</strong>、<strong>分离静态资源到独立域名</strong>（防止 Cookie 污染）、<strong>浏览器本地缓存</strong>、<strong>服务器 GZip 压缩</strong>、<strong>CDN 加速</strong>（ISP端）、<strong>使用反向代理</strong>（相当于 Gateway 主机，可缓存资源，还可以保护内部网络）等方式。</p>\n<h4 id=\"三、应用服务器优化：\"><a href=\"#三、应用服务器优化：\" class=\"headerlink\" title=\"三、应用服务器优化：\"></a>三、应用服务器优化：</h4><p>应用服务器主要用来处理系统业务，是整个网站架构中的核心，也是最复杂、变化最多的部分。常用的优化手段有：<strong>使用分布式缓存</strong>（网站优化第一定律：优先考虑使用缓存。缓存不适用于频繁修改的数据，不适用与没有热点访问的数据，并且容易产生“脏读”。系统的正常运行不应该依赖于缓存系统，初始的缓存系统可以先进行“<strong>缓存预热</strong>”，比如 Redis 在初始化时会从硬盘中读取数据放到内存。如果在日志中发现大量的无法命中缓存的请求，这可能是发生了“<strong>缓存穿透</strong>”，恶意用户持续高并发的访问系统不存在的资源，这些资源无法被缓存下来导致了穿透问题，一个简单的对策是将不存在的数据也缓存起来。常见的分布式缓存系统如 JBoss 和 Memcache；JBoss 的所有集群机器在数据改变时会在所有机器更新；而 Memcache 采用了 Leader 的方式，各个主机间不进行通信，因此<strong>其线性伸缩不会影响缓存系统的性能</strong>）。<strong>使用共享队列</strong>、<strong>使用集群</strong>、<strong>代码优化</strong>（采用多线程，线程数一般与 CPU 数量成正比，使用无状态对象或者加锁来防止一致性问题，数据连接、通信连接等资源复用）。</p>\n<h4 id=\"四、存储系统优化：\"><a href=\"#四、存储系统优化：\" class=\"headerlink\" title=\"四、存储系统优化：\"></a>四、存储系统优化：</h4><p>使用 SSD 硬盘、使用 NoSQL 数据库（由于 LSM 树的数据更新速度较 B+ 树更快）、根据需求使用 RAID 磁盘阵列和 HDFS（RAID 可以在一定程度上改善磁盘的访问延迟同时增强可用性。但对于大量数据的存储需求，基于 MapReduce 可以进行并发任务处理的 HDFS 可能更加合适）。</p>\n","site":{"data":{}},"id":"7f6b54071905541ba701c95d78034815","excerpt":"","more":"<p>第二篇读书总结，主要围绕着如何从多个方面来进行“高性能网站架构”来展开，性能优化小到一行代码的重构，大到服务器集群的重新架构设计。怎样通过各项数据指标来监控网站的实时性能？只有找出网站的性能“弱点”，并以此作为目标来进行迭代式的优化，才能够逐渐将网站架构演进到一个高性能的水平。</p>\n<h4 id=\"一、网站性能测试：\"><a href=\"#一、网站性能测试：\" class=\"headerlink\" title=\"一、网站性能测试：\"></a>一、网站性能测试：</h4><p>网站的性能指标，既可以是开发人员客观的性能分析数据，测试指标。也可以是主观的终端用户体验感受。一般而言，我们用如下一些指标来衡定一个网站的性能水平：<strong>响应时间、并发数量、吞吐量、性能计数器</strong>。响应时间即从请求发出开始，到收到响应并解析成对应可视化结果所花费的时间；并发数指系统能够<strong>同时</strong>处理的请求数量。吞吐量是指<strong>单位时间</strong>内系统能够处理的请求数量，常用的单位为 TPS（每秒事务数）、HPS（每秒 HTTP 请求数）、QPS（每秒数据库查询数）；性能计数器为直观的数据指标，比如当前系统负载、对象与线程数、CPU / 内存使用率、磁盘与网络 IO 等。理想的系统负载应该对应为系统的 CPU 数量，因为系统负载指当前正在排队被 CPU 处理的进程数量。</p>\n<p>常见的测试方法分为：<strong>性能测试、负载测试、压力测试</strong>和<strong>稳定性测试</strong>。性能测试用来验证在资源可接受范围内，系统在一定压力下能否达到预期的性能指标。负载测试用来测试当系统资源满载时，系统能够达到的最大吞吐量。压力测试则是在超过系统安全负载时继续施加压力，测试直到系统奔溃所用时间的长短。而稳定性测试则是让系统在一定压力下运行一段时间，检测系统在不同时间点是否有资源的使用异常，以此来推断系统的稳定性。</p>\n<p>在性能测试和负载测试中，系统的 TPS 随着压力的增加，值会不断增高。而在压力测试下，由于此时系统资源早已耗尽，更多的压力只会拖垮 CPU 的性能，因此此时的系统 TPS 会随着压力的不断增加而逐渐降低。而系统的响应时间在所有测试中都是随着压力的增加而逐渐增加的，不过在压力测试中，每对系统施加单位的压力，系统的响应时间会成倍的疯狂增长。</p>\n<p>对于系统性能的优化，需要从一个请求出发，记录下请求达到每个关键节点（比如代理服务器，负载均衡服务器，应用服务器）的时间，分析哪段时间不合理，再通过分析监控数据来检测问题所在。</p>\n<h4 id=\"二、WEB-前端优化：\"><a href=\"#二、WEB-前端优化：\" class=\"headerlink\" title=\"二、WEB 前端优化：\"></a>二、WEB 前端优化：</h4><p><strong>合并资源</strong>、<strong>分离静态资源到独立域名</strong>（防止 Cookie 污染）、<strong>浏览器本地缓存</strong>、<strong>服务器 GZip 压缩</strong>、<strong>CDN 加速</strong>（ISP端）、<strong>使用反向代理</strong>（相当于 Gateway 主机，可缓存资源，还可以保护内部网络）等方式。</p>\n<h4 id=\"三、应用服务器优化：\"><a href=\"#三、应用服务器优化：\" class=\"headerlink\" title=\"三、应用服务器优化：\"></a>三、应用服务器优化：</h4><p>应用服务器主要用来处理系统业务，是整个网站架构中的核心，也是最复杂、变化最多的部分。常用的优化手段有：<strong>使用分布式缓存</strong>（网站优化第一定律：优先考虑使用缓存。缓存不适用于频繁修改的数据，不适用与没有热点访问的数据，并且容易产生“脏读”。系统的正常运行不应该依赖于缓存系统，初始的缓存系统可以先进行“<strong>缓存预热</strong>”，比如 Redis 在初始化时会从硬盘中读取数据放到内存。如果在日志中发现大量的无法命中缓存的请求，这可能是发生了“<strong>缓存穿透</strong>”，恶意用户持续高并发的访问系统不存在的资源，这些资源无法被缓存下来导致了穿透问题，一个简单的对策是将不存在的数据也缓存起来。常见的分布式缓存系统如 JBoss 和 Memcache；JBoss 的所有集群机器在数据改变时会在所有机器更新；而 Memcache 采用了 Leader 的方式，各个主机间不进行通信，因此<strong>其线性伸缩不会影响缓存系统的性能</strong>）。<strong>使用共享队列</strong>、<strong>使用集群</strong>、<strong>代码优化</strong>（采用多线程，线程数一般与 CPU 数量成正比，使用无状态对象或者加锁来防止一致性问题，数据连接、通信连接等资源复用）。</p>\n<h4 id=\"四、存储系统优化：\"><a href=\"#四、存储系统优化：\" class=\"headerlink\" title=\"四、存储系统优化：\"></a>四、存储系统优化：</h4><p>使用 SSD 硬盘、使用 NoSQL 数据库（由于 LSM 树的数据更新速度较 B+ 树更快）、根据需求使用 RAID 磁盘阵列和 HDFS（RAID 可以在一定程度上改善磁盘的访问延迟同时增强可用性。但对于大量数据的存储需求，基于 MapReduce 可以进行并发任务处理的 HDFS 可能更加合适）。</p>\n"},{"title":"“重新定义团队：谷歌如何工作” 读书笔记","intro":"《重新定义团队：谷歌如何工作》读书笔记（5/20）。最近花了一些时间来读《重新定义团队：谷歌如何工作》这本书，在这里记录一下书中提出的关键点。怎样才能发挥团队的最大效能，同时让团队中的成员保持高涨的激情，这些都是在团队管理中会经常遇到的问题。","comments":1,"date":"2019-01-14T06:14:00.000Z","_content":"\n《重新定义团队：谷歌如何工作》读书笔记（5/20）。最近花了一些时间来读《重新定义团队：谷歌如何工作》这本书，在这里记录一下书中提出的关键点。怎样才能发挥团队的最大效能，同时让团队中的成员保持高涨的激情，这些都是在团队管理中会经常遇到的问题。 \n\n* 当员工信任领导层的时候，会达到企业的利益最大化；\n* 以谷歌为代表的管理方式，我们将其称作“高度自由”的方式，员工享有极大的自由。这将是未来的方向；\n* 这些全球精英希望在高度自由的企业中工作，而优秀人才都会流向此类企业。能够打造适宜的工作环境的领导者就像磁石一样，吸引着全球最优秀的人才；\n* 管理者的关注重点不是惩罚或奖励，而是清除路障，鼓励团队；\n* 员工所有制度；\n* 作为领导者要确保公司里的每个人都有良好的机遇，要让他们感觉到自己产生了有益的影响，为社会的向善贡献了力量；\n* 因为陈设是最显眼的，所以人们往往会根据人造物品陈设来阐释盛行的文化，但是价值观及其深层意义反而比陈设更加重要。即一个群体的文化可以用三种方式来了解：查看他们的“人造物品”（比如空间布置和陈设）、研究群体成员所信奉的信仰和价值观、深究这些价值观背后所反映的深刻意义；\n* **谷歌的使命**：“整合全球信息，使人人都能访问并从中受益”。在这个使命中没有言及利润或市场。没有言及顾客、股东或用户。没有言及为何选此作为公司使命，也未曾言及如何实现这些目标。这样的使命使个人的工作有了意义，因为它不是一种商业目标而是一种道德目标；\n* 地球上最有才华的人才需要能够激励人心的抱负。领导者所面临的挑战就是要创造出这样一个目标。即便是在谷歌，我们也发现并非所有人都感觉自己的工作与公司的使命有紧密联系；\n* 我们都希望自己的工作有意义，没有什么比知道自己正在改变世界能带来更强有力的激励作用；\n* 让员工与他们正在帮助的人见面是最有效的激励因素，即使会面只有几分钟。此举可为一个人的工作带来非凡的意义，胜过他们对职业生涯和金钱的渴求；\n* 发声的权利意味着给员工真正的话语权，决定公司如何运营。你需要决定是否相信员工，欢迎他们发表意见；\n* 聘用最优秀的人才，只聘用在某些特定的方面比你更优秀的人；四个招聘准则：设定高质量标准；寻找应聘者；客观地评估应聘者（请下级和同事参与其中，定期回忆员工面试记录与其工作表现）；给应聘者一个加入的理由。\n* **三种公司文化的基石**：使命、透明和发声的权利；\n* 成为公司的主人翁而非雇员，模糊等级概念，授权群众的第一步就是保证人们能够安全地发表意见；\n* 百分之一测试法；\n* **授权于员工**：消除地位象征，给予员工高期待，依靠数据而不是想法做决定；\n* 给予表现不佳（比如底部的5%）的员工以帮助，帮助他们解决在工作中遇到的问题，而非直接开除；\n* 优秀经理的特征：\n\n1. 做一名好导师；\n2. 给团队授权，不随便插手下属工作；\n3. 表达出对团队成员的成功和个人幸福的兴趣与关心；\n4. 高效/结果导向型；\n5. 善于沟通、聆听与分享信息；\n6. 在职业发展方面助力团队；\n7. 对团队有清晰的愿景和战略；\n8. 具备重要的技术技能，可为团队提供建议；\n\n* 让处于绩效分布底端的人了解真相，但是不要将绩效与薪酬或职业成果直接挂钩，尽可能用一种积极的方式警示并激励他们。\n","source":"_posts/“重新定义团队：谷歌如何工作”-读书笔记.md","raw":"---\ntitle: '“重新定义团队：谷歌如何工作” 读书笔记'\nintro: 《重新定义团队：谷歌如何工作》读书笔记（5/20）。最近花了一些时间来读《重新定义团队：谷歌如何工作》这本书，在这里记录一下书中提出的关键点。怎样才能发挥团队的最大效能，同时让团队中的成员保持高涨的激情，这些都是在团队管理中会经常遇到的问题。 \ncomments: true\ndate: 2019-01-14 14:14:00\ntags:\n- 读书\n- 创业\n---\n\n《重新定义团队：谷歌如何工作》读书笔记（5/20）。最近花了一些时间来读《重新定义团队：谷歌如何工作》这本书，在这里记录一下书中提出的关键点。怎样才能发挥团队的最大效能，同时让团队中的成员保持高涨的激情，这些都是在团队管理中会经常遇到的问题。 \n\n* 当员工信任领导层的时候，会达到企业的利益最大化；\n* 以谷歌为代表的管理方式，我们将其称作“高度自由”的方式，员工享有极大的自由。这将是未来的方向；\n* 这些全球精英希望在高度自由的企业中工作，而优秀人才都会流向此类企业。能够打造适宜的工作环境的领导者就像磁石一样，吸引着全球最优秀的人才；\n* 管理者的关注重点不是惩罚或奖励，而是清除路障，鼓励团队；\n* 员工所有制度；\n* 作为领导者要确保公司里的每个人都有良好的机遇，要让他们感觉到自己产生了有益的影响，为社会的向善贡献了力量；\n* 因为陈设是最显眼的，所以人们往往会根据人造物品陈设来阐释盛行的文化，但是价值观及其深层意义反而比陈设更加重要。即一个群体的文化可以用三种方式来了解：查看他们的“人造物品”（比如空间布置和陈设）、研究群体成员所信奉的信仰和价值观、深究这些价值观背后所反映的深刻意义；\n* **谷歌的使命**：“整合全球信息，使人人都能访问并从中受益”。在这个使命中没有言及利润或市场。没有言及顾客、股东或用户。没有言及为何选此作为公司使命，也未曾言及如何实现这些目标。这样的使命使个人的工作有了意义，因为它不是一种商业目标而是一种道德目标；\n* 地球上最有才华的人才需要能够激励人心的抱负。领导者所面临的挑战就是要创造出这样一个目标。即便是在谷歌，我们也发现并非所有人都感觉自己的工作与公司的使命有紧密联系；\n* 我们都希望自己的工作有意义，没有什么比知道自己正在改变世界能带来更强有力的激励作用；\n* 让员工与他们正在帮助的人见面是最有效的激励因素，即使会面只有几分钟。此举可为一个人的工作带来非凡的意义，胜过他们对职业生涯和金钱的渴求；\n* 发声的权利意味着给员工真正的话语权，决定公司如何运营。你需要决定是否相信员工，欢迎他们发表意见；\n* 聘用最优秀的人才，只聘用在某些特定的方面比你更优秀的人；四个招聘准则：设定高质量标准；寻找应聘者；客观地评估应聘者（请下级和同事参与其中，定期回忆员工面试记录与其工作表现）；给应聘者一个加入的理由。\n* **三种公司文化的基石**：使命、透明和发声的权利；\n* 成为公司的主人翁而非雇员，模糊等级概念，授权群众的第一步就是保证人们能够安全地发表意见；\n* 百分之一测试法；\n* **授权于员工**：消除地位象征，给予员工高期待，依靠数据而不是想法做决定；\n* 给予表现不佳（比如底部的5%）的员工以帮助，帮助他们解决在工作中遇到的问题，而非直接开除；\n* 优秀经理的特征：\n\n1. 做一名好导师；\n2. 给团队授权，不随便插手下属工作；\n3. 表达出对团队成员的成功和个人幸福的兴趣与关心；\n4. 高效/结果导向型；\n5. 善于沟通、聆听与分享信息；\n6. 在职业发展方面助力团队；\n7. 对团队有清晰的愿景和战略；\n8. 具备重要的技术技能，可为团队提供建议；\n\n* 让处于绩效分布底端的人了解真相，但是不要将绩效与薪酬或职业成果直接挂钩，尽可能用一种积极的方式警示并激励他们。\n","slug":"“重新定义团队：谷歌如何工作”-读书笔记","published":1,"updated":"2019-02-20T06:52:30.490Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtae004wknp2ir4fl57h","content":"<p>《重新定义团队：谷歌如何工作》读书笔记（5/20）。最近花了一些时间来读《重新定义团队：谷歌如何工作》这本书，在这里记录一下书中提出的关键点。怎样才能发挥团队的最大效能，同时让团队中的成员保持高涨的激情，这些都是在团队管理中会经常遇到的问题。 </p>\n<ul>\n<li>当员工信任领导层的时候，会达到企业的利益最大化；</li>\n<li>以谷歌为代表的管理方式，我们将其称作“高度自由”的方式，员工享有极大的自由。这将是未来的方向；</li>\n<li>这些全球精英希望在高度自由的企业中工作，而优秀人才都会流向此类企业。能够打造适宜的工作环境的领导者就像磁石一样，吸引着全球最优秀的人才；</li>\n<li>管理者的关注重点不是惩罚或奖励，而是清除路障，鼓励团队；</li>\n<li>员工所有制度；</li>\n<li>作为领导者要确保公司里的每个人都有良好的机遇，要让他们感觉到自己产生了有益的影响，为社会的向善贡献了力量；</li>\n<li>因为陈设是最显眼的，所以人们往往会根据人造物品陈设来阐释盛行的文化，但是价值观及其深层意义反而比陈设更加重要。即一个群体的文化可以用三种方式来了解：查看他们的“人造物品”（比如空间布置和陈设）、研究群体成员所信奉的信仰和价值观、深究这些价值观背后所反映的深刻意义；</li>\n<li><strong>谷歌的使命</strong>：“整合全球信息，使人人都能访问并从中受益”。在这个使命中没有言及利润或市场。没有言及顾客、股东或用户。没有言及为何选此作为公司使命，也未曾言及如何实现这些目标。这样的使命使个人的工作有了意义，因为它不是一种商业目标而是一种道德目标；</li>\n<li>地球上最有才华的人才需要能够激励人心的抱负。领导者所面临的挑战就是要创造出这样一个目标。即便是在谷歌，我们也发现并非所有人都感觉自己的工作与公司的使命有紧密联系；</li>\n<li>我们都希望自己的工作有意义，没有什么比知道自己正在改变世界能带来更强有力的激励作用；</li>\n<li>让员工与他们正在帮助的人见面是最有效的激励因素，即使会面只有几分钟。此举可为一个人的工作带来非凡的意义，胜过他们对职业生涯和金钱的渴求；</li>\n<li>发声的权利意味着给员工真正的话语权，决定公司如何运营。你需要决定是否相信员工，欢迎他们发表意见；</li>\n<li>聘用最优秀的人才，只聘用在某些特定的方面比你更优秀的人；四个招聘准则：设定高质量标准；寻找应聘者；客观地评估应聘者（请下级和同事参与其中，定期回忆员工面试记录与其工作表现）；给应聘者一个加入的理由。</li>\n<li><strong>三种公司文化的基石</strong>：使命、透明和发声的权利；</li>\n<li>成为公司的主人翁而非雇员，模糊等级概念，授权群众的第一步就是保证人们能够安全地发表意见；</li>\n<li>百分之一测试法；</li>\n<li><strong>授权于员工</strong>：消除地位象征，给予员工高期待，依靠数据而不是想法做决定；</li>\n<li>给予表现不佳（比如底部的5%）的员工以帮助，帮助他们解决在工作中遇到的问题，而非直接开除；</li>\n<li>优秀经理的特征：</li>\n</ul>\n<ol>\n<li>做一名好导师；</li>\n<li>给团队授权，不随便插手下属工作；</li>\n<li>表达出对团队成员的成功和个人幸福的兴趣与关心；</li>\n<li>高效/结果导向型；</li>\n<li>善于沟通、聆听与分享信息；</li>\n<li>在职业发展方面助力团队；</li>\n<li>对团队有清晰的愿景和战略；</li>\n<li>具备重要的技术技能，可为团队提供建议；</li>\n</ol>\n<ul>\n<li>让处于绩效分布底端的人了解真相，但是不要将绩效与薪酬或职业成果直接挂钩，尽可能用一种积极的方式警示并激励他们。</li>\n</ul>\n","site":{"data":{}},"id":"f90f06509e77a7f5feb3265dc521a8a8","excerpt":"","more":"<p>《重新定义团队：谷歌如何工作》读书笔记（5/20）。最近花了一些时间来读《重新定义团队：谷歌如何工作》这本书，在这里记录一下书中提出的关键点。怎样才能发挥团队的最大效能，同时让团队中的成员保持高涨的激情，这些都是在团队管理中会经常遇到的问题。 </p>\n<ul>\n<li>当员工信任领导层的时候，会达到企业的利益最大化；</li>\n<li>以谷歌为代表的管理方式，我们将其称作“高度自由”的方式，员工享有极大的自由。这将是未来的方向；</li>\n<li>这些全球精英希望在高度自由的企业中工作，而优秀人才都会流向此类企业。能够打造适宜的工作环境的领导者就像磁石一样，吸引着全球最优秀的人才；</li>\n<li>管理者的关注重点不是惩罚或奖励，而是清除路障，鼓励团队；</li>\n<li>员工所有制度；</li>\n<li>作为领导者要确保公司里的每个人都有良好的机遇，要让他们感觉到自己产生了有益的影响，为社会的向善贡献了力量；</li>\n<li>因为陈设是最显眼的，所以人们往往会根据人造物品陈设来阐释盛行的文化，但是价值观及其深层意义反而比陈设更加重要。即一个群体的文化可以用三种方式来了解：查看他们的“人造物品”（比如空间布置和陈设）、研究群体成员所信奉的信仰和价值观、深究这些价值观背后所反映的深刻意义；</li>\n<li><strong>谷歌的使命</strong>：“整合全球信息，使人人都能访问并从中受益”。在这个使命中没有言及利润或市场。没有言及顾客、股东或用户。没有言及为何选此作为公司使命，也未曾言及如何实现这些目标。这样的使命使个人的工作有了意义，因为它不是一种商业目标而是一种道德目标；</li>\n<li>地球上最有才华的人才需要能够激励人心的抱负。领导者所面临的挑战就是要创造出这样一个目标。即便是在谷歌，我们也发现并非所有人都感觉自己的工作与公司的使命有紧密联系；</li>\n<li>我们都希望自己的工作有意义，没有什么比知道自己正在改变世界能带来更强有力的激励作用；</li>\n<li>让员工与他们正在帮助的人见面是最有效的激励因素，即使会面只有几分钟。此举可为一个人的工作带来非凡的意义，胜过他们对职业生涯和金钱的渴求；</li>\n<li>发声的权利意味着给员工真正的话语权，决定公司如何运营。你需要决定是否相信员工，欢迎他们发表意见；</li>\n<li>聘用最优秀的人才，只聘用在某些特定的方面比你更优秀的人；四个招聘准则：设定高质量标准；寻找应聘者；客观地评估应聘者（请下级和同事参与其中，定期回忆员工面试记录与其工作表现）；给应聘者一个加入的理由。</li>\n<li><strong>三种公司文化的基石</strong>：使命、透明和发声的权利；</li>\n<li>成为公司的主人翁而非雇员，模糊等级概念，授权群众的第一步就是保证人们能够安全地发表意见；</li>\n<li>百分之一测试法；</li>\n<li><strong>授权于员工</strong>：消除地位象征，给予员工高期待，依靠数据而不是想法做决定；</li>\n<li>给予表现不佳（比如底部的5%）的员工以帮助，帮助他们解决在工作中遇到的问题，而非直接开除；</li>\n<li>优秀经理的特征：</li>\n</ul>\n<ol>\n<li>做一名好导师；</li>\n<li>给团队授权，不随便插手下属工作；</li>\n<li>表达出对团队成员的成功和个人幸福的兴趣与关心；</li>\n<li>高效/结果导向型；</li>\n<li>善于沟通、聆听与分享信息；</li>\n<li>在职业发展方面助力团队；</li>\n<li>对团队有清晰的愿景和战略；</li>\n<li>具备重要的技术技能，可为团队提供建议；</li>\n</ol>\n<ul>\n<li>让处于绩效分布底端的人了解真相，但是不要将绩效与薪酬或职业成果直接挂钩，尽可能用一种积极的方式警示并激励他们。</li>\n</ul>\n"},{"title":"“阿米巴经营” 读书笔记","intro":"《阿米巴经营》读书笔记（4/20）。这里记录了一些在读书过程中提炼出我觉得有价值的观点，仅供参考。","comments":1,"date":"2019-01-08T14:09:47.000Z","_content":"\n#### 一、总结与感想：\n\n《阿米巴经营》读书笔记（4/20）。这里记录了一些在读书过程中提炼出我觉得有价值的观点，仅供参考。 \n\n其实刚开始读第一章的时候，就能够感受到日本企业家那种用“爱”来驱动企业发展的力量。同7-11便利店的发展类似，稻盛和夫认为应在追求全体员工物质与精神两方面幸福的同时，再为人类和社会的进步与发展做出贡献。这里从侧面来看，我们也能够体会到日本社会企业与员工之间的“强绑定”关系（比如受到松下幸之助提出的“终身雇佣制”以及古老的“家臣”文化等影响）。 \n\n“阿米巴经营”的理念一共包含三个原则，即：独立核算、独立完成任务以及设定能够贯彻公司整体的目标和方针。前两个原则“独立核算”与“独立完成任务”可以理解为将大的组织划分为若干个小单元（阿米巴），每个单元采用独立的核算制度，并把单元的经营权下放给“阿米巴”领导，进而培养企业员工的经营者意识。而第三个原则“贯穿公司整体的目标和方针”则可以确保实现全体员工共同参与经营的目的。 \n\n实力主义 VS 成果主义：实力主义讲求的是以个人能力为主，不讲求其背景与工作年限，让有能力的人来担任领导；相反的，成果主义是指将个人工作成果直接与薪酬挂钩，采取激发员工物欲的方法来推进业绩增长。人的心理是很不可思议的，一旦业绩提升并拿到高额报酬后，就会在无意中习以为常，这也是成果主义的常见问题。“阿米巴经营”通过削减各职级间的报酬差距来降低日本同质化民族人民的抵触心理，相反它会通过在加薪、嘉奖和晋升等待遇中将个人为公司带来的业绩反应出来。 \n\n#### 二、几点记录：\n\n* **经营的原理和原则**：追求销售额最大化和经费最小化； \n","source":"_posts/“阿米巴经营”-读书笔记.md","raw":"---\ntitle: “阿米巴经营” 读书笔记\nintro: 《阿米巴经营》读书笔记（4/20）。这里记录了一些在读书过程中提炼出我觉得有价值的观点，仅供参考。 \ncomments: true\ndate: 2019-01-08 22:09:47\ntags:\n- 读书\n- 经营\n---\n\n#### 一、总结与感想：\n\n《阿米巴经营》读书笔记（4/20）。这里记录了一些在读书过程中提炼出我觉得有价值的观点，仅供参考。 \n\n其实刚开始读第一章的时候，就能够感受到日本企业家那种用“爱”来驱动企业发展的力量。同7-11便利店的发展类似，稻盛和夫认为应在追求全体员工物质与精神两方面幸福的同时，再为人类和社会的进步与发展做出贡献。这里从侧面来看，我们也能够体会到日本社会企业与员工之间的“强绑定”关系（比如受到松下幸之助提出的“终身雇佣制”以及古老的“家臣”文化等影响）。 \n\n“阿米巴经营”的理念一共包含三个原则，即：独立核算、独立完成任务以及设定能够贯彻公司整体的目标和方针。前两个原则“独立核算”与“独立完成任务”可以理解为将大的组织划分为若干个小单元（阿米巴），每个单元采用独立的核算制度，并把单元的经营权下放给“阿米巴”领导，进而培养企业员工的经营者意识。而第三个原则“贯穿公司整体的目标和方针”则可以确保实现全体员工共同参与经营的目的。 \n\n实力主义 VS 成果主义：实力主义讲求的是以个人能力为主，不讲求其背景与工作年限，让有能力的人来担任领导；相反的，成果主义是指将个人工作成果直接与薪酬挂钩，采取激发员工物欲的方法来推进业绩增长。人的心理是很不可思议的，一旦业绩提升并拿到高额报酬后，就会在无意中习以为常，这也是成果主义的常见问题。“阿米巴经营”通过削减各职级间的报酬差距来降低日本同质化民族人民的抵触心理，相反它会通过在加薪、嘉奖和晋升等待遇中将个人为公司带来的业绩反应出来。 \n\n#### 二、几点记录：\n\n* **经营的原理和原则**：追求销售额最大化和经费最小化； \n","slug":"“阿米巴经营”-读书笔记","published":1,"updated":"2019-02-20T06:52:45.869Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtaf004yknp2i442959q","content":"<h4 id=\"一、总结与感想：\"><a href=\"#一、总结与感想：\" class=\"headerlink\" title=\"一、总结与感想：\"></a>一、总结与感想：</h4><p>《阿米巴经营》读书笔记（4/20）。这里记录了一些在读书过程中提炼出我觉得有价值的观点，仅供参考。 </p>\n<p>其实刚开始读第一章的时候，就能够感受到日本企业家那种用“爱”来驱动企业发展的力量。同7-11便利店的发展类似，稻盛和夫认为应在追求全体员工物质与精神两方面幸福的同时，再为人类和社会的进步与发展做出贡献。这里从侧面来看，我们也能够体会到日本社会企业与员工之间的“强绑定”关系（比如受到松下幸之助提出的“终身雇佣制”以及古老的“家臣”文化等影响）。 </p>\n<p>“阿米巴经营”的理念一共包含三个原则，即：独立核算、独立完成任务以及设定能够贯彻公司整体的目标和方针。前两个原则“独立核算”与“独立完成任务”可以理解为将大的组织划分为若干个小单元（阿米巴），每个单元采用独立的核算制度，并把单元的经营权下放给“阿米巴”领导，进而培养企业员工的经营者意识。而第三个原则“贯穿公司整体的目标和方针”则可以确保实现全体员工共同参与经营的目的。 </p>\n<p>实力主义 VS 成果主义：实力主义讲求的是以个人能力为主，不讲求其背景与工作年限，让有能力的人来担任领导；相反的，成果主义是指将个人工作成果直接与薪酬挂钩，采取激发员工物欲的方法来推进业绩增长。人的心理是很不可思议的，一旦业绩提升并拿到高额报酬后，就会在无意中习以为常，这也是成果主义的常见问题。“阿米巴经营”通过削减各职级间的报酬差距来降低日本同质化民族人民的抵触心理，相反它会通过在加薪、嘉奖和晋升等待遇中将个人为公司带来的业绩反应出来。 </p>\n<h4 id=\"二、几点记录：\"><a href=\"#二、几点记录：\" class=\"headerlink\" title=\"二、几点记录：\"></a>二、几点记录：</h4><ul>\n<li><strong>经营的原理和原则</strong>：追求销售额最大化和经费最小化； </li>\n</ul>\n","site":{"data":{}},"id":"0ea3b0cc64466d1b51969bbbd76183b7","excerpt":"","more":"<h4 id=\"一、总结与感想：\"><a href=\"#一、总结与感想：\" class=\"headerlink\" title=\"一、总结与感想：\"></a>一、总结与感想：</h4><p>《阿米巴经营》读书笔记（4/20）。这里记录了一些在读书过程中提炼出我觉得有价值的观点，仅供参考。 </p>\n<p>其实刚开始读第一章的时候，就能够感受到日本企业家那种用“爱”来驱动企业发展的力量。同7-11便利店的发展类似，稻盛和夫认为应在追求全体员工物质与精神两方面幸福的同时，再为人类和社会的进步与发展做出贡献。这里从侧面来看，我们也能够体会到日本社会企业与员工之间的“强绑定”关系（比如受到松下幸之助提出的“终身雇佣制”以及古老的“家臣”文化等影响）。 </p>\n<p>“阿米巴经营”的理念一共包含三个原则，即：独立核算、独立完成任务以及设定能够贯彻公司整体的目标和方针。前两个原则“独立核算”与“独立完成任务”可以理解为将大的组织划分为若干个小单元（阿米巴），每个单元采用独立的核算制度，并把单元的经营权下放给“阿米巴”领导，进而培养企业员工的经营者意识。而第三个原则“贯穿公司整体的目标和方针”则可以确保实现全体员工共同参与经营的目的。 </p>\n<p>实力主义 VS 成果主义：实力主义讲求的是以个人能力为主，不讲求其背景与工作年限，让有能力的人来担任领导；相反的，成果主义是指将个人工作成果直接与薪酬挂钩，采取激发员工物欲的方法来推进业绩增长。人的心理是很不可思议的，一旦业绩提升并拿到高额报酬后，就会在无意中习以为常，这也是成果主义的常见问题。“阿米巴经营”通过削减各职级间的报酬差距来降低日本同质化民族人民的抵触心理，相反它会通过在加薪、嘉奖和晋升等待遇中将个人为公司带来的业绩反应出来。 </p>\n<h4 id=\"二、几点记录：\"><a href=\"#二、几点记录：\" class=\"headerlink\" title=\"二、几点记录：\"></a>二、几点记录：</h4><ul>\n<li><strong>经营的原理和原则</strong>：追求销售额最大化和经费最小化； </li>\n</ul>\n"},{"title":"jQuery 源码江湖 - 初入江湖","intro":"马上要元旦了，2016年有很多计划都没有完成。那么新的一年到了，有些计划是时候提到日程上来了。这第一件事就是要写一个《jQuery 源码江湖》系列。为什么要写 jQuery 呢？因为之前经常用到并且也看过很多书籍和文章，但他们对 jQuery 源码的整体分析都并不够清晰和深入。废话少说，今天开篇 - 初入江湖。","comments":1,"date":"2016-12-29T05:55:16.000Z","_content":"\n\n马上要元旦了，2016年有很多计划都没有完成。那么新的一年到了，有些计划是时候提到日程上来了。这第一件事就是要写一个《jQuery 源码江湖》系列。为什么要写 jQuery 呢？因为之前经常用到并且也看过很多书籍和文章，但他们对 jQuery 源码的整体分析都并不够清晰和深入。废话少说，今天开篇 - 初入江湖。\n\n本系列文章不会完整的阐述 jQuery 的基本用法，希望读者对 JavaScript 基础知识要有一定的了解。对原型链、词法作用域等有比较深刻的理解。本系列文章分析的 jQuery 源码版本为 “2.0.3” 版本，读者可以从 Github 上进行下载。由于我们在源代码上加入了一些注释信息，所以本文所展示代码的第一行行数为准确对应的源代码行数，第一行后的代码所对应的源代码行数可能由于加入了注释而并不与原代码的所在行一一对应。\n\n从整体上来看，jQuery 源码的整体被包裹在一个 IIFE 结构中，如下代码所示。这个 IIFE 结构保证了 jQuery 内部不会对全局的 window 环境造成污染，同时也对 jQuery 内部的属性、方法和结构进行了封装。源码开头的注释部分详细标识了该 jQuery 源码的版本、发布时间，以及内部使用 Sizzle 库（主要提供复杂选择器的功能）的相关信息。包裹 jQuery 的 IIFE 结构有两个形参：第一个是 `window`，另一个是 `undefined`。而传入的实参却只有一个 window 对象。**直接将 window 对象作为参数传入 IIFE 结构有两个目的：**\n\n**1. 可以缩短作用域链；**\n\n我们知道，在一个对象内部查找方法时会沿着作用域链逐层向上查找，直到查找到最顶端的 window 对象才会结束。而将 window 对象作为参数传入 IIFE 结构，可以使我们在使用 window 对象上的方法时只在 jQuery 内部的作用域进行查找即可，不用再回溯到最上层的 window 对象，使得查找 window 对象上属性和方法的效率得到提升；\n\n**2. 将 window 对象作为参数可以使 IIFE 内部使用的 window 对象标识符进行压缩，减少 jQuery 的代码量；**\n\n但为什么只传入一个实参，而另一个形参 undefined 没有其对应的实参被传入？这样就导致该形参所代表的值即为 JavaScript 的基本类型 undefined（未被赋值形参的值为 JS 原始值 undefined），这个 undefined 值会在 jQuery 内部做一些类型判断的用处。**为什么要这样做？**因为在一些低版本浏览器中，undefined 可以被更改为其他值。当然除此之外，我们也可以用 `var x = void 0;` 来获得一个原始的 undefined 值。\n\n\n```javascript\n/*!\n * jQuery JavaScript Library v2.0.3\n * http://jquery.com/\n *\n * Includes Sizzle.js\n * http://sizzlejs.com/\n *\n * Copyright 2005, 2013 jQuery Foundation, Inc. and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2013-07-03T13:30Z\n */\n\n// 以 IIFE 的方式将 window 对象传进匿名函数，可以缩短查找 window 对象方法属性的时间，同时也利于源代码的压缩；\n// JS 原始值 undefined 在低版本浏览器可以被修改赋值，所以这里以未赋值参数的形式来获取 JS 的原始 undefined 值；\n(function( window, undefined ) {\n\n    // 内部代码；\n\n})( window );\n```\n\n让我们来看看 IIFE 结构内部代码的第一段（一共可能会分成几百段来讲）如下所示。这里定义了一些在 jQuery 内部使用的变量，包括一些防止库冲突的检测变量. 一些 JS 原生对象的方法. 库版本号，还有对于 jQuery 跟文档对象的索引。我们可以深入来看下被注释掉的 `use strict;` 语句。通过在 jQuery 的 BUG 跟踪器里查询第 “#13335” 号 BUG，我们可以看到之所以这句话被注释掉，是因为 `use strict;` 语句在 Firefox 某些版本中会导致微软的一些 JS 库中的 AJAX 请求失败。\n\n\n```javascript\n// Can&#39;t do this because several apps including ASP.NET trace\n// the stack via arguments.caller.callee and Firefox dies if\n// you try to trace through \"use strict\" call chains. (#13335)\n// Support: Firefox 18+\n// 严格模式在老版本 Firefox 上会出现微软类库的 AJAX 请求失败的问题；\n//\"use strict\";\nvar\n    // A central reference to the root jQuery(document)\n    // 该变量等于 jQuery(document); 利于代码压缩，提高代码可读性；\n    rootjQuery,\n\n    // The deferred used on DOM ready \n    readyList,\n\n    // Support: IE9\n    // For `typeof xmlNode.method` instead of `xmlNode.method !== undefined`\n    // 存储 undefined 的字符串模式，由于低版本 IE 上的 xmlNode 类型需要通过 typeof 来检测；\n    core_strundefined = typeof undefined,\n\n    // Use the correct document accordingly with window argument (sandbox)\n    // 存储常用对象，利于代码压缩；\n    location = window.location,\n    document = window.document,\n    docElem = document.documentElement,\n\n    // 防止冲突，通过判断 _jQuery 和 _$ 是否为 undefined 来判断是否发生冲突；\n    // Map over jQuery in case of overwrite\n    _jQuery = window.jQuery,\n\n    // Map over the $ in case of overwrite\n    _$ = window.$,\n\n    // [[Class]] -> type pairs\n    // 主要用于 $.type() 方法，使用 Object.prototype.toString.call() 来检测变量类型；\n    class2type = {},\n\n    // List of deleted data cache ids, so we can reuse them\n    // 老版本与数据缓存有关 （该版本已无实际用途）；\n    core_deletedIds = [],\n\n    // 指定版本号\n    core_version = \"2.0.3\",\n\n    // Save a reference to some core methods\n    // 存储一些常用的数组方法；\n    core_concat = core_deletedIds.concat,\n    core_push = core_deletedIds.push,\n    core_slice = core_deletedIds.slice,\n    core_indexOf = core_deletedIds.indexOf,\n    // 存储 Object 对象的 toString 和 hasOwnProperty 方法；\n    core_toString = class2type.toString,\n    core_hasOwn = class2type.hasOwnProperty,\n    core_trim = core_version.trim,\n\n```\n\n我们暂时不需要将上述变量的用处全部弄懂，在后面的文章里当我们用到对应的变量时，会进行详细的讲解。接下来源代码的第 61 到 64 行，这里是 jQuery 的构造方法。也就是我们平时使用 jQuery 时所调用的构造方法，比如 `$()` 和 `jQuery()` 这两种常用的调用方式，这两者其实是等价的。在该构造方法里，jQuery 直接返回一个对象，使得我们可以直接进行接下来的链式操作，进而省去了实例化的过程。实际上，jQuery 内部真正的构造方法是其原型链上的 `jQuery.fn.init()` 方法，而 jQuery.fn 实际上就是 jQuery 的显式原型 jQuery.prototype。\n\n\n ```javascript\n// Define a local copy of jQuery\njQuery = function( selector, context ) {\n    // The jQuery object is actually just the init constructor &#39;enhanced&#39;\n\t\t\n    // 返回一个 jQuery 对象；\n    // jQuery.fn = jQuery.prototype;\n    // jQuery.fn.init.prototype = jQuery.fn (jQuery.prototype);\n    return new jQuery.fn.init( selector, context, rootjQuery );\n},\n```\n\n我们可以分别从如下所示源码的第 96 行和 283 行发现 jQuery 构造函数的整个结构，jQuery 为其内部的显式原型创建了一个别名 jQuery.fn，**别名的好处有两点：**\n\n1. 可以使查找原型链上方法和属性的时间减少；\n2. 利于代码的压缩。由于 jQuery 的初始化方法（构造方法）被放到在了原型上，因此为了使该对象可以继承 jQuery 原型上的方法，在第 283 行将 jQuery 的原型赋值给了 jQuery.fn.init 的原型；\n\n\n ```javascript\njQuery.fn = jQuery.prototype = {\n\t// The current version of jQuery being used\n```\n\n\n ```javascript\n// Give the init function the jQuery prototype for later instantiation\njQuery.fn.init.prototype = jQuery.fn;\n```\n\n在对 jQuery 构造函数结构有了大体印象之后我们接着该构造函数往下看。源码的第 66 行到 82 行为 jQuery 的核心正则表达式，这些正则用来匹配不同的标签和特定的结构，我们在后面的选择器匹配的部分可以看到。core_pnum 主用用来匹配各类数字，包括带有正负号. 科学记数法. 小数的各类数字，由于 core_pnum 一般并不单独使用，所以这里返回了正则的字符串表示；core_rnotwhite 很明显匹配了所有非空白字符；rquickExpr 匹配了严格闭合的 HTML 标签；rsingleTag 匹配了单独的空标签，比如 `<p>`；rmsPrefix 匹配了 IE 浏览器的 CSS 前缀“-ms-”；rdashAlpha 匹配了横线连接的字符串，这两者会联合起来使用，用来进行带有浏览器内核前缀的样式名的驼峰格式转换。\n\n\n ```javascript\n// Used for matching numbers\n// 匹配数字\ncore_pnum = /[+-]?(?:d*.|)d+(?:[eE][+-]?d+|)/.source,\n\n// Used for splitting on whitespace\n// 匹配非空白字符\ncore_rnotwhite = /S+/g,\n\n// A simple way to check for HTML strings\n// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n// Strict HTML recognition (#11290: must start with <)\n// 检测 selector 是否是复杂的 HTML 代码；\nrquickExpr = /^(?:s*(<[wW]+>)[^>]*|#([w-]*))$/,\n\n// Match a standalone tag\n// 匹配独立的空标签\nrsingleTag = /^<(w+)s*/?>(?:<!--1-->|)$/,\n\n// Matches dashed string for camelizing\n// 匹配浏览器前缀，-ms-marign-left -> MsMarginLeft\nrmsPrefix = /^-ms-/,\nrdashAlpha = /-([da-z])/gi,\n```\n\n接下来是两个内部函数 fcamelCase 和 completed。\n\nfcamelCase 主要用做 replace 函数的回调函数，结合第 552 行的 camelCase 函数我们可以看到，通过匹配 rmsPrefix 正则，首先会将一个类似于 “-ms-transform” 的带有 IE 内核前缀的样式属性标识符转换成 “ms-transform”，接下来通过匹配 rdashAlpha 正则和 fcamelCase 回调函数的替换规则，会把 “ms-transform” 最终转换成 msTransform，也就是转换成了一个 properity 属性的类型，比如这样调用时使用：`ele.style.msTransform`。\n\ncompleted 函数主要用于 jQuery 的 ready 事件，这个我们会在接下来的文章进行讲解。\n\n**深入：**通过查看 jQuery 的第 #9572 号 BUG 得知，这里之所以会为 IE 的样式标签进行单独处理，是由于微软在 IE 浏览器的带有浏览器内核前缀的样式进行 properity 转换时没有与其他浏览器达成统一。除 IE 外的所有主流浏览器都会将对应自己内核前缀的属性比如 “-moz-transform” 转换成大驼峰的写法即 “MozTransform” 应用在其 DOM 对象的 properity 里，而只有 IE 家族选择了小驼峰的写法，造成了这种尴尬的局面。\n\n\n ```javascript\n// Used by jQuery.camelCase as callback to replace()\nfcamelCase = function( all, letter ) {\n    return letter.toUpperCase();\n},\n\n// The ready event handler and self cleanup method\ncompleted = function() {\n    document.removeEventListener( \"DOMContentLoaded\", completed, false );\n    window.removeEventListener( \"load\", completed, false );\n    jQuery.ready();\n};\n```\n\n ```javascript\n// Convert dashed to camelCase; used by the css and data modules\n// Microsoft forgot to hump their vendor prefix (#9572)\ncamelCase: function( string ) {\n    return string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n},\n```","source":"_posts/jQuery-源码江湖-初入江湖.md","raw":"---\ntitle: jQuery 源码江湖 - 初入江湖\nintro: 马上要元旦了，2016年有很多计划都没有完成。那么新的一年到了，有些计划是时候提到日程上来了。这第一件事就是要写一个《jQuery 源码江湖》系列。为什么要写 jQuery 呢？因为之前经常用到并且也看过很多书籍和文章，但他们对 jQuery 源码的整体分析都并不够清晰和深入。废话少说，今天开篇 - 初入江湖。\ncomments: true\ndate: 2016-12-29 13:55:16\ntags:\n- JavaScript\n- jQuery\n---\n\n\n马上要元旦了，2016年有很多计划都没有完成。那么新的一年到了，有些计划是时候提到日程上来了。这第一件事就是要写一个《jQuery 源码江湖》系列。为什么要写 jQuery 呢？因为之前经常用到并且也看过很多书籍和文章，但他们对 jQuery 源码的整体分析都并不够清晰和深入。废话少说，今天开篇 - 初入江湖。\n\n本系列文章不会完整的阐述 jQuery 的基本用法，希望读者对 JavaScript 基础知识要有一定的了解。对原型链、词法作用域等有比较深刻的理解。本系列文章分析的 jQuery 源码版本为 “2.0.3” 版本，读者可以从 Github 上进行下载。由于我们在源代码上加入了一些注释信息，所以本文所展示代码的第一行行数为准确对应的源代码行数，第一行后的代码所对应的源代码行数可能由于加入了注释而并不与原代码的所在行一一对应。\n\n从整体上来看，jQuery 源码的整体被包裹在一个 IIFE 结构中，如下代码所示。这个 IIFE 结构保证了 jQuery 内部不会对全局的 window 环境造成污染，同时也对 jQuery 内部的属性、方法和结构进行了封装。源码开头的注释部分详细标识了该 jQuery 源码的版本、发布时间，以及内部使用 Sizzle 库（主要提供复杂选择器的功能）的相关信息。包裹 jQuery 的 IIFE 结构有两个形参：第一个是 `window`，另一个是 `undefined`。而传入的实参却只有一个 window 对象。**直接将 window 对象作为参数传入 IIFE 结构有两个目的：**\n\n**1. 可以缩短作用域链；**\n\n我们知道，在一个对象内部查找方法时会沿着作用域链逐层向上查找，直到查找到最顶端的 window 对象才会结束。而将 window 对象作为参数传入 IIFE 结构，可以使我们在使用 window 对象上的方法时只在 jQuery 内部的作用域进行查找即可，不用再回溯到最上层的 window 对象，使得查找 window 对象上属性和方法的效率得到提升；\n\n**2. 将 window 对象作为参数可以使 IIFE 内部使用的 window 对象标识符进行压缩，减少 jQuery 的代码量；**\n\n但为什么只传入一个实参，而另一个形参 undefined 没有其对应的实参被传入？这样就导致该形参所代表的值即为 JavaScript 的基本类型 undefined（未被赋值形参的值为 JS 原始值 undefined），这个 undefined 值会在 jQuery 内部做一些类型判断的用处。**为什么要这样做？**因为在一些低版本浏览器中，undefined 可以被更改为其他值。当然除此之外，我们也可以用 `var x = void 0;` 来获得一个原始的 undefined 值。\n\n\n```javascript\n/*!\n * jQuery JavaScript Library v2.0.3\n * http://jquery.com/\n *\n * Includes Sizzle.js\n * http://sizzlejs.com/\n *\n * Copyright 2005, 2013 jQuery Foundation, Inc. and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2013-07-03T13:30Z\n */\n\n// 以 IIFE 的方式将 window 对象传进匿名函数，可以缩短查找 window 对象方法属性的时间，同时也利于源代码的压缩；\n// JS 原始值 undefined 在低版本浏览器可以被修改赋值，所以这里以未赋值参数的形式来获取 JS 的原始 undefined 值；\n(function( window, undefined ) {\n\n    // 内部代码；\n\n})( window );\n```\n\n让我们来看看 IIFE 结构内部代码的第一段（一共可能会分成几百段来讲）如下所示。这里定义了一些在 jQuery 内部使用的变量，包括一些防止库冲突的检测变量. 一些 JS 原生对象的方法. 库版本号，还有对于 jQuery 跟文档对象的索引。我们可以深入来看下被注释掉的 `use strict;` 语句。通过在 jQuery 的 BUG 跟踪器里查询第 “#13335” 号 BUG，我们可以看到之所以这句话被注释掉，是因为 `use strict;` 语句在 Firefox 某些版本中会导致微软的一些 JS 库中的 AJAX 请求失败。\n\n\n```javascript\n// Can&#39;t do this because several apps including ASP.NET trace\n// the stack via arguments.caller.callee and Firefox dies if\n// you try to trace through \"use strict\" call chains. (#13335)\n// Support: Firefox 18+\n// 严格模式在老版本 Firefox 上会出现微软类库的 AJAX 请求失败的问题；\n//\"use strict\";\nvar\n    // A central reference to the root jQuery(document)\n    // 该变量等于 jQuery(document); 利于代码压缩，提高代码可读性；\n    rootjQuery,\n\n    // The deferred used on DOM ready \n    readyList,\n\n    // Support: IE9\n    // For `typeof xmlNode.method` instead of `xmlNode.method !== undefined`\n    // 存储 undefined 的字符串模式，由于低版本 IE 上的 xmlNode 类型需要通过 typeof 来检测；\n    core_strundefined = typeof undefined,\n\n    // Use the correct document accordingly with window argument (sandbox)\n    // 存储常用对象，利于代码压缩；\n    location = window.location,\n    document = window.document,\n    docElem = document.documentElement,\n\n    // 防止冲突，通过判断 _jQuery 和 _$ 是否为 undefined 来判断是否发生冲突；\n    // Map over jQuery in case of overwrite\n    _jQuery = window.jQuery,\n\n    // Map over the $ in case of overwrite\n    _$ = window.$,\n\n    // [[Class]] -> type pairs\n    // 主要用于 $.type() 方法，使用 Object.prototype.toString.call() 来检测变量类型；\n    class2type = {},\n\n    // List of deleted data cache ids, so we can reuse them\n    // 老版本与数据缓存有关 （该版本已无实际用途）；\n    core_deletedIds = [],\n\n    // 指定版本号\n    core_version = \"2.0.3\",\n\n    // Save a reference to some core methods\n    // 存储一些常用的数组方法；\n    core_concat = core_deletedIds.concat,\n    core_push = core_deletedIds.push,\n    core_slice = core_deletedIds.slice,\n    core_indexOf = core_deletedIds.indexOf,\n    // 存储 Object 对象的 toString 和 hasOwnProperty 方法；\n    core_toString = class2type.toString,\n    core_hasOwn = class2type.hasOwnProperty,\n    core_trim = core_version.trim,\n\n```\n\n我们暂时不需要将上述变量的用处全部弄懂，在后面的文章里当我们用到对应的变量时，会进行详细的讲解。接下来源代码的第 61 到 64 行，这里是 jQuery 的构造方法。也就是我们平时使用 jQuery 时所调用的构造方法，比如 `$()` 和 `jQuery()` 这两种常用的调用方式，这两者其实是等价的。在该构造方法里，jQuery 直接返回一个对象，使得我们可以直接进行接下来的链式操作，进而省去了实例化的过程。实际上，jQuery 内部真正的构造方法是其原型链上的 `jQuery.fn.init()` 方法，而 jQuery.fn 实际上就是 jQuery 的显式原型 jQuery.prototype。\n\n\n ```javascript\n// Define a local copy of jQuery\njQuery = function( selector, context ) {\n    // The jQuery object is actually just the init constructor &#39;enhanced&#39;\n\t\t\n    // 返回一个 jQuery 对象；\n    // jQuery.fn = jQuery.prototype;\n    // jQuery.fn.init.prototype = jQuery.fn (jQuery.prototype);\n    return new jQuery.fn.init( selector, context, rootjQuery );\n},\n```\n\n我们可以分别从如下所示源码的第 96 行和 283 行发现 jQuery 构造函数的整个结构，jQuery 为其内部的显式原型创建了一个别名 jQuery.fn，**别名的好处有两点：**\n\n1. 可以使查找原型链上方法和属性的时间减少；\n2. 利于代码的压缩。由于 jQuery 的初始化方法（构造方法）被放到在了原型上，因此为了使该对象可以继承 jQuery 原型上的方法，在第 283 行将 jQuery 的原型赋值给了 jQuery.fn.init 的原型；\n\n\n ```javascript\njQuery.fn = jQuery.prototype = {\n\t// The current version of jQuery being used\n```\n\n\n ```javascript\n// Give the init function the jQuery prototype for later instantiation\njQuery.fn.init.prototype = jQuery.fn;\n```\n\n在对 jQuery 构造函数结构有了大体印象之后我们接着该构造函数往下看。源码的第 66 行到 82 行为 jQuery 的核心正则表达式，这些正则用来匹配不同的标签和特定的结构，我们在后面的选择器匹配的部分可以看到。core_pnum 主用用来匹配各类数字，包括带有正负号. 科学记数法. 小数的各类数字，由于 core_pnum 一般并不单独使用，所以这里返回了正则的字符串表示；core_rnotwhite 很明显匹配了所有非空白字符；rquickExpr 匹配了严格闭合的 HTML 标签；rsingleTag 匹配了单独的空标签，比如 `<p>`；rmsPrefix 匹配了 IE 浏览器的 CSS 前缀“-ms-”；rdashAlpha 匹配了横线连接的字符串，这两者会联合起来使用，用来进行带有浏览器内核前缀的样式名的驼峰格式转换。\n\n\n ```javascript\n// Used for matching numbers\n// 匹配数字\ncore_pnum = /[+-]?(?:d*.|)d+(?:[eE][+-]?d+|)/.source,\n\n// Used for splitting on whitespace\n// 匹配非空白字符\ncore_rnotwhite = /S+/g,\n\n// A simple way to check for HTML strings\n// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n// Strict HTML recognition (#11290: must start with <)\n// 检测 selector 是否是复杂的 HTML 代码；\nrquickExpr = /^(?:s*(<[wW]+>)[^>]*|#([w-]*))$/,\n\n// Match a standalone tag\n// 匹配独立的空标签\nrsingleTag = /^<(w+)s*/?>(?:<!--1-->|)$/,\n\n// Matches dashed string for camelizing\n// 匹配浏览器前缀，-ms-marign-left -> MsMarginLeft\nrmsPrefix = /^-ms-/,\nrdashAlpha = /-([da-z])/gi,\n```\n\n接下来是两个内部函数 fcamelCase 和 completed。\n\nfcamelCase 主要用做 replace 函数的回调函数，结合第 552 行的 camelCase 函数我们可以看到，通过匹配 rmsPrefix 正则，首先会将一个类似于 “-ms-transform” 的带有 IE 内核前缀的样式属性标识符转换成 “ms-transform”，接下来通过匹配 rdashAlpha 正则和 fcamelCase 回调函数的替换规则，会把 “ms-transform” 最终转换成 msTransform，也就是转换成了一个 properity 属性的类型，比如这样调用时使用：`ele.style.msTransform`。\n\ncompleted 函数主要用于 jQuery 的 ready 事件，这个我们会在接下来的文章进行讲解。\n\n**深入：**通过查看 jQuery 的第 #9572 号 BUG 得知，这里之所以会为 IE 的样式标签进行单独处理，是由于微软在 IE 浏览器的带有浏览器内核前缀的样式进行 properity 转换时没有与其他浏览器达成统一。除 IE 外的所有主流浏览器都会将对应自己内核前缀的属性比如 “-moz-transform” 转换成大驼峰的写法即 “MozTransform” 应用在其 DOM 对象的 properity 里，而只有 IE 家族选择了小驼峰的写法，造成了这种尴尬的局面。\n\n\n ```javascript\n// Used by jQuery.camelCase as callback to replace()\nfcamelCase = function( all, letter ) {\n    return letter.toUpperCase();\n},\n\n// The ready event handler and self cleanup method\ncompleted = function() {\n    document.removeEventListener( \"DOMContentLoaded\", completed, false );\n    window.removeEventListener( \"load\", completed, false );\n    jQuery.ready();\n};\n```\n\n ```javascript\n// Convert dashed to camelCase; used by the css and data modules\n// Microsoft forgot to hump their vendor prefix (#9572)\ncamelCase: function( string ) {\n    return string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n},\n```","slug":"jQuery-源码江湖-初入江湖","published":1,"updated":"2019-02-12T05:24:36.917Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtag0051knp20ywc41kx","content":"<p>马上要元旦了，2016年有很多计划都没有完成。那么新的一年到了，有些计划是时候提到日程上来了。这第一件事就是要写一个《jQuery 源码江湖》系列。为什么要写 jQuery 呢？因为之前经常用到并且也看过很多书籍和文章，但他们对 jQuery 源码的整体分析都并不够清晰和深入。废话少说，今天开篇 - 初入江湖。</p>\n<p>本系列文章不会完整的阐述 jQuery 的基本用法，希望读者对 JavaScript 基础知识要有一定的了解。对原型链、词法作用域等有比较深刻的理解。本系列文章分析的 jQuery 源码版本为 “2.0.3” 版本，读者可以从 Github 上进行下载。由于我们在源代码上加入了一些注释信息，所以本文所展示代码的第一行行数为准确对应的源代码行数，第一行后的代码所对应的源代码行数可能由于加入了注释而并不与原代码的所在行一一对应。</p>\n<p>从整体上来看，jQuery 源码的整体被包裹在一个 IIFE 结构中，如下代码所示。这个 IIFE 结构保证了 jQuery 内部不会对全局的 window 环境造成污染，同时也对 jQuery 内部的属性、方法和结构进行了封装。源码开头的注释部分详细标识了该 jQuery 源码的版本、发布时间，以及内部使用 Sizzle 库（主要提供复杂选择器的功能）的相关信息。包裹 jQuery 的 IIFE 结构有两个形参：第一个是 <code>window</code>，另一个是 <code>undefined</code>。而传入的实参却只有一个 window 对象。<strong>直接将 window 对象作为参数传入 IIFE 结构有两个目的：</strong></p>\n<p><strong>1. 可以缩短作用域链；</strong></p>\n<p>我们知道，在一个对象内部查找方法时会沿着作用域链逐层向上查找，直到查找到最顶端的 window 对象才会结束。而将 window 对象作为参数传入 IIFE 结构，可以使我们在使用 window 对象上的方法时只在 jQuery 内部的作用域进行查找即可，不用再回溯到最上层的 window 对象，使得查找 window 对象上属性和方法的效率得到提升；</p>\n<p><strong>2. 将 window 对象作为参数可以使 IIFE 内部使用的 window 对象标识符进行压缩，减少 jQuery 的代码量；</strong></p>\n<p>但为什么只传入一个实参，而另一个形参 undefined 没有其对应的实参被传入？这样就导致该形参所代表的值即为 JavaScript 的基本类型 undefined（未被赋值形参的值为 JS 原始值 undefined），这个 undefined 值会在 jQuery 内部做一些类型判断的用处。<strong>为什么要这样做？</strong>因为在一些低版本浏览器中，undefined 可以被更改为其他值。当然除此之外，我们也可以用 <code>var x = void 0;</code> 来获得一个原始的 undefined 值。</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">/*!\n * jQuery JavaScript Library v2.0.3\n * http://jquery.com/\n *\n * Includes Sizzle.js\n * http://sizzlejs.com/\n *\n * Copyright 2005, 2013 jQuery Foundation, Inc. and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2013-07-03T13:30Z\n */</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 以 IIFE 的方式将 window 对象传进匿名函数，可以缩短查找 window 对象方法属性的时间，同时也利于源代码的压缩；</span>\n<span class=\"token comment\" spellcheck=\"true\">// JS 原始值 undefined 在低版本浏览器可以被修改赋值，所以这里以未赋值参数的形式来获取 JS 的原始 undefined 值；</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span> window<span class=\"token punctuation\">,</span> undefined <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 内部代码；</span>\n\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span> window <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>让我们来看看 IIFE 结构内部代码的第一段（一共可能会分成几百段来讲）如下所示。这里定义了一些在 jQuery 内部使用的变量，包括一些防止库冲突的检测变量. 一些 JS 原生对象的方法. 库版本号，还有对于 jQuery 跟文档对象的索引。我们可以深入来看下被注释掉的 <code>use strict;</code> 语句。通过在 jQuery 的 BUG 跟踪器里查询第 “#13335” 号 BUG，我们可以看到之所以这句话被注释掉，是因为 <code>use strict;</code> 语句在 Firefox 某些版本中会导致微软的一些 JS 库中的 AJAX 请求失败。</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">// Can&amp;#39;t do this because several apps including ASP.NET trace</span>\n<span class=\"token comment\" spellcheck=\"true\">// the stack via arguments.caller.callee and Firefox dies if</span>\n<span class=\"token comment\" spellcheck=\"true\">// you try to trace through \"use strict\" call chains. (#13335)</span>\n<span class=\"token comment\" spellcheck=\"true\">// Support: Firefox 18+</span>\n<span class=\"token comment\" spellcheck=\"true\">// 严格模式在老版本 Firefox 上会出现微软类库的 AJAX 请求失败的问题；</span>\n<span class=\"token comment\" spellcheck=\"true\">//\"use strict\";</span>\n<span class=\"token keyword\">var</span>\n    <span class=\"token comment\" spellcheck=\"true\">// A central reference to the root jQuery(document)</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 该变量等于 jQuery(document); 利于代码压缩，提高代码可读性；</span>\n    rootjQuery<span class=\"token punctuation\">,</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// The deferred used on DOM ready </span>\n    readyList<span class=\"token punctuation\">,</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Support: IE9</span>\n    <span class=\"token comment\" spellcheck=\"true\">// For `typeof xmlNode.method` instead of `xmlNode.method !== undefined`</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 存储 undefined 的字符串模式，由于低版本 IE 上的 xmlNode 类型需要通过 typeof 来检测；</span>\n    core_strundefined <span class=\"token operator\">=</span> <span class=\"token keyword\">typeof</span> undefined<span class=\"token punctuation\">,</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Use the correct document accordingly with window argument (sandbox)</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 存储常用对象，利于代码压缩；</span>\n    location <span class=\"token operator\">=</span> window<span class=\"token punctuation\">.</span>location<span class=\"token punctuation\">,</span>\n    document <span class=\"token operator\">=</span> window<span class=\"token punctuation\">.</span>document<span class=\"token punctuation\">,</span>\n    docElem <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span>documentElement<span class=\"token punctuation\">,</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 防止冲突，通过判断 _jQuery 和 _$ 是否为 undefined 来判断是否发生冲突；</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Map over jQuery in case of overwrite</span>\n    _jQuery <span class=\"token operator\">=</span> window<span class=\"token punctuation\">.</span>jQuery<span class=\"token punctuation\">,</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Map over the $ in case of overwrite</span>\n    _$ <span class=\"token operator\">=</span> window<span class=\"token punctuation\">.</span>$<span class=\"token punctuation\">,</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// [[Class]] -> type pairs</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 主要用于 $.type() 方法，使用 Object.prototype.toString.call() 来检测变量类型；</span>\n    class2type <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// List of deleted data cache ids, so we can reuse them</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 老版本与数据缓存有关 （该版本已无实际用途）；</span>\n    core_deletedIds <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 指定版本号</span>\n    core_version <span class=\"token operator\">=</span> <span class=\"token string\">\"2.0.3\"</span><span class=\"token punctuation\">,</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Save a reference to some core methods</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 存储一些常用的数组方法；</span>\n    core_concat <span class=\"token operator\">=</span> core_deletedIds<span class=\"token punctuation\">.</span>concat<span class=\"token punctuation\">,</span>\n    core_push <span class=\"token operator\">=</span> core_deletedIds<span class=\"token punctuation\">.</span>push<span class=\"token punctuation\">,</span>\n    core_slice <span class=\"token operator\">=</span> core_deletedIds<span class=\"token punctuation\">.</span>slice<span class=\"token punctuation\">,</span>\n    core_indexOf <span class=\"token operator\">=</span> core_deletedIds<span class=\"token punctuation\">.</span>indexOf<span class=\"token punctuation\">,</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 存储 Object 对象的 toString 和 hasOwnProperty 方法；</span>\n    core_toString <span class=\"token operator\">=</span> class2type<span class=\"token punctuation\">.</span>toString<span class=\"token punctuation\">,</span>\n    core_hasOwn <span class=\"token operator\">=</span> class2type<span class=\"token punctuation\">.</span>hasOwnProperty<span class=\"token punctuation\">,</span>\n    core_trim <span class=\"token operator\">=</span> core_version<span class=\"token punctuation\">.</span>trim<span class=\"token punctuation\">,</span>\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>我们暂时不需要将上述变量的用处全部弄懂，在后面的文章里当我们用到对应的变量时，会进行详细的讲解。接下来源代码的第 61 到 64 行，这里是 jQuery 的构造方法。也就是我们平时使用 jQuery 时所调用的构造方法，比如 <code>$()</code> 和 <code>jQuery()</code> 这两种常用的调用方式，这两者其实是等价的。在该构造方法里，jQuery 直接返回一个对象，使得我们可以直接进行接下来的链式操作，进而省去了实例化的过程。实际上，jQuery 内部真正的构造方法是其原型链上的 <code>jQuery.fn.init()</code> 方法，而 jQuery.fn 实际上就是 jQuery 的显式原型 jQuery.prototype。</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">// Define a local copy of jQuery</span>\njQuery <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span> selector<span class=\"token punctuation\">,</span> context <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// The jQuery object is actually just the init constructor &amp;#39;enhanced&amp;#39;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 返回一个 jQuery 对象；</span>\n    <span class=\"token comment\" spellcheck=\"true\">// jQuery.fn = jQuery.prototype;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// jQuery.fn.init.prototype = jQuery.fn (jQuery.prototype);</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">jQuery<span class=\"token punctuation\">.</span>fn<span class=\"token punctuation\">.</span>init</span><span class=\"token punctuation\">(</span> selector<span class=\"token punctuation\">,</span> context<span class=\"token punctuation\">,</span> rootjQuery <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>我们可以分别从如下所示源码的第 96 行和 283 行发现 jQuery 构造函数的整个结构，jQuery 为其内部的显式原型创建了一个别名 jQuery.fn，<strong>别名的好处有两点：</strong></p>\n<ol>\n<li>可以使查找原型链上方法和属性的时间减少；</li>\n<li>利于代码的压缩。由于 jQuery 的初始化方法（构造方法）被放到在了原型上，因此为了使该对象可以继承 jQuery 原型上的方法，在第 283 行将 jQuery 的原型赋值给了 jQuery.fn.init 的原型；</li>\n</ol>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\">jQuery<span class=\"token punctuation\">.</span>fn <span class=\"token operator\">=</span> jQuery<span class=\"token punctuation\">.</span>prototype <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// The current version of jQuery being used</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">// Give the init function the jQuery prototype for later instantiation</span>\njQuery<span class=\"token punctuation\">.</span>fn<span class=\"token punctuation\">.</span>init<span class=\"token punctuation\">.</span>prototype <span class=\"token operator\">=</span> jQuery<span class=\"token punctuation\">.</span>fn<span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>在对 jQuery 构造函数结构有了大体印象之后我们接着该构造函数往下看。源码的第 66 行到 82 行为 jQuery 的核心正则表达式，这些正则用来匹配不同的标签和特定的结构，我们在后面的选择器匹配的部分可以看到。core_pnum 主用用来匹配各类数字，包括带有正负号. 科学记数法. 小数的各类数字，由于 core_pnum 一般并不单独使用，所以这里返回了正则的字符串表示；core_rnotwhite 很明显匹配了所有非空白字符；rquickExpr 匹配了严格闭合的 HTML 标签；rsingleTag 匹配了单独的空标签，比如 <code>&lt;p&gt;</code>；rmsPrefix 匹配了 IE 浏览器的 CSS 前缀“-ms-”；rdashAlpha 匹配了横线连接的字符串，这两者会联合起来使用，用来进行带有浏览器内核前缀的样式名的驼峰格式转换。</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">// Used for matching numbers</span>\n<span class=\"token comment\" spellcheck=\"true\">// 匹配数字</span>\ncore_pnum <span class=\"token operator\">=</span> <span class=\"token regex\">/[+-]?(?:d*.|)d+(?:[eE][+-]?d+|)/</span><span class=\"token punctuation\">.</span>source<span class=\"token punctuation\">,</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// Used for splitting on whitespace</span>\n<span class=\"token comment\" spellcheck=\"true\">// 匹配非空白字符</span>\ncore_rnotwhite <span class=\"token operator\">=</span> <span class=\"token regex\">/S+/g</span><span class=\"token punctuation\">,</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// A simple way to check for HTML strings</span>\n<span class=\"token comment\" spellcheck=\"true\">// Prioritize #id over &lt;tag> to avoid XSS via location.hash (#9521)</span>\n<span class=\"token comment\" spellcheck=\"true\">// Strict HTML recognition (#11290: must start with &lt;)</span>\n<span class=\"token comment\" spellcheck=\"true\">// 检测 selector 是否是复杂的 HTML 代码；</span>\nrquickExpr <span class=\"token operator\">=</span> <span class=\"token regex\">/^(?:s*(&lt;[wW]+>)[^>]*|#([w-]*))$/</span><span class=\"token punctuation\">,</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// Match a standalone tag</span>\n<span class=\"token comment\" spellcheck=\"true\">// 匹配独立的空标签</span>\nrsingleTag <span class=\"token operator\">=</span> <span class=\"token operator\">/</span><span class=\"token operator\">^</span><span class=\"token operator\">&lt;</span><span class=\"token punctuation\">(</span>w<span class=\"token operator\">+</span><span class=\"token punctuation\">)</span>s<span class=\"token operator\">*</span><span class=\"token regex\">/?>(?:&lt;!--1-->|)$/</span><span class=\"token punctuation\">,</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// Matches dashed string for camelizing</span>\n<span class=\"token comment\" spellcheck=\"true\">// 匹配浏览器前缀，-ms-marign-left -> MsMarginLeft</span>\nrmsPrefix <span class=\"token operator\">=</span> <span class=\"token regex\">/^-ms-/</span><span class=\"token punctuation\">,</span>\nrdashAlpha <span class=\"token operator\">=</span> <span class=\"token regex\">/-([da-z])/gi</span><span class=\"token punctuation\">,</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>接下来是两个内部函数 fcamelCase 和 completed。</p>\n<p>fcamelCase 主要用做 replace 函数的回调函数，结合第 552 行的 camelCase 函数我们可以看到，通过匹配 rmsPrefix 正则，首先会将一个类似于 “-ms-transform” 的带有 IE 内核前缀的样式属性标识符转换成 “ms-transform”，接下来通过匹配 rdashAlpha 正则和 fcamelCase 回调函数的替换规则，会把 “ms-transform” 最终转换成 msTransform，也就是转换成了一个 properity 属性的类型，比如这样调用时使用：<code>ele.style.msTransform</code>。</p>\n<p>completed 函数主要用于 jQuery 的 ready 事件，这个我们会在接下来的文章进行讲解。</p>\n<p><strong>深入：</strong>通过查看 jQuery 的第 #9572 号 BUG 得知，这里之所以会为 IE 的样式标签进行单独处理，是由于微软在 IE 浏览器的带有浏览器内核前缀的样式进行 properity 转换时没有与其他浏览器达成统一。除 IE 外的所有主流浏览器都会将对应自己内核前缀的属性比如 “-moz-transform” 转换成大驼峰的写法即 “MozTransform” 应用在其 DOM 对象的 properity 里，而只有 IE 家族选择了小驼峰的写法，造成了这种尴尬的局面。</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">// Used by jQuery.camelCase as callback to replace()</span>\nfcamelCase <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span> all<span class=\"token punctuation\">,</span> letter <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> letter<span class=\"token punctuation\">.</span><span class=\"token function\">toUpperCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// The ready event handler and self cleanup method</span>\ncompleted <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    document<span class=\"token punctuation\">.</span><span class=\"token function\">removeEventListener</span><span class=\"token punctuation\">(</span> <span class=\"token string\">\"DOMContentLoaded\"</span><span class=\"token punctuation\">,</span> completed<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    window<span class=\"token punctuation\">.</span><span class=\"token function\">removeEventListener</span><span class=\"token punctuation\">(</span> <span class=\"token string\">\"load\"</span><span class=\"token punctuation\">,</span> completed<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    jQuery<span class=\"token punctuation\">.</span><span class=\"token function\">ready</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">// Convert dashed to camelCase; used by the css and data modules</span>\n<span class=\"token comment\" spellcheck=\"true\">// Microsoft forgot to hump their vendor prefix (#9572)</span>\ncamelCase<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span> string <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> string<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span> rmsPrefix<span class=\"token punctuation\">,</span> <span class=\"token string\">\"ms-\"</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span> rdashAlpha<span class=\"token punctuation\">,</span> fcamelCase <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"id":"e9b1dc89335ad895fbefbcffa767b488","excerpt":"","more":"<p>马上要元旦了，2016年有很多计划都没有完成。那么新的一年到了，有些计划是时候提到日程上来了。这第一件事就是要写一个《jQuery 源码江湖》系列。为什么要写 jQuery 呢？因为之前经常用到并且也看过很多书籍和文章，但他们对 jQuery 源码的整体分析都并不够清晰和深入。废话少说，今天开篇 - 初入江湖。</p>\n<p>本系列文章不会完整的阐述 jQuery 的基本用法，希望读者对 JavaScript 基础知识要有一定的了解。对原型链、词法作用域等有比较深刻的理解。本系列文章分析的 jQuery 源码版本为 “2.0.3” 版本，读者可以从 Github 上进行下载。由于我们在源代码上加入了一些注释信息，所以本文所展示代码的第一行行数为准确对应的源代码行数，第一行后的代码所对应的源代码行数可能由于加入了注释而并不与原代码的所在行一一对应。</p>\n<p>从整体上来看，jQuery 源码的整体被包裹在一个 IIFE 结构中，如下代码所示。这个 IIFE 结构保证了 jQuery 内部不会对全局的 window 环境造成污染，同时也对 jQuery 内部的属性、方法和结构进行了封装。源码开头的注释部分详细标识了该 jQuery 源码的版本、发布时间，以及内部使用 Sizzle 库（主要提供复杂选择器的功能）的相关信息。包裹 jQuery 的 IIFE 结构有两个形参：第一个是 <code>window</code>，另一个是 <code>undefined</code>。而传入的实参却只有一个 window 对象。<strong>直接将 window 对象作为参数传入 IIFE 结构有两个目的：</strong></p>\n<p><strong>1. 可以缩短作用域链；</strong></p>\n<p>我们知道，在一个对象内部查找方法时会沿着作用域链逐层向上查找，直到查找到最顶端的 window 对象才会结束。而将 window 对象作为参数传入 IIFE 结构，可以使我们在使用 window 对象上的方法时只在 jQuery 内部的作用域进行查找即可，不用再回溯到最上层的 window 对象，使得查找 window 对象上属性和方法的效率得到提升；</p>\n<p><strong>2. 将 window 对象作为参数可以使 IIFE 内部使用的 window 对象标识符进行压缩，减少 jQuery 的代码量；</strong></p>\n<p>但为什么只传入一个实参，而另一个形参 undefined 没有其对应的实参被传入？这样就导致该形参所代表的值即为 JavaScript 的基本类型 undefined（未被赋值形参的值为 JS 原始值 undefined），这个 undefined 值会在 jQuery 内部做一些类型判断的用处。<strong>为什么要这样做？</strong>因为在一些低版本浏览器中，undefined 可以被更改为其他值。当然除此之外，我们也可以用 <code>var x = void 0;</code> 来获得一个原始的 undefined 值。</p>\n<pre><code class=\"javascript\">/*!\n * jQuery JavaScript Library v2.0.3\n * http://jquery.com/\n *\n * Includes Sizzle.js\n * http://sizzlejs.com/\n *\n * Copyright 2005, 2013 jQuery Foundation, Inc. and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2013-07-03T13:30Z\n */\n\n// 以 IIFE 的方式将 window 对象传进匿名函数，可以缩短查找 window 对象方法属性的时间，同时也利于源代码的压缩；\n// JS 原始值 undefined 在低版本浏览器可以被修改赋值，所以这里以未赋值参数的形式来获取 JS 的原始 undefined 值；\n(function( window, undefined ) {\n\n    // 内部代码；\n\n})( window );\n</code></pre>\n<p>让我们来看看 IIFE 结构内部代码的第一段（一共可能会分成几百段来讲）如下所示。这里定义了一些在 jQuery 内部使用的变量，包括一些防止库冲突的检测变量. 一些 JS 原生对象的方法. 库版本号，还有对于 jQuery 跟文档对象的索引。我们可以深入来看下被注释掉的 <code>use strict;</code> 语句。通过在 jQuery 的 BUG 跟踪器里查询第 “#13335” 号 BUG，我们可以看到之所以这句话被注释掉，是因为 <code>use strict;</code> 语句在 Firefox 某些版本中会导致微软的一些 JS 库中的 AJAX 请求失败。</p>\n<pre><code class=\"javascript\">// Can&amp;#39;t do this because several apps including ASP.NET trace\n// the stack via arguments.caller.callee and Firefox dies if\n// you try to trace through &quot;use strict&quot; call chains. (#13335)\n// Support: Firefox 18+\n// 严格模式在老版本 Firefox 上会出现微软类库的 AJAX 请求失败的问题；\n//&quot;use strict&quot;;\nvar\n    // A central reference to the root jQuery(document)\n    // 该变量等于 jQuery(document); 利于代码压缩，提高代码可读性；\n    rootjQuery,\n\n    // The deferred used on DOM ready \n    readyList,\n\n    // Support: IE9\n    // For `typeof xmlNode.method` instead of `xmlNode.method !== undefined`\n    // 存储 undefined 的字符串模式，由于低版本 IE 上的 xmlNode 类型需要通过 typeof 来检测；\n    core_strundefined = typeof undefined,\n\n    // Use the correct document accordingly with window argument (sandbox)\n    // 存储常用对象，利于代码压缩；\n    location = window.location,\n    document = window.document,\n    docElem = document.documentElement,\n\n    // 防止冲突，通过判断 _jQuery 和 _$ 是否为 undefined 来判断是否发生冲突；\n    // Map over jQuery in case of overwrite\n    _jQuery = window.jQuery,\n\n    // Map over the $ in case of overwrite\n    _$ = window.$,\n\n    // [[Class]] -&gt; type pairs\n    // 主要用于 $.type() 方法，使用 Object.prototype.toString.call() 来检测变量类型；\n    class2type = {},\n\n    // List of deleted data cache ids, so we can reuse them\n    // 老版本与数据缓存有关 （该版本已无实际用途）；\n    core_deletedIds = [],\n\n    // 指定版本号\n    core_version = &quot;2.0.3&quot;,\n\n    // Save a reference to some core methods\n    // 存储一些常用的数组方法；\n    core_concat = core_deletedIds.concat,\n    core_push = core_deletedIds.push,\n    core_slice = core_deletedIds.slice,\n    core_indexOf = core_deletedIds.indexOf,\n    // 存储 Object 对象的 toString 和 hasOwnProperty 方法；\n    core_toString = class2type.toString,\n    core_hasOwn = class2type.hasOwnProperty,\n    core_trim = core_version.trim,\n\n</code></pre>\n<p>我们暂时不需要将上述变量的用处全部弄懂，在后面的文章里当我们用到对应的变量时，会进行详细的讲解。接下来源代码的第 61 到 64 行，这里是 jQuery 的构造方法。也就是我们平时使用 jQuery 时所调用的构造方法，比如 <code>$()</code> 和 <code>jQuery()</code> 这两种常用的调用方式，这两者其实是等价的。在该构造方法里，jQuery 直接返回一个对象，使得我们可以直接进行接下来的链式操作，进而省去了实例化的过程。实际上，jQuery 内部真正的构造方法是其原型链上的 <code>jQuery.fn.init()</code> 方法，而 jQuery.fn 实际上就是 jQuery 的显式原型 jQuery.prototype。</p>\n<pre><code class=\"javascript\">// Define a local copy of jQuery\njQuery = function( selector, context ) {\n    // The jQuery object is actually just the init constructor &amp;#39;enhanced&amp;#39;\n\n    // 返回一个 jQuery 对象；\n    // jQuery.fn = jQuery.prototype;\n    // jQuery.fn.init.prototype = jQuery.fn (jQuery.prototype);\n    return new jQuery.fn.init( selector, context, rootjQuery );\n},\n</code></pre>\n<p>我们可以分别从如下所示源码的第 96 行和 283 行发现 jQuery 构造函数的整个结构，jQuery 为其内部的显式原型创建了一个别名 jQuery.fn，<strong>别名的好处有两点：</strong></p>\n<ol>\n<li>可以使查找原型链上方法和属性的时间减少；</li>\n<li>利于代码的压缩。由于 jQuery 的初始化方法（构造方法）被放到在了原型上，因此为了使该对象可以继承 jQuery 原型上的方法，在第 283 行将 jQuery 的原型赋值给了 jQuery.fn.init 的原型；</li>\n</ol>\n<pre><code class=\"javascript\">jQuery.fn = jQuery.prototype = {\n    // The current version of jQuery being used\n</code></pre>\n<pre><code class=\"javascript\">// Give the init function the jQuery prototype for later instantiation\njQuery.fn.init.prototype = jQuery.fn;\n</code></pre>\n<p>在对 jQuery 构造函数结构有了大体印象之后我们接着该构造函数往下看。源码的第 66 行到 82 行为 jQuery 的核心正则表达式，这些正则用来匹配不同的标签和特定的结构，我们在后面的选择器匹配的部分可以看到。core_pnum 主用用来匹配各类数字，包括带有正负号. 科学记数法. 小数的各类数字，由于 core_pnum 一般并不单独使用，所以这里返回了正则的字符串表示；core_rnotwhite 很明显匹配了所有非空白字符；rquickExpr 匹配了严格闭合的 HTML 标签；rsingleTag 匹配了单独的空标签，比如 <code>&lt;p&gt;</code>；rmsPrefix 匹配了 IE 浏览器的 CSS 前缀“-ms-”；rdashAlpha 匹配了横线连接的字符串，这两者会联合起来使用，用来进行带有浏览器内核前缀的样式名的驼峰格式转换。</p>\n<pre><code class=\"javascript\">// Used for matching numbers\n// 匹配数字\ncore_pnum = /[+-]?(?:d*.|)d+(?:[eE][+-]?d+|)/.source,\n\n// Used for splitting on whitespace\n// 匹配非空白字符\ncore_rnotwhite = /S+/g,\n\n// A simple way to check for HTML strings\n// Prioritize #id over &lt;tag&gt; to avoid XSS via location.hash (#9521)\n// Strict HTML recognition (#11290: must start with &lt;)\n// 检测 selector 是否是复杂的 HTML 代码；\nrquickExpr = /^(?:s*(&lt;[wW]+&gt;)[^&gt;]*|#([w-]*))$/,\n\n// Match a standalone tag\n// 匹配独立的空标签\nrsingleTag = /^&lt;(w+)s*/?&gt;(?:&lt;!--1--&gt;|)$/,\n\n// Matches dashed string for camelizing\n// 匹配浏览器前缀，-ms-marign-left -&gt; MsMarginLeft\nrmsPrefix = /^-ms-/,\nrdashAlpha = /-([da-z])/gi,\n</code></pre>\n<p>接下来是两个内部函数 fcamelCase 和 completed。</p>\n<p>fcamelCase 主要用做 replace 函数的回调函数，结合第 552 行的 camelCase 函数我们可以看到，通过匹配 rmsPrefix 正则，首先会将一个类似于 “-ms-transform” 的带有 IE 内核前缀的样式属性标识符转换成 “ms-transform”，接下来通过匹配 rdashAlpha 正则和 fcamelCase 回调函数的替换规则，会把 “ms-transform” 最终转换成 msTransform，也就是转换成了一个 properity 属性的类型，比如这样调用时使用：<code>ele.style.msTransform</code>。</p>\n<p>completed 函数主要用于 jQuery 的 ready 事件，这个我们会在接下来的文章进行讲解。</p>\n<p><strong>深入：</strong>通过查看 jQuery 的第 #9572 号 BUG 得知，这里之所以会为 IE 的样式标签进行单独处理，是由于微软在 IE 浏览器的带有浏览器内核前缀的样式进行 properity 转换时没有与其他浏览器达成统一。除 IE 外的所有主流浏览器都会将对应自己内核前缀的属性比如 “-moz-transform” 转换成大驼峰的写法即 “MozTransform” 应用在其 DOM 对象的 properity 里，而只有 IE 家族选择了小驼峰的写法，造成了这种尴尬的局面。</p>\n<pre><code class=\"javascript\">// Used by jQuery.camelCase as callback to replace()\nfcamelCase = function( all, letter ) {\n    return letter.toUpperCase();\n},\n\n// The ready event handler and self cleanup method\ncompleted = function() {\n    document.removeEventListener( &quot;DOMContentLoaded&quot;, completed, false );\n    window.removeEventListener( &quot;load&quot;, completed, false );\n    jQuery.ready();\n};\n</code></pre>\n<pre><code class=\"javascript\">// Convert dashed to camelCase; used by the css and data modules\n// Microsoft forgot to hump their vendor prefix (#9572)\ncamelCase: function( string ) {\n    return string.replace( rmsPrefix, &quot;ms-&quot; ).replace( rdashAlpha, fcamelCase );\n},\n</code></pre>\n"},{"title":"“零售的哲学” 读书笔记","intro":"《零售的哲学》读书笔记（3/20）。这里记录了一些在读书过程中提炼出我觉得有价值的观点，仅供参考。读下来铃木先生以其自身的经历为线索介绍了7-11这40年来发展的重点历程。整个创业经验总结出一句话就是“以人为本，学会改变”。相信这样的态度可以让冰冷的“商业”与消费者走的更近，从而获得用户的信任和支持。但这样的创业信条是否适用于处在发展中国家的我们呢？这还是个疑问，持保留态度。","comments":1,"date":"2019-01-07T02:46:25.000Z","_content":"\n#### 一、总结与感想：\n\n《零售的哲学》读书笔记（3/20）。这里记录了一些在读书过程中提炼出我觉得有价值的观点，仅供参考。读下来铃木先生以其自身的经历为线索介绍了7-11这40年来发展的重点历程。整个创业经验总结出一句话就是“以人为本，学会改变”。相信这样的态度可以让冰冷的“商业”与消费者走的更近，从而获得用户的信任和支持。但这样的创业信条是否适用于处在发展中国家的我们呢？这还是个疑问，持保留态度。 \n\n通读下来，7&I（后来在收购7-11美国”分部“后成立的母公司）在日本这种发达社会的整体发展路径与发展中国家其实是完全不同的。日本作为发达社会相较发展中国家其人口流动并没有那么频繁（或者说日本本土居民的贫富差距较小，从小城市往大城市迁移的现象没有那么严重），以“片”来布局的便利店可以很好地融入当地居民的生活当中，成为其日常生活中必不可少的一部分。而7&I在发展过程中也秉承着“用心”和“品质至上”的观念，比如其并不会由于员工冗余（比如每个便利店都有专门负责配送服务的驻点员工）所增加的成本而去刻意降低用户的购物体验。其他细节比如：便利店内的膳食从营养和健康的方面考虑，而不会去压榨成本偷工减料（当然消费者也会对适当增加的售价买单）、主动了解消费者的需求使便利店更加“便利”等等。总的来说，不惜一切代价提升用户体验和人文情怀（地震救援）所带来的边际成本可以完全被消费者接受，而且还能进一步拉近与消费者之间的关系。让两者的关系从“生产者-消费者”变成了“伙伴”。 \n\n但反观国内市场，一线城市人口流动频繁，人浮于事，无暇顾及人和便利店之间的“亲切感”，而可能更多地去关注商品的价格。并且国内诸如全家等便利店都是采用“员工轮班制“，驻店人员很少甚至没有冗余，因此也无法满足“员工配送”的要求。如果按照精益创业的规则，职能细分才能更好的提效，但这与书中所说的亲切感又相互违背。而这可能就是发展中国家（追求效率和利益最大）和发达国家（追求商业和人之间的关系最融洽，以人为本）的区别了。如果再仔细思考，可以发现其实7-11所作出的”精细“并不是指行业上的细分，而是在统筹所有相关行业（物流、供应链、店铺等）时，对用户需求的调研上进行的”精细“，精打细算每样商品的销量、推测大部分消费者最喜爱的口味，进而推陈出新。 \n\n另一方面，7&I在日本经济不景气的时候也同样度过了难关，总体来说靠的是对消费者需求的严格把控。所谓经济不景气一般表面上看是由于实体经济产能过剩而需求不足，进而导致裁员和失业。但需求不足又是什么原因导致的呢？对于便利店这种销售刚需产品（食品用品）的零售行业来说应该是没什么太大影响。即人们将目光更多的从溢出价值（钻石、奢侈品）转移到了实用价值上。 \n\n截止2018年初的相关统计数据表明，在罗森、全家等各类便利店品牌不断涌出和布局的同时，7-11仍然以39%的市场占有率遥遥领先。由于90年代初的日本经济大萧条，导致日本经济在后来的20年里几乎停滞，直至10年初期才开始缓慢增长，但在此期间，日本便利店的数量却一直在保持着正增长。随着铃木先生16年辞职后，7-11在中国大陆的发展状态可能已经大不如从前。 \n\n\n#### 二、几点记录：\n\n* **利他谈判**：在谈判过程中站在对方立场思考，着眼于未来所能产生的利益，长远考虑； \n* **便利店的密集型选址**：一定区域内产生的品牌效应；大幅提升物流配送效率；广告集中投放的效果好，成本低； \n* **经营不是简单的数字游戏**：数字只是用来衡量企业发展规模的一种表达方式，并不是要追求的绝对目标； \n* **扁平化管理**：减少企业人员结构的“中间人”角色，以直接对接员工的方式来传达企业的理念以及发展方向。真正有实际产出的是底层的员工，而不是中间的职业经理人； \n","source":"_posts/“零售的哲学”-读书笔记.md","raw":"---\ntitle: “零售的哲学” 读书笔记\nintro: 《零售的哲学》读书笔记（3/20）。这里记录了一些在读书过程中提炼出我觉得有价值的观点，仅供参考。读下来铃木先生以其自身的经历为线索介绍了7-11这40年来发展的重点历程。整个创业经验总结出一句话就是“以人为本，学会改变”。相信这样的态度可以让冰冷的“商业”与消费者走的更近，从而获得用户的信任和支持。但这样的创业信条是否适用于处在发展中国家的我们呢？这还是个疑问，持保留态度。 \ncomments: true\ndate: 2019-01-07 10:46:25\ntags:\n- 读书\n- 创业\n---\n\n#### 一、总结与感想：\n\n《零售的哲学》读书笔记（3/20）。这里记录了一些在读书过程中提炼出我觉得有价值的观点，仅供参考。读下来铃木先生以其自身的经历为线索介绍了7-11这40年来发展的重点历程。整个创业经验总结出一句话就是“以人为本，学会改变”。相信这样的态度可以让冰冷的“商业”与消费者走的更近，从而获得用户的信任和支持。但这样的创业信条是否适用于处在发展中国家的我们呢？这还是个疑问，持保留态度。 \n\n通读下来，7&I（后来在收购7-11美国”分部“后成立的母公司）在日本这种发达社会的整体发展路径与发展中国家其实是完全不同的。日本作为发达社会相较发展中国家其人口流动并没有那么频繁（或者说日本本土居民的贫富差距较小，从小城市往大城市迁移的现象没有那么严重），以“片”来布局的便利店可以很好地融入当地居民的生活当中，成为其日常生活中必不可少的一部分。而7&I在发展过程中也秉承着“用心”和“品质至上”的观念，比如其并不会由于员工冗余（比如每个便利店都有专门负责配送服务的驻点员工）所增加的成本而去刻意降低用户的购物体验。其他细节比如：便利店内的膳食从营养和健康的方面考虑，而不会去压榨成本偷工减料（当然消费者也会对适当增加的售价买单）、主动了解消费者的需求使便利店更加“便利”等等。总的来说，不惜一切代价提升用户体验和人文情怀（地震救援）所带来的边际成本可以完全被消费者接受，而且还能进一步拉近与消费者之间的关系。让两者的关系从“生产者-消费者”变成了“伙伴”。 \n\n但反观国内市场，一线城市人口流动频繁，人浮于事，无暇顾及人和便利店之间的“亲切感”，而可能更多地去关注商品的价格。并且国内诸如全家等便利店都是采用“员工轮班制“，驻店人员很少甚至没有冗余，因此也无法满足“员工配送”的要求。如果按照精益创业的规则，职能细分才能更好的提效，但这与书中所说的亲切感又相互违背。而这可能就是发展中国家（追求效率和利益最大）和发达国家（追求商业和人之间的关系最融洽，以人为本）的区别了。如果再仔细思考，可以发现其实7-11所作出的”精细“并不是指行业上的细分，而是在统筹所有相关行业（物流、供应链、店铺等）时，对用户需求的调研上进行的”精细“，精打细算每样商品的销量、推测大部分消费者最喜爱的口味，进而推陈出新。 \n\n另一方面，7&I在日本经济不景气的时候也同样度过了难关，总体来说靠的是对消费者需求的严格把控。所谓经济不景气一般表面上看是由于实体经济产能过剩而需求不足，进而导致裁员和失业。但需求不足又是什么原因导致的呢？对于便利店这种销售刚需产品（食品用品）的零售行业来说应该是没什么太大影响。即人们将目光更多的从溢出价值（钻石、奢侈品）转移到了实用价值上。 \n\n截止2018年初的相关统计数据表明，在罗森、全家等各类便利店品牌不断涌出和布局的同时，7-11仍然以39%的市场占有率遥遥领先。由于90年代初的日本经济大萧条，导致日本经济在后来的20年里几乎停滞，直至10年初期才开始缓慢增长，但在此期间，日本便利店的数量却一直在保持着正增长。随着铃木先生16年辞职后，7-11在中国大陆的发展状态可能已经大不如从前。 \n\n\n#### 二、几点记录：\n\n* **利他谈判**：在谈判过程中站在对方立场思考，着眼于未来所能产生的利益，长远考虑； \n* **便利店的密集型选址**：一定区域内产生的品牌效应；大幅提升物流配送效率；广告集中投放的效果好，成本低； \n* **经营不是简单的数字游戏**：数字只是用来衡量企业发展规模的一种表达方式，并不是要追求的绝对目标； \n* **扁平化管理**：减少企业人员结构的“中间人”角色，以直接对接员工的方式来传达企业的理念以及发展方向。真正有实际产出的是底层的员工，而不是中间的职业经理人； \n","slug":"“零售的哲学”-读书笔记","published":1,"updated":"2019-02-20T06:52:41.058Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtah0052knp2q91r2nf2","content":"<h4 id=\"一、总结与感想：\"><a href=\"#一、总结与感想：\" class=\"headerlink\" title=\"一、总结与感想：\"></a>一、总结与感想：</h4><p>《零售的哲学》读书笔记（3/20）。这里记录了一些在读书过程中提炼出我觉得有价值的观点，仅供参考。读下来铃木先生以其自身的经历为线索介绍了7-11这40年来发展的重点历程。整个创业经验总结出一句话就是“以人为本，学会改变”。相信这样的态度可以让冰冷的“商业”与消费者走的更近，从而获得用户的信任和支持。但这样的创业信条是否适用于处在发展中国家的我们呢？这还是个疑问，持保留态度。 </p>\n<p>通读下来，7&amp;I（后来在收购7-11美国”分部“后成立的母公司）在日本这种发达社会的整体发展路径与发展中国家其实是完全不同的。日本作为发达社会相较发展中国家其人口流动并没有那么频繁（或者说日本本土居民的贫富差距较小，从小城市往大城市迁移的现象没有那么严重），以“片”来布局的便利店可以很好地融入当地居民的生活当中，成为其日常生活中必不可少的一部分。而7&amp;I在发展过程中也秉承着“用心”和“品质至上”的观念，比如其并不会由于员工冗余（比如每个便利店都有专门负责配送服务的驻点员工）所增加的成本而去刻意降低用户的购物体验。其他细节比如：便利店内的膳食从营养和健康的方面考虑，而不会去压榨成本偷工减料（当然消费者也会对适当增加的售价买单）、主动了解消费者的需求使便利店更加“便利”等等。总的来说，不惜一切代价提升用户体验和人文情怀（地震救援）所带来的边际成本可以完全被消费者接受，而且还能进一步拉近与消费者之间的关系。让两者的关系从“生产者-消费者”变成了“伙伴”。 </p>\n<p>但反观国内市场，一线城市人口流动频繁，人浮于事，无暇顾及人和便利店之间的“亲切感”，而可能更多地去关注商品的价格。并且国内诸如全家等便利店都是采用“员工轮班制“，驻店人员很少甚至没有冗余，因此也无法满足“员工配送”的要求。如果按照精益创业的规则，职能细分才能更好的提效，但这与书中所说的亲切感又相互违背。而这可能就是发展中国家（追求效率和利益最大）和发达国家（追求商业和人之间的关系最融洽，以人为本）的区别了。如果再仔细思考，可以发现其实7-11所作出的”精细“并不是指行业上的细分，而是在统筹所有相关行业（物流、供应链、店铺等）时，对用户需求的调研上进行的”精细“，精打细算每样商品的销量、推测大部分消费者最喜爱的口味，进而推陈出新。 </p>\n<p>另一方面，7&amp;I在日本经济不景气的时候也同样度过了难关，总体来说靠的是对消费者需求的严格把控。所谓经济不景气一般表面上看是由于实体经济产能过剩而需求不足，进而导致裁员和失业。但需求不足又是什么原因导致的呢？对于便利店这种销售刚需产品（食品用品）的零售行业来说应该是没什么太大影响。即人们将目光更多的从溢出价值（钻石、奢侈品）转移到了实用价值上。 </p>\n<p>截止2018年初的相关统计数据表明，在罗森、全家等各类便利店品牌不断涌出和布局的同时，7-11仍然以39%的市场占有率遥遥领先。由于90年代初的日本经济大萧条，导致日本经济在后来的20年里几乎停滞，直至10年初期才开始缓慢增长，但在此期间，日本便利店的数量却一直在保持着正增长。随着铃木先生16年辞职后，7-11在中国大陆的发展状态可能已经大不如从前。 </p>\n<h4 id=\"二、几点记录：\"><a href=\"#二、几点记录：\" class=\"headerlink\" title=\"二、几点记录：\"></a>二、几点记录：</h4><ul>\n<li><strong>利他谈判</strong>：在谈判过程中站在对方立场思考，着眼于未来所能产生的利益，长远考虑； </li>\n<li><strong>便利店的密集型选址</strong>：一定区域内产生的品牌效应；大幅提升物流配送效率；广告集中投放的效果好，成本低； </li>\n<li><strong>经营不是简单的数字游戏</strong>：数字只是用来衡量企业发展规模的一种表达方式，并不是要追求的绝对目标； </li>\n<li><strong>扁平化管理</strong>：减少企业人员结构的“中间人”角色，以直接对接员工的方式来传达企业的理念以及发展方向。真正有实际产出的是底层的员工，而不是中间的职业经理人； </li>\n</ul>\n","site":{"data":{}},"id":"2696cc6edd0311182273ecdd9e9a7f5e","excerpt":"","more":"<h4 id=\"一、总结与感想：\"><a href=\"#一、总结与感想：\" class=\"headerlink\" title=\"一、总结与感想：\"></a>一、总结与感想：</h4><p>《零售的哲学》读书笔记（3/20）。这里记录了一些在读书过程中提炼出我觉得有价值的观点，仅供参考。读下来铃木先生以其自身的经历为线索介绍了7-11这40年来发展的重点历程。整个创业经验总结出一句话就是“以人为本，学会改变”。相信这样的态度可以让冰冷的“商业”与消费者走的更近，从而获得用户的信任和支持。但这样的创业信条是否适用于处在发展中国家的我们呢？这还是个疑问，持保留态度。 </p>\n<p>通读下来，7&amp;I（后来在收购7-11美国”分部“后成立的母公司）在日本这种发达社会的整体发展路径与发展中国家其实是完全不同的。日本作为发达社会相较发展中国家其人口流动并没有那么频繁（或者说日本本土居民的贫富差距较小，从小城市往大城市迁移的现象没有那么严重），以“片”来布局的便利店可以很好地融入当地居民的生活当中，成为其日常生活中必不可少的一部分。而7&amp;I在发展过程中也秉承着“用心”和“品质至上”的观念，比如其并不会由于员工冗余（比如每个便利店都有专门负责配送服务的驻点员工）所增加的成本而去刻意降低用户的购物体验。其他细节比如：便利店内的膳食从营养和健康的方面考虑，而不会去压榨成本偷工减料（当然消费者也会对适当增加的售价买单）、主动了解消费者的需求使便利店更加“便利”等等。总的来说，不惜一切代价提升用户体验和人文情怀（地震救援）所带来的边际成本可以完全被消费者接受，而且还能进一步拉近与消费者之间的关系。让两者的关系从“生产者-消费者”变成了“伙伴”。 </p>\n<p>但反观国内市场，一线城市人口流动频繁，人浮于事，无暇顾及人和便利店之间的“亲切感”，而可能更多地去关注商品的价格。并且国内诸如全家等便利店都是采用“员工轮班制“，驻店人员很少甚至没有冗余，因此也无法满足“员工配送”的要求。如果按照精益创业的规则，职能细分才能更好的提效，但这与书中所说的亲切感又相互违背。而这可能就是发展中国家（追求效率和利益最大）和发达国家（追求商业和人之间的关系最融洽，以人为本）的区别了。如果再仔细思考，可以发现其实7-11所作出的”精细“并不是指行业上的细分，而是在统筹所有相关行业（物流、供应链、店铺等）时，对用户需求的调研上进行的”精细“，精打细算每样商品的销量、推测大部分消费者最喜爱的口味，进而推陈出新。 </p>\n<p>另一方面，7&amp;I在日本经济不景气的时候也同样度过了难关，总体来说靠的是对消费者需求的严格把控。所谓经济不景气一般表面上看是由于实体经济产能过剩而需求不足，进而导致裁员和失业。但需求不足又是什么原因导致的呢？对于便利店这种销售刚需产品（食品用品）的零售行业来说应该是没什么太大影响。即人们将目光更多的从溢出价值（钻石、奢侈品）转移到了实用价值上。 </p>\n<p>截止2018年初的相关统计数据表明，在罗森、全家等各类便利店品牌不断涌出和布局的同时，7-11仍然以39%的市场占有率遥遥领先。由于90年代初的日本经济大萧条，导致日本经济在后来的20年里几乎停滞，直至10年初期才开始缓慢增长，但在此期间，日本便利店的数量却一直在保持着正增长。随着铃木先生16年辞职后，7-11在中国大陆的发展状态可能已经大不如从前。 </p>\n<h4 id=\"二、几点记录：\"><a href=\"#二、几点记录：\" class=\"headerlink\" title=\"二、几点记录：\"></a>二、几点记录：</h4><ul>\n<li><strong>利他谈判</strong>：在谈判过程中站在对方立场思考，着眼于未来所能产生的利益，长远考虑； </li>\n<li><strong>便利店的密集型选址</strong>：一定区域内产生的品牌效应；大幅提升物流配送效率；广告集中投放的效果好，成本低； </li>\n<li><strong>经营不是简单的数字游戏</strong>：数字只是用来衡量企业发展规模的一种表达方式，并不是要追求的绝对目标； </li>\n<li><strong>扁平化管理</strong>：减少企业人员结构的“中间人”角色，以直接对接员工的方式来传达企业的理念以及发展方向。真正有实际产出的是底层的员工，而不是中间的职业经理人； </li>\n</ul>\n"},{"title":"一种新的共享计算力模式","intro":"随着云计算、深度学习和区块链技术的发展与普及，人们对“计算力”的需求变得越来越迫切。大型公司可以通过横向扩展机房的形式来增加自己的“计算力”，但这种从物理上扩展机器的方式对一些初创的小公司来说可是一笔不小得开销负担。","comments":1,"date":"2017-09-30T07:59:42.000Z","_content":"\n随着云计算、深度学习和区块链技术的发展与普及，人们对“计算力”的需求变得越来越迫切。大型公司可以通过横向扩展机房的形式来增加自己的“计算力”，但这种从物理上扩展机器的方式对一些初创的小公司来说可是一笔不小得开销负担。\n\n其实在我们的身边还有一种大部分时间都在被浪费的计算力，而这些计算力便是来自于我们每个人都拥有的、生活中所必不可少的电子设备 - “个人电脑”，甚至是 - “智能手机”。这些智能设备在日常被使用的 90% 时间里都不会达到其 100% 的性能。相对的，如果我们能把这 90% 时间的闲置计算力使用起来，那会是一个十分强大的计算资源。\n\n下面给出了一个基础架构的拓扑图，架构的整体还是基于已经趋于成熟的大数据处理框架，唯一的不同是这个分布式系统只负责基本的“计算任务”调度，具体的“计算任务”处理过程全部放在 Client 端的浏览器进行。由于只需要基本的任务分配和调度，因此不需要集群过大的横向拓展，成本上来讲并不算很高。位于集群最底层的 Worker 负责将上层的任务通过 MapReduce 切分成不同的“子任务块”然后下放给客户端，客户端的计算结果与 Worker 之间是实时通信的。\n\n![](1.png)\n\n整个架构系统的难点在于，Worker 分配给 Client 端的任务并不是一定会被完全完成的，由于客户端的不确定性，对任务完成比率的校对会是一个比较棘手的问题。可以想到的方案是把“计算任务”分割成独立的小型任务，每次下放任务块时从**没有完成的任务块**中连续选择固定数量的任务块进行下放，如下图所示。\n\n![](2.png)\n\n如果最后服务化变成产品，对用户计算任务的定义还要再进行具体的设计。\n\n![](3.png)\n","source":"_posts/一种新的共享计算力模式.md","raw":"---\ntitle: 一种新的共享计算力模式\nintro: 随着云计算、深度学习和区块链技术的发展与普及，人们对“计算力”的需求变得越来越迫切。大型公司可以通过横向扩展机房的形式来增加自己的“计算力”，但这种从物理上扩展机器的方式对一些初创的小公司来说可是一笔不小得开销负担。\ncomments: true\ndate: 2017-09-30 15:59:42\ntags:\n- 架构\n---\n\n随着云计算、深度学习和区块链技术的发展与普及，人们对“计算力”的需求变得越来越迫切。大型公司可以通过横向扩展机房的形式来增加自己的“计算力”，但这种从物理上扩展机器的方式对一些初创的小公司来说可是一笔不小得开销负担。\n\n其实在我们的身边还有一种大部分时间都在被浪费的计算力，而这些计算力便是来自于我们每个人都拥有的、生活中所必不可少的电子设备 - “个人电脑”，甚至是 - “智能手机”。这些智能设备在日常被使用的 90% 时间里都不会达到其 100% 的性能。相对的，如果我们能把这 90% 时间的闲置计算力使用起来，那会是一个十分强大的计算资源。\n\n下面给出了一个基础架构的拓扑图，架构的整体还是基于已经趋于成熟的大数据处理框架，唯一的不同是这个分布式系统只负责基本的“计算任务”调度，具体的“计算任务”处理过程全部放在 Client 端的浏览器进行。由于只需要基本的任务分配和调度，因此不需要集群过大的横向拓展，成本上来讲并不算很高。位于集群最底层的 Worker 负责将上层的任务通过 MapReduce 切分成不同的“子任务块”然后下放给客户端，客户端的计算结果与 Worker 之间是实时通信的。\n\n![](1.png)\n\n整个架构系统的难点在于，Worker 分配给 Client 端的任务并不是一定会被完全完成的，由于客户端的不确定性，对任务完成比率的校对会是一个比较棘手的问题。可以想到的方案是把“计算任务”分割成独立的小型任务，每次下放任务块时从**没有完成的任务块**中连续选择固定数量的任务块进行下放，如下图所示。\n\n![](2.png)\n\n如果最后服务化变成产品，对用户计算任务的定义还要再进行具体的设计。\n\n![](3.png)\n","slug":"一种新的共享计算力模式","published":1,"updated":"2019-02-19T10:44:40.273Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtah0054knp2f1cumq23","content":"<p>随着云计算、深度学习和区块链技术的发展与普及，人们对“计算力”的需求变得越来越迫切。大型公司可以通过横向扩展机房的形式来增加自己的“计算力”，但这种从物理上扩展机器的方式对一些初创的小公司来说可是一笔不小得开销负担。</p>\n<p>其实在我们的身边还有一种大部分时间都在被浪费的计算力，而这些计算力便是来自于我们每个人都拥有的、生活中所必不可少的电子设备 - “个人电脑”，甚至是 - “智能手机”。这些智能设备在日常被使用的 90% 时间里都不会达到其 100% 的性能。相对的，如果我们能把这 90% 时间的闲置计算力使用起来，那会是一个十分强大的计算资源。</p>\n<p>下面给出了一个基础架构的拓扑图，架构的整体还是基于已经趋于成熟的大数据处理框架，唯一的不同是这个分布式系统只负责基本的“计算任务”调度，具体的“计算任务”处理过程全部放在 Client 端的浏览器进行。由于只需要基本的任务分配和调度，因此不需要集群过大的横向拓展，成本上来讲并不算很高。位于集群最底层的 Worker 负责将上层的任务通过 MapReduce 切分成不同的“子任务块”然后下放给客户端，客户端的计算结果与 Worker 之间是实时通信的。</p>\n<p><img src=\"1.png\" alt></p>\n<p>整个架构系统的难点在于，Worker 分配给 Client 端的任务并不是一定会被完全完成的，由于客户端的不确定性，对任务完成比率的校对会是一个比较棘手的问题。可以想到的方案是把“计算任务”分割成独立的小型任务，每次下放任务块时从<strong>没有完成的任务块</strong>中连续选择固定数量的任务块进行下放，如下图所示。</p>\n<p><img src=\"2.png\" alt></p>\n<p>如果最后服务化变成产品，对用户计算任务的定义还要再进行具体的设计。</p>\n<p><img src=\"3.png\" alt></p>\n","site":{"data":{}},"id":"05f9dde306d34e3dcbe3d5ac533bd37d","excerpt":"","more":"<p>随着云计算、深度学习和区块链技术的发展与普及，人们对“计算力”的需求变得越来越迫切。大型公司可以通过横向扩展机房的形式来增加自己的“计算力”，但这种从物理上扩展机器的方式对一些初创的小公司来说可是一笔不小得开销负担。</p>\n<p>其实在我们的身边还有一种大部分时间都在被浪费的计算力，而这些计算力便是来自于我们每个人都拥有的、生活中所必不可少的电子设备 - “个人电脑”，甚至是 - “智能手机”。这些智能设备在日常被使用的 90% 时间里都不会达到其 100% 的性能。相对的，如果我们能把这 90% 时间的闲置计算力使用起来，那会是一个十分强大的计算资源。</p>\n<p>下面给出了一个基础架构的拓扑图，架构的整体还是基于已经趋于成熟的大数据处理框架，唯一的不同是这个分布式系统只负责基本的“计算任务”调度，具体的“计算任务”处理过程全部放在 Client 端的浏览器进行。由于只需要基本的任务分配和调度，因此不需要集群过大的横向拓展，成本上来讲并不算很高。位于集群最底层的 Worker 负责将上层的任务通过 MapReduce 切分成不同的“子任务块”然后下放给客户端，客户端的计算结果与 Worker 之间是实时通信的。</p>\n<p><img src=\"1.png\" alt></p>\n<p>整个架构系统的难点在于，Worker 分配给 Client 端的任务并不是一定会被完全完成的，由于客户端的不确定性，对任务完成比率的校对会是一个比较棘手的问题。可以想到的方案是把“计算任务”分割成独立的小型任务，每次下放任务块时从<strong>没有完成的任务块</strong>中连续选择固定数量的任务块进行下放，如下图所示。</p>\n<p><img src=\"2.png\" alt></p>\n<p>如果最后服务化变成产品，对用户计算任务的定义还要再进行具体的设计。</p>\n<p><img src=\"3.png\" alt></p>\n"},{"title":"“大型网站技术架构”总结：一，概述","intro":"最近集中花了两天时间把这本《大型网站技术架构》看完了，分章节来记录一些干货。本书可以作为架构师入门的第一本书，因为很少涉及到具体的编程或者系统设计，而是以一个宏观的角度讨论了大型网站的架构演进方案。可以让我们从全局的角度来了解架构师的工作和职责，并做到心中有数。","comments":1,"date":"2017-04-29T11:07:02.000Z","_content":"\n\n最近集中花了两天时间把这本《大型网站技术架构》看完了，分章节来记录一些干货。本书可以作为架构师入门的第一本书，因为很少涉及到具体的编程或者系统设计，而是以一个宏观的角度讨论了大型网站的架构演进方案。可以让我们从全局的角度来了解架构师的工作和职责，并做到心中有数。\n\n一个好的网站架构设计需要具备以下几个特点：**高可用、高性能、易扩展、可伸缩且安全**。同时网站的访问特点符合二八定律，即：**80%的业务访问集中在20%的数据资源上**。网站的技术架构发展应该由其本身的业务发展来驱动，小型网站不应该过于关注高性能的网站架构，而应该从业务做起，当业务规模发展到一定程度时再来考虑技术架构上的发展。大公司的技术架构只能作为参考，不应该盲目跟从，毕竟每家公司的业务流程都是不同的。有时要更加关注于业务层面是否得当，在确定业务流程合理的情况下再进行技术架构上的拓展。\n\n![](1.jpg)\n\n上图为一个大型网站架构的“最终”演化结构图。一个网站架构的发展从最初的单机处理到最后的分布式集群、业务拆分细化，这整个过程中间经历着数次的迭代与重构：\n\n* **初始版本**：单机应用（数据库、应用系统、文件系统）；\n* **服务分离**：多机系统（数据库、应用系统、文件系统各自独立到单独的机器）；\n* **增加缓存**：解决 DB 压力（本地缓存、远程缓存集群，存放80%的常用数据）；\n* **应用集群**：应用服务器使用集群（使用 “Load Balance” 调度集群压力）；\n* **读写分离**：数据库读写分离，主从热备（分离读写操作，主从双备）；\n* **CDN / 反向代理**：提高静态文件传输效率（缓存在反向代理服务器或者使用 CDN 加速）；\n* **文件 / 数据集群**：文件系统和数据库使用集群（全部服务化，对外部透明）；\n* **独立服务**：比如微服务架构（独立出各个服务，服务内部单独架构，服务间通过 URL / 服务发现中心来通信）；\n\n常用的大型网站架构模式有：**分层、分割、分布式、集群、缓存、异步（共享队列）、冗余、自动化、安全**。其中分层和分割是进行后续架构模式的前提，同互联网的七层模型一样，“高耦合低内聚”的独立模块是灵活部署和弹性伸缩的前提。\n\n**分层**：横向，从逻辑上分层，物理上可以在同一个机器上。比如将网站的结构分为视图层，控制层和数据层（MVC）。各个层次之间要保持相对独立的接口，职责单一明确。\n\n**分割**：纵向，比如对业务的划分，大的业务部门分割成小的业务部门，每个部门独自负责本部门的业务以及技术架构。\n\n**分布式**：分布式可以将网站架构的所有资源模块化，每个模块有自己单独的资源池来为自己提供计算，同时分布式也可以增加网站的可用性，增强和提高资源的处理效率。但带来的问题是数据一致性难以保证。\n\n**集群**：将进行分布式架构后的各个模块以“多机集群”的方式代替“单机”模式，这样的好处是可以通过即时的灾备服务，同时大大提高计算效率。每个集群通过一个 “Load Balance” 透明化的对外提供服务。（***在使用集群的时候要注意对用户 Session 等信息的状态保存不应该与应用服务器放到一起**）\n\n**缓存**：主要包括 CDN、反向代理、分布式缓存和本地缓存。使用缓存的两个前提条件：第一是数据数据访问热点不均衡，把热点数据放入缓存；第二是数据在某个时间段内有效，不会很快过期。\n\n**异步（共享队列）**：这里我把异步改成“共享队列”，模块化后的业务组件在功能上没有任何的耦合，即组件之间没有功能的先后顺序。所有资源均放入一个共享队列中，由各个组件进行处理，处理后的资源仍会在队列中。各个组件只需要负责队列中自己可以进行处理的资源即可。同时，“共享队列”还可以作为“压力容器”，在高并发访问时用来承载来不及处理的资源，防止资源的阻塞导致服务器宕机进而影响用户体验。\n\n**冗余**：即一定程度上的服务器冗余运行，数据冗余备份。数据除了需要定期备份，存档的冷备份，还需要即时同步到“从数据库”以实现热备份。\n\n**自动化**：自动化部署、自动化代码管理、自动化安全检测、自动化监控和报警、自动化失效转移（将故障机器从集群中隔离出去）、自动化失效恢复、自动化降级（通过关闭一些不重要的服务来保证系统负载在一个安全的水平）、自动化资源分配。\n\n**安全**：加密、验证码、防止攻击、风险控制等。\n","source":"_posts/“大型网站技术架构”总结：一，概述.md","raw":"---\ntitle: “大型网站技术架构”总结：一，概述\nintro: 最近集中花了两天时间把这本《大型网站技术架构》看完了，分章节来记录一些干货。本书可以作为架构师入门的第一本书，因为很少涉及到具体的编程或者系统设计，而是以一个宏观的角度讨论了大型网站的架构演进方案。可以让我们从全局的角度来了解架构师的工作和职责，并做到心中有数。\ncomments: true\ndate: 2017-04-29 19:07:02\ntags:\n- 后端\n- 架构\n---\n\n\n最近集中花了两天时间把这本《大型网站技术架构》看完了，分章节来记录一些干货。本书可以作为架构师入门的第一本书，因为很少涉及到具体的编程或者系统设计，而是以一个宏观的角度讨论了大型网站的架构演进方案。可以让我们从全局的角度来了解架构师的工作和职责，并做到心中有数。\n\n一个好的网站架构设计需要具备以下几个特点：**高可用、高性能、易扩展、可伸缩且安全**。同时网站的访问特点符合二八定律，即：**80%的业务访问集中在20%的数据资源上**。网站的技术架构发展应该由其本身的业务发展来驱动，小型网站不应该过于关注高性能的网站架构，而应该从业务做起，当业务规模发展到一定程度时再来考虑技术架构上的发展。大公司的技术架构只能作为参考，不应该盲目跟从，毕竟每家公司的业务流程都是不同的。有时要更加关注于业务层面是否得当，在确定业务流程合理的情况下再进行技术架构上的拓展。\n\n![](1.jpg)\n\n上图为一个大型网站架构的“最终”演化结构图。一个网站架构的发展从最初的单机处理到最后的分布式集群、业务拆分细化，这整个过程中间经历着数次的迭代与重构：\n\n* **初始版本**：单机应用（数据库、应用系统、文件系统）；\n* **服务分离**：多机系统（数据库、应用系统、文件系统各自独立到单独的机器）；\n* **增加缓存**：解决 DB 压力（本地缓存、远程缓存集群，存放80%的常用数据）；\n* **应用集群**：应用服务器使用集群（使用 “Load Balance” 调度集群压力）；\n* **读写分离**：数据库读写分离，主从热备（分离读写操作，主从双备）；\n* **CDN / 反向代理**：提高静态文件传输效率（缓存在反向代理服务器或者使用 CDN 加速）；\n* **文件 / 数据集群**：文件系统和数据库使用集群（全部服务化，对外部透明）；\n* **独立服务**：比如微服务架构（独立出各个服务，服务内部单独架构，服务间通过 URL / 服务发现中心来通信）；\n\n常用的大型网站架构模式有：**分层、分割、分布式、集群、缓存、异步（共享队列）、冗余、自动化、安全**。其中分层和分割是进行后续架构模式的前提，同互联网的七层模型一样，“高耦合低内聚”的独立模块是灵活部署和弹性伸缩的前提。\n\n**分层**：横向，从逻辑上分层，物理上可以在同一个机器上。比如将网站的结构分为视图层，控制层和数据层（MVC）。各个层次之间要保持相对独立的接口，职责单一明确。\n\n**分割**：纵向，比如对业务的划分，大的业务部门分割成小的业务部门，每个部门独自负责本部门的业务以及技术架构。\n\n**分布式**：分布式可以将网站架构的所有资源模块化，每个模块有自己单独的资源池来为自己提供计算，同时分布式也可以增加网站的可用性，增强和提高资源的处理效率。但带来的问题是数据一致性难以保证。\n\n**集群**：将进行分布式架构后的各个模块以“多机集群”的方式代替“单机”模式，这样的好处是可以通过即时的灾备服务，同时大大提高计算效率。每个集群通过一个 “Load Balance” 透明化的对外提供服务。（***在使用集群的时候要注意对用户 Session 等信息的状态保存不应该与应用服务器放到一起**）\n\n**缓存**：主要包括 CDN、反向代理、分布式缓存和本地缓存。使用缓存的两个前提条件：第一是数据数据访问热点不均衡，把热点数据放入缓存；第二是数据在某个时间段内有效，不会很快过期。\n\n**异步（共享队列）**：这里我把异步改成“共享队列”，模块化后的业务组件在功能上没有任何的耦合，即组件之间没有功能的先后顺序。所有资源均放入一个共享队列中，由各个组件进行处理，处理后的资源仍会在队列中。各个组件只需要负责队列中自己可以进行处理的资源即可。同时，“共享队列”还可以作为“压力容器”，在高并发访问时用来承载来不及处理的资源，防止资源的阻塞导致服务器宕机进而影响用户体验。\n\n**冗余**：即一定程度上的服务器冗余运行，数据冗余备份。数据除了需要定期备份，存档的冷备份，还需要即时同步到“从数据库”以实现热备份。\n\n**自动化**：自动化部署、自动化代码管理、自动化安全检测、自动化监控和报警、自动化失效转移（将故障机器从集群中隔离出去）、自动化失效恢复、自动化降级（通过关闭一些不重要的服务来保证系统负载在一个安全的水平）、自动化资源分配。\n\n**安全**：加密、验证码、防止攻击、风险控制等。\n","slug":"“大型网站技术架构”总结：一，概述","published":1,"updated":"2019-02-17T15:14:04.972Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtai0056knp2efaw9ib0","content":"<p>最近集中花了两天时间把这本《大型网站技术架构》看完了，分章节来记录一些干货。本书可以作为架构师入门的第一本书，因为很少涉及到具体的编程或者系统设计，而是以一个宏观的角度讨论了大型网站的架构演进方案。可以让我们从全局的角度来了解架构师的工作和职责，并做到心中有数。</p>\n<p>一个好的网站架构设计需要具备以下几个特点：<strong>高可用、高性能、易扩展、可伸缩且安全</strong>。同时网站的访问特点符合二八定律，即：<strong>80%的业务访问集中在20%的数据资源上</strong>。网站的技术架构发展应该由其本身的业务发展来驱动，小型网站不应该过于关注高性能的网站架构，而应该从业务做起，当业务规模发展到一定程度时再来考虑技术架构上的发展。大公司的技术架构只能作为参考，不应该盲目跟从，毕竟每家公司的业务流程都是不同的。有时要更加关注于业务层面是否得当，在确定业务流程合理的情况下再进行技术架构上的拓展。</p>\n<p><img src=\"1.jpg\" alt></p>\n<p>上图为一个大型网站架构的“最终”演化结构图。一个网站架构的发展从最初的单机处理到最后的分布式集群、业务拆分细化，这整个过程中间经历着数次的迭代与重构：</p>\n<ul>\n<li><strong>初始版本</strong>：单机应用（数据库、应用系统、文件系统）；</li>\n<li><strong>服务分离</strong>：多机系统（数据库、应用系统、文件系统各自独立到单独的机器）；</li>\n<li><strong>增加缓存</strong>：解决 DB 压力（本地缓存、远程缓存集群，存放80%的常用数据）；</li>\n<li><strong>应用集群</strong>：应用服务器使用集群（使用 “Load Balance” 调度集群压力）；</li>\n<li><strong>读写分离</strong>：数据库读写分离，主从热备（分离读写操作，主从双备）；</li>\n<li><strong>CDN / 反向代理</strong>：提高静态文件传输效率（缓存在反向代理服务器或者使用 CDN 加速）；</li>\n<li><strong>文件 / 数据集群</strong>：文件系统和数据库使用集群（全部服务化，对外部透明）；</li>\n<li><strong>独立服务</strong>：比如微服务架构（独立出各个服务，服务内部单独架构，服务间通过 URL / 服务发现中心来通信）；</li>\n</ul>\n<p>常用的大型网站架构模式有：<strong>分层、分割、分布式、集群、缓存、异步（共享队列）、冗余、自动化、安全</strong>。其中分层和分割是进行后续架构模式的前提，同互联网的七层模型一样，“高耦合低内聚”的独立模块是灵活部署和弹性伸缩的前提。</p>\n<p><strong>分层</strong>：横向，从逻辑上分层，物理上可以在同一个机器上。比如将网站的结构分为视图层，控制层和数据层（MVC）。各个层次之间要保持相对独立的接口，职责单一明确。</p>\n<p><strong>分割</strong>：纵向，比如对业务的划分，大的业务部门分割成小的业务部门，每个部门独自负责本部门的业务以及技术架构。</p>\n<p><strong>分布式</strong>：分布式可以将网站架构的所有资源模块化，每个模块有自己单独的资源池来为自己提供计算，同时分布式也可以增加网站的可用性，增强和提高资源的处理效率。但带来的问题是数据一致性难以保证。</p>\n<p><strong>集群</strong>：将进行分布式架构后的各个模块以“多机集群”的方式代替“单机”模式，这样的好处是可以通过即时的灾备服务，同时大大提高计算效率。每个集群通过一个 “Load Balance” 透明化的对外提供服务。（<strong>*在使用集群的时候要注意对用户 Session 等信息的状态保存不应该与应用服务器放到一起</strong>）</p>\n<p><strong>缓存</strong>：主要包括 CDN、反向代理、分布式缓存和本地缓存。使用缓存的两个前提条件：第一是数据数据访问热点不均衡，把热点数据放入缓存；第二是数据在某个时间段内有效，不会很快过期。</p>\n<p><strong>异步（共享队列）</strong>：这里我把异步改成“共享队列”，模块化后的业务组件在功能上没有任何的耦合，即组件之间没有功能的先后顺序。所有资源均放入一个共享队列中，由各个组件进行处理，处理后的资源仍会在队列中。各个组件只需要负责队列中自己可以进行处理的资源即可。同时，“共享队列”还可以作为“压力容器”，在高并发访问时用来承载来不及处理的资源，防止资源的阻塞导致服务器宕机进而影响用户体验。</p>\n<p><strong>冗余</strong>：即一定程度上的服务器冗余运行，数据冗余备份。数据除了需要定期备份，存档的冷备份，还需要即时同步到“从数据库”以实现热备份。</p>\n<p><strong>自动化</strong>：自动化部署、自动化代码管理、自动化安全检测、自动化监控和报警、自动化失效转移（将故障机器从集群中隔离出去）、自动化失效恢复、自动化降级（通过关闭一些不重要的服务来保证系统负载在一个安全的水平）、自动化资源分配。</p>\n<p><strong>安全</strong>：加密、验证码、防止攻击、风险控制等。</p>\n","site":{"data":{}},"id":"e44cf211b4c684731190c3c51979ac63","excerpt":"","more":"<p>最近集中花了两天时间把这本《大型网站技术架构》看完了，分章节来记录一些干货。本书可以作为架构师入门的第一本书，因为很少涉及到具体的编程或者系统设计，而是以一个宏观的角度讨论了大型网站的架构演进方案。可以让我们从全局的角度来了解架构师的工作和职责，并做到心中有数。</p>\n<p>一个好的网站架构设计需要具备以下几个特点：<strong>高可用、高性能、易扩展、可伸缩且安全</strong>。同时网站的访问特点符合二八定律，即：<strong>80%的业务访问集中在20%的数据资源上</strong>。网站的技术架构发展应该由其本身的业务发展来驱动，小型网站不应该过于关注高性能的网站架构，而应该从业务做起，当业务规模发展到一定程度时再来考虑技术架构上的发展。大公司的技术架构只能作为参考，不应该盲目跟从，毕竟每家公司的业务流程都是不同的。有时要更加关注于业务层面是否得当，在确定业务流程合理的情况下再进行技术架构上的拓展。</p>\n<p><img src=\"1.jpg\" alt></p>\n<p>上图为一个大型网站架构的“最终”演化结构图。一个网站架构的发展从最初的单机处理到最后的分布式集群、业务拆分细化，这整个过程中间经历着数次的迭代与重构：</p>\n<ul>\n<li><strong>初始版本</strong>：单机应用（数据库、应用系统、文件系统）；</li>\n<li><strong>服务分离</strong>：多机系统（数据库、应用系统、文件系统各自独立到单独的机器）；</li>\n<li><strong>增加缓存</strong>：解决 DB 压力（本地缓存、远程缓存集群，存放80%的常用数据）；</li>\n<li><strong>应用集群</strong>：应用服务器使用集群（使用 “Load Balance” 调度集群压力）；</li>\n<li><strong>读写分离</strong>：数据库读写分离，主从热备（分离读写操作，主从双备）；</li>\n<li><strong>CDN / 反向代理</strong>：提高静态文件传输效率（缓存在反向代理服务器或者使用 CDN 加速）；</li>\n<li><strong>文件 / 数据集群</strong>：文件系统和数据库使用集群（全部服务化，对外部透明）；</li>\n<li><strong>独立服务</strong>：比如微服务架构（独立出各个服务，服务内部单独架构，服务间通过 URL / 服务发现中心来通信）；</li>\n</ul>\n<p>常用的大型网站架构模式有：<strong>分层、分割、分布式、集群、缓存、异步（共享队列）、冗余、自动化、安全</strong>。其中分层和分割是进行后续架构模式的前提，同互联网的七层模型一样，“高耦合低内聚”的独立模块是灵活部署和弹性伸缩的前提。</p>\n<p><strong>分层</strong>：横向，从逻辑上分层，物理上可以在同一个机器上。比如将网站的结构分为视图层，控制层和数据层（MVC）。各个层次之间要保持相对独立的接口，职责单一明确。</p>\n<p><strong>分割</strong>：纵向，比如对业务的划分，大的业务部门分割成小的业务部门，每个部门独自负责本部门的业务以及技术架构。</p>\n<p><strong>分布式</strong>：分布式可以将网站架构的所有资源模块化，每个模块有自己单独的资源池来为自己提供计算，同时分布式也可以增加网站的可用性，增强和提高资源的处理效率。但带来的问题是数据一致性难以保证。</p>\n<p><strong>集群</strong>：将进行分布式架构后的各个模块以“多机集群”的方式代替“单机”模式，这样的好处是可以通过即时的灾备服务，同时大大提高计算效率。每个集群通过一个 “Load Balance” 透明化的对外提供服务。（<strong>*在使用集群的时候要注意对用户 Session 等信息的状态保存不应该与应用服务器放到一起</strong>）</p>\n<p><strong>缓存</strong>：主要包括 CDN、反向代理、分布式缓存和本地缓存。使用缓存的两个前提条件：第一是数据数据访问热点不均衡，把热点数据放入缓存；第二是数据在某个时间段内有效，不会很快过期。</p>\n<p><strong>异步（共享队列）</strong>：这里我把异步改成“共享队列”，模块化后的业务组件在功能上没有任何的耦合，即组件之间没有功能的先后顺序。所有资源均放入一个共享队列中，由各个组件进行处理，处理后的资源仍会在队列中。各个组件只需要负责队列中自己可以进行处理的资源即可。同时，“共享队列”还可以作为“压力容器”，在高并发访问时用来承载来不及处理的资源，防止资源的阻塞导致服务器宕机进而影响用户体验。</p>\n<p><strong>冗余</strong>：即一定程度上的服务器冗余运行，数据冗余备份。数据除了需要定期备份，存档的冷备份，还需要即时同步到“从数据库”以实现热备份。</p>\n<p><strong>自动化</strong>：自动化部署、自动化代码管理、自动化安全检测、自动化监控和报警、自动化失效转移（将故障机器从集群中隔离出去）、自动化失效恢复、自动化降级（通过关闭一些不重要的服务来保证系统负载在一个安全的水平）、自动化资源分配。</p>\n<p><strong>安全</strong>：加密、验证码、防止攻击、风险控制等。</p>\n"},{"title":"一道面试题的思考","intro":"今天在微信群里聊天，突然想起之前的一道面试题，特地拿出来讲解一下。同时进行记录与分享，如有不对，敬请指正。“((Math.random() * (2 ** 31 - 1)) << 0).toString(36);” 请谈谈你对上述代码的理解，这段代码主要用来生成一个随机字符串。涉及到的知识点很多。","comments":1,"date":"2017-03-21T10:32:40.000Z","_content":"\n今天在群里讨论，突然想起之前的一道面试题，特地拿出来讲解一下。同时进行记录与分享，如有不对，敬请指正。`((Math.random() * (2 ** 31 - 1)) << 0).toString(36);` 请谈谈你对上述代码的理解，这段代码主要用来生成一个随机字符串。涉及到的知识点很多。\n\n* `Math.random()` 会生成一个 [0-1) 区间的随机数（包含0）；\n* `**`是 V8 在 ES7 中新加入的幂运算符，功能上相当于 `Math.pow`。但相比 Math.pow，`**` 运算符的运算效率更高（某些情况下，两者的运算结果可能并不相等）；\n* `Number.prototype.toString` 可以把一个 Number 类型的数字按照特定的“进制”进行编码；`toString(36)` 表示将当前的数字以 BASE36 （相当于36进制）的方式进行格式化。BASE36 的格式化方法同 BASE64，只不过基准元字符为 “[0-9a-z]” 共36个字符。\n* “<<” 左移运算符只支持 32 位数字的左移运算，在这里用来去除小数位，只保留整数位；\n* 因此这里使用 `2 ** 31 - 1` 为 << 左移运算符的最大安全数字；\n* 上述的生成随机字符串代码可以用：`((Math.random() * (2 ** 53 - 1))).toString(36).split(\".\")[0];` 来代替；\n\n \n\n**扩展解析：**`2 ** 53 - 1`\n\n这里的 “2 ** 53 - 1” 其实是 JS 中的最大安全整数，即 `Number.MAX_SAFE_INTEGER`。JS 中对浮点数的规范是基于 IEEE754 规范制定的。\n\n首先需要知道的是，在 JS 中所有的 Number 数字类型在内存中都是以 64 位双精度浮点类型无差别对待的。因此某种程度上，Typed Array（Int8Array、Int16Array 等）这种数据类型可以降低我们对内存的使用率。在 IEEE754 协议下，64 位的双精度浮点被分为“1位符号位”，“11位指数位”和“52位的小数位”。\n\n比如小数 0.1 对应的二进制格式的**小数位**为：“1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001...（无限循环）”，由于内存中 IEEE754 协议规定最多只预留52位小数位，因此这里的无限循环会在内存中进行“零舍一入”，变成“1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1010”。同理其他小数也会有类似的问题，因此常见的 0.1 + 0.2 不等于 0.3 的问题便是由此诞生的。\n\n**Number.MAX_VALUE & Number.MAX_SAFE_INTEGER？**\n\n由于指数位只有11位，因此能够取得的最大值为 (2048 - 1) = 2047，由于指数有正有负，为了使正指数与负指数平衡，这里 IEEE754 选择一个偏移量 bias，其值为1023。因此将可选的指数范围转换为-1023到1024。\n\n当指数位的值位2047时，即指数为 (2047 - bias) = 1024 时，此时代表的值为正负 Inifinity。当指数位为0时，即指数为 (0 - bias) = -1023 时，此时代表的值为正负 0。因此这两个极端值均无法代表最大或最小的**可见值**。\n\n因此当可见的最大正整值是为当符号位为0，指数值为1023，小数位全为1时。即 `(-1)**0 * 2**1023 * (Number.parseInt( \"1\".repeat(53) ,2) * 2**-52);`， 同理最小正整值为 `(-1)**0 * 2**-1022 * (Number.parseInt(\"0\".repeat(52) + \"1\", 2) * 2**-52);`\n\n由上述推断可以得出，所谓最大安全整数即 `Number.MAX_SAFE_INTEGER` 就是在**小于该范围的所有整数在内存中都可以进行准确的存储（不会超过最大的小数位）**。因此只有当小数位长度小于等于52时，才能保证该整数的“安全性”，因此改变指数位的值为 52，即每个小数位都表示浮点数的整数部分。所得的最大安全整数为 `(-1)**0 * 2**52 * (Number.parseInt(\"1\".repeat(53),2) * 2**-52);`， 即 `2 ** 53 - 1`。\n\n\n","source":"_posts/一道面试题的思考.md","raw":"---\ntitle: 一道面试题的思考\nintro: 今天在微信群里聊天，突然想起之前的一道面试题，特地拿出来讲解一下。同时进行记录与分享，如有不对，敬请指正。“((Math.random() * (2 ** 31 - 1)) << 0).toString(36);” 请谈谈你对上述代码的理解，这段代码主要用来生成一个随机字符串。涉及到的知识点很多。\ncomments: true\ndate: 2017-03-21 18:32:40\ntags:\n- JavaScript\n---\n\n今天在群里讨论，突然想起之前的一道面试题，特地拿出来讲解一下。同时进行记录与分享，如有不对，敬请指正。`((Math.random() * (2 ** 31 - 1)) << 0).toString(36);` 请谈谈你对上述代码的理解，这段代码主要用来生成一个随机字符串。涉及到的知识点很多。\n\n* `Math.random()` 会生成一个 [0-1) 区间的随机数（包含0）；\n* `**`是 V8 在 ES7 中新加入的幂运算符，功能上相当于 `Math.pow`。但相比 Math.pow，`**` 运算符的运算效率更高（某些情况下，两者的运算结果可能并不相等）；\n* `Number.prototype.toString` 可以把一个 Number 类型的数字按照特定的“进制”进行编码；`toString(36)` 表示将当前的数字以 BASE36 （相当于36进制）的方式进行格式化。BASE36 的格式化方法同 BASE64，只不过基准元字符为 “[0-9a-z]” 共36个字符。\n* “<<” 左移运算符只支持 32 位数字的左移运算，在这里用来去除小数位，只保留整数位；\n* 因此这里使用 `2 ** 31 - 1` 为 << 左移运算符的最大安全数字；\n* 上述的生成随机字符串代码可以用：`((Math.random() * (2 ** 53 - 1))).toString(36).split(\".\")[0];` 来代替；\n\n \n\n**扩展解析：**`2 ** 53 - 1`\n\n这里的 “2 ** 53 - 1” 其实是 JS 中的最大安全整数，即 `Number.MAX_SAFE_INTEGER`。JS 中对浮点数的规范是基于 IEEE754 规范制定的。\n\n首先需要知道的是，在 JS 中所有的 Number 数字类型在内存中都是以 64 位双精度浮点类型无差别对待的。因此某种程度上，Typed Array（Int8Array、Int16Array 等）这种数据类型可以降低我们对内存的使用率。在 IEEE754 协议下，64 位的双精度浮点被分为“1位符号位”，“11位指数位”和“52位的小数位”。\n\n比如小数 0.1 对应的二进制格式的**小数位**为：“1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001...（无限循环）”，由于内存中 IEEE754 协议规定最多只预留52位小数位，因此这里的无限循环会在内存中进行“零舍一入”，变成“1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1010”。同理其他小数也会有类似的问题，因此常见的 0.1 + 0.2 不等于 0.3 的问题便是由此诞生的。\n\n**Number.MAX_VALUE & Number.MAX_SAFE_INTEGER？**\n\n由于指数位只有11位，因此能够取得的最大值为 (2048 - 1) = 2047，由于指数有正有负，为了使正指数与负指数平衡，这里 IEEE754 选择一个偏移量 bias，其值为1023。因此将可选的指数范围转换为-1023到1024。\n\n当指数位的值位2047时，即指数为 (2047 - bias) = 1024 时，此时代表的值为正负 Inifinity。当指数位为0时，即指数为 (0 - bias) = -1023 时，此时代表的值为正负 0。因此这两个极端值均无法代表最大或最小的**可见值**。\n\n因此当可见的最大正整值是为当符号位为0，指数值为1023，小数位全为1时。即 `(-1)**0 * 2**1023 * (Number.parseInt( \"1\".repeat(53) ,2) * 2**-52);`， 同理最小正整值为 `(-1)**0 * 2**-1022 * (Number.parseInt(\"0\".repeat(52) + \"1\", 2) * 2**-52);`\n\n由上述推断可以得出，所谓最大安全整数即 `Number.MAX_SAFE_INTEGER` 就是在**小于该范围的所有整数在内存中都可以进行准确的存储（不会超过最大的小数位）**。因此只有当小数位长度小于等于52时，才能保证该整数的“安全性”，因此改变指数位的值为 52，即每个小数位都表示浮点数的整数部分。所得的最大安全整数为 `(-1)**0 * 2**52 * (Number.parseInt(\"1\".repeat(53),2) * 2**-52);`， 即 `2 ** 53 - 1`。\n\n\n","slug":"一道面试题的思考","published":1,"updated":"2019-02-12T06:16:53.766Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtaj0059knp24k9nv07v","content":"<p>今天在群里讨论，突然想起之前的一道面试题，特地拿出来讲解一下。同时进行记录与分享，如有不对，敬请指正。<code>((Math.random() * (2 ** 31 - 1)) &lt;&lt; 0).toString(36);</code> 请谈谈你对上述代码的理解，这段代码主要用来生成一个随机字符串。涉及到的知识点很多。</p>\n<ul>\n<li><code>Math.random()</code> 会生成一个 [0-1) 区间的随机数（包含0）；</li>\n<li><code>**</code>是 V8 在 ES7 中新加入的幂运算符，功能上相当于 <code>Math.pow</code>。但相比 Math.pow，<code>**</code> 运算符的运算效率更高（某些情况下，两者的运算结果可能并不相等）；</li>\n<li><code>Number.prototype.toString</code> 可以把一个 Number 类型的数字按照特定的“进制”进行编码；<code>toString(36)</code> 表示将当前的数字以 BASE36 （相当于36进制）的方式进行格式化。BASE36 的格式化方法同 BASE64，只不过基准元字符为 “[0-9a-z]” 共36个字符。</li>\n<li>“&lt;&lt;” 左移运算符只支持 32 位数字的左移运算，在这里用来去除小数位，只保留整数位；</li>\n<li>因此这里使用 <code>2 ** 31 - 1</code> 为 &lt;&lt; 左移运算符的最大安全数字；</li>\n<li>上述的生成随机字符串代码可以用：<code>((Math.random() * (2 ** 53 - 1))).toString(36).split(&quot;.&quot;)[0];</code> 来代替；</li>\n</ul>\n<p><strong>扩展解析：</strong><code>2 ** 53 - 1</code></p>\n<p>这里的 “2 ** 53 - 1” 其实是 JS 中的最大安全整数，即 <code>Number.MAX_SAFE_INTEGER</code>。JS 中对浮点数的规范是基于 IEEE754 规范制定的。</p>\n<p>首先需要知道的是，在 JS 中所有的 Number 数字类型在内存中都是以 64 位双精度浮点类型无差别对待的。因此某种程度上，Typed Array（Int8Array、Int16Array 等）这种数据类型可以降低我们对内存的使用率。在 IEEE754 协议下，64 位的双精度浮点被分为“1位符号位”，“11位指数位”和“52位的小数位”。</p>\n<p>比如小数 0.1 对应的二进制格式的<strong>小数位</strong>为：“1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001…（无限循环）”，由于内存中 IEEE754 协议规定最多只预留52位小数位，因此这里的无限循环会在内存中进行“零舍一入”，变成“1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1010”。同理其他小数也会有类似的问题，因此常见的 0.1 + 0.2 不等于 0.3 的问题便是由此诞生的。</p>\n<p><strong>Number.MAX_VALUE &amp; Number.MAX_SAFE_INTEGER？</strong></p>\n<p>由于指数位只有11位，因此能够取得的最大值为 (2048 - 1) = 2047，由于指数有正有负，为了使正指数与负指数平衡，这里 IEEE754 选择一个偏移量 bias，其值为1023。因此将可选的指数范围转换为-1023到1024。</p>\n<p>当指数位的值位2047时，即指数为 (2047 - bias) = 1024 时，此时代表的值为正负 Inifinity。当指数位为0时，即指数为 (0 - bias) = -1023 时，此时代表的值为正负 0。因此这两个极端值均无法代表最大或最小的<strong>可见值</strong>。</p>\n<p>因此当可见的最大正整值是为当符号位为0，指数值为1023，小数位全为1时。即 <code>(-1)**0 * 2**1023 * (Number.parseInt( &quot;1&quot;.repeat(53) ,2) * 2**-52);</code>， 同理最小正整值为 <code>(-1)**0 * 2**-1022 * (Number.parseInt(&quot;0&quot;.repeat(52) + &quot;1&quot;, 2) * 2**-52);</code></p>\n<p>由上述推断可以得出，所谓最大安全整数即 <code>Number.MAX_SAFE_INTEGER</code> 就是在<strong>小于该范围的所有整数在内存中都可以进行准确的存储（不会超过最大的小数位）</strong>。因此只有当小数位长度小于等于52时，才能保证该整数的“安全性”，因此改变指数位的值为 52，即每个小数位都表示浮点数的整数部分。所得的最大安全整数为 <code>(-1)**0 * 2**52 * (Number.parseInt(&quot;1&quot;.repeat(53),2) * 2**-52);</code>， 即 <code>2 ** 53 - 1</code>。</p>\n","site":{"data":{}},"id":"f8444a62572628be372a7af488ca317c","excerpt":"","more":"<p>今天在群里讨论，突然想起之前的一道面试题，特地拿出来讲解一下。同时进行记录与分享，如有不对，敬请指正。<code>((Math.random() * (2 ** 31 - 1)) &lt;&lt; 0).toString(36);</code> 请谈谈你对上述代码的理解，这段代码主要用来生成一个随机字符串。涉及到的知识点很多。</p>\n<ul>\n<li><code>Math.random()</code> 会生成一个 [0-1) 区间的随机数（包含0）；</li>\n<li><code>**</code>是 V8 在 ES7 中新加入的幂运算符，功能上相当于 <code>Math.pow</code>。但相比 Math.pow，<code>**</code> 运算符的运算效率更高（某些情况下，两者的运算结果可能并不相等）；</li>\n<li><code>Number.prototype.toString</code> 可以把一个 Number 类型的数字按照特定的“进制”进行编码；<code>toString(36)</code> 表示将当前的数字以 BASE36 （相当于36进制）的方式进行格式化。BASE36 的格式化方法同 BASE64，只不过基准元字符为 “[0-9a-z]” 共36个字符。</li>\n<li>“&lt;&lt;” 左移运算符只支持 32 位数字的左移运算，在这里用来去除小数位，只保留整数位；</li>\n<li>因此这里使用 <code>2 ** 31 - 1</code> 为 &lt;&lt; 左移运算符的最大安全数字；</li>\n<li>上述的生成随机字符串代码可以用：<code>((Math.random() * (2 ** 53 - 1))).toString(36).split(&quot;.&quot;)[0];</code> 来代替；</li>\n</ul>\n<p><strong>扩展解析：</strong><code>2 ** 53 - 1</code></p>\n<p>这里的 “2 ** 53 - 1” 其实是 JS 中的最大安全整数，即 <code>Number.MAX_SAFE_INTEGER</code>。JS 中对浮点数的规范是基于 IEEE754 规范制定的。</p>\n<p>首先需要知道的是，在 JS 中所有的 Number 数字类型在内存中都是以 64 位双精度浮点类型无差别对待的。因此某种程度上，Typed Array（Int8Array、Int16Array 等）这种数据类型可以降低我们对内存的使用率。在 IEEE754 协议下，64 位的双精度浮点被分为“1位符号位”，“11位指数位”和“52位的小数位”。</p>\n<p>比如小数 0.1 对应的二进制格式的<strong>小数位</strong>为：“1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001…（无限循环）”，由于内存中 IEEE754 协议规定最多只预留52位小数位，因此这里的无限循环会在内存中进行“零舍一入”，变成“1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1010”。同理其他小数也会有类似的问题，因此常见的 0.1 + 0.2 不等于 0.3 的问题便是由此诞生的。</p>\n<p><strong>Number.MAX_VALUE &amp; Number.MAX_SAFE_INTEGER？</strong></p>\n<p>由于指数位只有11位，因此能够取得的最大值为 (2048 - 1) = 2047，由于指数有正有负，为了使正指数与负指数平衡，这里 IEEE754 选择一个偏移量 bias，其值为1023。因此将可选的指数范围转换为-1023到1024。</p>\n<p>当指数位的值位2047时，即指数为 (2047 - bias) = 1024 时，此时代表的值为正负 Inifinity。当指数位为0时，即指数为 (0 - bias) = -1023 时，此时代表的值为正负 0。因此这两个极端值均无法代表最大或最小的<strong>可见值</strong>。</p>\n<p>因此当可见的最大正整值是为当符号位为0，指数值为1023，小数位全为1时。即 <code>(-1)**0 * 2**1023 * (Number.parseInt( &quot;1&quot;.repeat(53) ,2) * 2**-52);</code>， 同理最小正整值为 <code>(-1)**0 * 2**-1022 * (Number.parseInt(&quot;0&quot;.repeat(52) + &quot;1&quot;, 2) * 2**-52);</code></p>\n<p>由上述推断可以得出，所谓最大安全整数即 <code>Number.MAX_SAFE_INTEGER</code> 就是在<strong>小于该范围的所有整数在内存中都可以进行准确的存储（不会超过最大的小数位）</strong>。因此只有当小数位长度小于等于52时，才能保证该整数的“安全性”，因此改变指数位的值为 52，即每个小数位都表示浮点数的整数部分。所得的最大安全整数为 <code>(-1)**0 * 2**52 * (Number.parseInt(&quot;1&quot;.repeat(53),2) * 2**-52);</code>， 即 <code>2 ** 53 - 1</code>。</p>\n"},{"title":"为 Swing 控件 JList 动态添加元素","intro":"最近在做的一些项目中用到了 JavaSE 中 Swing 扩展库的 JList 控件，在使用中逐渐发现 JList 很好用，我们可以更改其样式变成单行的下拉列表形式，或者变成显示多行的选择列表形式。并且还可以同时实现多项选择或者单项选择，也可以显示纯文字选项或者图片，甚至显示各种自定义的样式。","comments":1,"date":"2015-03-21T16:33:01.000Z","_content":"\n最近在做的一些项目中用到了 JavaSE 中 Swing 扩展库的 JList 控件，在使用中逐渐发现 JList 很好用，我们可以更改其样式变成单行的下拉列表形式，或者变成显示多行的选择列表形式。并且还可以同时实现多项选择或者单项选择，也可以显示纯文字选项或者图片，甚至显示各种自定义的样式。\n\n但最近遇到的一个问题是如何使 JList 可以动态的添加或者删除其列表中的元素，经过查询 API 文档以及各种 Google 搜索，现整理解决方案如下。\n\n我们最常见的构造 JList 对象的方式是使用静态数组来构建，即如下代码所示的构建方法：\n\n```java\nString[] jlistData = { \"DATA\", \"DATA\", \"DATA\", \"DATA\" };\nJList myJList = new JList(jlistData);\n```\n\n还有另一种方法即可以通过 `Vector` 来构建 JList，这种构造方法可以在生成 JList 对象之后再单独进行赋值，即如下代码所示的构建方法：\n\n```java\nVector superClasses = new Vector();\nClass rootClass = javax.swing.JList.class;\nfor (Class cls = rootClass; cls != null; cls = cls.getSuperclass()) {\n  superClasses.addElement(cls);\n}\nJList myList = new JList(superClasses);\nsuperClasses.addElement(\"DATA1\"); \nsuperClasses.addElement(\"DATA2\"); \n```\n\n如果使用以上这些方式来构建 JList 对象，数据一旦添加后便不能够再次修改，删除或者增加 JList 列表中的内容。因此我们需要使用以下方法来构建 JList 对象能够动态添加或删除其中的数据。\n\n```java\nDefaultListModel dlmIns = new DefaultListModel();\ndlmIns.addElement(\"DATA1\");\ndlmIns.addElement(\"DATA2\");\n\n// ...\n\nJList jlist = new JList();\njlist.setModel(dlmIns);\n\n// 删除元素；\ndlmIns.clear();\njlist.setModel(dlmIns); \n\n// 添加元素；\ndlmIns.addElement(\"DATA3\");\ndlmIns.addElement(\"DATA4\");\njlist.setModel(dlmIns); \n```\n\n各个类的继承关系如下：ListMode 接口 -> AbstractListMode 类 -> DefaultListModel 类。其实在整个 JList 的继承树中，DefaultListModel 类是负责对 JList 元素进行管理的。因此所有对于 JList 元素的操作均是基于此类实现的。","source":"_posts/为-Swing-控件-JList-动态添加元素.md","raw":"---\ntitle: 为 Swing 控件 JList 动态添加元素\nintro: 最近在做的一些项目中用到了 JavaSE 中 Swing 扩展库的 JList 控件，在使用中逐渐发现 JList 很好用，我们可以更改其样式变成单行的下拉列表形式，或者变成显示多行的选择列表形式。并且还可以同时实现多项选择或者单项选择，也可以显示纯文字选项或者图片，甚至显示各种自定义的样式。\ncomments: true\ndate: 2015-03-22 00:33:01\ntags:\n- Java\n---\n\n最近在做的一些项目中用到了 JavaSE 中 Swing 扩展库的 JList 控件，在使用中逐渐发现 JList 很好用，我们可以更改其样式变成单行的下拉列表形式，或者变成显示多行的选择列表形式。并且还可以同时实现多项选择或者单项选择，也可以显示纯文字选项或者图片，甚至显示各种自定义的样式。\n\n但最近遇到的一个问题是如何使 JList 可以动态的添加或者删除其列表中的元素，经过查询 API 文档以及各种 Google 搜索，现整理解决方案如下。\n\n我们最常见的构造 JList 对象的方式是使用静态数组来构建，即如下代码所示的构建方法：\n\n```java\nString[] jlistData = { \"DATA\", \"DATA\", \"DATA\", \"DATA\" };\nJList myJList = new JList(jlistData);\n```\n\n还有另一种方法即可以通过 `Vector` 来构建 JList，这种构造方法可以在生成 JList 对象之后再单独进行赋值，即如下代码所示的构建方法：\n\n```java\nVector superClasses = new Vector();\nClass rootClass = javax.swing.JList.class;\nfor (Class cls = rootClass; cls != null; cls = cls.getSuperclass()) {\n  superClasses.addElement(cls);\n}\nJList myList = new JList(superClasses);\nsuperClasses.addElement(\"DATA1\"); \nsuperClasses.addElement(\"DATA2\"); \n```\n\n如果使用以上这些方式来构建 JList 对象，数据一旦添加后便不能够再次修改，删除或者增加 JList 列表中的内容。因此我们需要使用以下方法来构建 JList 对象能够动态添加或删除其中的数据。\n\n```java\nDefaultListModel dlmIns = new DefaultListModel();\ndlmIns.addElement(\"DATA1\");\ndlmIns.addElement(\"DATA2\");\n\n// ...\n\nJList jlist = new JList();\njlist.setModel(dlmIns);\n\n// 删除元素；\ndlmIns.clear();\njlist.setModel(dlmIns); \n\n// 添加元素；\ndlmIns.addElement(\"DATA3\");\ndlmIns.addElement(\"DATA4\");\njlist.setModel(dlmIns); \n```\n\n各个类的继承关系如下：ListMode 接口 -> AbstractListMode 类 -> DefaultListModel 类。其实在整个 JList 的继承树中，DefaultListModel 类是负责对 JList 元素进行管理的。因此所有对于 JList 元素的操作均是基于此类实现的。","slug":"为-Swing-控件-JList-动态添加元素","published":1,"updated":"2019-02-04T07:53:16.095Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtak005aknp2du596dos","content":"<p>最近在做的一些项目中用到了 JavaSE 中 Swing 扩展库的 JList 控件，在使用中逐渐发现 JList 很好用，我们可以更改其样式变成单行的下拉列表形式，或者变成显示多行的选择列表形式。并且还可以同时实现多项选择或者单项选择，也可以显示纯文字选项或者图片，甚至显示各种自定义的样式。</p>\n<p>但最近遇到的一个问题是如何使 JList 可以动态的添加或者删除其列表中的元素，经过查询 API 文档以及各种 Google 搜索，现整理解决方案如下。</p>\n<p>我们最常见的构造 JList 对象的方式是使用静态数组来构建，即如下代码所示的构建方法：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\">String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> jlistData <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token string\">\"DATA\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"DATA\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"DATA\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"DATA\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nJList myJList <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">JList</span><span class=\"token punctuation\">(</span>jlistData<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>还有另一种方法即可以通过 <code>Vector</code> 来构建 JList，这种构造方法可以在生成 JList 对象之后再单独进行赋值，即如下代码所示的构建方法：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\">Vector superClasses <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Vector</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nClass <span class=\"token class-name\">rootClass</span> <span class=\"token operator\">=</span> javax<span class=\"token punctuation\">.</span>swing<span class=\"token punctuation\">.</span>JList<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>Class <span class=\"token class-name\">cls</span> <span class=\"token operator\">=</span> rootClass<span class=\"token punctuation\">;</span> cls <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">;</span> cls <span class=\"token operator\">=</span> cls<span class=\"token punctuation\">.</span><span class=\"token function\">getSuperclass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  superClasses<span class=\"token punctuation\">.</span><span class=\"token function\">addElement</span><span class=\"token punctuation\">(</span>cls<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\nJList myList <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">JList</span><span class=\"token punctuation\">(</span>superClasses<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nsuperClasses<span class=\"token punctuation\">.</span><span class=\"token function\">addElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"DATA1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \nsuperClasses<span class=\"token punctuation\">.</span><span class=\"token function\">addElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"DATA2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>如果使用以上这些方式来构建 JList 对象，数据一旦添加后便不能够再次修改，删除或者增加 JList 列表中的内容。因此我们需要使用以下方法来构建 JList 对象能够动态添加或删除其中的数据。</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\">DefaultListModel dlmIns <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">DefaultListModel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ndlmIns<span class=\"token punctuation\">.</span><span class=\"token function\">addElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"DATA1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ndlmIns<span class=\"token punctuation\">.</span><span class=\"token function\">addElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"DATA2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// ...</span>\n\nJList jlist <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">JList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\njlist<span class=\"token punctuation\">.</span><span class=\"token function\">setModel</span><span class=\"token punctuation\">(</span>dlmIns<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 删除元素；</span>\ndlmIns<span class=\"token punctuation\">.</span><span class=\"token function\">clear</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\njlist<span class=\"token punctuation\">.</span><span class=\"token function\">setModel</span><span class=\"token punctuation\">(</span>dlmIns<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n\n<span class=\"token comment\" spellcheck=\"true\">// 添加元素；</span>\ndlmIns<span class=\"token punctuation\">.</span><span class=\"token function\">addElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"DATA3\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ndlmIns<span class=\"token punctuation\">.</span><span class=\"token function\">addElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"DATA4\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\njlist<span class=\"token punctuation\">.</span><span class=\"token function\">setModel</span><span class=\"token punctuation\">(</span>dlmIns<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>各个类的继承关系如下：ListMode 接口 -&gt; AbstractListMode 类 -&gt; DefaultListModel 类。其实在整个 JList 的继承树中，DefaultListModel 类是负责对 JList 元素进行管理的。因此所有对于 JList 元素的操作均是基于此类实现的。</p>\n","site":{"data":{}},"id":"9740c5df630e01beac85a0cdc1a0b3d2","excerpt":"","more":"<p>最近在做的一些项目中用到了 JavaSE 中 Swing 扩展库的 JList 控件，在使用中逐渐发现 JList 很好用，我们可以更改其样式变成单行的下拉列表形式，或者变成显示多行的选择列表形式。并且还可以同时实现多项选择或者单项选择，也可以显示纯文字选项或者图片，甚至显示各种自定义的样式。</p>\n<p>但最近遇到的一个问题是如何使 JList 可以动态的添加或者删除其列表中的元素，经过查询 API 文档以及各种 Google 搜索，现整理解决方案如下。</p>\n<p>我们最常见的构造 JList 对象的方式是使用静态数组来构建，即如下代码所示的构建方法：</p>\n<pre><code class=\"java\">String[] jlistData = { &quot;DATA&quot;, &quot;DATA&quot;, &quot;DATA&quot;, &quot;DATA&quot; };\nJList myJList = new JList(jlistData);\n</code></pre>\n<p>还有另一种方法即可以通过 <code>Vector</code> 来构建 JList，这种构造方法可以在生成 JList 对象之后再单独进行赋值，即如下代码所示的构建方法：</p>\n<pre><code class=\"java\">Vector superClasses = new Vector();\nClass rootClass = javax.swing.JList.class;\nfor (Class cls = rootClass; cls != null; cls = cls.getSuperclass()) {\n  superClasses.addElement(cls);\n}\nJList myList = new JList(superClasses);\nsuperClasses.addElement(&quot;DATA1&quot;); \nsuperClasses.addElement(&quot;DATA2&quot;); \n</code></pre>\n<p>如果使用以上这些方式来构建 JList 对象，数据一旦添加后便不能够再次修改，删除或者增加 JList 列表中的内容。因此我们需要使用以下方法来构建 JList 对象能够动态添加或删除其中的数据。</p>\n<pre><code class=\"java\">DefaultListModel dlmIns = new DefaultListModel();\ndlmIns.addElement(&quot;DATA1&quot;);\ndlmIns.addElement(&quot;DATA2&quot;);\n\n// ...\n\nJList jlist = new JList();\njlist.setModel(dlmIns);\n\n// 删除元素；\ndlmIns.clear();\njlist.setModel(dlmIns); \n\n// 添加元素；\ndlmIns.addElement(&quot;DATA3&quot;);\ndlmIns.addElement(&quot;DATA4&quot;);\njlist.setModel(dlmIns); \n</code></pre>\n<p>各个类的继承关系如下：ListMode 接口 -&gt; AbstractListMode 类 -&gt; DefaultListModel 类。其实在整个 JList 的继承树中，DefaultListModel 类是负责对 JList 元素进行管理的。因此所有对于 JList 元素的操作均是基于此类实现的。</p>\n"},{"title":"“大型网站技术架构”总结：三，网站的高可用架构","intro":"第三篇总结，主要围绕着如何从多方面进行“高可用的网站架构”展开。网站页面能够完整呈现在最终用户面前，需要经过多个环节，任何一个环节出了问题，都可能导致网站页面不可访问，服务中断。网络请求的情况千变万化，可能一个“突然来袭”的实时热点访问，都会把你的网站重重拖垮。","comments":1,"date":"2017-05-02T12:35:19.000Z","_content":"\n第三篇总结，主要围绕着如何从多方面进行“高可用的网站架构”展开。网站页面能够完整呈现在最终用户面前，需要经过多个环节，任何一个环节出了问题，都可能导致网站页面不可访问，服务中断。网络请求的情况千变万化，可能一个“突然来袭”的实时热点访问，都会把你的网站重重拖垮。\n\n#### 一、可用性度量：\n\n我们通常使用“多个9”来衡量网站的可用性，比如“4个9”代表一个服务 99.99% 可用，即需要保证在单位时间内只有最多 0.01% 的时间内可以发生服务不可用的故障。而“2个9”与“3个9”的意思也同样如此。但对于网站整体而言，想要达到“4个9”甚至更高的可用性，除了过硬的技术、大量的设备及资金投入外还需要有个好运气。\n\n一般为了将网站的可用性指标转换成对应的责任度量下放到个人或者组织，我们一般使用“故障分”来对网站的单位时间故障进行加权计算，进而将责任分担下放到个人，加入其年度的绩效考核中。比如可以对不同级别的故障类型划分不同的权重分，再通过对应类型故障的发生时间来得到该故障的故障分。\n\n#### 二、高可用的整体架构：\n\n我们一般将网站架构分为三层：**应用层**、**服务层**、**数据层**；应用层负责业务逻辑处理，服务层提供可复用的服务，数据层负责数据的封装与存储，各层之间相对独立。由于网站的架构资源中，硬件故障是最常见的问题。那么高可用架构的主要目的就是保证服务器在硬件故障时依然可用。其主要手段是：**数据和服务的冗余备份以及失效转移**。\n\n![](1.jpg)\n\n位于应用层的服务器通常为了应对高并发的请求，会通过负载均衡（Load Balancer）组成集群来对外透明的提供服务。负载均衡会通过“心跳检测”来监控服务器状态，当发现不可用机器时将其从集群中剔除，并将该机器的路由设置为不可用，同时所有请求将转发到集群内的其他机器。服务层的机器与应用层类似。位于数据层的服务器比较特殊，为了保证数据不丢失，我们需要在数据写入时同时对集群内的其他服务器同步复制数据，以保证数据的一致性和可用性。\n\n#### 三、高可用的应用：\n\n由于应用层主要负责对业务的处理，为了使用集群来提高应用服务的高可用性，我们将应用层设计成无状态的服务，即不在应用服务器本地保存用户的会话状态信息（比如 Session）。这样的做的目的是为了让集群内的所有服务器对等，在负载均衡调度请求时可以无差别对待。而用户的状态信息我们会用专门的方式来进行管理。\n\n由于**业务总是有状态的**，在单机情况下，我们将会话信息交由服务器上的 Web 容器来管理。但对于集群环境来说，我们通常使用以下几种方式来处理：\n\n* **Session 复制**：所有应用服务器在本地共享同一套会话信息，且每次新增的会话都会在整个应用集群内进行复制。随着会话数量的增加及应用集群的扩大，系统压力会成倍增长，因此只适用于小型集群；\n* **Session 绑定**：负载均衡服务器将同一 IP 来源的所有请求绑定在固定的应用服务器上，该方式又被称为“会话粘滞”，但其整体并不符合高可用的特性；\n* **利用 Cookie**：将用户的会话信息存储在客户端的浏览器中，安全性低、影响传输性能、受到浏览器限制：\n* **Session 服务器**：使用专门的 Session 集群，由负载均衡调度，可以利用分布式缓存 / 数据库来进行包装：\n\n#### 四、高可用的服务：\n\n高可用的服务一定是**独立的**、**可复用的**。服务的设计同样需要遵循几个原则：**分级管理**（核心应用和服务优先使用更好的硬件，核心服务和数据需要部署在不同地域的数据中心，低优先级的服务甚至可以只使用多线程来隔离）、**超时设置**（设置服务的远程调用超时时间，某一台机器超过规定的响应时间即由集群 Leader 或负载均衡重新分配资源）、**异步调用**（将一次完整的业务流程拆分，比如发送成功邮件等任务，可以延后执行的步骤均放在消息队列中异步进行，即使用传统的消费者模式）、**服务降级**（在并发数较高的情况下，可以通过适当关闭不必要的低优先级服务来节约系统性能，或者通过随机拒绝服务的方式，将压力分散）、**幂等设计**（我们无法确定一次失败的服务请求是否真的失败了，为了避免服务的二次调用产生“非预期”的结构，我们需要将服务调用幂等化，即一次调用和多次调用产生的效果是一致的）。\n\n#### 五、高可用的数据：\n\n保证高可用数据的手段主要是“数据备份”和“失效转移”。一般为了保证数据高可用，我们可能会牺牲另一个指标，即：”数据一致性“。高可用数据一般包括“**数据持久性**”、“**数据可用性**”和“**数据一致性**”三个指标。根据 CAP 原理，一个数据服务的存储系统是无法同时满足数据一致性（Consistency）、数据可用性（Availibility）和分区耐受性（Partition Tolerance）的。数据一致性即：所有应用都能访问到相同的数据；数据可用性即：任何时候，任何应用都可以进行数据读写；分区耐受性指：系统可以跨网络分区线性的伸缩。由于 A 和 P 两个指标较 C 更为重要，我们既然放弃了数据的强一致性，退而求其次在不影响用户体验时，可以选择保障数据用户一致。\n\n常用的数据备份方式分为**热备份**和**冷备份**。冷备份是一种古老而有效的数据保护手段，主要通过定期将数据复制到存储介质上并物理存档保存来保护数据。缺点是不能保证数据的最终一致（最弱的一致性，系统经过一段时间的自我恢复和修正最终达到一致），而且在数据备份时需要宕机。热备份是一种实时备份的数据保护方式，分为异步热备和同步热备。同时对于关系型数据库来说，热备机制的 “Master-Slave” 同步机制还可以通过读写分离的方式来改善数据库性能。\n\n失效转移一般通过心跳检测或者应用程序的访问失败报告来进行通知，控制中心在收到失败报告时会再次通过心跳检测来进行确认，如果确认失败则将该机器路由转移到其他可用机器上。\n\n#### 六、高可用的软件质量保证：\n\n比如我们在发布软件的新版本时一定要注意不能影响原有的线上正在运行中的服务。因此我们一般通过发布脚本每次只关闭一部分集群的机器，进行软件更新，然后启用。再关闭另一部分机器，重复上述过程。在软件发布之前还需要进行“预发布”，即先发布到线上集群中一台**只有内网能够访问**到的机器，但使用的是线上数据，在通过内部测试无误后再逐渐全量地发布到线上。\n\n同时对于大型网站的软件发布，我们可以采用“**灰度发布**”的方式，即：一段时间内只发布线上集群中的一部分机器，待观察一段时间没有问题后，再逐渐发布集群内的其他机器。在进行“灰度发布”的同时，我们甚至可以进行“A/B测试”，以新发布的机器作为对照组，查看新旧软件使用用户的反馈情况。\n\n另一方面，也需要对网站进行全天候的实时监控。比如监控服务端日志、客户端日志、运行数据报告（缓存命中率、平均响应延迟等）。甚至要做到自动检测系统报警并向 Leader 机器反馈，可以即时做到系统失效转移，以及优雅降级（高并发、高压力时自动关闭某些低优先级的服务）等操作。\n","source":"_posts/“大型网站技术架构”总结：三，网站的高可用架构.md","raw":"---\ntitle: “大型网站技术架构”总结：三，网站的高可用架构\nintro: 第三篇总结，主要围绕着如何从多方面进行“高可用的网站架构”展开。网站页面能够完整呈现在最终用户面前，需要经过多个环节，任何一个环节出了问题，都可能导致网站页面不可访问，服务中断。网络请求的情况千变万化，可能一个“突然来袭”的实时热点访问，都会把你的网站重重拖垮。\ncomments: true\ndate: 2017-05-02 20:35:19\ntags:\n- 后端\n- 架构\n---\n\n第三篇总结，主要围绕着如何从多方面进行“高可用的网站架构”展开。网站页面能够完整呈现在最终用户面前，需要经过多个环节，任何一个环节出了问题，都可能导致网站页面不可访问，服务中断。网络请求的情况千变万化，可能一个“突然来袭”的实时热点访问，都会把你的网站重重拖垮。\n\n#### 一、可用性度量：\n\n我们通常使用“多个9”来衡量网站的可用性，比如“4个9”代表一个服务 99.99% 可用，即需要保证在单位时间内只有最多 0.01% 的时间内可以发生服务不可用的故障。而“2个9”与“3个9”的意思也同样如此。但对于网站整体而言，想要达到“4个9”甚至更高的可用性，除了过硬的技术、大量的设备及资金投入外还需要有个好运气。\n\n一般为了将网站的可用性指标转换成对应的责任度量下放到个人或者组织，我们一般使用“故障分”来对网站的单位时间故障进行加权计算，进而将责任分担下放到个人，加入其年度的绩效考核中。比如可以对不同级别的故障类型划分不同的权重分，再通过对应类型故障的发生时间来得到该故障的故障分。\n\n#### 二、高可用的整体架构：\n\n我们一般将网站架构分为三层：**应用层**、**服务层**、**数据层**；应用层负责业务逻辑处理，服务层提供可复用的服务，数据层负责数据的封装与存储，各层之间相对独立。由于网站的架构资源中，硬件故障是最常见的问题。那么高可用架构的主要目的就是保证服务器在硬件故障时依然可用。其主要手段是：**数据和服务的冗余备份以及失效转移**。\n\n![](1.jpg)\n\n位于应用层的服务器通常为了应对高并发的请求，会通过负载均衡（Load Balancer）组成集群来对外透明的提供服务。负载均衡会通过“心跳检测”来监控服务器状态，当发现不可用机器时将其从集群中剔除，并将该机器的路由设置为不可用，同时所有请求将转发到集群内的其他机器。服务层的机器与应用层类似。位于数据层的服务器比较特殊，为了保证数据不丢失，我们需要在数据写入时同时对集群内的其他服务器同步复制数据，以保证数据的一致性和可用性。\n\n#### 三、高可用的应用：\n\n由于应用层主要负责对业务的处理，为了使用集群来提高应用服务的高可用性，我们将应用层设计成无状态的服务，即不在应用服务器本地保存用户的会话状态信息（比如 Session）。这样的做的目的是为了让集群内的所有服务器对等，在负载均衡调度请求时可以无差别对待。而用户的状态信息我们会用专门的方式来进行管理。\n\n由于**业务总是有状态的**，在单机情况下，我们将会话信息交由服务器上的 Web 容器来管理。但对于集群环境来说，我们通常使用以下几种方式来处理：\n\n* **Session 复制**：所有应用服务器在本地共享同一套会话信息，且每次新增的会话都会在整个应用集群内进行复制。随着会话数量的增加及应用集群的扩大，系统压力会成倍增长，因此只适用于小型集群；\n* **Session 绑定**：负载均衡服务器将同一 IP 来源的所有请求绑定在固定的应用服务器上，该方式又被称为“会话粘滞”，但其整体并不符合高可用的特性；\n* **利用 Cookie**：将用户的会话信息存储在客户端的浏览器中，安全性低、影响传输性能、受到浏览器限制：\n* **Session 服务器**：使用专门的 Session 集群，由负载均衡调度，可以利用分布式缓存 / 数据库来进行包装：\n\n#### 四、高可用的服务：\n\n高可用的服务一定是**独立的**、**可复用的**。服务的设计同样需要遵循几个原则：**分级管理**（核心应用和服务优先使用更好的硬件，核心服务和数据需要部署在不同地域的数据中心，低优先级的服务甚至可以只使用多线程来隔离）、**超时设置**（设置服务的远程调用超时时间，某一台机器超过规定的响应时间即由集群 Leader 或负载均衡重新分配资源）、**异步调用**（将一次完整的业务流程拆分，比如发送成功邮件等任务，可以延后执行的步骤均放在消息队列中异步进行，即使用传统的消费者模式）、**服务降级**（在并发数较高的情况下，可以通过适当关闭不必要的低优先级服务来节约系统性能，或者通过随机拒绝服务的方式，将压力分散）、**幂等设计**（我们无法确定一次失败的服务请求是否真的失败了，为了避免服务的二次调用产生“非预期”的结构，我们需要将服务调用幂等化，即一次调用和多次调用产生的效果是一致的）。\n\n#### 五、高可用的数据：\n\n保证高可用数据的手段主要是“数据备份”和“失效转移”。一般为了保证数据高可用，我们可能会牺牲另一个指标，即：”数据一致性“。高可用数据一般包括“**数据持久性**”、“**数据可用性**”和“**数据一致性**”三个指标。根据 CAP 原理，一个数据服务的存储系统是无法同时满足数据一致性（Consistency）、数据可用性（Availibility）和分区耐受性（Partition Tolerance）的。数据一致性即：所有应用都能访问到相同的数据；数据可用性即：任何时候，任何应用都可以进行数据读写；分区耐受性指：系统可以跨网络分区线性的伸缩。由于 A 和 P 两个指标较 C 更为重要，我们既然放弃了数据的强一致性，退而求其次在不影响用户体验时，可以选择保障数据用户一致。\n\n常用的数据备份方式分为**热备份**和**冷备份**。冷备份是一种古老而有效的数据保护手段，主要通过定期将数据复制到存储介质上并物理存档保存来保护数据。缺点是不能保证数据的最终一致（最弱的一致性，系统经过一段时间的自我恢复和修正最终达到一致），而且在数据备份时需要宕机。热备份是一种实时备份的数据保护方式，分为异步热备和同步热备。同时对于关系型数据库来说，热备机制的 “Master-Slave” 同步机制还可以通过读写分离的方式来改善数据库性能。\n\n失效转移一般通过心跳检测或者应用程序的访问失败报告来进行通知，控制中心在收到失败报告时会再次通过心跳检测来进行确认，如果确认失败则将该机器路由转移到其他可用机器上。\n\n#### 六、高可用的软件质量保证：\n\n比如我们在发布软件的新版本时一定要注意不能影响原有的线上正在运行中的服务。因此我们一般通过发布脚本每次只关闭一部分集群的机器，进行软件更新，然后启用。再关闭另一部分机器，重复上述过程。在软件发布之前还需要进行“预发布”，即先发布到线上集群中一台**只有内网能够访问**到的机器，但使用的是线上数据，在通过内部测试无误后再逐渐全量地发布到线上。\n\n同时对于大型网站的软件发布，我们可以采用“**灰度发布**”的方式，即：一段时间内只发布线上集群中的一部分机器，待观察一段时间没有问题后，再逐渐发布集群内的其他机器。在进行“灰度发布”的同时，我们甚至可以进行“A/B测试”，以新发布的机器作为对照组，查看新旧软件使用用户的反馈情况。\n\n另一方面，也需要对网站进行全天候的实时监控。比如监控服务端日志、客户端日志、运行数据报告（缓存命中率、平均响应延迟等）。甚至要做到自动检测系统报警并向 Leader 机器反馈，可以即时做到系统失效转移，以及优雅降级（高并发、高压力时自动关闭某些低优先级的服务）等操作。\n","slug":"“大型网站技术架构”总结：三，网站的高可用架构","published":1,"updated":"2019-02-17T15:42:01.630Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtak005dknp2dh10qo6e","content":"<p>第三篇总结，主要围绕着如何从多方面进行“高可用的网站架构”展开。网站页面能够完整呈现在最终用户面前，需要经过多个环节，任何一个环节出了问题，都可能导致网站页面不可访问，服务中断。网络请求的情况千变万化，可能一个“突然来袭”的实时热点访问，都会把你的网站重重拖垮。</p>\n<h4 id=\"一、可用性度量：\"><a href=\"#一、可用性度量：\" class=\"headerlink\" title=\"一、可用性度量：\"></a>一、可用性度量：</h4><p>我们通常使用“多个9”来衡量网站的可用性，比如“4个9”代表一个服务 99.99% 可用，即需要保证在单位时间内只有最多 0.01% 的时间内可以发生服务不可用的故障。而“2个9”与“3个9”的意思也同样如此。但对于网站整体而言，想要达到“4个9”甚至更高的可用性，除了过硬的技术、大量的设备及资金投入外还需要有个好运气。</p>\n<p>一般为了将网站的可用性指标转换成对应的责任度量下放到个人或者组织，我们一般使用“故障分”来对网站的单位时间故障进行加权计算，进而将责任分担下放到个人，加入其年度的绩效考核中。比如可以对不同级别的故障类型划分不同的权重分，再通过对应类型故障的发生时间来得到该故障的故障分。</p>\n<h4 id=\"二、高可用的整体架构：\"><a href=\"#二、高可用的整体架构：\" class=\"headerlink\" title=\"二、高可用的整体架构：\"></a>二、高可用的整体架构：</h4><p>我们一般将网站架构分为三层：<strong>应用层</strong>、<strong>服务层</strong>、<strong>数据层</strong>；应用层负责业务逻辑处理，服务层提供可复用的服务，数据层负责数据的封装与存储，各层之间相对独立。由于网站的架构资源中，硬件故障是最常见的问题。那么高可用架构的主要目的就是保证服务器在硬件故障时依然可用。其主要手段是：<strong>数据和服务的冗余备份以及失效转移</strong>。</p>\n<p><img src=\"1.jpg\" alt></p>\n<p>位于应用层的服务器通常为了应对高并发的请求，会通过负载均衡（Load Balancer）组成集群来对外透明的提供服务。负载均衡会通过“心跳检测”来监控服务器状态，当发现不可用机器时将其从集群中剔除，并将该机器的路由设置为不可用，同时所有请求将转发到集群内的其他机器。服务层的机器与应用层类似。位于数据层的服务器比较特殊，为了保证数据不丢失，我们需要在数据写入时同时对集群内的其他服务器同步复制数据，以保证数据的一致性和可用性。</p>\n<h4 id=\"三、高可用的应用：\"><a href=\"#三、高可用的应用：\" class=\"headerlink\" title=\"三、高可用的应用：\"></a>三、高可用的应用：</h4><p>由于应用层主要负责对业务的处理，为了使用集群来提高应用服务的高可用性，我们将应用层设计成无状态的服务，即不在应用服务器本地保存用户的会话状态信息（比如 Session）。这样的做的目的是为了让集群内的所有服务器对等，在负载均衡调度请求时可以无差别对待。而用户的状态信息我们会用专门的方式来进行管理。</p>\n<p>由于<strong>业务总是有状态的</strong>，在单机情况下，我们将会话信息交由服务器上的 Web 容器来管理。但对于集群环境来说，我们通常使用以下几种方式来处理：</p>\n<ul>\n<li><strong>Session 复制</strong>：所有应用服务器在本地共享同一套会话信息，且每次新增的会话都会在整个应用集群内进行复制。随着会话数量的增加及应用集群的扩大，系统压力会成倍增长，因此只适用于小型集群；</li>\n<li><strong>Session 绑定</strong>：负载均衡服务器将同一 IP 来源的所有请求绑定在固定的应用服务器上，该方式又被称为“会话粘滞”，但其整体并不符合高可用的特性；</li>\n<li><strong>利用 Cookie</strong>：将用户的会话信息存储在客户端的浏览器中，安全性低、影响传输性能、受到浏览器限制：</li>\n<li><strong>Session 服务器</strong>：使用专门的 Session 集群，由负载均衡调度，可以利用分布式缓存 / 数据库来进行包装：</li>\n</ul>\n<h4 id=\"四、高可用的服务：\"><a href=\"#四、高可用的服务：\" class=\"headerlink\" title=\"四、高可用的服务：\"></a>四、高可用的服务：</h4><p>高可用的服务一定是<strong>独立的</strong>、<strong>可复用的</strong>。服务的设计同样需要遵循几个原则：<strong>分级管理</strong>（核心应用和服务优先使用更好的硬件，核心服务和数据需要部署在不同地域的数据中心，低优先级的服务甚至可以只使用多线程来隔离）、<strong>超时设置</strong>（设置服务的远程调用超时时间，某一台机器超过规定的响应时间即由集群 Leader 或负载均衡重新分配资源）、<strong>异步调用</strong>（将一次完整的业务流程拆分，比如发送成功邮件等任务，可以延后执行的步骤均放在消息队列中异步进行，即使用传统的消费者模式）、<strong>服务降级</strong>（在并发数较高的情况下，可以通过适当关闭不必要的低优先级服务来节约系统性能，或者通过随机拒绝服务的方式，将压力分散）、<strong>幂等设计</strong>（我们无法确定一次失败的服务请求是否真的失败了，为了避免服务的二次调用产生“非预期”的结构，我们需要将服务调用幂等化，即一次调用和多次调用产生的效果是一致的）。</p>\n<h4 id=\"五、高可用的数据：\"><a href=\"#五、高可用的数据：\" class=\"headerlink\" title=\"五、高可用的数据：\"></a>五、高可用的数据：</h4><p>保证高可用数据的手段主要是“数据备份”和“失效转移”。一般为了保证数据高可用，我们可能会牺牲另一个指标，即：”数据一致性“。高可用数据一般包括“<strong>数据持久性</strong>”、“<strong>数据可用性</strong>”和“<strong>数据一致性</strong>”三个指标。根据 CAP 原理，一个数据服务的存储系统是无法同时满足数据一致性（Consistency）、数据可用性（Availibility）和分区耐受性（Partition Tolerance）的。数据一致性即：所有应用都能访问到相同的数据；数据可用性即：任何时候，任何应用都可以进行数据读写；分区耐受性指：系统可以跨网络分区线性的伸缩。由于 A 和 P 两个指标较 C 更为重要，我们既然放弃了数据的强一致性，退而求其次在不影响用户体验时，可以选择保障数据用户一致。</p>\n<p>常用的数据备份方式分为<strong>热备份</strong>和<strong>冷备份</strong>。冷备份是一种古老而有效的数据保护手段，主要通过定期将数据复制到存储介质上并物理存档保存来保护数据。缺点是不能保证数据的最终一致（最弱的一致性，系统经过一段时间的自我恢复和修正最终达到一致），而且在数据备份时需要宕机。热备份是一种实时备份的数据保护方式，分为异步热备和同步热备。同时对于关系型数据库来说，热备机制的 “Master-Slave” 同步机制还可以通过读写分离的方式来改善数据库性能。</p>\n<p>失效转移一般通过心跳检测或者应用程序的访问失败报告来进行通知，控制中心在收到失败报告时会再次通过心跳检测来进行确认，如果确认失败则将该机器路由转移到其他可用机器上。</p>\n<h4 id=\"六、高可用的软件质量保证：\"><a href=\"#六、高可用的软件质量保证：\" class=\"headerlink\" title=\"六、高可用的软件质量保证：\"></a>六、高可用的软件质量保证：</h4><p>比如我们在发布软件的新版本时一定要注意不能影响原有的线上正在运行中的服务。因此我们一般通过发布脚本每次只关闭一部分集群的机器，进行软件更新，然后启用。再关闭另一部分机器，重复上述过程。在软件发布之前还需要进行“预发布”，即先发布到线上集群中一台<strong>只有内网能够访问</strong>到的机器，但使用的是线上数据，在通过内部测试无误后再逐渐全量地发布到线上。</p>\n<p>同时对于大型网站的软件发布，我们可以采用“<strong>灰度发布</strong>”的方式，即：一段时间内只发布线上集群中的一部分机器，待观察一段时间没有问题后，再逐渐发布集群内的其他机器。在进行“灰度发布”的同时，我们甚至可以进行“A/B测试”，以新发布的机器作为对照组，查看新旧软件使用用户的反馈情况。</p>\n<p>另一方面，也需要对网站进行全天候的实时监控。比如监控服务端日志、客户端日志、运行数据报告（缓存命中率、平均响应延迟等）。甚至要做到自动检测系统报警并向 Leader 机器反馈，可以即时做到系统失效转移，以及优雅降级（高并发、高压力时自动关闭某些低优先级的服务）等操作。</p>\n","site":{"data":{}},"id":"01cf95dc44e12c59e7d05b3c7c6b66f5","excerpt":"","more":"<p>第三篇总结，主要围绕着如何从多方面进行“高可用的网站架构”展开。网站页面能够完整呈现在最终用户面前，需要经过多个环节，任何一个环节出了问题，都可能导致网站页面不可访问，服务中断。网络请求的情况千变万化，可能一个“突然来袭”的实时热点访问，都会把你的网站重重拖垮。</p>\n<h4 id=\"一、可用性度量：\"><a href=\"#一、可用性度量：\" class=\"headerlink\" title=\"一、可用性度量：\"></a>一、可用性度量：</h4><p>我们通常使用“多个9”来衡量网站的可用性，比如“4个9”代表一个服务 99.99% 可用，即需要保证在单位时间内只有最多 0.01% 的时间内可以发生服务不可用的故障。而“2个9”与“3个9”的意思也同样如此。但对于网站整体而言，想要达到“4个9”甚至更高的可用性，除了过硬的技术、大量的设备及资金投入外还需要有个好运气。</p>\n<p>一般为了将网站的可用性指标转换成对应的责任度量下放到个人或者组织，我们一般使用“故障分”来对网站的单位时间故障进行加权计算，进而将责任分担下放到个人，加入其年度的绩效考核中。比如可以对不同级别的故障类型划分不同的权重分，再通过对应类型故障的发生时间来得到该故障的故障分。</p>\n<h4 id=\"二、高可用的整体架构：\"><a href=\"#二、高可用的整体架构：\" class=\"headerlink\" title=\"二、高可用的整体架构：\"></a>二、高可用的整体架构：</h4><p>我们一般将网站架构分为三层：<strong>应用层</strong>、<strong>服务层</strong>、<strong>数据层</strong>；应用层负责业务逻辑处理，服务层提供可复用的服务，数据层负责数据的封装与存储，各层之间相对独立。由于网站的架构资源中，硬件故障是最常见的问题。那么高可用架构的主要目的就是保证服务器在硬件故障时依然可用。其主要手段是：<strong>数据和服务的冗余备份以及失效转移</strong>。</p>\n<p><img src=\"1.jpg\" alt></p>\n<p>位于应用层的服务器通常为了应对高并发的请求，会通过负载均衡（Load Balancer）组成集群来对外透明的提供服务。负载均衡会通过“心跳检测”来监控服务器状态，当发现不可用机器时将其从集群中剔除，并将该机器的路由设置为不可用，同时所有请求将转发到集群内的其他机器。服务层的机器与应用层类似。位于数据层的服务器比较特殊，为了保证数据不丢失，我们需要在数据写入时同时对集群内的其他服务器同步复制数据，以保证数据的一致性和可用性。</p>\n<h4 id=\"三、高可用的应用：\"><a href=\"#三、高可用的应用：\" class=\"headerlink\" title=\"三、高可用的应用：\"></a>三、高可用的应用：</h4><p>由于应用层主要负责对业务的处理，为了使用集群来提高应用服务的高可用性，我们将应用层设计成无状态的服务，即不在应用服务器本地保存用户的会话状态信息（比如 Session）。这样的做的目的是为了让集群内的所有服务器对等，在负载均衡调度请求时可以无差别对待。而用户的状态信息我们会用专门的方式来进行管理。</p>\n<p>由于<strong>业务总是有状态的</strong>，在单机情况下，我们将会话信息交由服务器上的 Web 容器来管理。但对于集群环境来说，我们通常使用以下几种方式来处理：</p>\n<ul>\n<li><strong>Session 复制</strong>：所有应用服务器在本地共享同一套会话信息，且每次新增的会话都会在整个应用集群内进行复制。随着会话数量的增加及应用集群的扩大，系统压力会成倍增长，因此只适用于小型集群；</li>\n<li><strong>Session 绑定</strong>：负载均衡服务器将同一 IP 来源的所有请求绑定在固定的应用服务器上，该方式又被称为“会话粘滞”，但其整体并不符合高可用的特性；</li>\n<li><strong>利用 Cookie</strong>：将用户的会话信息存储在客户端的浏览器中，安全性低、影响传输性能、受到浏览器限制：</li>\n<li><strong>Session 服务器</strong>：使用专门的 Session 集群，由负载均衡调度，可以利用分布式缓存 / 数据库来进行包装：</li>\n</ul>\n<h4 id=\"四、高可用的服务：\"><a href=\"#四、高可用的服务：\" class=\"headerlink\" title=\"四、高可用的服务：\"></a>四、高可用的服务：</h4><p>高可用的服务一定是<strong>独立的</strong>、<strong>可复用的</strong>。服务的设计同样需要遵循几个原则：<strong>分级管理</strong>（核心应用和服务优先使用更好的硬件，核心服务和数据需要部署在不同地域的数据中心，低优先级的服务甚至可以只使用多线程来隔离）、<strong>超时设置</strong>（设置服务的远程调用超时时间，某一台机器超过规定的响应时间即由集群 Leader 或负载均衡重新分配资源）、<strong>异步调用</strong>（将一次完整的业务流程拆分，比如发送成功邮件等任务，可以延后执行的步骤均放在消息队列中异步进行，即使用传统的消费者模式）、<strong>服务降级</strong>（在并发数较高的情况下，可以通过适当关闭不必要的低优先级服务来节约系统性能，或者通过随机拒绝服务的方式，将压力分散）、<strong>幂等设计</strong>（我们无法确定一次失败的服务请求是否真的失败了，为了避免服务的二次调用产生“非预期”的结构，我们需要将服务调用幂等化，即一次调用和多次调用产生的效果是一致的）。</p>\n<h4 id=\"五、高可用的数据：\"><a href=\"#五、高可用的数据：\" class=\"headerlink\" title=\"五、高可用的数据：\"></a>五、高可用的数据：</h4><p>保证高可用数据的手段主要是“数据备份”和“失效转移”。一般为了保证数据高可用，我们可能会牺牲另一个指标，即：”数据一致性“。高可用数据一般包括“<strong>数据持久性</strong>”、“<strong>数据可用性</strong>”和“<strong>数据一致性</strong>”三个指标。根据 CAP 原理，一个数据服务的存储系统是无法同时满足数据一致性（Consistency）、数据可用性（Availibility）和分区耐受性（Partition Tolerance）的。数据一致性即：所有应用都能访问到相同的数据；数据可用性即：任何时候，任何应用都可以进行数据读写；分区耐受性指：系统可以跨网络分区线性的伸缩。由于 A 和 P 两个指标较 C 更为重要，我们既然放弃了数据的强一致性，退而求其次在不影响用户体验时，可以选择保障数据用户一致。</p>\n<p>常用的数据备份方式分为<strong>热备份</strong>和<strong>冷备份</strong>。冷备份是一种古老而有效的数据保护手段，主要通过定期将数据复制到存储介质上并物理存档保存来保护数据。缺点是不能保证数据的最终一致（最弱的一致性，系统经过一段时间的自我恢复和修正最终达到一致），而且在数据备份时需要宕机。热备份是一种实时备份的数据保护方式，分为异步热备和同步热备。同时对于关系型数据库来说，热备机制的 “Master-Slave” 同步机制还可以通过读写分离的方式来改善数据库性能。</p>\n<p>失效转移一般通过心跳检测或者应用程序的访问失败报告来进行通知，控制中心在收到失败报告时会再次通过心跳检测来进行确认，如果确认失败则将该机器路由转移到其他可用机器上。</p>\n<h4 id=\"六、高可用的软件质量保证：\"><a href=\"#六、高可用的软件质量保证：\" class=\"headerlink\" title=\"六、高可用的软件质量保证：\"></a>六、高可用的软件质量保证：</h4><p>比如我们在发布软件的新版本时一定要注意不能影响原有的线上正在运行中的服务。因此我们一般通过发布脚本每次只关闭一部分集群的机器，进行软件更新，然后启用。再关闭另一部分机器，重复上述过程。在软件发布之前还需要进行“预发布”，即先发布到线上集群中一台<strong>只有内网能够访问</strong>到的机器，但使用的是线上数据，在通过内部测试无误后再逐渐全量地发布到线上。</p>\n<p>同时对于大型网站的软件发布，我们可以采用“<strong>灰度发布</strong>”的方式，即：一段时间内只发布线上集群中的一部分机器，待观察一段时间没有问题后，再逐渐发布集群内的其他机器。在进行“灰度发布”的同时，我们甚至可以进行“A/B测试”，以新发布的机器作为对照组，查看新旧软件使用用户的反馈情况。</p>\n<p>另一方面，也需要对网站进行全天候的实时监控。比如监控服务端日志、客户端日志、运行数据报告（缓存命中率、平均响应延迟等）。甚至要做到自动检测系统报警并向 Leader 机器反馈，可以即时做到系统失效转移，以及优雅降级（高并发、高压力时自动关闭某些低优先级的服务）等操作。</p>\n"},{"title":"不得不防范的 iframe 非法嵌入","intro":"Web 工程师在 iframe 标签上的讨论一直不少，包括其可以用来进行跨域，以及便于开发的特性。但从另一方面来看它的存在又不利于对页面进行 SEO 优化，并且同时会降低网站整体的安全性。说到 iframe 的安全性问题，利用 iframe 来非法嵌入正规官方网站的页面，同时在自己页面两边打着自己产品的标语，宣称自己与正规网站合作来推销自己产品的例子，并不少见。","comments":1,"date":"2015-08-12T14:08:46.000Z","_content":"\nWeb 工程师在 `iframe` 标签上的讨论一直不少，包括其可以用来进行跨域，以及便于开发的特性。但从另一方面来看它的存在又不利于对页面进行 SEO 优化，并且同时会降低网站整体的安全性。说到 `iframe` 的安全性问题，利用 `iframe` 来非法嵌入正规官方网站的页面，同时在自己页面两边打着自己产品的标语，宣称自己与正规网站合作来推销自己产品的例子，并不少见。\n\n那么应该如何保护自己的网站不被非法分子利用呢？其实很简单，一小段 JavaScript 代码即可：\n\n```javascript\n    if (window != top)\n        top.location.href = window.location.href; \n```\n\n即通过 JS 来判断当前页面所处的 DOM 对象是否是最顶层页面。因为在最顶层页面中，`window` 对象即等于 `top` 对象，如果不相等便将当前最顶层的页面（即非法分子的主页面）跳转到 `iframe` 中的页面。但是这段代码有一个问题，即自己的网站也无法使用 `iframe` 来嵌入自己的页面。解决方法很简单，我们稍微改进一下：\n```javascript\n    var myDomain = \"abc\";\n    var webHost = top.location.href;\n    var tempArr = webHost.split(\".\");\n    if (tempArr.indexOf(myDomain) == -1) {\n        if (window != top)\n            top.location.href = window.location.href;\n    }\n```\n\n通过 `top` 对象的 `href` 属性来判断当前顶层页面的域名是否为自己网站的域名即可。只需要把这里的 “myDomain” 替换成自己网站域名的二/三级域名部分。然后再把这段代码放入页面的 `onload` 事件中即可完成对网站的保护。\n","source":"_posts/不得不防范的-iframe-非法嵌入.md","raw":"---\ntitle: 不得不防范的 iframe 非法嵌入\nintro: Web 工程师在 iframe 标签上的讨论一直不少，包括其可以用来进行跨域，以及便于开发的特性。但从另一方面来看它的存在又不利于对页面进行 SEO 优化，并且同时会降低网站整体的安全性。说到 iframe 的安全性问题，利用 iframe 来非法嵌入正规官方网站的页面，同时在自己页面两边打着自己产品的标语，宣称自己与正规网站合作来推销自己产品的例子，并不少见。\ncomments: true\ndate: 2015-08-12 22:08:46\ntags:\n- JavaScript\n---\n\nWeb 工程师在 `iframe` 标签上的讨论一直不少，包括其可以用来进行跨域，以及便于开发的特性。但从另一方面来看它的存在又不利于对页面进行 SEO 优化，并且同时会降低网站整体的安全性。说到 `iframe` 的安全性问题，利用 `iframe` 来非法嵌入正规官方网站的页面，同时在自己页面两边打着自己产品的标语，宣称自己与正规网站合作来推销自己产品的例子，并不少见。\n\n那么应该如何保护自己的网站不被非法分子利用呢？其实很简单，一小段 JavaScript 代码即可：\n\n```javascript\n    if (window != top)\n        top.location.href = window.location.href; \n```\n\n即通过 JS 来判断当前页面所处的 DOM 对象是否是最顶层页面。因为在最顶层页面中，`window` 对象即等于 `top` 对象，如果不相等便将当前最顶层的页面（即非法分子的主页面）跳转到 `iframe` 中的页面。但是这段代码有一个问题，即自己的网站也无法使用 `iframe` 来嵌入自己的页面。解决方法很简单，我们稍微改进一下：\n```javascript\n    var myDomain = \"abc\";\n    var webHost = top.location.href;\n    var tempArr = webHost.split(\".\");\n    if (tempArr.indexOf(myDomain) == -1) {\n        if (window != top)\n            top.location.href = window.location.href;\n    }\n```\n\n通过 `top` 对象的 `href` 属性来判断当前顶层页面的域名是否为自己网站的域名即可。只需要把这里的 “myDomain” 替换成自己网站域名的二/三级域名部分。然后再把这段代码放入页面的 `onload` 事件中即可完成对网站的保护。\n","slug":"不得不防范的-iframe-非法嵌入","published":1,"updated":"2019-02-04T16:51:24.341Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtal005fknp2atx236c1","content":"<p>Web 工程师在 <code>iframe</code> 标签上的讨论一直不少，包括其可以用来进行跨域，以及便于开发的特性。但从另一方面来看它的存在又不利于对页面进行 SEO 优化，并且同时会降低网站整体的安全性。说到 <code>iframe</code> 的安全性问题，利用 <code>iframe</code> 来非法嵌入正规官方网站的页面，同时在自己页面两边打着自己产品的标语，宣称自己与正规网站合作来推销自己产品的例子，并不少见。</p>\n<p>那么应该如何保护自己的网站不被非法分子利用呢？其实很简单，一小段 JavaScript 代码即可：</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\">    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>window <span class=\"token operator\">!=</span> top<span class=\"token punctuation\">)</span>\n        top<span class=\"token punctuation\">.</span>location<span class=\"token punctuation\">.</span>href <span class=\"token operator\">=</span> window<span class=\"token punctuation\">.</span>location<span class=\"token punctuation\">.</span>href<span class=\"token punctuation\">;</span> \n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>即通过 JS 来判断当前页面所处的 DOM 对象是否是最顶层页面。因为在最顶层页面中，<code>window</code> 对象即等于 <code>top</code> 对象，如果不相等便将当前最顶层的页面（即非法分子的主页面）跳转到 <code>iframe</code> 中的页面。但是这段代码有一个问题，即自己的网站也无法使用 <code>iframe</code> 来嵌入自己的页面。解决方法很简单，我们稍微改进一下：</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\">    <span class=\"token keyword\">var</span> myDomain <span class=\"token operator\">=</span> <span class=\"token string\">\"abc\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> webHost <span class=\"token operator\">=</span> top<span class=\"token punctuation\">.</span>location<span class=\"token punctuation\">.</span>href<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> tempArr <span class=\"token operator\">=</span> webHost<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">\".\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>tempArr<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span>myDomain<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>window <span class=\"token operator\">!=</span> top<span class=\"token punctuation\">)</span>\n            top<span class=\"token punctuation\">.</span>location<span class=\"token punctuation\">.</span>href <span class=\"token operator\">=</span> window<span class=\"token punctuation\">.</span>location<span class=\"token punctuation\">.</span>href<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>通过 <code>top</code> 对象的 <code>href</code> 属性来判断当前顶层页面的域名是否为自己网站的域名即可。只需要把这里的 “myDomain” 替换成自己网站域名的二/三级域名部分。然后再把这段代码放入页面的 <code>onload</code> 事件中即可完成对网站的保护。</p>\n","site":{"data":{}},"id":"9f29a91ec18d9659d768b981f5d11955","excerpt":"","more":"<p>Web 工程师在 <code>iframe</code> 标签上的讨论一直不少，包括其可以用来进行跨域，以及便于开发的特性。但从另一方面来看它的存在又不利于对页面进行 SEO 优化，并且同时会降低网站整体的安全性。说到 <code>iframe</code> 的安全性问题，利用 <code>iframe</code> 来非法嵌入正规官方网站的页面，同时在自己页面两边打着自己产品的标语，宣称自己与正规网站合作来推销自己产品的例子，并不少见。</p>\n<p>那么应该如何保护自己的网站不被非法分子利用呢？其实很简单，一小段 JavaScript 代码即可：</p>\n<pre><code class=\"javascript\">    if (window != top)\n        top.location.href = window.location.href; \n</code></pre>\n<p>即通过 JS 来判断当前页面所处的 DOM 对象是否是最顶层页面。因为在最顶层页面中，<code>window</code> 对象即等于 <code>top</code> 对象，如果不相等便将当前最顶层的页面（即非法分子的主页面）跳转到 <code>iframe</code> 中的页面。但是这段代码有一个问题，即自己的网站也无法使用 <code>iframe</code> 来嵌入自己的页面。解决方法很简单，我们稍微改进一下：</p>\n<pre><code class=\"javascript\">    var myDomain = &quot;abc&quot;;\n    var webHost = top.location.href;\n    var tempArr = webHost.split(&quot;.&quot;);\n    if (tempArr.indexOf(myDomain) == -1) {\n        if (window != top)\n            top.location.href = window.location.href;\n    }\n</code></pre>\n<p>通过 <code>top</code> 对象的 <code>href</code> 属性来判断当前顶层页面的域名是否为自己网站的域名即可。只需要把这里的 “myDomain” 替换成自己网站域名的二/三级域名部分。然后再把这段代码放入页面的 <code>onload</code> 事件中即可完成对网站的保护。</p>\n"},{"title":"五分钟算法 - 二分法查找（Binary Search）","intro":"二分法查找（Binary Search）顾名思义就是利用“二分法”从一个特定的已排序序列集合（Sorted Array）中来查找指定大小或维度值的位置。但对于一个容量比较小的集合来说，一般通过完全“遍历”（时间复杂度 T(n) = O(n)）来查找特定元素的位置即可。","comments":1,"date":"2016-04-09T01:09:20.000Z","_content":"\n二分法查找（Binary Search）顾名思义就是利用“二分法”从一个特定的已排序序列集合（Sorted Array）中来查找指定大小或维度值的位置。但对于一个容量比较小的集合来说，一般通过完全“遍历”（时间复杂度 T(n) = O(n)）来查找特定元素的位置即可。\n\n但对于一个容量较大的集合（几十万到几百万）来说，使用“遍历”的方式来查找特定元素其效率就显得比较低下了，O(n) 的时间复杂度并不能满足我们追求高性能算法的需求。而在这里通过使用二分法查找（Binary Search）便可以使元素的查找效率显著地增加。二分法查找的具体思路如下（这里使用数组进行举例）：\n\n1. 给定一个已排序好的数组（此处假定为递增数组）；\n2. 首先将目标值（Target）与数组的中间位置元素值（Middle）进行大小比较；\n3. 如果目标值（Target）小于中间位置元素值（Middle）则去掉数组的后半段，因为对于递增数组，目标值（Target）肯定在该数组的前半段；\n4. 再次将目标值（Target）与数组剩余部分的中间位置元素值（Middle）进行大小比较；\n5. 如果目标值（Target）大于中间位置元素值（Middle）则去掉数组的前半段，因为对于递增数组，目标值（Target）肯定在该数组的后半段；\n6. 依次重复进行上边四步的两种情况，直到找到目标值的位置；\n\n![](1.jpg)\n\n\n上述算法的思路对于递减排列的数组也同样适用，下面给出一道例题，和该题对应的解决方案代码（Java 实现）：\n\n> 给出一个已排序的递增数组 [1, 2, 3, 3, 4, 5, 5, 5, 6, 7, 8, 10, 11]，请利用二分法查找（Binary Search）给出该数组中数字5最后一次出现的位置。\n\n解题代码，仅供参考：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n\t    // 给定数组；\n        Int [] sortedArray = {1, 2, 3, 3, 4, 5, 5, 5, 6, 7, 8, 10, 11};\n\t    // 调用方法；\n        System.out.print(Main.binarySearchLastPos(sortedArray, 5));\n    }\n\n    public static int binarySearchLastPos(int[] nums, int target) {\n        // 判断数组是否合法；\n        if (nums == null || nums.length == 0) {\n            return -1;\n        }  \n        // 设置标志，初始化时start为0，end为数组长度减1，即分别指向头尾；\n        int start = 0, end = nums.length - 1;\n        \n        // Main method (find the last position of the target)\n        // if start = 1, end = 2;\n        // if then nums[1] = target, mid = (start + end) / 2 = 1\n        // cause endless loop\n\n        while (start + 1 &lt; end) {\n            int mid = (start + end) / 2;  // 中间指针指向数组中间元素；\n            \n            // Better usage, in case of over range\n            // int mid = start + (end - start) / 2;\n            \n            // 根据三种不同情况分别移动首尾指针；\n            if (nums[mid] == target) {\n                start = mid;  \n            } else if (nums[mid] &lt; target) {\n                start = mid;\n            } else if (nums[mid] &gt; target) {\n                end = mid;\n            }\n        }\n        if (nums[start] == target) {\n            return start;\n        }\n        if (nums[end] == target) {\n            return end;\n        }\n        return -1;\n    }\n}\n```\n\n\n二分法查找（Binary Search）的**时间复杂度**：可以推算，一次 O(1) 的操作会将数组长度变为二分之一，两次 O(1) 的操作会将数组长度变为四分之一，三次 O(1) 的操作会将数组长度变为八分之一，n 次 O(1) 的操作会将数组长度变为2的 n 次方分之一，以此类推 “T(n) = T(n/2) + O(1) = T(n/4) + O(2) = ...” 可以得到该算法的时间复杂度为 “**O(logn)**”，即最多执行 logn 次该算法便可得到最后的结果。\n","source":"_posts/五分钟算法-二分法查找（Binary-Search）.md","raw":"---\ntitle: 五分钟算法 - 二分法查找（Binary Search）\nintro: 二分法查找（Binary Search）顾名思义就是利用“二分法”从一个特定的已排序序列集合（Sorted Array）中来查找指定大小或维度值的位置。但对于一个容量比较小的集合来说，一般通过完全“遍历”（时间复杂度 T(n) = O(n)）来查找特定元素的位置即可。\ncomments: true\ndate: 2016-04-09 09:09:20\ntags:\n- 算法\n---\n\n二分法查找（Binary Search）顾名思义就是利用“二分法”从一个特定的已排序序列集合（Sorted Array）中来查找指定大小或维度值的位置。但对于一个容量比较小的集合来说，一般通过完全“遍历”（时间复杂度 T(n) = O(n)）来查找特定元素的位置即可。\n\n但对于一个容量较大的集合（几十万到几百万）来说，使用“遍历”的方式来查找特定元素其效率就显得比较低下了，O(n) 的时间复杂度并不能满足我们追求高性能算法的需求。而在这里通过使用二分法查找（Binary Search）便可以使元素的查找效率显著地增加。二分法查找的具体思路如下（这里使用数组进行举例）：\n\n1. 给定一个已排序好的数组（此处假定为递增数组）；\n2. 首先将目标值（Target）与数组的中间位置元素值（Middle）进行大小比较；\n3. 如果目标值（Target）小于中间位置元素值（Middle）则去掉数组的后半段，因为对于递增数组，目标值（Target）肯定在该数组的前半段；\n4. 再次将目标值（Target）与数组剩余部分的中间位置元素值（Middle）进行大小比较；\n5. 如果目标值（Target）大于中间位置元素值（Middle）则去掉数组的前半段，因为对于递增数组，目标值（Target）肯定在该数组的后半段；\n6. 依次重复进行上边四步的两种情况，直到找到目标值的位置；\n\n![](1.jpg)\n\n\n上述算法的思路对于递减排列的数组也同样适用，下面给出一道例题，和该题对应的解决方案代码（Java 实现）：\n\n> 给出一个已排序的递增数组 [1, 2, 3, 3, 4, 5, 5, 5, 6, 7, 8, 10, 11]，请利用二分法查找（Binary Search）给出该数组中数字5最后一次出现的位置。\n\n解题代码，仅供参考：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n\t    // 给定数组；\n        Int [] sortedArray = {1, 2, 3, 3, 4, 5, 5, 5, 6, 7, 8, 10, 11};\n\t    // 调用方法；\n        System.out.print(Main.binarySearchLastPos(sortedArray, 5));\n    }\n\n    public static int binarySearchLastPos(int[] nums, int target) {\n        // 判断数组是否合法；\n        if (nums == null || nums.length == 0) {\n            return -1;\n        }  \n        // 设置标志，初始化时start为0，end为数组长度减1，即分别指向头尾；\n        int start = 0, end = nums.length - 1;\n        \n        // Main method (find the last position of the target)\n        // if start = 1, end = 2;\n        // if then nums[1] = target, mid = (start + end) / 2 = 1\n        // cause endless loop\n\n        while (start + 1 &lt; end) {\n            int mid = (start + end) / 2;  // 中间指针指向数组中间元素；\n            \n            // Better usage, in case of over range\n            // int mid = start + (end - start) / 2;\n            \n            // 根据三种不同情况分别移动首尾指针；\n            if (nums[mid] == target) {\n                start = mid;  \n            } else if (nums[mid] &lt; target) {\n                start = mid;\n            } else if (nums[mid] &gt; target) {\n                end = mid;\n            }\n        }\n        if (nums[start] == target) {\n            return start;\n        }\n        if (nums[end] == target) {\n            return end;\n        }\n        return -1;\n    }\n}\n```\n\n\n二分法查找（Binary Search）的**时间复杂度**：可以推算，一次 O(1) 的操作会将数组长度变为二分之一，两次 O(1) 的操作会将数组长度变为四分之一，三次 O(1) 的操作会将数组长度变为八分之一，n 次 O(1) 的操作会将数组长度变为2的 n 次方分之一，以此类推 “T(n) = T(n/2) + O(1) = T(n/4) + O(2) = ...” 可以得到该算法的时间复杂度为 “**O(logn)**”，即最多执行 logn 次该算法便可得到最后的结果。\n","slug":"五分钟算法-二分法查找（Binary-Search）","published":1,"updated":"2019-02-07T03:50:00.581Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtam005iknp2zvp6il7j","content":"<p>二分法查找（Binary Search）顾名思义就是利用“二分法”从一个特定的已排序序列集合（Sorted Array）中来查找指定大小或维度值的位置。但对于一个容量比较小的集合来说，一般通过完全“遍历”（时间复杂度 T(n) = O(n)）来查找特定元素的位置即可。</p>\n<p>但对于一个容量较大的集合（几十万到几百万）来说，使用“遍历”的方式来查找特定元素其效率就显得比较低下了，O(n) 的时间复杂度并不能满足我们追求高性能算法的需求。而在这里通过使用二分法查找（Binary Search）便可以使元素的查找效率显著地增加。二分法查找的具体思路如下（这里使用数组进行举例）：</p>\n<ol>\n<li>给定一个已排序好的数组（此处假定为递增数组）；</li>\n<li>首先将目标值（Target）与数组的中间位置元素值（Middle）进行大小比较；</li>\n<li>如果目标值（Target）小于中间位置元素值（Middle）则去掉数组的后半段，因为对于递增数组，目标值（Target）肯定在该数组的前半段；</li>\n<li>再次将目标值（Target）与数组剩余部分的中间位置元素值（Middle）进行大小比较；</li>\n<li>如果目标值（Target）大于中间位置元素值（Middle）则去掉数组的前半段，因为对于递增数组，目标值（Target）肯定在该数组的后半段；</li>\n<li>依次重复进行上边四步的两种情况，直到找到目标值的位置；</li>\n</ol>\n<p><img src=\"1.jpg\" alt></p>\n<p>上述算法的思路对于递减排列的数组也同样适用，下面给出一道例题，和该题对应的解决方案代码（Java 实现）：</p>\n<blockquote>\n<p>给出一个已排序的递增数组 [1, 2, 3, 3, 4, 5, 5, 5, 6, 7, 8, 10, 11]，请利用二分法查找（Binary Search）给出该数组中数字5最后一次出现的位置。</p>\n</blockquote>\n<p>解题代码，仅供参考：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 给定数组；</span>\n        Int <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> sortedArray <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">11</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 调用方法；</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">print</span><span class=\"token punctuation\">(</span>Main<span class=\"token punctuation\">.</span><span class=\"token function\">binarySearchLastPos</span><span class=\"token punctuation\">(</span>sortedArray<span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">binarySearchLastPos</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> target<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 判断数组是否合法；</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nums <span class=\"token operator\">==</span> null <span class=\"token operator\">||</span> nums<span class=\"token punctuation\">.</span>length <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>  \n        <span class=\"token comment\" spellcheck=\"true\">// 设置标志，初始化时start为0，end为数组长度减1，即分别指向头尾；</span>\n        <span class=\"token keyword\">int</span> start <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> end <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// Main method (find the last position of the target)</span>\n        <span class=\"token comment\" spellcheck=\"true\">// if start = 1, end = 2;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// if then nums[1] = target, mid = (start + end) / 2 = 1</span>\n        <span class=\"token comment\" spellcheck=\"true\">// cause endless loop</span>\n\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>start <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span> end<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> mid <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>start <span class=\"token operator\">+</span> end<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 中间指针指向数组中间元素；</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">// Better usage, in case of over range</span>\n            <span class=\"token comment\" spellcheck=\"true\">// int mid = start + (end - start) / 2;</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">// 根据三种不同情况分别移动首尾指针；</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> target<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                start <span class=\"token operator\">=</span> mid<span class=\"token punctuation\">;</span>  \n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;</span>lt<span class=\"token punctuation\">;</span> target<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                start <span class=\"token operator\">=</span> mid<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;</span>gt<span class=\"token punctuation\">;</span> target<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                end <span class=\"token operator\">=</span> mid<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>start<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> target<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> start<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>end<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> target<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> end<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>二分法查找（Binary Search）的<strong>时间复杂度</strong>：可以推算，一次 O(1) 的操作会将数组长度变为二分之一，两次 O(1) 的操作会将数组长度变为四分之一，三次 O(1) 的操作会将数组长度变为八分之一，n 次 O(1) 的操作会将数组长度变为2的 n 次方分之一，以此类推 “T(n) = T(n/2) + O(1) = T(n/4) + O(2) = …” 可以得到该算法的时间复杂度为 “<strong>O(logn)</strong>”，即最多执行 logn 次该算法便可得到最后的结果。</p>\n","site":{"data":{}},"id":"f349b9ff99b4154489e4ff9b9f869f4a","excerpt":"","more":"<p>二分法查找（Binary Search）顾名思义就是利用“二分法”从一个特定的已排序序列集合（Sorted Array）中来查找指定大小或维度值的位置。但对于一个容量比较小的集合来说，一般通过完全“遍历”（时间复杂度 T(n) = O(n)）来查找特定元素的位置即可。</p>\n<p>但对于一个容量较大的集合（几十万到几百万）来说，使用“遍历”的方式来查找特定元素其效率就显得比较低下了，O(n) 的时间复杂度并不能满足我们追求高性能算法的需求。而在这里通过使用二分法查找（Binary Search）便可以使元素的查找效率显著地增加。二分法查找的具体思路如下（这里使用数组进行举例）：</p>\n<ol>\n<li>给定一个已排序好的数组（此处假定为递增数组）；</li>\n<li>首先将目标值（Target）与数组的中间位置元素值（Middle）进行大小比较；</li>\n<li>如果目标值（Target）小于中间位置元素值（Middle）则去掉数组的后半段，因为对于递增数组，目标值（Target）肯定在该数组的前半段；</li>\n<li>再次将目标值（Target）与数组剩余部分的中间位置元素值（Middle）进行大小比较；</li>\n<li>如果目标值（Target）大于中间位置元素值（Middle）则去掉数组的前半段，因为对于递增数组，目标值（Target）肯定在该数组的后半段；</li>\n<li>依次重复进行上边四步的两种情况，直到找到目标值的位置；</li>\n</ol>\n<p><img src=\"1.jpg\" alt></p>\n<p>上述算法的思路对于递减排列的数组也同样适用，下面给出一道例题，和该题对应的解决方案代码（Java 实现）：</p>\n<blockquote>\n<p>给出一个已排序的递增数组 [1, 2, 3, 3, 4, 5, 5, 5, 6, 7, 8, 10, 11]，请利用二分法查找（Binary Search）给出该数组中数字5最后一次出现的位置。</p>\n</blockquote>\n<p>解题代码，仅供参考：</p>\n<pre><code class=\"java\">public class Main {\n    public static void main(String[] args) {\n        // 给定数组；\n        Int [] sortedArray = {1, 2, 3, 3, 4, 5, 5, 5, 6, 7, 8, 10, 11};\n        // 调用方法；\n        System.out.print(Main.binarySearchLastPos(sortedArray, 5));\n    }\n\n    public static int binarySearchLastPos(int[] nums, int target) {\n        // 判断数组是否合法；\n        if (nums == null || nums.length == 0) {\n            return -1;\n        }  \n        // 设置标志，初始化时start为0，end为数组长度减1，即分别指向头尾；\n        int start = 0, end = nums.length - 1;\n\n        // Main method (find the last position of the target)\n        // if start = 1, end = 2;\n        // if then nums[1] = target, mid = (start + end) / 2 = 1\n        // cause endless loop\n\n        while (start + 1 &amp;lt; end) {\n            int mid = (start + end) / 2;  // 中间指针指向数组中间元素；\n\n            // Better usage, in case of over range\n            // int mid = start + (end - start) / 2;\n\n            // 根据三种不同情况分别移动首尾指针；\n            if (nums[mid] == target) {\n                start = mid;  \n            } else if (nums[mid] &amp;lt; target) {\n                start = mid;\n            } else if (nums[mid] &amp;gt; target) {\n                end = mid;\n            }\n        }\n        if (nums[start] == target) {\n            return start;\n        }\n        if (nums[end] == target) {\n            return end;\n        }\n        return -1;\n    }\n}\n</code></pre>\n<p>二分法查找（Binary Search）的<strong>时间复杂度</strong>：可以推算，一次 O(1) 的操作会将数组长度变为二分之一，两次 O(1) 的操作会将数组长度变为四分之一，三次 O(1) 的操作会将数组长度变为八分之一，n 次 O(1) 的操作会将数组长度变为2的 n 次方分之一，以此类推 “T(n) = T(n/2) + O(1) = T(n/4) + O(2) = …” 可以得到该算法的时间复杂度为 “<strong>O(logn)</strong>”，即最多执行 logn 次该算法便可得到最后的结果。</p>\n"},{"title":"今日商业评论 — 瑞幸咖啡 VS 星巴克，如何互补？","intro":"瑞幸咖啡凭借大量补贴和快速开店的策略，在国内咖啡市场快速扩张，目前门店已经超过2000家，预计今年还将新开2500家门店。快速发展的背后是瑞幸的高额亏损，累计亏损超过8亿元，且亏损还在持续扩大。若瑞幸一直持续补贴，没有明确的盈利模式，其资金链必将受到影响。而作为咖啡市场老大的星巴克，由于瑞幸咖啡的崛起，在中国也出现了增长乏力的现象。你认为瑞幸和星巴克在营业模式上有哪些值得相互学习的地方？","comments":1,"date":"2019-02-28T06:30:40.000Z","_content":"\n> 瑞幸咖啡凭借大量补贴和快速开店的策略，在国内咖啡市场快速扩张，目前门店已经超过2000家，预计今年还将新开2500家门店。快速发展的背后是瑞幸的高额亏损，累计亏损超过8亿元，且亏损还在持续扩大。若瑞幸一直持续补贴，没有明确的盈利模式，其资金链必将受到影响。而作为咖啡市场老大的星巴克，由于瑞幸咖啡的崛起，在中国也出现了增长乏力的现象。你认为瑞幸和星巴克在营业模式上有哪些值得相互学习的地方？\n\n#### 我的短评：\n\n个人觉得瑞幸可以尝试学习 “拼多多/趣头条” 从二三四线城市入手。像我的老家一个二线城市，从去年起才刚刚开始有星巴克的门店入驻，到现在也才不过三四家。虽然相比一线城市，二三四线城市的人群需要主动去培养其“喝咖啡”的用户心智，但综合来看二三四线城市的特点：\n\n1. 店铺租金低；\n2. 人群对价格敏感；\n3. 人群对品牌不敏感；\n\n这三个特点会成为瑞幸很好的布局入口。而反观一线城市人群，毕竟咖啡不是强需求，有喝咖啡习惯的人大多对品牌\\口感敏感、对价格不敏感，低价策略很难奏效。头部资源毕竟有限，除非瑞幸能有独特的卖点，否则一直补贴很难突破。而一旦融资不够用，客户群还没培养起来，那就晚了。\n\n另一方面，个人觉得瑞幸想在一线深入无非是认为流量大、客户群多，从头部市场抢资源。在当前国内各路 VC 都以用户流量多少作为重要投资指标的这个“浮躁”的时代，瑞幸可能已经想好了在最坏情况下“最好”的退出手段。但现实中其本身没有足够的技术来降低产品的制作成本，并同时提高品质。靠着对标竞品和一系列运营手段（附加价值）来提升用户心中认同的品牌感，做着赔本的买卖最后可能还是会无疾而终。\n","source":"_posts/今日商业评论—瑞幸咖啡VS星巴克，如何互补？.md","raw":"---\ntitle: 今日商业评论 — 瑞幸咖啡 VS 星巴克，如何互补？\nintro: 瑞幸咖啡凭借大量补贴和快速开店的策略，在国内咖啡市场快速扩张，目前门店已经超过2000家，预计今年还将新开2500家门店。快速发展的背后是瑞幸的高额亏损，累计亏损超过8亿元，且亏损还在持续扩大。若瑞幸一直持续补贴，没有明确的盈利模式，其资金链必将受到影响。而作为咖啡市场老大的星巴克，由于瑞幸咖啡的崛起，在中国也出现了增长乏力的现象。你认为瑞幸和星巴克在营业模式上有哪些值得相互学习的地方？\n\ncomments: true\ndate: 2019-02-28 14:30:40\ntags:\n- 商业评论\n---\n\n> 瑞幸咖啡凭借大量补贴和快速开店的策略，在国内咖啡市场快速扩张，目前门店已经超过2000家，预计今年还将新开2500家门店。快速发展的背后是瑞幸的高额亏损，累计亏损超过8亿元，且亏损还在持续扩大。若瑞幸一直持续补贴，没有明确的盈利模式，其资金链必将受到影响。而作为咖啡市场老大的星巴克，由于瑞幸咖啡的崛起，在中国也出现了增长乏力的现象。你认为瑞幸和星巴克在营业模式上有哪些值得相互学习的地方？\n\n#### 我的短评：\n\n个人觉得瑞幸可以尝试学习 “拼多多/趣头条” 从二三四线城市入手。像我的老家一个二线城市，从去年起才刚刚开始有星巴克的门店入驻，到现在也才不过三四家。虽然相比一线城市，二三四线城市的人群需要主动去培养其“喝咖啡”的用户心智，但综合来看二三四线城市的特点：\n\n1. 店铺租金低；\n2. 人群对价格敏感；\n3. 人群对品牌不敏感；\n\n这三个特点会成为瑞幸很好的布局入口。而反观一线城市人群，毕竟咖啡不是强需求，有喝咖啡习惯的人大多对品牌\\口感敏感、对价格不敏感，低价策略很难奏效。头部资源毕竟有限，除非瑞幸能有独特的卖点，否则一直补贴很难突破。而一旦融资不够用，客户群还没培养起来，那就晚了。\n\n另一方面，个人觉得瑞幸想在一线深入无非是认为流量大、客户群多，从头部市场抢资源。在当前国内各路 VC 都以用户流量多少作为重要投资指标的这个“浮躁”的时代，瑞幸可能已经想好了在最坏情况下“最好”的退出手段。但现实中其本身没有足够的技术来降低产品的制作成本，并同时提高品质。靠着对标竞品和一系列运营手段（附加价值）来提升用户心中认同的品牌感，做着赔本的买卖最后可能还是会无疾而终。\n","slug":"今日商业评论—瑞幸咖啡VS星巴克，如何互补？","published":1,"updated":"2019-02-28T16:29:28.204Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtan005kknp2ukpuhjab","content":"<blockquote>\n<p>瑞幸咖啡凭借大量补贴和快速开店的策略，在国内咖啡市场快速扩张，目前门店已经超过2000家，预计今年还将新开2500家门店。快速发展的背后是瑞幸的高额亏损，累计亏损超过8亿元，且亏损还在持续扩大。若瑞幸一直持续补贴，没有明确的盈利模式，其资金链必将受到影响。而作为咖啡市场老大的星巴克，由于瑞幸咖啡的崛起，在中国也出现了增长乏力的现象。你认为瑞幸和星巴克在营业模式上有哪些值得相互学习的地方？</p>\n</blockquote>\n<h4 id=\"我的短评：\"><a href=\"#我的短评：\" class=\"headerlink\" title=\"我的短评：\"></a>我的短评：</h4><p>个人觉得瑞幸可以尝试学习 “拼多多/趣头条” 从二三四线城市入手。像我的老家一个二线城市，从去年起才刚刚开始有星巴克的门店入驻，到现在也才不过三四家。虽然相比一线城市，二三四线城市的人群需要主动去培养其“喝咖啡”的用户心智，但综合来看二三四线城市的特点：</p>\n<ol>\n<li>店铺租金低；</li>\n<li>人群对价格敏感；</li>\n<li>人群对品牌不敏感；</li>\n</ol>\n<p>这三个特点会成为瑞幸很好的布局入口。而反观一线城市人群，毕竟咖啡不是强需求，有喝咖啡习惯的人大多对品牌\\口感敏感、对价格不敏感，低价策略很难奏效。头部资源毕竟有限，除非瑞幸能有独特的卖点，否则一直补贴很难突破。而一旦融资不够用，客户群还没培养起来，那就晚了。</p>\n<p>另一方面，个人觉得瑞幸想在一线深入无非是认为流量大、客户群多，从头部市场抢资源。在当前国内各路 VC 都以用户流量多少作为重要投资指标的这个“浮躁”的时代，瑞幸可能已经想好了在最坏情况下“最好”的退出手段。但现实中其本身没有足够的技术来降低产品的制作成本，并同时提高品质。靠着对标竞品和一系列运营手段（附加价值）来提升用户心中认同的品牌感，做着赔本的买卖最后可能还是会无疾而终。</p>\n","site":{"data":{}},"id":"e34d12cab4c35cb12ae834db43220856","excerpt":"","more":"<blockquote>\n<p>瑞幸咖啡凭借大量补贴和快速开店的策略，在国内咖啡市场快速扩张，目前门店已经超过2000家，预计今年还将新开2500家门店。快速发展的背后是瑞幸的高额亏损，累计亏损超过8亿元，且亏损还在持续扩大。若瑞幸一直持续补贴，没有明确的盈利模式，其资金链必将受到影响。而作为咖啡市场老大的星巴克，由于瑞幸咖啡的崛起，在中国也出现了增长乏力的现象。你认为瑞幸和星巴克在营业模式上有哪些值得相互学习的地方？</p>\n</blockquote>\n<h4 id=\"我的短评：\"><a href=\"#我的短评：\" class=\"headerlink\" title=\"我的短评：\"></a>我的短评：</h4><p>个人觉得瑞幸可以尝试学习 “拼多多/趣头条” 从二三四线城市入手。像我的老家一个二线城市，从去年起才刚刚开始有星巴克的门店入驻，到现在也才不过三四家。虽然相比一线城市，二三四线城市的人群需要主动去培养其“喝咖啡”的用户心智，但综合来看二三四线城市的特点：</p>\n<ol>\n<li>店铺租金低；</li>\n<li>人群对价格敏感；</li>\n<li>人群对品牌不敏感；</li>\n</ol>\n<p>这三个特点会成为瑞幸很好的布局入口。而反观一线城市人群，毕竟咖啡不是强需求，有喝咖啡习惯的人大多对品牌\\口感敏感、对价格不敏感，低价策略很难奏效。头部资源毕竟有限，除非瑞幸能有独特的卖点，否则一直补贴很难突破。而一旦融资不够用，客户群还没培养起来，那就晚了。</p>\n<p>另一方面，个人觉得瑞幸想在一线深入无非是认为流量大、客户群多，从头部市场抢资源。在当前国内各路 VC 都以用户流量多少作为重要投资指标的这个“浮躁”的时代，瑞幸可能已经想好了在最坏情况下“最好”的退出手段。但现实中其本身没有足够的技术来降低产品的制作成本，并同时提高品质。靠着对标竞品和一系列运营手段（附加价值）来提升用户心中认同的品牌感，做着赔本的买卖最后可能还是会无疾而终。</p>\n"},{"title":"使用 Noteflight 来快速作曲和 MusicXML 导出","intro":"最近一直有想法把自己喜欢的一首曲子转换成 MusicXML 格式，用来分享到其他的 Midi 设备上来使用。MacOS 上的大多数乐谱处理软件都需要很高的费用来购买正版。索性无意间发现了 Noteflight，可以直接在线编曲，在线导出成 MusicXML 或者 MIDI 等其他常用格式，使用起来十分方便。","comments":1,"date":"2017-07-06T06:15:40.000Z","_content":"\n最近一直有想法把自己喜欢的一首曲子转换成 MusicXML 格式，用来分享到其他的 Midi 设备上来使用。MacOS 上的大多数乐谱处理软件都需要很高的费用来购买正版。索性无意间发现了 Noteflight，可以直接在线编曲，在线导出成 MusicXML 或者 MIDI 等其他常用格式，使用起来十分方便。\n\n![](1.png)\n\n\nNoteflight 基本涵盖了所有你见过和没见过的乐谱标记，作为一个只会弹琴不会作曲的人，这些标记简直多到离谱。可以通过设置菜单选择自己常用的标记即可。同时 Noteflight 也支持不同演奏乐器的切换，种类十分丰富，包括弦乐、打击乐器、键盘等等。\n\n除了作曲之外，Noteflight 还有一个庞大的乐谱社区，大部分在网络上难找到的曲谱基本上都可以在这里找到。\n\n![](2.png)\n\n在 Noteflight 上作曲也十分简单方便，直接使用鼠标来点击需要添加音符的五线谱位置即可，如果是八分音符或者十六分音符也会自动连线。自动在线演奏功能十分强大，对于一些譬如“琶音”的地方处理的很棒。不过整体演奏质量还有待加强。但毕竟免费，仍然还是强力推荐。\n\n","source":"_posts/使用-Noteflight-来快速作曲和-MusicXML-导出.md","raw":"---\ntitle: 使用 Noteflight 来快速作曲和 MusicXML 导出\nintro: 最近一直有想法把自己喜欢的一首曲子转换成 MusicXML 格式，用来分享到其他的 Midi 设备上来使用。MacOS 上的大多数乐谱处理软件都需要很高的费用来购买正版。索性无意间发现了 Noteflight，可以直接在线编曲，在线导出成 MusicXML 或者 MIDI 等其他常用格式，使用起来十分方便。\ncomments: true\ndate: 2017-07-06 14:15:40\ntags:\n- 钢琴\n---\n\n最近一直有想法把自己喜欢的一首曲子转换成 MusicXML 格式，用来分享到其他的 Midi 设备上来使用。MacOS 上的大多数乐谱处理软件都需要很高的费用来购买正版。索性无意间发现了 Noteflight，可以直接在线编曲，在线导出成 MusicXML 或者 MIDI 等其他常用格式，使用起来十分方便。\n\n![](1.png)\n\n\nNoteflight 基本涵盖了所有你见过和没见过的乐谱标记，作为一个只会弹琴不会作曲的人，这些标记简直多到离谱。可以通过设置菜单选择自己常用的标记即可。同时 Noteflight 也支持不同演奏乐器的切换，种类十分丰富，包括弦乐、打击乐器、键盘等等。\n\n除了作曲之外，Noteflight 还有一个庞大的乐谱社区，大部分在网络上难找到的曲谱基本上都可以在这里找到。\n\n![](2.png)\n\n在 Noteflight 上作曲也十分简单方便，直接使用鼠标来点击需要添加音符的五线谱位置即可，如果是八分音符或者十六分音符也会自动连线。自动在线演奏功能十分强大，对于一些譬如“琶音”的地方处理的很棒。不过整体演奏质量还有待加强。但毕竟免费，仍然还是强力推荐。\n\n","slug":"使用-Noteflight-来快速作曲和-MusicXML-导出","published":1,"updated":"2019-02-20T00:59:13.701Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtao005nknp2iust0fpy","content":"<p>最近一直有想法把自己喜欢的一首曲子转换成 MusicXML 格式，用来分享到其他的 Midi 设备上来使用。MacOS 上的大多数乐谱处理软件都需要很高的费用来购买正版。索性无意间发现了 Noteflight，可以直接在线编曲，在线导出成 MusicXML 或者 MIDI 等其他常用格式，使用起来十分方便。</p>\n<p><img src=\"1.png\" alt></p>\n<p>Noteflight 基本涵盖了所有你见过和没见过的乐谱标记，作为一个只会弹琴不会作曲的人，这些标记简直多到离谱。可以通过设置菜单选择自己常用的标记即可。同时 Noteflight 也支持不同演奏乐器的切换，种类十分丰富，包括弦乐、打击乐器、键盘等等。</p>\n<p>除了作曲之外，Noteflight 还有一个庞大的乐谱社区，大部分在网络上难找到的曲谱基本上都可以在这里找到。</p>\n<p><img src=\"2.png\" alt></p>\n<p>在 Noteflight 上作曲也十分简单方便，直接使用鼠标来点击需要添加音符的五线谱位置即可，如果是八分音符或者十六分音符也会自动连线。自动在线演奏功能十分强大，对于一些譬如“琶音”的地方处理的很棒。不过整体演奏质量还有待加强。但毕竟免费，仍然还是强力推荐。</p>\n","site":{"data":{}},"id":"2b246311cbc5ac7cd1211f1f8969e9ec","excerpt":"","more":"<p>最近一直有想法把自己喜欢的一首曲子转换成 MusicXML 格式，用来分享到其他的 Midi 设备上来使用。MacOS 上的大多数乐谱处理软件都需要很高的费用来购买正版。索性无意间发现了 Noteflight，可以直接在线编曲，在线导出成 MusicXML 或者 MIDI 等其他常用格式，使用起来十分方便。</p>\n<p><img src=\"1.png\" alt></p>\n<p>Noteflight 基本涵盖了所有你见过和没见过的乐谱标记，作为一个只会弹琴不会作曲的人，这些标记简直多到离谱。可以通过设置菜单选择自己常用的标记即可。同时 Noteflight 也支持不同演奏乐器的切换，种类十分丰富，包括弦乐、打击乐器、键盘等等。</p>\n<p>除了作曲之外，Noteflight 还有一个庞大的乐谱社区，大部分在网络上难找到的曲谱基本上都可以在这里找到。</p>\n<p><img src=\"2.png\" alt></p>\n<p>在 Noteflight 上作曲也十分简单方便，直接使用鼠标来点击需要添加音符的五线谱位置即可，如果是八分音符或者十六分音符也会自动连线。自动在线演奏功能十分强大，对于一些譬如“琶音”的地方处理的很棒。不过整体演奏质量还有待加强。但毕竟免费，仍然还是强力推荐。</p>\n"},{"title":"利用 ab 命令进行简单压测","intro":"Enter intro here to display on home page","comments":1,"date":"2015-03-12T15:02:58.000Z","_content":"\n我们可以使用 Apache 服务器自带的 Web 站点压力测试工具 `ab` 来对站点进行简单的压力测试，这里讲解的是在 Windows 平台上使用 Apache 工具进行压力测试，所以需要首先在 Windows 平台上配置 Aapache 环境。然后将 Apache 安装目录内的 bin 目录添加到系统的 path 路径中。\n\n然后以管理员权限运行 `cmd.exe`，基本的压力测试命令为 `ab.exe` 命令。其用法为：\n\n```bash\nab.exe -n 100 -c 50 -w https://www.baidu.com/\n```\n\n其中的参数 `-n` 表示在测试会话中需要执行的请求个数。默认仅发送一个请求。`-c` 参数表示并行请求的请求个数。`-w` 参数表示需要以 HTML 表格形式输出结果。默认时，它是以白色为背景的两列宽度的一张表。在命令的最后给出压力测试的远程服务 URL 。等待一段时间后便会回显出服务器端处理请求的百分比以及所花费的毫秒数。\n\n![ab 命令回显的测试结果](1.png)\n\n也可以这样写，将压力测试的结果输出到一个 HTML 文件里，这里会反馈出更加详细的测试结果。\n\n```bash\nab.exe -n 100 -c 50 -w https://www.baidu.com/ >> C:ab_result.html\n```\n\n![结果 H\u0014TML 文件中记录的压测结果](2.png)\n\n输出到 HTML 文件中的信息包括服务器完成的请求和失败的请求数量，连接服务器和处理请求花费的时间，以及每秒钟服务器请求的数量等压力测试的相关信息。\n","source":"_posts/利用-ab-命令进行简单压测.md","raw":"---\ntitle: 利用 ab 命令进行简单压测\nintro: Enter intro here to display on home page\ncomments: true\ndate: 2015-03-12 23:02:58\ntags:\n- Apache\n---\n\n我们可以使用 Apache 服务器自带的 Web 站点压力测试工具 `ab` 来对站点进行简单的压力测试，这里讲解的是在 Windows 平台上使用 Apache 工具进行压力测试，所以需要首先在 Windows 平台上配置 Aapache 环境。然后将 Apache 安装目录内的 bin 目录添加到系统的 path 路径中。\n\n然后以管理员权限运行 `cmd.exe`，基本的压力测试命令为 `ab.exe` 命令。其用法为：\n\n```bash\nab.exe -n 100 -c 50 -w https://www.baidu.com/\n```\n\n其中的参数 `-n` 表示在测试会话中需要执行的请求个数。默认仅发送一个请求。`-c` 参数表示并行请求的请求个数。`-w` 参数表示需要以 HTML 表格形式输出结果。默认时，它是以白色为背景的两列宽度的一张表。在命令的最后给出压力测试的远程服务 URL 。等待一段时间后便会回显出服务器端处理请求的百分比以及所花费的毫秒数。\n\n![ab 命令回显的测试结果](1.png)\n\n也可以这样写，将压力测试的结果输出到一个 HTML 文件里，这里会反馈出更加详细的测试结果。\n\n```bash\nab.exe -n 100 -c 50 -w https://www.baidu.com/ >> C:ab_result.html\n```\n\n![结果 H\u0014TML 文件中记录的压测结果](2.png)\n\n输出到 HTML 文件中的信息包括服务器完成的请求和失败的请求数量，连接服务器和处理请求花费的时间，以及每秒钟服务器请求的数量等压力测试的相关信息。\n","slug":"利用-ab-命令进行简单压测","published":1,"updated":"2019-02-04T07:21:18.352Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtar005pknp2qt7keuqm","content":"<p>我们可以使用 Apache 服务器自带的 Web 站点压力测试工具 <code>ab</code> 来对站点进行简单的压力测试，这里讲解的是在 Windows 平台上使用 Apache 工具进行压力测试，所以需要首先在 Windows 平台上配置 Aapache 环境。然后将 Apache 安装目录内的 bin 目录添加到系统的 path 路径中。</p>\n<p>然后以管理员权限运行 <code>cmd.exe</code>，基本的压力测试命令为 <code>ab.exe</code> 命令。其用法为：</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\">ab.exe -n 100 -c 50 -w https://www.baidu.com/\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>其中的参数 <code>-n</code> 表示在测试会话中需要执行的请求个数。默认仅发送一个请求。<code>-c</code> 参数表示并行请求的请求个数。<code>-w</code> 参数表示需要以 HTML 表格形式输出结果。默认时，它是以白色为背景的两列宽度的一张表。在命令的最后给出压力测试的远程服务 URL 。等待一段时间后便会回显出服务器端处理请求的百分比以及所花费的毫秒数。</p>\n<p><img src=\"1.png\" alt=\"ab 命令回显的测试结果\"></p>\n<p>也可以这样写，将压力测试的结果输出到一个 HTML 文件里，这里会反馈出更加详细的测试结果。</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\">ab.exe -n 100 -c 50 -w https://www.baidu.com/ <span class=\"token operator\">>></span> C:ab_result.html\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><img src=\"2.png\" alt=\"结果 H\u0014TML 文件中记录的压测结果\"></p>\n<p>输出到 HTML 文件中的信息包括服务器完成的请求和失败的请求数量，连接服务器和处理请求花费的时间，以及每秒钟服务器请求的数量等压力测试的相关信息。</p>\n","site":{"data":{}},"id":"a17958170d26c33833e63f1177c6bfb2","excerpt":"","more":"<p>我们可以使用 Apache 服务器自带的 Web 站点压力测试工具 <code>ab</code> 来对站点进行简单的压力测试，这里讲解的是在 Windows 平台上使用 Apache 工具进行压力测试，所以需要首先在 Windows 平台上配置 Aapache 环境。然后将 Apache 安装目录内的 bin 目录添加到系统的 path 路径中。</p>\n<p>然后以管理员权限运行 <code>cmd.exe</code>，基本的压力测试命令为 <code>ab.exe</code> 命令。其用法为：</p>\n<pre><code class=\"bash\">ab.exe -n 100 -c 50 -w https://www.baidu.com/\n</code></pre>\n<p>其中的参数 <code>-n</code> 表示在测试会话中需要执行的请求个数。默认仅发送一个请求。<code>-c</code> 参数表示并行请求的请求个数。<code>-w</code> 参数表示需要以 HTML 表格形式输出结果。默认时，它是以白色为背景的两列宽度的一张表。在命令的最后给出压力测试的远程服务 URL 。等待一段时间后便会回显出服务器端处理请求的百分比以及所花费的毫秒数。</p>\n<p><img src=\"1.png\" alt=\"ab 命令回显的测试结果\"></p>\n<p>也可以这样写，将压力测试的结果输出到一个 HTML 文件里，这里会反馈出更加详细的测试结果。</p>\n<pre><code class=\"bash\">ab.exe -n 100 -c 50 -w https://www.baidu.com/ &gt;&gt; C:ab_result.html\n</code></pre>\n<p><img src=\"2.png\" alt=\"结果 H\u0014TML 文件中记录的压测结果\"></p>\n<p>输出到 HTML 文件中的信息包括服务器完成的请求和失败的请求数量，连接服务器和处理请求花费的时间，以及每秒钟服务器请求的数量等压力测试的相关信息。</p>\n"},{"title":"前端 DCE 策略之 — Tree Shaking","intro":"“Tree Shaking” 是 JavaScript 中一种常用的 DCE(Dead Code Elimination) 手段。它通过依赖于 ES2015/ES6 的模块系统来静态分析出源码依赖结构中的无用代码，然后便可以在打包时大大压缩源代码的体积，同时尽最大程度上的只保留用到的业务功能。","comments":1,"date":"2017-05-08T06:51:24.000Z","_content":"\n\n“Tree Shaking” 是 JavaScript 中一种常用的 DCE(Dead Code Elimination) 手段。它通过依赖于 ES2015/ES6 的模块系统来静态分析出源码依赖结构中的无用代码，然后便可以在打包时大大压缩源代码的体积，同时尽最大程度上的只保留用到的业务功能。\n\nTree Shaking 的存在完全是基于 ES6 的模块机制，由于在 ES6 的 模块机制中，`import` 和 `export` 语句是完全静态化的（代码运行之前就能够静态地把依赖关系明确的指定），因此可以在非运行时便对源代码进行可靠的静态分析来剔除无用代码。具体基于的可靠规则如下：\n\n1. 两个关键字只能作为模块顶层的语句出现，不能出现在函数或者其他的块语句里面；\n2. `import` 的模块名只能是字符串常量，不能使用变量；\n\n![](1.jpg)\n\n3. 不管 `import` 的语句的出现位置在哪里，模块在初始化的所有的 `import` 都必须已经导入完成；\n\n![](2.jpg)\n\n4. `import` 绑定的变量是不可变的，类似于 `const`；\n\n![](3.jpg)\n","source":"_posts/前端-DCE-策略之-—-Tree-Shaking.md","raw":"---\ntitle: 前端 DCE 策略之 — Tree Shaking\nintro: “Tree Shaking” 是 JavaScript 中一种常用的 DCE(Dead Code Elimination) 手段。它通过依赖于 ES2015/ES6 的模块系统来静态分析出源码依赖结构中的无用代码，然后便可以在打包时大大压缩源代码的体积，同时尽最大程度上的只保留用到的业务功能。\ncomments: true\ndate: 2017-05-08 14:51:24\ntags:\n- ES6\n- DCE\n---\n\n\n“Tree Shaking” 是 JavaScript 中一种常用的 DCE(Dead Code Elimination) 手段。它通过依赖于 ES2015/ES6 的模块系统来静态分析出源码依赖结构中的无用代码，然后便可以在打包时大大压缩源代码的体积，同时尽最大程度上的只保留用到的业务功能。\n\nTree Shaking 的存在完全是基于 ES6 的模块机制，由于在 ES6 的 模块机制中，`import` 和 `export` 语句是完全静态化的（代码运行之前就能够静态地把依赖关系明确的指定），因此可以在非运行时便对源代码进行可靠的静态分析来剔除无用代码。具体基于的可靠规则如下：\n\n1. 两个关键字只能作为模块顶层的语句出现，不能出现在函数或者其他的块语句里面；\n2. `import` 的模块名只能是字符串常量，不能使用变量；\n\n![](1.jpg)\n\n3. 不管 `import` 的语句的出现位置在哪里，模块在初始化的所有的 `import` 都必须已经导入完成；\n\n![](2.jpg)\n\n4. `import` 绑定的变量是不可变的，类似于 `const`；\n\n![](3.jpg)\n","slug":"前端-DCE-策略之-—-Tree-Shaking","published":1,"updated":"2019-02-18T01:52:23.232Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtas005sknp26egbxmch","content":"<p>“Tree Shaking” 是 JavaScript 中一种常用的 DCE(Dead Code Elimination) 手段。它通过依赖于 ES2015/ES6 的模块系统来静态分析出源码依赖结构中的无用代码，然后便可以在打包时大大压缩源代码的体积，同时尽最大程度上的只保留用到的业务功能。</p>\n<p>Tree Shaking 的存在完全是基于 ES6 的模块机制，由于在 ES6 的 模块机制中，<code>import</code> 和 <code>export</code> 语句是完全静态化的（代码运行之前就能够静态地把依赖关系明确的指定），因此可以在非运行时便对源代码进行可靠的静态分析来剔除无用代码。具体基于的可靠规则如下：</p>\n<ol>\n<li>两个关键字只能作为模块顶层的语句出现，不能出现在函数或者其他的块语句里面；</li>\n<li><code>import</code> 的模块名只能是字符串常量，不能使用变量；</li>\n</ol>\n<p><img src=\"1.jpg\" alt></p>\n<ol start=\"3\">\n<li>不管 <code>import</code> 的语句的出现位置在哪里，模块在初始化的所有的 <code>import</code> 都必须已经导入完成；</li>\n</ol>\n<p><img src=\"2.jpg\" alt></p>\n<ol start=\"4\">\n<li><code>import</code> 绑定的变量是不可变的，类似于 <code>const</code>；</li>\n</ol>\n<p><img src=\"3.jpg\" alt></p>\n","site":{"data":{}},"id":"ac2c06509c0f781104fb20802307c308","excerpt":"","more":"<p>“Tree Shaking” 是 JavaScript 中一种常用的 DCE(Dead Code Elimination) 手段。它通过依赖于 ES2015/ES6 的模块系统来静态分析出源码依赖结构中的无用代码，然后便可以在打包时大大压缩源代码的体积，同时尽最大程度上的只保留用到的业务功能。</p>\n<p>Tree Shaking 的存在完全是基于 ES6 的模块机制，由于在 ES6 的 模块机制中，<code>import</code> 和 <code>export</code> 语句是完全静态化的（代码运行之前就能够静态地把依赖关系明确的指定），因此可以在非运行时便对源代码进行可靠的静态分析来剔除无用代码。具体基于的可靠规则如下：</p>\n<ol>\n<li>两个关键字只能作为模块顶层的语句出现，不能出现在函数或者其他的块语句里面；</li>\n<li><code>import</code> 的模块名只能是字符串常量，不能使用变量；</li>\n</ol>\n<p><img src=\"1.jpg\" alt></p>\n<ol start=\"3\">\n<li>不管 <code>import</code> 的语句的出现位置在哪里，模块在初始化的所有的 <code>import</code> 都必须已经导入完成；</li>\n</ol>\n<p><img src=\"2.jpg\" alt></p>\n<ol start=\"4\">\n<li><code>import</code> 绑定的变量是不可变的，类似于 <code>const</code>；</li>\n</ol>\n<p><img src=\"3.jpg\" alt></p>\n"},{"title":"前端关键技术点杂烩","intro":"本篇文章主要总结一下 Web 前端面试的一些常见面试题，同时这些问题也是对一些基础的技术概念和思想的理解。对这些基本知识的掌握程度和深度决定了你的技术层级。高级工程师是必须掌握本文列出的这些知识点，资深工程师则要对这些基本概念的纵向深度进行挖掘，【问题解答全部原创，转载请注明来源】。","comments":1,"date":"2016-12-09T10:23:15.000Z","_content":"\n本篇文章主要总结一下 Web 前端面试的一些常见面试题，同时这些问题也是对一些基础的技术概念和思想的理解。对这些基本知识的掌握程度和深度决定了你的技术层级。高级工程师是必须掌握本文列出的这些知识点，资深工程师则要对这些基本概念的纵向深度进行挖掘，【问题解答全部原创，转载请注明来源】。\n\n### 综合技术方面：\n\n#### 1. 网站和页面性能优化：\n\n**缓存：**ETag、Expire、Last-Modified 三者合用，Expire 字段可以让浏览器完全不发起 HTTP 请求，若按 F5 键发起请求，也可以通过判断 ETag（对应浏览器字段 If-None-Match） 和 Last-Modified（对应浏览器字段 If-Modified-Since）字段来确认是否需要更新资源还是使用 304(Not Modified)缓存的本地资源；\n\n**静态资源：**代码压缩合并、CSS 雪碧图、分析 FTTB 是否采用 CDN、服务器开启 GZIP 压缩、图片压缩、静态资源使用独立域名，防止域名污染（静态资源不需要携带 Cookie，又叫 Cookie 隔离）；\n\n**页面结构：**样式表放顶部，JS 脚本放底部，不让 JS 脚本阻碍页面 DOM 的加载；\n\n**代码优化：**缩短原型链，减少属性和方法的查找时间；使用事件代理代替事件绑定；减少对 DOM 的直接操作，减少页面重绘；使用 H5 新方法 `requestAnimationFrame` 来执行 DOM 动画；使用 `createElement` 代替 `innerHTML` 进行 DOM 插入，因为它的速度更快；\n\n**其他方法：**BigPipe 优化、BigRender 优化、Quickling 优化；\n\n#### 2. 字体大小常用单位：\n\n**绝对值：**像素 px、点 pt = (DPI / 72) px；\n\n**相对值：**一个字的大小 em（默认值 **1em = 16px**，16px 也为浏览器的默认字体大小，继承父元素的大小，为了计算通常设 `html { font-size: 63%; }`，即 1em = 10px）相对于根节点的一个字大小 rem；\n\n#### 3. CSS Reset：\n\n“CSS Reset” 就是由于各种浏览器解释 CSS 样式的初始值有所不同，导致设计师在没有定义某个 CSS 属性时，不同的浏览器会按照自己的默认值来为没有定义的样式赋值，所以我们要先定义好一些 CSS 样式，来让所有浏览器都按照同样的规则解释 CSS，这样就能避免发生这种问题。本质就是清除浏览器默认样式，并且进行全局样式定义，Reset 文件要在项目初期定好，这样才不会产生后期的回归测试问题。\n\n\n```css\n* {\n    vertical-align: baseline;\n    font-weight: inherit;\n    font-family: inherit;\n    font-style: inherit;\n    font-size: 100%;\n    outline: 0;\n    padding: 0;\n    margin: 0;\n    border: 0;\n}\n```\n\n#### 4. 弹性布局、响应式、重构：\n\n**弹性布局：**Flexbox 布局模式，适用于多行多列自适应布局。\n\n**响应式布局：**媒体查询（Media Queries）和 Viewport（初始比例，最大比例，最大宽度，缩放控制）控制。\n\n#### 5. 什么叫优雅降级和渐进增强：\n\n**渐进增强：**针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。\n\n**优雅降级：**一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。\n\n两者区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。\n\n#### 6. HTML5 主要增强了什么：\n\n增加了很多利于网站 SEO 的语义化标签如 `header`、`footer`、`article`、`nav`，功能性标签如 `canvas`、`video`、`audio` 使得浏览器可以进一步摆脱插件。WebSocket、LocalStorage、WebSQL 等新功能特性，还有很多功能化的标签属性如 `autocomplete`、`autofocus` 和很常用的 `datalist` 标签。\n\n#### 7. Node.js 主要解决了什么问题：\n\n虽然单进程、单线程，但其事件环机制、非阻塞 IO，可以高效的处理高并发请求，并且与前端脚本语言统一。\n\n#### 8. 提高 CSS 性能：\n\n**加载性能：**压缩样式表，不要使用 `@import`（诞生于 CSS2），@import 使用在低网速下会存在页面闪烁问题（link 标签是在加载页面前把 CSS 加载完毕，而 @import 则是读取到引用的文件之后再加载，会延长页面的留白期）；\n\n**选择器性能：**可忽略不计。\n\n**渲染性能：**用 `createDocumentFragment` 对象在内存里操作 DOM、使用 class 类名替换来代替直接更改样式、开启 GPU 硬件加速；\n\n**Repaint（重绘）：**当在页面上修改了一些不需要改变定位的样式的时候（比如 `background-color`、`border-color` 以及 `visibility`)，浏览器只会将新的样式重新绘制给元素（这就叫一次“重绘”或者“重新定义样式”）。这时只需要屏幕的一部分要重画。\n\n**Reflow（回流重排）：**当页面上的改变影响了文档内容、结构或者元素定位时，就会发生重排（或称“重新布局”）。\n\n**其他：**去除空规则；属性值为0时，不加单位；属性值为浮动小数“0.**”时，可以省略小数点之前的0；标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后；\n\n#### 9. CSS 预处理：\n\nCSS 预处理器用一种专门的编程语言，在编写 CSS 的过程中可以使用变量、循环、递归等特性，然后再编译成正常的 CSS 文件，可以提高 CSS 编写效率，常用的预编译语言有 LESS、SESS 等。\n\n#### 10. 关于浮动的原理和工作方式：\n\n浮动本质就是个带有方位的 `display: inline-block` 属性；会打破同一行的 inline-box 模型；\n\n#### 11. 浮动会产生什么影响呢，要怎么处理？\n\n会产生高度塌陷，子元素均设置了浮动样式，父元素会失去高度。\n\n**解决方案：**父级 div 层定义 `overflow: hidden`、结尾处加空 div 标签 `clear:both`、父级 div 定义伪类 `:after`（最后一个子元素的后边）和 `zoom` 属性。\n\n\n```css\n.clearfix{zoom:1;}\n.clearfix:after{display:block; content:\".\"; clear:both; line-height:0; visibility:hidden;}\n```\n\n#### 12. 你了解哪些常用 CSS 选择器？以及这些选择器的使用场景？\n\nID 选择器、类选择器、伪类选择器、全局选择器 ...（请跳至 W3School 查看更多）。\n\n#### 13. 你知道这些选择器的权重怎么计算？\n\n**权值为1000：**代表内联样式，如 “style=\"...\"”。\n\n**权值为100：**代表ID选择器，如 “#content”。\n\n**权值为10：**代表类，伪类和属性选择器，如 “.content”。\n\n**权值为1：**代表类型选择器和伪元素选择器，如 “div p”。\n\n***通用选择器（*），子选择器（>）和相邻同胞选择器（+）的权值都为0。**\n\n#### 14. 你了解哪些布局？你平时有使用过什么布局实现？\n\n弹性布局（与流体布局相似，大小单位使用 em）、固定布局、混合布局、绝对定位布局、流体布局（宽高以百分比计算，配合媒体查询完成） ...\n\n#### 15. 你常用的 JS 框架有哪些？\n\njQuery、Knockout.js、Vue.js、AngularJs、EmberJs、React.js ...（很多 MVVM 框架可以使用）\n\n#### 16. 你从 jQuery 学到了什么？\n\n看了源码中一些“类型检测”函数的实现，jQuery 中的这些方法完成度非常高，实现很全面，性能也是很高的。例如如下所示代码：\n\n\n```javascript\nclass2type = {};\n\njQuery.each(\"Boolean Number String Function Array Date RegExp Object\".split(\" \"), function(i, name) {\n    class2type[\"[object \" + name + \"]\"] = name.toLowerCase();\n}\n\ntype: function(obj) {\n  return obj == null ? String(obj) : class2type[Object.prototype.toString.call(obj)] || \"object\";\n}\n\nisFunction: function(obj) {\n  return jQuery.type(obj) === \"function\";\n}\n\nisArray: Array.isArray || function() {\n  return jQuery.type(obj) === \"array\";\n}\n```\n\n（其他知识点还有很多，异步队列，数据缓存，事件系统，异步请求等）。\n\n#### 17. JS 有哪些数据类型？\n\nnull、undefined、数字、字符串、数组、对象、布尔。\n\n#### 18. JS 的数据类型中哪些是引用类型？\n\n数组、对象。\n\n#### 19. 原型链：\n\n（内容太多，请自行 Google）\n\n#### 20. 函数表达式和函数声明的区别：\n\n函数表达式只有函数定义的提升，函数声明则可以将函数定义和声明同时提升；函数表达式可以放在任何地方，函数声明则只能放到全局环境中。\n\n#### 21. 什么是闭包，为什么要使用闭包？\n\n可以简单理解为“函数中的函数”。两个常见作用：一可以读取函数内部的变量、二让这些变量的值始终保持在内存中。父函数定义的变量在子函数的作用域链中，子函数没有被销毁，其作用域链中所有变量和函数就会被维护，不会被销毁。\n\n\n```javascript\n// 此处在绑定函数时的 i 是没有问题的，从 0 到 “elements.length - 1”；\n// 只是在子函数中的 i 是一直保持对父环境对象中的 i 的引用的，所以在调用时一直会输出 “elements.length”；\nfor (var i = 0; i < elements.length; i++) {\n  elements[i].onclick = function() {\n    console.log(i);\n  }\n}\n// 用 IIFE 隔离外部环境对象，使父环境对象可以及时释放；\n// IIFE 中定义的任何变量和函数，都会在执行结束时被销毁；\nfor (var i = 0; i < elements.length; i++) {\n  (function(n) {\n    elements[n].onclick = function() {\n      console.log(n);\n    }\n  })(i);\n}\n```\n\n#### 22. DOM 中的 Property 和 Attribute 两者的区别：\n\nAttribute 就是 DOM 节点自带的属性，例如 div 中常用的 id、class 等；Property 是这个 DOM 元素作为对象，其附加的内容，例如 `childNodes`、`firstChild` 等；\n\n自定义的 Attribute 不会附加到 Property 上，对于属性 Property 的赋值在 IE 中可能会引起循环引用，内存泄漏。\n\n操作 Attribute 时使用 `setAttribute` 和 `getAttribute` 两个方法来操作，由于 getAttribute 可能会有浏览器兼容性问题，所以在 jQuery 中，在使用之前会对该方法进行测试：\n\n```javascript\ndiv.className = \"a\";\nvar judge = div.getAttribute(\"className\") === \"a\";\n```\n\n*对于 “style” 和 “onclick” 两个属性，它们的 Property 和 Attribute 分别是对象和字符串，与其他有所区别。\n\n#### 23. JS 作用域链：\n\n在一些类 C 的语言中有“块级作用域”，即花括号的每一段代码都有自己的独立作用域，而 JS 只有函数级作用域；JS 作用域链的第一个对象始终是当前执行代码所在环境的变量对象（VO），声明函数在全局作用域，此时作用域链只有一个环境对象；运行函数时作用域链顶端加入了函数内的环境对象，运行完毕时顶端环境对象被销毁，以此类推。\n\nJS 在查找变量时会从链的**顶端（就近原则）**一直向下查找。如果一个跨作用域的对象被引用了一次以上，则先把它存储到局部变量里再使用。全局变量总是存在于运行期上下文作用域链的最**末端**，因此在标识符解析的时候，查找全局变量是最慢的。（最好和闭包一起理解）\n\n#### 24. 你对前端有什么理解？\n\n前端工程化、组件化 ...\n\n#### 25. 你觉得前端体系应该是怎样的？\n\n* 开发工具；\n* 代码质量；\n* 前端框架；\n* 前端开发标准；\n* 部署流程；\n* 代码组织；\n* 代码安全；\n* 移动 Web 开发；\n* 前沿技术社区；\n* 计算机网络体系；\n* 软件工程；\n* 可视化；\n* 浏览器；\n* 编程语言；\n\n#### 26. Hybrid App：\n\n“Hybrid App” 底层依赖于 Native 提供的容器（UIWebview），上层使用传统前端技术做业务开发，底层透明化、上层多样化，这种场景非常有利于前端介入，非常适合业务快速迭代。（详情需深入研究，笔者这方面研究不多）\n\n#### 27. IFC、BFC、GFC 和 FFC：\n\n**IFC：**内联 `display: inline` 格式化上下文，容器里面的子元素不会影响到外面的元素，表示盒子从左到右的水平排列方式；\n\n**BFC：**块级 `display: block` 格式化上下文，表示盒子从上到下的垂直排列方式；\n\n**GFC：**网格 `display: grid` 布局格式化上下文；\n\n**FFC：**自适应 `display: flex` 格式化上下文；\n\n**Box: CSS 布局的基本单位：**\n\nBox 是 CSS 布局的对象和基本单位。直观点来说，就是一个页面是由很多个 Box 组成的。元素的类型和 `display` 属性，决定了这个 Box 的类型。 不同类型的 Box，会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此 Box 内的元素会以不同的方式渲染。\n\n**Formatting Context：**\n\n“Formatting Context” 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的 Formatting Context 有 “Block Fomatting Context”（简称 BFC）和 “Inline Formatting Context”（简称 IFC）。\n\n**BFC布局规则：**\n\n* 内部的 Box 会在垂直方向，一个接一个地放置。\n* Box 垂直方向的距离由 `margin` 样式决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠。\n* 每个元素的 “margin box” 的左边， 与包含块 “border box” 的左边相接触（对于从左往右的格式化，否则相反）。即使存在浮动也是如此。\n* BFC 的区域不会与 “float box” 重叠。\n* BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。\n* 计算 BFC 的高度时，浮动元素也参与计算。\n\n**哪些元素会生成 BFC？**\n\n* 根元素；\n* `float` 属性不为 “none”；\n* `position` 为 “absolute” 或 “fixed”；\n* `display` 为 “inline-block”、“table-cell”、“ table-caption”、“flex”、“inline-flex”；\n* `overflow` 不为 “visible”；\n\n#### 28. JS 垃圾回收机制：\n\n**标记清除：**跟踪环境对象，即跟踪作用域链，GC 会把那些没有作用域影响的内存清除掉；\n\n**引用计数：**即跟踪记录每个值被引用的次数，但可能会有“循环引用”的问题；\n\n#### 29. Ajax 完整流程：\n\n```javascript\n// 获取 XHR 对象;\n// 设置回调函数;\nxmlHTTP.onreadystatechange = callback;\n\n// 打开一个 XHR 链接;\nxmlHTTP.open(\"GET\", url, true);\n\n// POST 请求要设置编码类型;\n// xmlHTTP.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");  \n// 发送请求;\nxmlHTTP.send(null);\n\nfunction callback() {\n  if (xmlHTTP.readyState == 4) {\n    if (xmlHTTP.status == 200) {\n      console.log(xmlHTTP.responseText);\n    }\n  }\n}\n```\n\n#### 30. Gulp 和 Grunt 的异同点？\n\nGulp 基于“流”的概念，只有一次 IO 过程，类似于 Linux 里的管道，又像 jQuery 的链式调用；Gulp 更易用；\n\n#### 31. 浏览器可以并行下载多少个资源？\n\n在 HTTP/1.1 协议下一般是6个，最多不超过8个；\n\n#### 32. 你觉得哪些网站前端技术比较好，这些网站的架构怎样？\n\n举例：淘宝网，用来很多 H5 的语义化标签；降级兼容做的很好，对禁用脚本的浏览器提供友好的选项；云客服使用 WS ，来代替 Ajax 轮询等；\n\n#### 33. 淘宝网上的商品项，如图片，滚动到了才加载，是怎么实现的？\n\n应该是 PipeRender 技术的一种，BigRender 的原理是通过某种方式，将首屏不需要的 HTML 代码先存放起来。渲染好首屏后，再将存储好的 HTML 代码逐步渲染出来。\n\n#### 34. 你了解后端技术么，前后端一般是怎么配合的？\n\n笔者公司用的是 CakePHP 和 Laravel 两套 PHP 框架，Laravel 本身有自己的模板引擎，同时可以与 Gulp 进行无缝衔接；模板会预留出需要替换的变量位置，前后端分离处理；前端模板可以进行模板的继承与嵌套；\n\n#### 35. 安卓上如何实现 1px 像素线？\n\n因为 Retine 屏的分辨率始终是普通屏幕的2倍，导致原本 1px 的细线在手机上显示为 2px；\n\nIOS8 及以上可以直接使用 `border-width: 0.5px;` 来设置 1px 的线段，其他平台可以用 `transform` 将细线高度缩小一半：\n\n```css\n.hairlines li:after {     \n    content: \"\";     \n    position: absolute;     \n    left: 0;     \n    background: #000;     \n    width: 100%;     \n    height: 1px;     \n    -webkit-transform: scaleY(0.5);             \n    transform: scaleY(0.5);     \n    -webkit-transform-origin: 0 0;             \n    transform-origin: 0 0; \n}\n```\n\n#### 36. 流应用是什么？\n\n“流应用”结合了原生 App 和 Web App 的优势，又消除了各自的缺点。流应用建立在 “H5+” 这一突破性技术之上，通过强化 HTML5 使其达到原生 App 的功能和体验，并辅以**类似流媒体的边用边下发行技术**，这2项技术是流应用诞生的关键。\n\n#### 37. 移动设备浏览器的 click 事件300毫秒延迟？\n\n来源于最初的 Safari 浏览器在用户点击屏幕时会等待300毫秒，以判断用户是想进行单击还是进行双击缩放。其他浏览器也借鉴 Safari 的特性，导致了这一问题。\n\n**基本解决：**修改 viewport 来禁用缩放 `<meta name=\"viewport\" content=\"width=device-width, user-scalable=no\">` 并同时设置 CSS 属性 `touch-action: none;`。\n\n**完美方案：**FastClick 的实现原理是在检测到 touchend 事件的时候，会通过 DOM 自定义事件立即出发模拟一个 click 事件，并把浏览器在 300ms 之后的 click 事件阻止掉。\n\n#### 38. touchstart 的点击穿透问题：\n\n因为在移动端浏览器，事件执行的顺序是 **touchstart > touchend > click**，而 click 事件有 300ms 的延迟，当 touchstart 事件把 B 元素隐藏之后，隔了 300ms，浏览器触发了 click 事件，但是此时 B 元素不见了，所以该事件被派发到了 A 元素身上。如果 A 元素是一个链接，那此时页面就会意外地跳转。\n\n","source":"_posts/前端关键技术点杂烩.md","raw":"---\ntitle: 前端关键技术点杂烩\nintro: 本篇文章主要总结一下 Web 前端面试的一些常见面试题，同时这些问题也是对一些基础的技术概念和思想的理解。对这些基本知识的掌握程度和深度决定了你的技术层级。高级工程师是必须掌握本文列出的这些知识点，资深工程师则要对这些基本概念的纵向深度进行挖掘，【问题解答全部原创，转载请注明来源】。\ncomments: true\ndate: 2016-12-09 18:23:15\ntags:\n- JavaScript\n- CSS\n---\n\n本篇文章主要总结一下 Web 前端面试的一些常见面试题，同时这些问题也是对一些基础的技术概念和思想的理解。对这些基本知识的掌握程度和深度决定了你的技术层级。高级工程师是必须掌握本文列出的这些知识点，资深工程师则要对这些基本概念的纵向深度进行挖掘，【问题解答全部原创，转载请注明来源】。\n\n### 综合技术方面：\n\n#### 1. 网站和页面性能优化：\n\n**缓存：**ETag、Expire、Last-Modified 三者合用，Expire 字段可以让浏览器完全不发起 HTTP 请求，若按 F5 键发起请求，也可以通过判断 ETag（对应浏览器字段 If-None-Match） 和 Last-Modified（对应浏览器字段 If-Modified-Since）字段来确认是否需要更新资源还是使用 304(Not Modified)缓存的本地资源；\n\n**静态资源：**代码压缩合并、CSS 雪碧图、分析 FTTB 是否采用 CDN、服务器开启 GZIP 压缩、图片压缩、静态资源使用独立域名，防止域名污染（静态资源不需要携带 Cookie，又叫 Cookie 隔离）；\n\n**页面结构：**样式表放顶部，JS 脚本放底部，不让 JS 脚本阻碍页面 DOM 的加载；\n\n**代码优化：**缩短原型链，减少属性和方法的查找时间；使用事件代理代替事件绑定；减少对 DOM 的直接操作，减少页面重绘；使用 H5 新方法 `requestAnimationFrame` 来执行 DOM 动画；使用 `createElement` 代替 `innerHTML` 进行 DOM 插入，因为它的速度更快；\n\n**其他方法：**BigPipe 优化、BigRender 优化、Quickling 优化；\n\n#### 2. 字体大小常用单位：\n\n**绝对值：**像素 px、点 pt = (DPI / 72) px；\n\n**相对值：**一个字的大小 em（默认值 **1em = 16px**，16px 也为浏览器的默认字体大小，继承父元素的大小，为了计算通常设 `html { font-size: 63%; }`，即 1em = 10px）相对于根节点的一个字大小 rem；\n\n#### 3. CSS Reset：\n\n“CSS Reset” 就是由于各种浏览器解释 CSS 样式的初始值有所不同，导致设计师在没有定义某个 CSS 属性时，不同的浏览器会按照自己的默认值来为没有定义的样式赋值，所以我们要先定义好一些 CSS 样式，来让所有浏览器都按照同样的规则解释 CSS，这样就能避免发生这种问题。本质就是清除浏览器默认样式，并且进行全局样式定义，Reset 文件要在项目初期定好，这样才不会产生后期的回归测试问题。\n\n\n```css\n* {\n    vertical-align: baseline;\n    font-weight: inherit;\n    font-family: inherit;\n    font-style: inherit;\n    font-size: 100%;\n    outline: 0;\n    padding: 0;\n    margin: 0;\n    border: 0;\n}\n```\n\n#### 4. 弹性布局、响应式、重构：\n\n**弹性布局：**Flexbox 布局模式，适用于多行多列自适应布局。\n\n**响应式布局：**媒体查询（Media Queries）和 Viewport（初始比例，最大比例，最大宽度，缩放控制）控制。\n\n#### 5. 什么叫优雅降级和渐进增强：\n\n**渐进增强：**针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。\n\n**优雅降级：**一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。\n\n两者区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。\n\n#### 6. HTML5 主要增强了什么：\n\n增加了很多利于网站 SEO 的语义化标签如 `header`、`footer`、`article`、`nav`，功能性标签如 `canvas`、`video`、`audio` 使得浏览器可以进一步摆脱插件。WebSocket、LocalStorage、WebSQL 等新功能特性，还有很多功能化的标签属性如 `autocomplete`、`autofocus` 和很常用的 `datalist` 标签。\n\n#### 7. Node.js 主要解决了什么问题：\n\n虽然单进程、单线程，但其事件环机制、非阻塞 IO，可以高效的处理高并发请求，并且与前端脚本语言统一。\n\n#### 8. 提高 CSS 性能：\n\n**加载性能：**压缩样式表，不要使用 `@import`（诞生于 CSS2），@import 使用在低网速下会存在页面闪烁问题（link 标签是在加载页面前把 CSS 加载完毕，而 @import 则是读取到引用的文件之后再加载，会延长页面的留白期）；\n\n**选择器性能：**可忽略不计。\n\n**渲染性能：**用 `createDocumentFragment` 对象在内存里操作 DOM、使用 class 类名替换来代替直接更改样式、开启 GPU 硬件加速；\n\n**Repaint（重绘）：**当在页面上修改了一些不需要改变定位的样式的时候（比如 `background-color`、`border-color` 以及 `visibility`)，浏览器只会将新的样式重新绘制给元素（这就叫一次“重绘”或者“重新定义样式”）。这时只需要屏幕的一部分要重画。\n\n**Reflow（回流重排）：**当页面上的改变影响了文档内容、结构或者元素定位时，就会发生重排（或称“重新布局”）。\n\n**其他：**去除空规则；属性值为0时，不加单位；属性值为浮动小数“0.**”时，可以省略小数点之前的0；标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后；\n\n#### 9. CSS 预处理：\n\nCSS 预处理器用一种专门的编程语言，在编写 CSS 的过程中可以使用变量、循环、递归等特性，然后再编译成正常的 CSS 文件，可以提高 CSS 编写效率，常用的预编译语言有 LESS、SESS 等。\n\n#### 10. 关于浮动的原理和工作方式：\n\n浮动本质就是个带有方位的 `display: inline-block` 属性；会打破同一行的 inline-box 模型；\n\n#### 11. 浮动会产生什么影响呢，要怎么处理？\n\n会产生高度塌陷，子元素均设置了浮动样式，父元素会失去高度。\n\n**解决方案：**父级 div 层定义 `overflow: hidden`、结尾处加空 div 标签 `clear:both`、父级 div 定义伪类 `:after`（最后一个子元素的后边）和 `zoom` 属性。\n\n\n```css\n.clearfix{zoom:1;}\n.clearfix:after{display:block; content:\".\"; clear:both; line-height:0; visibility:hidden;}\n```\n\n#### 12. 你了解哪些常用 CSS 选择器？以及这些选择器的使用场景？\n\nID 选择器、类选择器、伪类选择器、全局选择器 ...（请跳至 W3School 查看更多）。\n\n#### 13. 你知道这些选择器的权重怎么计算？\n\n**权值为1000：**代表内联样式，如 “style=\"...\"”。\n\n**权值为100：**代表ID选择器，如 “#content”。\n\n**权值为10：**代表类，伪类和属性选择器，如 “.content”。\n\n**权值为1：**代表类型选择器和伪元素选择器，如 “div p”。\n\n***通用选择器（*），子选择器（>）和相邻同胞选择器（+）的权值都为0。**\n\n#### 14. 你了解哪些布局？你平时有使用过什么布局实现？\n\n弹性布局（与流体布局相似，大小单位使用 em）、固定布局、混合布局、绝对定位布局、流体布局（宽高以百分比计算，配合媒体查询完成） ...\n\n#### 15. 你常用的 JS 框架有哪些？\n\njQuery、Knockout.js、Vue.js、AngularJs、EmberJs、React.js ...（很多 MVVM 框架可以使用）\n\n#### 16. 你从 jQuery 学到了什么？\n\n看了源码中一些“类型检测”函数的实现，jQuery 中的这些方法完成度非常高，实现很全面，性能也是很高的。例如如下所示代码：\n\n\n```javascript\nclass2type = {};\n\njQuery.each(\"Boolean Number String Function Array Date RegExp Object\".split(\" \"), function(i, name) {\n    class2type[\"[object \" + name + \"]\"] = name.toLowerCase();\n}\n\ntype: function(obj) {\n  return obj == null ? String(obj) : class2type[Object.prototype.toString.call(obj)] || \"object\";\n}\n\nisFunction: function(obj) {\n  return jQuery.type(obj) === \"function\";\n}\n\nisArray: Array.isArray || function() {\n  return jQuery.type(obj) === \"array\";\n}\n```\n\n（其他知识点还有很多，异步队列，数据缓存，事件系统，异步请求等）。\n\n#### 17. JS 有哪些数据类型？\n\nnull、undefined、数字、字符串、数组、对象、布尔。\n\n#### 18. JS 的数据类型中哪些是引用类型？\n\n数组、对象。\n\n#### 19. 原型链：\n\n（内容太多，请自行 Google）\n\n#### 20. 函数表达式和函数声明的区别：\n\n函数表达式只有函数定义的提升，函数声明则可以将函数定义和声明同时提升；函数表达式可以放在任何地方，函数声明则只能放到全局环境中。\n\n#### 21. 什么是闭包，为什么要使用闭包？\n\n可以简单理解为“函数中的函数”。两个常见作用：一可以读取函数内部的变量、二让这些变量的值始终保持在内存中。父函数定义的变量在子函数的作用域链中，子函数没有被销毁，其作用域链中所有变量和函数就会被维护，不会被销毁。\n\n\n```javascript\n// 此处在绑定函数时的 i 是没有问题的，从 0 到 “elements.length - 1”；\n// 只是在子函数中的 i 是一直保持对父环境对象中的 i 的引用的，所以在调用时一直会输出 “elements.length”；\nfor (var i = 0; i < elements.length; i++) {\n  elements[i].onclick = function() {\n    console.log(i);\n  }\n}\n// 用 IIFE 隔离外部环境对象，使父环境对象可以及时释放；\n// IIFE 中定义的任何变量和函数，都会在执行结束时被销毁；\nfor (var i = 0; i < elements.length; i++) {\n  (function(n) {\n    elements[n].onclick = function() {\n      console.log(n);\n    }\n  })(i);\n}\n```\n\n#### 22. DOM 中的 Property 和 Attribute 两者的区别：\n\nAttribute 就是 DOM 节点自带的属性，例如 div 中常用的 id、class 等；Property 是这个 DOM 元素作为对象，其附加的内容，例如 `childNodes`、`firstChild` 等；\n\n自定义的 Attribute 不会附加到 Property 上，对于属性 Property 的赋值在 IE 中可能会引起循环引用，内存泄漏。\n\n操作 Attribute 时使用 `setAttribute` 和 `getAttribute` 两个方法来操作，由于 getAttribute 可能会有浏览器兼容性问题，所以在 jQuery 中，在使用之前会对该方法进行测试：\n\n```javascript\ndiv.className = \"a\";\nvar judge = div.getAttribute(\"className\") === \"a\";\n```\n\n*对于 “style” 和 “onclick” 两个属性，它们的 Property 和 Attribute 分别是对象和字符串，与其他有所区别。\n\n#### 23. JS 作用域链：\n\n在一些类 C 的语言中有“块级作用域”，即花括号的每一段代码都有自己的独立作用域，而 JS 只有函数级作用域；JS 作用域链的第一个对象始终是当前执行代码所在环境的变量对象（VO），声明函数在全局作用域，此时作用域链只有一个环境对象；运行函数时作用域链顶端加入了函数内的环境对象，运行完毕时顶端环境对象被销毁，以此类推。\n\nJS 在查找变量时会从链的**顶端（就近原则）**一直向下查找。如果一个跨作用域的对象被引用了一次以上，则先把它存储到局部变量里再使用。全局变量总是存在于运行期上下文作用域链的最**末端**，因此在标识符解析的时候，查找全局变量是最慢的。（最好和闭包一起理解）\n\n#### 24. 你对前端有什么理解？\n\n前端工程化、组件化 ...\n\n#### 25. 你觉得前端体系应该是怎样的？\n\n* 开发工具；\n* 代码质量；\n* 前端框架；\n* 前端开发标准；\n* 部署流程；\n* 代码组织；\n* 代码安全；\n* 移动 Web 开发；\n* 前沿技术社区；\n* 计算机网络体系；\n* 软件工程；\n* 可视化；\n* 浏览器；\n* 编程语言；\n\n#### 26. Hybrid App：\n\n“Hybrid App” 底层依赖于 Native 提供的容器（UIWebview），上层使用传统前端技术做业务开发，底层透明化、上层多样化，这种场景非常有利于前端介入，非常适合业务快速迭代。（详情需深入研究，笔者这方面研究不多）\n\n#### 27. IFC、BFC、GFC 和 FFC：\n\n**IFC：**内联 `display: inline` 格式化上下文，容器里面的子元素不会影响到外面的元素，表示盒子从左到右的水平排列方式；\n\n**BFC：**块级 `display: block` 格式化上下文，表示盒子从上到下的垂直排列方式；\n\n**GFC：**网格 `display: grid` 布局格式化上下文；\n\n**FFC：**自适应 `display: flex` 格式化上下文；\n\n**Box: CSS 布局的基本单位：**\n\nBox 是 CSS 布局的对象和基本单位。直观点来说，就是一个页面是由很多个 Box 组成的。元素的类型和 `display` 属性，决定了这个 Box 的类型。 不同类型的 Box，会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此 Box 内的元素会以不同的方式渲染。\n\n**Formatting Context：**\n\n“Formatting Context” 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的 Formatting Context 有 “Block Fomatting Context”（简称 BFC）和 “Inline Formatting Context”（简称 IFC）。\n\n**BFC布局规则：**\n\n* 内部的 Box 会在垂直方向，一个接一个地放置。\n* Box 垂直方向的距离由 `margin` 样式决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠。\n* 每个元素的 “margin box” 的左边， 与包含块 “border box” 的左边相接触（对于从左往右的格式化，否则相反）。即使存在浮动也是如此。\n* BFC 的区域不会与 “float box” 重叠。\n* BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。\n* 计算 BFC 的高度时，浮动元素也参与计算。\n\n**哪些元素会生成 BFC？**\n\n* 根元素；\n* `float` 属性不为 “none”；\n* `position` 为 “absolute” 或 “fixed”；\n* `display` 为 “inline-block”、“table-cell”、“ table-caption”、“flex”、“inline-flex”；\n* `overflow` 不为 “visible”；\n\n#### 28. JS 垃圾回收机制：\n\n**标记清除：**跟踪环境对象，即跟踪作用域链，GC 会把那些没有作用域影响的内存清除掉；\n\n**引用计数：**即跟踪记录每个值被引用的次数，但可能会有“循环引用”的问题；\n\n#### 29. Ajax 完整流程：\n\n```javascript\n// 获取 XHR 对象;\n// 设置回调函数;\nxmlHTTP.onreadystatechange = callback;\n\n// 打开一个 XHR 链接;\nxmlHTTP.open(\"GET\", url, true);\n\n// POST 请求要设置编码类型;\n// xmlHTTP.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");  \n// 发送请求;\nxmlHTTP.send(null);\n\nfunction callback() {\n  if (xmlHTTP.readyState == 4) {\n    if (xmlHTTP.status == 200) {\n      console.log(xmlHTTP.responseText);\n    }\n  }\n}\n```\n\n#### 30. Gulp 和 Grunt 的异同点？\n\nGulp 基于“流”的概念，只有一次 IO 过程，类似于 Linux 里的管道，又像 jQuery 的链式调用；Gulp 更易用；\n\n#### 31. 浏览器可以并行下载多少个资源？\n\n在 HTTP/1.1 协议下一般是6个，最多不超过8个；\n\n#### 32. 你觉得哪些网站前端技术比较好，这些网站的架构怎样？\n\n举例：淘宝网，用来很多 H5 的语义化标签；降级兼容做的很好，对禁用脚本的浏览器提供友好的选项；云客服使用 WS ，来代替 Ajax 轮询等；\n\n#### 33. 淘宝网上的商品项，如图片，滚动到了才加载，是怎么实现的？\n\n应该是 PipeRender 技术的一种，BigRender 的原理是通过某种方式，将首屏不需要的 HTML 代码先存放起来。渲染好首屏后，再将存储好的 HTML 代码逐步渲染出来。\n\n#### 34. 你了解后端技术么，前后端一般是怎么配合的？\n\n笔者公司用的是 CakePHP 和 Laravel 两套 PHP 框架，Laravel 本身有自己的模板引擎，同时可以与 Gulp 进行无缝衔接；模板会预留出需要替换的变量位置，前后端分离处理；前端模板可以进行模板的继承与嵌套；\n\n#### 35. 安卓上如何实现 1px 像素线？\n\n因为 Retine 屏的分辨率始终是普通屏幕的2倍，导致原本 1px 的细线在手机上显示为 2px；\n\nIOS8 及以上可以直接使用 `border-width: 0.5px;` 来设置 1px 的线段，其他平台可以用 `transform` 将细线高度缩小一半：\n\n```css\n.hairlines li:after {     \n    content: \"\";     \n    position: absolute;     \n    left: 0;     \n    background: #000;     \n    width: 100%;     \n    height: 1px;     \n    -webkit-transform: scaleY(0.5);             \n    transform: scaleY(0.5);     \n    -webkit-transform-origin: 0 0;             \n    transform-origin: 0 0; \n}\n```\n\n#### 36. 流应用是什么？\n\n“流应用”结合了原生 App 和 Web App 的优势，又消除了各自的缺点。流应用建立在 “H5+” 这一突破性技术之上，通过强化 HTML5 使其达到原生 App 的功能和体验，并辅以**类似流媒体的边用边下发行技术**，这2项技术是流应用诞生的关键。\n\n#### 37. 移动设备浏览器的 click 事件300毫秒延迟？\n\n来源于最初的 Safari 浏览器在用户点击屏幕时会等待300毫秒，以判断用户是想进行单击还是进行双击缩放。其他浏览器也借鉴 Safari 的特性，导致了这一问题。\n\n**基本解决：**修改 viewport 来禁用缩放 `<meta name=\"viewport\" content=\"width=device-width, user-scalable=no\">` 并同时设置 CSS 属性 `touch-action: none;`。\n\n**完美方案：**FastClick 的实现原理是在检测到 touchend 事件的时候，会通过 DOM 自定义事件立即出发模拟一个 click 事件，并把浏览器在 300ms 之后的 click 事件阻止掉。\n\n#### 38. touchstart 的点击穿透问题：\n\n因为在移动端浏览器，事件执行的顺序是 **touchstart > touchend > click**，而 click 事件有 300ms 的延迟，当 touchstart 事件把 B 元素隐藏之后，隔了 300ms，浏览器触发了 click 事件，但是此时 B 元素不见了，所以该事件被派发到了 A 元素身上。如果 A 元素是一个链接，那此时页面就会意外地跳转。\n\n","slug":"前端关键技术点杂烩","published":1,"updated":"2019-02-10T06:56:55.703Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtat005uknp2txzoy9t6","content":"<p>本篇文章主要总结一下 Web 前端面试的一些常见面试题，同时这些问题也是对一些基础的技术概念和思想的理解。对这些基本知识的掌握程度和深度决定了你的技术层级。高级工程师是必须掌握本文列出的这些知识点，资深工程师则要对这些基本概念的纵向深度进行挖掘，【问题解答全部原创，转载请注明来源】。</p>\n<h3 id=\"综合技术方面：\"><a href=\"#综合技术方面：\" class=\"headerlink\" title=\"综合技术方面：\"></a>综合技术方面：</h3><h4 id=\"1-网站和页面性能优化：\"><a href=\"#1-网站和页面性能优化：\" class=\"headerlink\" title=\"1. 网站和页面性能优化：\"></a>1. 网站和页面性能优化：</h4><p><strong>缓存：</strong>ETag、Expire、Last-Modified 三者合用，Expire 字段可以让浏览器完全不发起 HTTP 请求，若按 F5 键发起请求，也可以通过判断 ETag（对应浏览器字段 If-None-Match） 和 Last-Modified（对应浏览器字段 If-Modified-Since）字段来确认是否需要更新资源还是使用 304(Not Modified)缓存的本地资源；</p>\n<p><strong>静态资源：</strong>代码压缩合并、CSS 雪碧图、分析 FTTB 是否采用 CDN、服务器开启 GZIP 压缩、图片压缩、静态资源使用独立域名，防止域名污染（静态资源不需要携带 Cookie，又叫 Cookie 隔离）；</p>\n<p><strong>页面结构：</strong>样式表放顶部，JS 脚本放底部，不让 JS 脚本阻碍页面 DOM 的加载；</p>\n<p><strong>代码优化：</strong>缩短原型链，减少属性和方法的查找时间；使用事件代理代替事件绑定；减少对 DOM 的直接操作，减少页面重绘；使用 H5 新方法 <code>requestAnimationFrame</code> 来执行 DOM 动画；使用 <code>createElement</code> 代替 <code>innerHTML</code> 进行 DOM 插入，因为它的速度更快；</p>\n<p><strong>其他方法：</strong>BigPipe 优化、BigRender 优化、Quickling 优化；</p>\n<h4 id=\"2-字体大小常用单位：\"><a href=\"#2-字体大小常用单位：\" class=\"headerlink\" title=\"2. 字体大小常用单位：\"></a>2. 字体大小常用单位：</h4><p><strong>绝对值：</strong>像素 px、点 pt = (DPI / 72) px；</p>\n<p><strong>相对值：</strong>一个字的大小 em（默认值 <strong>1em = 16px</strong>，16px 也为浏览器的默认字体大小，继承父元素的大小，为了计算通常设 <code>html { font-size: 63%; }</code>，即 1em = 10px）相对于根节点的一个字大小 rem；</p>\n<h4 id=\"3-CSS-Reset：\"><a href=\"#3-CSS-Reset：\" class=\"headerlink\" title=\"3. CSS Reset：\"></a>3. CSS Reset：</h4><p>“CSS Reset” 就是由于各种浏览器解释 CSS 样式的初始值有所不同，导致设计师在没有定义某个 CSS 属性时，不同的浏览器会按照自己的默认值来为没有定义的样式赋值，所以我们要先定义好一些 CSS 样式，来让所有浏览器都按照同样的规则解释 CSS，这样就能避免发生这种问题。本质就是清除浏览器默认样式，并且进行全局样式定义，Reset 文件要在项目初期定好，这样才不会产生后期的回归测试问题。</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token selector\">* </span><span class=\"token punctuation\">{</span>\n    <span class=\"token property\">vertical-align</span><span class=\"token punctuation\">:</span> baseline<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">font-weight</span><span class=\"token punctuation\">:</span> inherit<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">font-family</span><span class=\"token punctuation\">:</span> inherit<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">font-style</span><span class=\"token punctuation\">:</span> inherit<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">font-size</span><span class=\"token punctuation\">:</span> <span class=\"token number\">100%</span><span class=\"token punctuation\">;</span>\n    <span class=\"token property\">outline</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token property\">padding</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token property\">margin</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token property\">border</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"4-弹性布局、响应式、重构：\"><a href=\"#4-弹性布局、响应式、重构：\" class=\"headerlink\" title=\"4. 弹性布局、响应式、重构：\"></a>4. 弹性布局、响应式、重构：</h4><p><strong>弹性布局：</strong>Flexbox 布局模式，适用于多行多列自适应布局。</p>\n<p><strong>响应式布局：</strong>媒体查询（Media Queries）和 Viewport（初始比例，最大比例，最大宽度，缩放控制）控制。</p>\n<h4 id=\"5-什么叫优雅降级和渐进增强：\"><a href=\"#5-什么叫优雅降级和渐进增强：\" class=\"headerlink\" title=\"5. 什么叫优雅降级和渐进增强：\"></a>5. 什么叫优雅降级和渐进增强：</h4><p><strong>渐进增强：</strong>针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</p>\n<p><strong>优雅降级：</strong>一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</p>\n<p>两者区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。</p>\n<h4 id=\"6-HTML5-主要增强了什么：\"><a href=\"#6-HTML5-主要增强了什么：\" class=\"headerlink\" title=\"6. HTML5 主要增强了什么：\"></a>6. HTML5 主要增强了什么：</h4><p>增加了很多利于网站 SEO 的语义化标签如 <code>header</code>、<code>footer</code>、<code>article</code>、<code>nav</code>，功能性标签如 <code>canvas</code>、<code>video</code>、<code>audio</code> 使得浏览器可以进一步摆脱插件。WebSocket、LocalStorage、WebSQL 等新功能特性，还有很多功能化的标签属性如 <code>autocomplete</code>、<code>autofocus</code> 和很常用的 <code>datalist</code> 标签。</p>\n<h4 id=\"7-Node-js-主要解决了什么问题：\"><a href=\"#7-Node-js-主要解决了什么问题：\" class=\"headerlink\" title=\"7. Node.js 主要解决了什么问题：\"></a>7. Node.js 主要解决了什么问题：</h4><p>虽然单进程、单线程，但其事件环机制、非阻塞 IO，可以高效的处理高并发请求，并且与前端脚本语言统一。</p>\n<h4 id=\"8-提高-CSS-性能：\"><a href=\"#8-提高-CSS-性能：\" class=\"headerlink\" title=\"8. 提高 CSS 性能：\"></a>8. 提高 CSS 性能：</h4><p><strong>加载性能：</strong>压缩样式表，不要使用 <code>@import</code>（诞生于 CSS2），@import 使用在低网速下会存在页面闪烁问题（link 标签是在加载页面前把 CSS 加载完毕，而 @import 则是读取到引用的文件之后再加载，会延长页面的留白期）；</p>\n<p><strong>选择器性能：</strong>可忽略不计。</p>\n<p><strong>渲染性能：</strong>用 <code>createDocumentFragment</code> 对象在内存里操作 DOM、使用 class 类名替换来代替直接更改样式、开启 GPU 硬件加速；</p>\n<p><strong>Repaint（重绘）：</strong>当在页面上修改了一些不需要改变定位的样式的时候（比如 <code>background-color</code>、<code>border-color</code> 以及 <code>visibility</code>)，浏览器只会将新的样式重新绘制给元素（这就叫一次“重绘”或者“重新定义样式”）。这时只需要屏幕的一部分要重画。</p>\n<p><strong>Reflow（回流重排）：</strong>当页面上的改变影响了文档内容、结构或者元素定位时，就会发生重排（或称“重新布局”）。</p>\n<p><strong>其他：</strong>去除空规则；属性值为0时，不加单位；属性值为浮动小数“0.**”时，可以省略小数点之前的0；标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后；</p>\n<h4 id=\"9-CSS-预处理：\"><a href=\"#9-CSS-预处理：\" class=\"headerlink\" title=\"9. CSS 预处理：\"></a>9. CSS 预处理：</h4><p>CSS 预处理器用一种专门的编程语言，在编写 CSS 的过程中可以使用变量、循环、递归等特性，然后再编译成正常的 CSS 文件，可以提高 CSS 编写效率，常用的预编译语言有 LESS、SESS 等。</p>\n<h4 id=\"10-关于浮动的原理和工作方式：\"><a href=\"#10-关于浮动的原理和工作方式：\" class=\"headerlink\" title=\"10. 关于浮动的原理和工作方式：\"></a>10. 关于浮动的原理和工作方式：</h4><p>浮动本质就是个带有方位的 <code>display: inline-block</code> 属性；会打破同一行的 inline-box 模型；</p>\n<h4 id=\"11-浮动会产生什么影响呢，要怎么处理？\"><a href=\"#11-浮动会产生什么影响呢，要怎么处理？\" class=\"headerlink\" title=\"11. 浮动会产生什么影响呢，要怎么处理？\"></a>11. 浮动会产生什么影响呢，要怎么处理？</h4><p>会产生高度塌陷，子元素均设置了浮动样式，父元素会失去高度。</p>\n<p><strong>解决方案：</strong>父级 div 层定义 <code>overflow: hidden</code>、结尾处加空 div 标签 <code>clear:both</code>、父级 div 定义伪类 <code>:after</code>（最后一个子元素的后边）和 <code>zoom</code> 属性。</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token selector\"><span class=\"token class\">.clearfix</span></span><span class=\"token punctuation\">{</span><span class=\"token property\">zoom</span><span class=\"token punctuation\">:</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span>\n<span class=\"token selector\"><span class=\"token class\">.clearfix</span><span class=\"token pseudo-element\">:after</span></span><span class=\"token punctuation\">{</span><span class=\"token property\">display</span><span class=\"token punctuation\">:</span>block<span class=\"token punctuation\">;</span> <span class=\"token property\">content</span><span class=\"token punctuation\">:</span><span class=\"token string\">\".\"</span><span class=\"token punctuation\">;</span> <span class=\"token property\">clear</span><span class=\"token punctuation\">:</span>both<span class=\"token punctuation\">;</span> <span class=\"token property\">line-height</span><span class=\"token punctuation\">:</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token property\">visibility</span><span class=\"token punctuation\">:</span>hidden<span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h4 id=\"12-你了解哪些常用-CSS-选择器？以及这些选择器的使用场景？\"><a href=\"#12-你了解哪些常用-CSS-选择器？以及这些选择器的使用场景？\" class=\"headerlink\" title=\"12. 你了解哪些常用 CSS 选择器？以及这些选择器的使用场景？\"></a>12. 你了解哪些常用 CSS 选择器？以及这些选择器的使用场景？</h4><p>ID 选择器、类选择器、伪类选择器、全局选择器 …（请跳至 W3School 查看更多）。</p>\n<h4 id=\"13-你知道这些选择器的权重怎么计算？\"><a href=\"#13-你知道这些选择器的权重怎么计算？\" class=\"headerlink\" title=\"13. 你知道这些选择器的权重怎么计算？\"></a>13. 你知道这些选择器的权重怎么计算？</h4><p><strong>权值为1000：</strong>代表内联样式，如 “style=”…””。</p>\n<p><strong>权值为100：</strong>代表ID选择器，如 “#content”。</p>\n<p><strong>权值为10：</strong>代表类，伪类和属性选择器，如 “.content”。</p>\n<p><strong>权值为1：</strong>代表类型选择器和伪元素选择器，如 “div p”。</p>\n<p><strong><em>通用选择器（</em>），子选择器（&gt;）和相邻同胞选择器（+）的权值都为0。</strong></p>\n<h4 id=\"14-你了解哪些布局？你平时有使用过什么布局实现？\"><a href=\"#14-你了解哪些布局？你平时有使用过什么布局实现？\" class=\"headerlink\" title=\"14. 你了解哪些布局？你平时有使用过什么布局实现？\"></a>14. 你了解哪些布局？你平时有使用过什么布局实现？</h4><p>弹性布局（与流体布局相似，大小单位使用 em）、固定布局、混合布局、绝对定位布局、流体布局（宽高以百分比计算，配合媒体查询完成） …</p>\n<h4 id=\"15-你常用的-JS-框架有哪些？\"><a href=\"#15-你常用的-JS-框架有哪些？\" class=\"headerlink\" title=\"15. 你常用的 JS 框架有哪些？\"></a>15. 你常用的 JS 框架有哪些？</h4><p>jQuery、Knockout.js、Vue.js、AngularJs、EmberJs、React.js …（很多 MVVM 框架可以使用）</p>\n<h4 id=\"16-你从-jQuery-学到了什么？\"><a href=\"#16-你从-jQuery-学到了什么？\" class=\"headerlink\" title=\"16. 你从 jQuery 学到了什么？\"></a>16. 你从 jQuery 学到了什么？</h4><p>看了源码中一些“类型检测”函数的实现，jQuery 中的这些方法完成度非常高，实现很全面，性能也是很高的。例如如下所示代码：</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\">class2type <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\njQuery<span class=\"token punctuation\">.</span><span class=\"token function\">each</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Boolean Number String Function Array Date RegExp Object\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">\" \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    class2type<span class=\"token punctuation\">[</span><span class=\"token string\">\"[object \"</span> <span class=\"token operator\">+</span> name <span class=\"token operator\">+</span> <span class=\"token string\">\"]\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> name<span class=\"token punctuation\">.</span><span class=\"token function\">toLowerCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\ntype<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> obj <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">?</span> <span class=\"token function\">String</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span> class2type<span class=\"token punctuation\">[</span>Object<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>toString<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">||</span> <span class=\"token string\">\"object\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nisFunction<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> jQuery<span class=\"token punctuation\">.</span><span class=\"token function\">type</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token string\">\"function\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nisArray<span class=\"token punctuation\">:</span> Array<span class=\"token punctuation\">.</span>isArray <span class=\"token operator\">||</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> jQuery<span class=\"token punctuation\">.</span><span class=\"token function\">type</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token string\">\"array\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>（其他知识点还有很多，异步队列，数据缓存，事件系统，异步请求等）。</p>\n<h4 id=\"17-JS-有哪些数据类型？\"><a href=\"#17-JS-有哪些数据类型？\" class=\"headerlink\" title=\"17. JS 有哪些数据类型？\"></a>17. JS 有哪些数据类型？</h4><p>null、undefined、数字、字符串、数组、对象、布尔。</p>\n<h4 id=\"18-JS-的数据类型中哪些是引用类型？\"><a href=\"#18-JS-的数据类型中哪些是引用类型？\" class=\"headerlink\" title=\"18. JS 的数据类型中哪些是引用类型？\"></a>18. JS 的数据类型中哪些是引用类型？</h4><p>数组、对象。</p>\n<h4 id=\"19-原型链：\"><a href=\"#19-原型链：\" class=\"headerlink\" title=\"19. 原型链：\"></a>19. 原型链：</h4><p>（内容太多，请自行 Google）</p>\n<h4 id=\"20-函数表达式和函数声明的区别：\"><a href=\"#20-函数表达式和函数声明的区别：\" class=\"headerlink\" title=\"20. 函数表达式和函数声明的区别：\"></a>20. 函数表达式和函数声明的区别：</h4><p>函数表达式只有函数定义的提升，函数声明则可以将函数定义和声明同时提升；函数表达式可以放在任何地方，函数声明则只能放到全局环境中。</p>\n<h4 id=\"21-什么是闭包，为什么要使用闭包？\"><a href=\"#21-什么是闭包，为什么要使用闭包？\" class=\"headerlink\" title=\"21. 什么是闭包，为什么要使用闭包？\"></a>21. 什么是闭包，为什么要使用闭包？</h4><p>可以简单理解为“函数中的函数”。两个常见作用：一可以读取函数内部的变量、二让这些变量的值始终保持在内存中。父函数定义的变量在子函数的作用域链中，子函数没有被销毁，其作用域链中所有变量和函数就会被维护，不会被销毁。</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">// 此处在绑定函数时的 i 是没有问题的，从 0 到 “elements.length - 1”；</span>\n<span class=\"token comment\" spellcheck=\"true\">// 只是在子函数中的 i 是一直保持对父环境对象中的 i 的引用的，所以在调用时一直会输出 “elements.length”；</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> elements<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  elements<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>onclick <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">// 用 IIFE 隔离外部环境对象，使父环境对象可以及时释放；</span>\n<span class=\"token comment\" spellcheck=\"true\">// IIFE 中定义的任何变量和函数，都会在执行结束时被销毁；</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> elements<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    elements<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>onclick <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"22-DOM-中的-Property-和-Attribute-两者的区别：\"><a href=\"#22-DOM-中的-Property-和-Attribute-两者的区别：\" class=\"headerlink\" title=\"22. DOM 中的 Property 和 Attribute 两者的区别：\"></a>22. DOM 中的 Property 和 Attribute 两者的区别：</h4><p>Attribute 就是 DOM 节点自带的属性，例如 div 中常用的 id、class 等；Property 是这个 DOM 元素作为对象，其附加的内容，例如 <code>childNodes</code>、<code>firstChild</code> 等；</p>\n<p>自定义的 Attribute 不会附加到 Property 上，对于属性 Property 的赋值在 IE 中可能会引起循环引用，内存泄漏。</p>\n<p>操作 Attribute 时使用 <code>setAttribute</code> 和 <code>getAttribute</code> 两个方法来操作，由于 getAttribute 可能会有浏览器兼容性问题，所以在 jQuery 中，在使用之前会对该方法进行测试：</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\">div<span class=\"token punctuation\">.</span>className <span class=\"token operator\">=</span> <span class=\"token string\">\"a\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> judge <span class=\"token operator\">=</span> div<span class=\"token punctuation\">.</span><span class=\"token function\">getAttribute</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"className\"</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token string\">\"a\"</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>*对于 “style” 和 “onclick” 两个属性，它们的 Property 和 Attribute 分别是对象和字符串，与其他有所区别。</p>\n<h4 id=\"23-JS-作用域链：\"><a href=\"#23-JS-作用域链：\" class=\"headerlink\" title=\"23. JS 作用域链：\"></a>23. JS 作用域链：</h4><p>在一些类 C 的语言中有“块级作用域”，即花括号的每一段代码都有自己的独立作用域，而 JS 只有函数级作用域；JS 作用域链的第一个对象始终是当前执行代码所在环境的变量对象（VO），声明函数在全局作用域，此时作用域链只有一个环境对象；运行函数时作用域链顶端加入了函数内的环境对象，运行完毕时顶端环境对象被销毁，以此类推。</p>\n<p>JS 在查找变量时会从链的<strong>顶端（就近原则）</strong>一直向下查找。如果一个跨作用域的对象被引用了一次以上，则先把它存储到局部变量里再使用。全局变量总是存在于运行期上下文作用域链的最<strong>末端</strong>，因此在标识符解析的时候，查找全局变量是最慢的。（最好和闭包一起理解）</p>\n<h4 id=\"24-你对前端有什么理解？\"><a href=\"#24-你对前端有什么理解？\" class=\"headerlink\" title=\"24. 你对前端有什么理解？\"></a>24. 你对前端有什么理解？</h4><p>前端工程化、组件化 …</p>\n<h4 id=\"25-你觉得前端体系应该是怎样的？\"><a href=\"#25-你觉得前端体系应该是怎样的？\" class=\"headerlink\" title=\"25. 你觉得前端体系应该是怎样的？\"></a>25. 你觉得前端体系应该是怎样的？</h4><ul>\n<li>开发工具；</li>\n<li>代码质量；</li>\n<li>前端框架；</li>\n<li>前端开发标准；</li>\n<li>部署流程；</li>\n<li>代码组织；</li>\n<li>代码安全；</li>\n<li>移动 Web 开发；</li>\n<li>前沿技术社区；</li>\n<li>计算机网络体系；</li>\n<li>软件工程；</li>\n<li>可视化；</li>\n<li>浏览器；</li>\n<li>编程语言；</li>\n</ul>\n<h4 id=\"26-Hybrid-App：\"><a href=\"#26-Hybrid-App：\" class=\"headerlink\" title=\"26. Hybrid App：\"></a>26. Hybrid App：</h4><p>“Hybrid App” 底层依赖于 Native 提供的容器（UIWebview），上层使用传统前端技术做业务开发，底层透明化、上层多样化，这种场景非常有利于前端介入，非常适合业务快速迭代。（详情需深入研究，笔者这方面研究不多）</p>\n<h4 id=\"27-IFC、BFC、GFC-和-FFC：\"><a href=\"#27-IFC、BFC、GFC-和-FFC：\" class=\"headerlink\" title=\"27. IFC、BFC、GFC 和 FFC：\"></a>27. IFC、BFC、GFC 和 FFC：</h4><p><strong>IFC：</strong>内联 <code>display: inline</code> 格式化上下文，容器里面的子元素不会影响到外面的元素，表示盒子从左到右的水平排列方式；</p>\n<p><strong>BFC：</strong>块级 <code>display: block</code> 格式化上下文，表示盒子从上到下的垂直排列方式；</p>\n<p><strong>GFC：</strong>网格 <code>display: grid</code> 布局格式化上下文；</p>\n<p><strong>FFC：</strong>自适应 <code>display: flex</code> 格式化上下文；</p>\n<p><strong>Box: CSS 布局的基本单位：</strong></p>\n<p>Box 是 CSS 布局的对象和基本单位。直观点来说，就是一个页面是由很多个 Box 组成的。元素的类型和 <code>display</code> 属性，决定了这个 Box 的类型。 不同类型的 Box，会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此 Box 内的元素会以不同的方式渲染。</p>\n<p><strong>Formatting Context：</strong></p>\n<p>“Formatting Context” 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的 Formatting Context 有 “Block Fomatting Context”（简称 BFC）和 “Inline Formatting Context”（简称 IFC）。</p>\n<p><strong>BFC布局规则：</strong></p>\n<ul>\n<li>内部的 Box 会在垂直方向，一个接一个地放置。</li>\n<li>Box 垂直方向的距离由 <code>margin</code> 样式决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠。</li>\n<li>每个元素的 “margin box” 的左边， 与包含块 “border box” 的左边相接触（对于从左往右的格式化，否则相反）。即使存在浮动也是如此。</li>\n<li>BFC 的区域不会与 “float box” 重叠。</li>\n<li>BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li>\n<li>计算 BFC 的高度时，浮动元素也参与计算。</li>\n</ul>\n<p><strong>哪些元素会生成 BFC？</strong></p>\n<ul>\n<li>根元素；</li>\n<li><code>float</code> 属性不为 “none”；</li>\n<li><code>position</code> 为 “absolute” 或 “fixed”；</li>\n<li><code>display</code> 为 “inline-block”、“table-cell”、“ table-caption”、“flex”、“inline-flex”；</li>\n<li><code>overflow</code> 不为 “visible”；</li>\n</ul>\n<h4 id=\"28-JS-垃圾回收机制：\"><a href=\"#28-JS-垃圾回收机制：\" class=\"headerlink\" title=\"28. JS 垃圾回收机制：\"></a>28. JS 垃圾回收机制：</h4><p><strong>标记清除：</strong>跟踪环境对象，即跟踪作用域链，GC 会把那些没有作用域影响的内存清除掉；</p>\n<p><strong>引用计数：</strong>即跟踪记录每个值被引用的次数，但可能会有“循环引用”的问题；</p>\n<h4 id=\"29-Ajax-完整流程：\"><a href=\"#29-Ajax-完整流程：\" class=\"headerlink\" title=\"29. Ajax 完整流程：\"></a>29. Ajax 完整流程：</h4><pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">// 获取 XHR 对象;</span>\n<span class=\"token comment\" spellcheck=\"true\">// 设置回调函数;</span>\nxmlHTTP<span class=\"token punctuation\">.</span>onreadystatechange <span class=\"token operator\">=</span> callback<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 打开一个 XHR 链接;</span>\nxmlHTTP<span class=\"token punctuation\">.</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"GET\"</span><span class=\"token punctuation\">,</span> url<span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// POST 请求要设置编码类型;</span>\n<span class=\"token comment\" spellcheck=\"true\">// xmlHTTP.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");  </span>\n<span class=\"token comment\" spellcheck=\"true\">// 发送请求;</span>\nxmlHTTP<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">callback</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>xmlHTTP<span class=\"token punctuation\">.</span>readyState <span class=\"token operator\">==</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>xmlHTTP<span class=\"token punctuation\">.</span>status <span class=\"token operator\">==</span> <span class=\"token number\">200</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>xmlHTTP<span class=\"token punctuation\">.</span>responseText<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"30-Gulp-和-Grunt-的异同点？\"><a href=\"#30-Gulp-和-Grunt-的异同点？\" class=\"headerlink\" title=\"30. Gulp 和 Grunt 的异同点？\"></a>30. Gulp 和 Grunt 的异同点？</h4><p>Gulp 基于“流”的概念，只有一次 IO 过程，类似于 Linux 里的管道，又像 jQuery 的链式调用；Gulp 更易用；</p>\n<h4 id=\"31-浏览器可以并行下载多少个资源？\"><a href=\"#31-浏览器可以并行下载多少个资源？\" class=\"headerlink\" title=\"31. 浏览器可以并行下载多少个资源？\"></a>31. 浏览器可以并行下载多少个资源？</h4><p>在 HTTP/1.1 协议下一般是6个，最多不超过8个；</p>\n<h4 id=\"32-你觉得哪些网站前端技术比较好，这些网站的架构怎样？\"><a href=\"#32-你觉得哪些网站前端技术比较好，这些网站的架构怎样？\" class=\"headerlink\" title=\"32. 你觉得哪些网站前端技术比较好，这些网站的架构怎样？\"></a>32. 你觉得哪些网站前端技术比较好，这些网站的架构怎样？</h4><p>举例：淘宝网，用来很多 H5 的语义化标签；降级兼容做的很好，对禁用脚本的浏览器提供友好的选项；云客服使用 WS ，来代替 Ajax 轮询等；</p>\n<h4 id=\"33-淘宝网上的商品项，如图片，滚动到了才加载，是怎么实现的？\"><a href=\"#33-淘宝网上的商品项，如图片，滚动到了才加载，是怎么实现的？\" class=\"headerlink\" title=\"33. 淘宝网上的商品项，如图片，滚动到了才加载，是怎么实现的？\"></a>33. 淘宝网上的商品项，如图片，滚动到了才加载，是怎么实现的？</h4><p>应该是 PipeRender 技术的一种，BigRender 的原理是通过某种方式，将首屏不需要的 HTML 代码先存放起来。渲染好首屏后，再将存储好的 HTML 代码逐步渲染出来。</p>\n<h4 id=\"34-你了解后端技术么，前后端一般是怎么配合的？\"><a href=\"#34-你了解后端技术么，前后端一般是怎么配合的？\" class=\"headerlink\" title=\"34. 你了解后端技术么，前后端一般是怎么配合的？\"></a>34. 你了解后端技术么，前后端一般是怎么配合的？</h4><p>笔者公司用的是 CakePHP 和 Laravel 两套 PHP 框架，Laravel 本身有自己的模板引擎，同时可以与 Gulp 进行无缝衔接；模板会预留出需要替换的变量位置，前后端分离处理；前端模板可以进行模板的继承与嵌套；</p>\n<h4 id=\"35-安卓上如何实现-1px-像素线？\"><a href=\"#35-安卓上如何实现-1px-像素线？\" class=\"headerlink\" title=\"35. 安卓上如何实现 1px 像素线？\"></a>35. 安卓上如何实现 1px 像素线？</h4><p>因为 Retine 屏的分辨率始终是普通屏幕的2倍，导致原本 1px 的细线在手机上显示为 2px；</p>\n<p>IOS8 及以上可以直接使用 <code>border-width: 0.5px;</code> 来设置 1px 的线段，其他平台可以用 <code>transform</code> 将细线高度缩小一半：</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token selector\"><span class=\"token class\">.hairlines</span> li<span class=\"token pseudo-element\">:after</span> </span><span class=\"token punctuation\">{</span>     \n    <span class=\"token property\">content</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">;</span>     \n    <span class=\"token property\">position</span><span class=\"token punctuation\">:</span> absolute<span class=\"token punctuation\">;</span>     \n    <span class=\"token property\">left</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>     \n    <span class=\"token property\">background</span><span class=\"token punctuation\">:</span> <span class=\"token hexcode\">#000</span><span class=\"token punctuation\">;</span>     \n    <span class=\"token property\">width</span><span class=\"token punctuation\">:</span> <span class=\"token number\">100%</span><span class=\"token punctuation\">;</span>     \n    <span class=\"token property\">height</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span>px<span class=\"token punctuation\">;</span>     \n    <span class=\"token property\">-webkit-transform</span><span class=\"token punctuation\">:</span> <span class=\"token function\">scaleY</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>             \n    <span class=\"token property\">transform</span><span class=\"token punctuation\">:</span> <span class=\"token function\">scaleY</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>     \n    <span class=\"token property\">-webkit-transform-origin</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>             \n    <span class=\"token property\">transform-origin</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"36-流应用是什么？\"><a href=\"#36-流应用是什么？\" class=\"headerlink\" title=\"36. 流应用是什么？\"></a>36. 流应用是什么？</h4><p>“流应用”结合了原生 App 和 Web App 的优势，又消除了各自的缺点。流应用建立在 “H5+” 这一突破性技术之上，通过强化 HTML5 使其达到原生 App 的功能和体验，并辅以<strong>类似流媒体的边用边下发行技术</strong>，这2项技术是流应用诞生的关键。</p>\n<h4 id=\"37-移动设备浏览器的-click-事件300毫秒延迟？\"><a href=\"#37-移动设备浏览器的-click-事件300毫秒延迟？\" class=\"headerlink\" title=\"37. 移动设备浏览器的 click 事件300毫秒延迟？\"></a>37. 移动设备浏览器的 click 事件300毫秒延迟？</h4><p>来源于最初的 Safari 浏览器在用户点击屏幕时会等待300毫秒，以判断用户是想进行单击还是进行双击缩放。其他浏览器也借鉴 Safari 的特性，导致了这一问题。</p>\n<p><strong>基本解决：</strong>修改 viewport 来禁用缩放 <code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no&quot;&gt;</code> 并同时设置 CSS 属性 <code>touch-action: none;</code>。</p>\n<p><strong>完美方案：</strong>FastClick 的实现原理是在检测到 touchend 事件的时候，会通过 DOM 自定义事件立即出发模拟一个 click 事件，并把浏览器在 300ms 之后的 click 事件阻止掉。</p>\n<h4 id=\"38-touchstart-的点击穿透问题：\"><a href=\"#38-touchstart-的点击穿透问题：\" class=\"headerlink\" title=\"38. touchstart 的点击穿透问题：\"></a>38. touchstart 的点击穿透问题：</h4><p>因为在移动端浏览器，事件执行的顺序是 <strong>touchstart &gt; touchend &gt; click</strong>，而 click 事件有 300ms 的延迟，当 touchstart 事件把 B 元素隐藏之后，隔了 300ms，浏览器触发了 click 事件，但是此时 B 元素不见了，所以该事件被派发到了 A 元素身上。如果 A 元素是一个链接，那此时页面就会意外地跳转。</p>\n","site":{"data":{}},"id":"5a57d996bcd5d6298914c04485e98746","excerpt":"","more":"<p>本篇文章主要总结一下 Web 前端面试的一些常见面试题，同时这些问题也是对一些基础的技术概念和思想的理解。对这些基本知识的掌握程度和深度决定了你的技术层级。高级工程师是必须掌握本文列出的这些知识点，资深工程师则要对这些基本概念的纵向深度进行挖掘，【问题解答全部原创，转载请注明来源】。</p>\n<h3 id=\"综合技术方面：\"><a href=\"#综合技术方面：\" class=\"headerlink\" title=\"综合技术方面：\"></a>综合技术方面：</h3><h4 id=\"1-网站和页面性能优化：\"><a href=\"#1-网站和页面性能优化：\" class=\"headerlink\" title=\"1. 网站和页面性能优化：\"></a>1. 网站和页面性能优化：</h4><p><strong>缓存：</strong>ETag、Expire、Last-Modified 三者合用，Expire 字段可以让浏览器完全不发起 HTTP 请求，若按 F5 键发起请求，也可以通过判断 ETag（对应浏览器字段 If-None-Match） 和 Last-Modified（对应浏览器字段 If-Modified-Since）字段来确认是否需要更新资源还是使用 304(Not Modified)缓存的本地资源；</p>\n<p><strong>静态资源：</strong>代码压缩合并、CSS 雪碧图、分析 FTTB 是否采用 CDN、服务器开启 GZIP 压缩、图片压缩、静态资源使用独立域名，防止域名污染（静态资源不需要携带 Cookie，又叫 Cookie 隔离）；</p>\n<p><strong>页面结构：</strong>样式表放顶部，JS 脚本放底部，不让 JS 脚本阻碍页面 DOM 的加载；</p>\n<p><strong>代码优化：</strong>缩短原型链，减少属性和方法的查找时间；使用事件代理代替事件绑定；减少对 DOM 的直接操作，减少页面重绘；使用 H5 新方法 <code>requestAnimationFrame</code> 来执行 DOM 动画；使用 <code>createElement</code> 代替 <code>innerHTML</code> 进行 DOM 插入，因为它的速度更快；</p>\n<p><strong>其他方法：</strong>BigPipe 优化、BigRender 优化、Quickling 优化；</p>\n<h4 id=\"2-字体大小常用单位：\"><a href=\"#2-字体大小常用单位：\" class=\"headerlink\" title=\"2. 字体大小常用单位：\"></a>2. 字体大小常用单位：</h4><p><strong>绝对值：</strong>像素 px、点 pt = (DPI / 72) px；</p>\n<p><strong>相对值：</strong>一个字的大小 em（默认值 <strong>1em = 16px</strong>，16px 也为浏览器的默认字体大小，继承父元素的大小，为了计算通常设 <code>html { font-size: 63%; }</code>，即 1em = 10px）相对于根节点的一个字大小 rem；</p>\n<h4 id=\"3-CSS-Reset：\"><a href=\"#3-CSS-Reset：\" class=\"headerlink\" title=\"3. CSS Reset：\"></a>3. CSS Reset：</h4><p>“CSS Reset” 就是由于各种浏览器解释 CSS 样式的初始值有所不同，导致设计师在没有定义某个 CSS 属性时，不同的浏览器会按照自己的默认值来为没有定义的样式赋值，所以我们要先定义好一些 CSS 样式，来让所有浏览器都按照同样的规则解释 CSS，这样就能避免发生这种问题。本质就是清除浏览器默认样式，并且进行全局样式定义，Reset 文件要在项目初期定好，这样才不会产生后期的回归测试问题。</p>\n<pre><code class=\"css\">* {\n    vertical-align: baseline;\n    font-weight: inherit;\n    font-family: inherit;\n    font-style: inherit;\n    font-size: 100%;\n    outline: 0;\n    padding: 0;\n    margin: 0;\n    border: 0;\n}\n</code></pre>\n<h4 id=\"4-弹性布局、响应式、重构：\"><a href=\"#4-弹性布局、响应式、重构：\" class=\"headerlink\" title=\"4. 弹性布局、响应式、重构：\"></a>4. 弹性布局、响应式、重构：</h4><p><strong>弹性布局：</strong>Flexbox 布局模式，适用于多行多列自适应布局。</p>\n<p><strong>响应式布局：</strong>媒体查询（Media Queries）和 Viewport（初始比例，最大比例，最大宽度，缩放控制）控制。</p>\n<h4 id=\"5-什么叫优雅降级和渐进增强：\"><a href=\"#5-什么叫优雅降级和渐进增强：\" class=\"headerlink\" title=\"5. 什么叫优雅降级和渐进增强：\"></a>5. 什么叫优雅降级和渐进增强：</h4><p><strong>渐进增强：</strong>针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</p>\n<p><strong>优雅降级：</strong>一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</p>\n<p>两者区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。</p>\n<h4 id=\"6-HTML5-主要增强了什么：\"><a href=\"#6-HTML5-主要增强了什么：\" class=\"headerlink\" title=\"6. HTML5 主要增强了什么：\"></a>6. HTML5 主要增强了什么：</h4><p>增加了很多利于网站 SEO 的语义化标签如 <code>header</code>、<code>footer</code>、<code>article</code>、<code>nav</code>，功能性标签如 <code>canvas</code>、<code>video</code>、<code>audio</code> 使得浏览器可以进一步摆脱插件。WebSocket、LocalStorage、WebSQL 等新功能特性，还有很多功能化的标签属性如 <code>autocomplete</code>、<code>autofocus</code> 和很常用的 <code>datalist</code> 标签。</p>\n<h4 id=\"7-Node-js-主要解决了什么问题：\"><a href=\"#7-Node-js-主要解决了什么问题：\" class=\"headerlink\" title=\"7. Node.js 主要解决了什么问题：\"></a>7. Node.js 主要解决了什么问题：</h4><p>虽然单进程、单线程，但其事件环机制、非阻塞 IO，可以高效的处理高并发请求，并且与前端脚本语言统一。</p>\n<h4 id=\"8-提高-CSS-性能：\"><a href=\"#8-提高-CSS-性能：\" class=\"headerlink\" title=\"8. 提高 CSS 性能：\"></a>8. 提高 CSS 性能：</h4><p><strong>加载性能：</strong>压缩样式表，不要使用 <code>@import</code>（诞生于 CSS2），@import 使用在低网速下会存在页面闪烁问题（link 标签是在加载页面前把 CSS 加载完毕，而 @import 则是读取到引用的文件之后再加载，会延长页面的留白期）；</p>\n<p><strong>选择器性能：</strong>可忽略不计。</p>\n<p><strong>渲染性能：</strong>用 <code>createDocumentFragment</code> 对象在内存里操作 DOM、使用 class 类名替换来代替直接更改样式、开启 GPU 硬件加速；</p>\n<p><strong>Repaint（重绘）：</strong>当在页面上修改了一些不需要改变定位的样式的时候（比如 <code>background-color</code>、<code>border-color</code> 以及 <code>visibility</code>)，浏览器只会将新的样式重新绘制给元素（这就叫一次“重绘”或者“重新定义样式”）。这时只需要屏幕的一部分要重画。</p>\n<p><strong>Reflow（回流重排）：</strong>当页面上的改变影响了文档内容、结构或者元素定位时，就会发生重排（或称“重新布局”）。</p>\n<p><strong>其他：</strong>去除空规则；属性值为0时，不加单位；属性值为浮动小数“0.**”时，可以省略小数点之前的0；标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后；</p>\n<h4 id=\"9-CSS-预处理：\"><a href=\"#9-CSS-预处理：\" class=\"headerlink\" title=\"9. CSS 预处理：\"></a>9. CSS 预处理：</h4><p>CSS 预处理器用一种专门的编程语言，在编写 CSS 的过程中可以使用变量、循环、递归等特性，然后再编译成正常的 CSS 文件，可以提高 CSS 编写效率，常用的预编译语言有 LESS、SESS 等。</p>\n<h4 id=\"10-关于浮动的原理和工作方式：\"><a href=\"#10-关于浮动的原理和工作方式：\" class=\"headerlink\" title=\"10. 关于浮动的原理和工作方式：\"></a>10. 关于浮动的原理和工作方式：</h4><p>浮动本质就是个带有方位的 <code>display: inline-block</code> 属性；会打破同一行的 inline-box 模型；</p>\n<h4 id=\"11-浮动会产生什么影响呢，要怎么处理？\"><a href=\"#11-浮动会产生什么影响呢，要怎么处理？\" class=\"headerlink\" title=\"11. 浮动会产生什么影响呢，要怎么处理？\"></a>11. 浮动会产生什么影响呢，要怎么处理？</h4><p>会产生高度塌陷，子元素均设置了浮动样式，父元素会失去高度。</p>\n<p><strong>解决方案：</strong>父级 div 层定义 <code>overflow: hidden</code>、结尾处加空 div 标签 <code>clear:both</code>、父级 div 定义伪类 <code>:after</code>（最后一个子元素的后边）和 <code>zoom</code> 属性。</p>\n<pre><code class=\"css\">.clearfix{zoom:1;}\n.clearfix:after{display:block; content:&quot;.&quot;; clear:both; line-height:0; visibility:hidden;}\n</code></pre>\n<h4 id=\"12-你了解哪些常用-CSS-选择器？以及这些选择器的使用场景？\"><a href=\"#12-你了解哪些常用-CSS-选择器？以及这些选择器的使用场景？\" class=\"headerlink\" title=\"12. 你了解哪些常用 CSS 选择器？以及这些选择器的使用场景？\"></a>12. 你了解哪些常用 CSS 选择器？以及这些选择器的使用场景？</h4><p>ID 选择器、类选择器、伪类选择器、全局选择器 …（请跳至 W3School 查看更多）。</p>\n<h4 id=\"13-你知道这些选择器的权重怎么计算？\"><a href=\"#13-你知道这些选择器的权重怎么计算？\" class=\"headerlink\" title=\"13. 你知道这些选择器的权重怎么计算？\"></a>13. 你知道这些选择器的权重怎么计算？</h4><p><strong>权值为1000：</strong>代表内联样式，如 “style=”…””。</p>\n<p><strong>权值为100：</strong>代表ID选择器，如 “#content”。</p>\n<p><strong>权值为10：</strong>代表类，伪类和属性选择器，如 “.content”。</p>\n<p><strong>权值为1：</strong>代表类型选择器和伪元素选择器，如 “div p”。</p>\n<p><strong><em>通用选择器（</em>），子选择器（&gt;）和相邻同胞选择器（+）的权值都为0。</strong></p>\n<h4 id=\"14-你了解哪些布局？你平时有使用过什么布局实现？\"><a href=\"#14-你了解哪些布局？你平时有使用过什么布局实现？\" class=\"headerlink\" title=\"14. 你了解哪些布局？你平时有使用过什么布局实现？\"></a>14. 你了解哪些布局？你平时有使用过什么布局实现？</h4><p>弹性布局（与流体布局相似，大小单位使用 em）、固定布局、混合布局、绝对定位布局、流体布局（宽高以百分比计算，配合媒体查询完成） …</p>\n<h4 id=\"15-你常用的-JS-框架有哪些？\"><a href=\"#15-你常用的-JS-框架有哪些？\" class=\"headerlink\" title=\"15. 你常用的 JS 框架有哪些？\"></a>15. 你常用的 JS 框架有哪些？</h4><p>jQuery、Knockout.js、Vue.js、AngularJs、EmberJs、React.js …（很多 MVVM 框架可以使用）</p>\n<h4 id=\"16-你从-jQuery-学到了什么？\"><a href=\"#16-你从-jQuery-学到了什么？\" class=\"headerlink\" title=\"16. 你从 jQuery 学到了什么？\"></a>16. 你从 jQuery 学到了什么？</h4><p>看了源码中一些“类型检测”函数的实现，jQuery 中的这些方法完成度非常高，实现很全面，性能也是很高的。例如如下所示代码：</p>\n<pre><code class=\"javascript\">class2type = {};\n\njQuery.each(&quot;Boolean Number String Function Array Date RegExp Object&quot;.split(&quot; &quot;), function(i, name) {\n    class2type[&quot;[object &quot; + name + &quot;]&quot;] = name.toLowerCase();\n}\n\ntype: function(obj) {\n  return obj == null ? String(obj) : class2type[Object.prototype.toString.call(obj)] || &quot;object&quot;;\n}\n\nisFunction: function(obj) {\n  return jQuery.type(obj) === &quot;function&quot;;\n}\n\nisArray: Array.isArray || function() {\n  return jQuery.type(obj) === &quot;array&quot;;\n}\n</code></pre>\n<p>（其他知识点还有很多，异步队列，数据缓存，事件系统，异步请求等）。</p>\n<h4 id=\"17-JS-有哪些数据类型？\"><a href=\"#17-JS-有哪些数据类型？\" class=\"headerlink\" title=\"17. JS 有哪些数据类型？\"></a>17. JS 有哪些数据类型？</h4><p>null、undefined、数字、字符串、数组、对象、布尔。</p>\n<h4 id=\"18-JS-的数据类型中哪些是引用类型？\"><a href=\"#18-JS-的数据类型中哪些是引用类型？\" class=\"headerlink\" title=\"18. JS 的数据类型中哪些是引用类型？\"></a>18. JS 的数据类型中哪些是引用类型？</h4><p>数组、对象。</p>\n<h4 id=\"19-原型链：\"><a href=\"#19-原型链：\" class=\"headerlink\" title=\"19. 原型链：\"></a>19. 原型链：</h4><p>（内容太多，请自行 Google）</p>\n<h4 id=\"20-函数表达式和函数声明的区别：\"><a href=\"#20-函数表达式和函数声明的区别：\" class=\"headerlink\" title=\"20. 函数表达式和函数声明的区别：\"></a>20. 函数表达式和函数声明的区别：</h4><p>函数表达式只有函数定义的提升，函数声明则可以将函数定义和声明同时提升；函数表达式可以放在任何地方，函数声明则只能放到全局环境中。</p>\n<h4 id=\"21-什么是闭包，为什么要使用闭包？\"><a href=\"#21-什么是闭包，为什么要使用闭包？\" class=\"headerlink\" title=\"21. 什么是闭包，为什么要使用闭包？\"></a>21. 什么是闭包，为什么要使用闭包？</h4><p>可以简单理解为“函数中的函数”。两个常见作用：一可以读取函数内部的变量、二让这些变量的值始终保持在内存中。父函数定义的变量在子函数的作用域链中，子函数没有被销毁，其作用域链中所有变量和函数就会被维护，不会被销毁。</p>\n<pre><code class=\"javascript\">// 此处在绑定函数时的 i 是没有问题的，从 0 到 “elements.length - 1”；\n// 只是在子函数中的 i 是一直保持对父环境对象中的 i 的引用的，所以在调用时一直会输出 “elements.length”；\nfor (var i = 0; i &lt; elements.length; i++) {\n  elements[i].onclick = function() {\n    console.log(i);\n  }\n}\n// 用 IIFE 隔离外部环境对象，使父环境对象可以及时释放；\n// IIFE 中定义的任何变量和函数，都会在执行结束时被销毁；\nfor (var i = 0; i &lt; elements.length; i++) {\n  (function(n) {\n    elements[n].onclick = function() {\n      console.log(n);\n    }\n  })(i);\n}\n</code></pre>\n<h4 id=\"22-DOM-中的-Property-和-Attribute-两者的区别：\"><a href=\"#22-DOM-中的-Property-和-Attribute-两者的区别：\" class=\"headerlink\" title=\"22. DOM 中的 Property 和 Attribute 两者的区别：\"></a>22. DOM 中的 Property 和 Attribute 两者的区别：</h4><p>Attribute 就是 DOM 节点自带的属性，例如 div 中常用的 id、class 等；Property 是这个 DOM 元素作为对象，其附加的内容，例如 <code>childNodes</code>、<code>firstChild</code> 等；</p>\n<p>自定义的 Attribute 不会附加到 Property 上，对于属性 Property 的赋值在 IE 中可能会引起循环引用，内存泄漏。</p>\n<p>操作 Attribute 时使用 <code>setAttribute</code> 和 <code>getAttribute</code> 两个方法来操作，由于 getAttribute 可能会有浏览器兼容性问题，所以在 jQuery 中，在使用之前会对该方法进行测试：</p>\n<pre><code class=\"javascript\">div.className = &quot;a&quot;;\nvar judge = div.getAttribute(&quot;className&quot;) === &quot;a&quot;;\n</code></pre>\n<p>*对于 “style” 和 “onclick” 两个属性，它们的 Property 和 Attribute 分别是对象和字符串，与其他有所区别。</p>\n<h4 id=\"23-JS-作用域链：\"><a href=\"#23-JS-作用域链：\" class=\"headerlink\" title=\"23. JS 作用域链：\"></a>23. JS 作用域链：</h4><p>在一些类 C 的语言中有“块级作用域”，即花括号的每一段代码都有自己的独立作用域，而 JS 只有函数级作用域；JS 作用域链的第一个对象始终是当前执行代码所在环境的变量对象（VO），声明函数在全局作用域，此时作用域链只有一个环境对象；运行函数时作用域链顶端加入了函数内的环境对象，运行完毕时顶端环境对象被销毁，以此类推。</p>\n<p>JS 在查找变量时会从链的<strong>顶端（就近原则）</strong>一直向下查找。如果一个跨作用域的对象被引用了一次以上，则先把它存储到局部变量里再使用。全局变量总是存在于运行期上下文作用域链的最<strong>末端</strong>，因此在标识符解析的时候，查找全局变量是最慢的。（最好和闭包一起理解）</p>\n<h4 id=\"24-你对前端有什么理解？\"><a href=\"#24-你对前端有什么理解？\" class=\"headerlink\" title=\"24. 你对前端有什么理解？\"></a>24. 你对前端有什么理解？</h4><p>前端工程化、组件化 …</p>\n<h4 id=\"25-你觉得前端体系应该是怎样的？\"><a href=\"#25-你觉得前端体系应该是怎样的？\" class=\"headerlink\" title=\"25. 你觉得前端体系应该是怎样的？\"></a>25. 你觉得前端体系应该是怎样的？</h4><ul>\n<li>开发工具；</li>\n<li>代码质量；</li>\n<li>前端框架；</li>\n<li>前端开发标准；</li>\n<li>部署流程；</li>\n<li>代码组织；</li>\n<li>代码安全；</li>\n<li>移动 Web 开发；</li>\n<li>前沿技术社区；</li>\n<li>计算机网络体系；</li>\n<li>软件工程；</li>\n<li>可视化；</li>\n<li>浏览器；</li>\n<li>编程语言；</li>\n</ul>\n<h4 id=\"26-Hybrid-App：\"><a href=\"#26-Hybrid-App：\" class=\"headerlink\" title=\"26. Hybrid App：\"></a>26. Hybrid App：</h4><p>“Hybrid App” 底层依赖于 Native 提供的容器（UIWebview），上层使用传统前端技术做业务开发，底层透明化、上层多样化，这种场景非常有利于前端介入，非常适合业务快速迭代。（详情需深入研究，笔者这方面研究不多）</p>\n<h4 id=\"27-IFC、BFC、GFC-和-FFC：\"><a href=\"#27-IFC、BFC、GFC-和-FFC：\" class=\"headerlink\" title=\"27. IFC、BFC、GFC 和 FFC：\"></a>27. IFC、BFC、GFC 和 FFC：</h4><p><strong>IFC：</strong>内联 <code>display: inline</code> 格式化上下文，容器里面的子元素不会影响到外面的元素，表示盒子从左到右的水平排列方式；</p>\n<p><strong>BFC：</strong>块级 <code>display: block</code> 格式化上下文，表示盒子从上到下的垂直排列方式；</p>\n<p><strong>GFC：</strong>网格 <code>display: grid</code> 布局格式化上下文；</p>\n<p><strong>FFC：</strong>自适应 <code>display: flex</code> 格式化上下文；</p>\n<p><strong>Box: CSS 布局的基本单位：</strong></p>\n<p>Box 是 CSS 布局的对象和基本单位。直观点来说，就是一个页面是由很多个 Box 组成的。元素的类型和 <code>display</code> 属性，决定了这个 Box 的类型。 不同类型的 Box，会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此 Box 内的元素会以不同的方式渲染。</p>\n<p><strong>Formatting Context：</strong></p>\n<p>“Formatting Context” 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的 Formatting Context 有 “Block Fomatting Context”（简称 BFC）和 “Inline Formatting Context”（简称 IFC）。</p>\n<p><strong>BFC布局规则：</strong></p>\n<ul>\n<li>内部的 Box 会在垂直方向，一个接一个地放置。</li>\n<li>Box 垂直方向的距离由 <code>margin</code> 样式决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠。</li>\n<li>每个元素的 “margin box” 的左边， 与包含块 “border box” 的左边相接触（对于从左往右的格式化，否则相反）。即使存在浮动也是如此。</li>\n<li>BFC 的区域不会与 “float box” 重叠。</li>\n<li>BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li>\n<li>计算 BFC 的高度时，浮动元素也参与计算。</li>\n</ul>\n<p><strong>哪些元素会生成 BFC？</strong></p>\n<ul>\n<li>根元素；</li>\n<li><code>float</code> 属性不为 “none”；</li>\n<li><code>position</code> 为 “absolute” 或 “fixed”；</li>\n<li><code>display</code> 为 “inline-block”、“table-cell”、“ table-caption”、“flex”、“inline-flex”；</li>\n<li><code>overflow</code> 不为 “visible”；</li>\n</ul>\n<h4 id=\"28-JS-垃圾回收机制：\"><a href=\"#28-JS-垃圾回收机制：\" class=\"headerlink\" title=\"28. JS 垃圾回收机制：\"></a>28. JS 垃圾回收机制：</h4><p><strong>标记清除：</strong>跟踪环境对象，即跟踪作用域链，GC 会把那些没有作用域影响的内存清除掉；</p>\n<p><strong>引用计数：</strong>即跟踪记录每个值被引用的次数，但可能会有“循环引用”的问题；</p>\n<h4 id=\"29-Ajax-完整流程：\"><a href=\"#29-Ajax-完整流程：\" class=\"headerlink\" title=\"29. Ajax 完整流程：\"></a>29. Ajax 完整流程：</h4><pre><code class=\"javascript\">// 获取 XHR 对象;\n// 设置回调函数;\nxmlHTTP.onreadystatechange = callback;\n\n// 打开一个 XHR 链接;\nxmlHTTP.open(&quot;GET&quot;, url, true);\n\n// POST 请求要设置编码类型;\n// xmlHTTP.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);  \n// 发送请求;\nxmlHTTP.send(null);\n\nfunction callback() {\n  if (xmlHTTP.readyState == 4) {\n    if (xmlHTTP.status == 200) {\n      console.log(xmlHTTP.responseText);\n    }\n  }\n}\n</code></pre>\n<h4 id=\"30-Gulp-和-Grunt-的异同点？\"><a href=\"#30-Gulp-和-Grunt-的异同点？\" class=\"headerlink\" title=\"30. Gulp 和 Grunt 的异同点？\"></a>30. Gulp 和 Grunt 的异同点？</h4><p>Gulp 基于“流”的概念，只有一次 IO 过程，类似于 Linux 里的管道，又像 jQuery 的链式调用；Gulp 更易用；</p>\n<h4 id=\"31-浏览器可以并行下载多少个资源？\"><a href=\"#31-浏览器可以并行下载多少个资源？\" class=\"headerlink\" title=\"31. 浏览器可以并行下载多少个资源？\"></a>31. 浏览器可以并行下载多少个资源？</h4><p>在 HTTP/1.1 协议下一般是6个，最多不超过8个；</p>\n<h4 id=\"32-你觉得哪些网站前端技术比较好，这些网站的架构怎样？\"><a href=\"#32-你觉得哪些网站前端技术比较好，这些网站的架构怎样？\" class=\"headerlink\" title=\"32. 你觉得哪些网站前端技术比较好，这些网站的架构怎样？\"></a>32. 你觉得哪些网站前端技术比较好，这些网站的架构怎样？</h4><p>举例：淘宝网，用来很多 H5 的语义化标签；降级兼容做的很好，对禁用脚本的浏览器提供友好的选项；云客服使用 WS ，来代替 Ajax 轮询等；</p>\n<h4 id=\"33-淘宝网上的商品项，如图片，滚动到了才加载，是怎么实现的？\"><a href=\"#33-淘宝网上的商品项，如图片，滚动到了才加载，是怎么实现的？\" class=\"headerlink\" title=\"33. 淘宝网上的商品项，如图片，滚动到了才加载，是怎么实现的？\"></a>33. 淘宝网上的商品项，如图片，滚动到了才加载，是怎么实现的？</h4><p>应该是 PipeRender 技术的一种，BigRender 的原理是通过某种方式，将首屏不需要的 HTML 代码先存放起来。渲染好首屏后，再将存储好的 HTML 代码逐步渲染出来。</p>\n<h4 id=\"34-你了解后端技术么，前后端一般是怎么配合的？\"><a href=\"#34-你了解后端技术么，前后端一般是怎么配合的？\" class=\"headerlink\" title=\"34. 你了解后端技术么，前后端一般是怎么配合的？\"></a>34. 你了解后端技术么，前后端一般是怎么配合的？</h4><p>笔者公司用的是 CakePHP 和 Laravel 两套 PHP 框架，Laravel 本身有自己的模板引擎，同时可以与 Gulp 进行无缝衔接；模板会预留出需要替换的变量位置，前后端分离处理；前端模板可以进行模板的继承与嵌套；</p>\n<h4 id=\"35-安卓上如何实现-1px-像素线？\"><a href=\"#35-安卓上如何实现-1px-像素线？\" class=\"headerlink\" title=\"35. 安卓上如何实现 1px 像素线？\"></a>35. 安卓上如何实现 1px 像素线？</h4><p>因为 Retine 屏的分辨率始终是普通屏幕的2倍，导致原本 1px 的细线在手机上显示为 2px；</p>\n<p>IOS8 及以上可以直接使用 <code>border-width: 0.5px;</code> 来设置 1px 的线段，其他平台可以用 <code>transform</code> 将细线高度缩小一半：</p>\n<pre><code class=\"css\">.hairlines li:after {     \n    content: &quot;&quot;;     \n    position: absolute;     \n    left: 0;     \n    background: #000;     \n    width: 100%;     \n    height: 1px;     \n    -webkit-transform: scaleY(0.5);             \n    transform: scaleY(0.5);     \n    -webkit-transform-origin: 0 0;             \n    transform-origin: 0 0; \n}\n</code></pre>\n<h4 id=\"36-流应用是什么？\"><a href=\"#36-流应用是什么？\" class=\"headerlink\" title=\"36. 流应用是什么？\"></a>36. 流应用是什么？</h4><p>“流应用”结合了原生 App 和 Web App 的优势，又消除了各自的缺点。流应用建立在 “H5+” 这一突破性技术之上，通过强化 HTML5 使其达到原生 App 的功能和体验，并辅以<strong>类似流媒体的边用边下发行技术</strong>，这2项技术是流应用诞生的关键。</p>\n<h4 id=\"37-移动设备浏览器的-click-事件300毫秒延迟？\"><a href=\"#37-移动设备浏览器的-click-事件300毫秒延迟？\" class=\"headerlink\" title=\"37. 移动设备浏览器的 click 事件300毫秒延迟？\"></a>37. 移动设备浏览器的 click 事件300毫秒延迟？</h4><p>来源于最初的 Safari 浏览器在用户点击屏幕时会等待300毫秒，以判断用户是想进行单击还是进行双击缩放。其他浏览器也借鉴 Safari 的特性，导致了这一问题。</p>\n<p><strong>基本解决：</strong>修改 viewport 来禁用缩放 <code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no&quot;&gt;</code> 并同时设置 CSS 属性 <code>touch-action: none;</code>。</p>\n<p><strong>完美方案：</strong>FastClick 的实现原理是在检测到 touchend 事件的时候，会通过 DOM 自定义事件立即出发模拟一个 click 事件，并把浏览器在 300ms 之后的 click 事件阻止掉。</p>\n<h4 id=\"38-touchstart-的点击穿透问题：\"><a href=\"#38-touchstart-的点击穿透问题：\" class=\"headerlink\" title=\"38. touchstart 的点击穿透问题：\"></a>38. touchstart 的点击穿透问题：</h4><p>因为在移动端浏览器，事件执行的顺序是 <strong>touchstart &gt; touchend &gt; click</strong>，而 click 事件有 300ms 的延迟，当 touchstart 事件把 B 元素隐藏之后，隔了 300ms，浏览器触发了 click 事件，但是此时 B 元素不见了，所以该事件被派发到了 A 元素身上。如果 A 元素是一个链接，那此时页面就会意外地跳转。</p>\n"},{"title":"前端常见技术点 - CSS / DOM / 布局","intro":"这里总结一下 Web 前端面试中 CSS 部分的常见面试问题，同时这些问题也是对一些基础的技术概念和思想的理解。对这些基本知识的掌握程度和深度决定了你的技术层级。高级工程师是必须掌握本文列出的这些知识点，资深工程师则要对这些基本概念的纵向深度进行挖掘，【问题解答全部原创，转载请注明来源】。","comments":1,"date":"2016-12-12T16:16:19.000Z","_content":"\n这里总结一下 Web 前端面试中 CSS 部分的常见面试问题，同时这些问题也是对一些基础的技术概念和思想的理解。对这些基本知识的掌握程度和深度决定了你的技术层级。高级工程师是必须掌握本文列出的这些知识点，资深工程师则要对这些基本概念的纵向深度进行挖掘，【问题解答全部原创，转载请注明来源】。\n\n### CSS 技术部分：\n\n#### 1. 标准 CSS 的盒子模型？与低版本 IE 的盒子模型有什么不同？\n\nIE 盒子模型的范围同标准 CSS 盒子模型一样，包括 margin、border、padding 以及 content 四部分。和标准 W3C 盒子模型不同的是：IE 盒子模型的 content 部分包含了 border 和 padding。两者分别对应于 `box-sizing` 属性的 `content-box` 和 `border-box` 两个值。\n\n#### 2. 手写动画你认为最小的时间间隔是多久？\n\n多数显示器默认频率是 60Hz，即1秒刷新60次，所以理论上最小间隔为 1/60＊1000ms ＝ **16.7ms**；\n\n#### 3. 在网页中的应该使用奇数还是偶数的字体？\n\n偶数字号相对更容易和 Web 设计的其他部分构成比例关系，也是为了兼容 Windows Vista 上的点阵宋体字体（只提供了偶数字体点阵）。其他方面笔者感觉，并没有区别。\n\n#### 4. 设置元素浮动后，该元素的 display 值是多少？\n\n自动变成 `display: block`。\n\n#### 5. 如何用 CSS 让页面里的字体变清晰？\n\n设置 `-webkit-font-smoothing: antialiased;`（抗锯齿）\n\n#### 6. 如何用 CSS 创建一个三角形？\n\n```css\nborder-top:solid 100px red;\nborder-left:solid 100px green;\nborder-right:solid 100px orange;\nborder-bottom:solid 100px blue;\nwidth: 0;\nheight: 0;\n```\n\n#### 7. 如何修改 Chrome 记住密码后自动填充表单的黄色背景？\n\n浏览器自动添加了 `input: -webkit-autofill` 这个私有属性。\n\n#### 8. 浏览器是怎样解析 CSS 选择器的？\n\nCSS 选择器是**从右往左解析**的，这样效率较高，从子元素向上寻找父元素的情况在大多数正常情况下都比正向从父元素查找子元素要快得多，从左到右的查找在大多数规则读到最后（最右）才会发现是不匹配的，这样会做费时耗能，最后有很多都是无用的。\n\n浏览器渲染过程：\n\n* HTML -> HTML 解析器 -> DOM 树；\n* 样式 -> 样式解析器 -> 样式规则；\n\nDOM 树和样式规则进行结合形成渲染树。\n\n#### 9. CSS 继承：\n\nCSS 样式继承性是指下级的样式属性会继承上级的属性，比如 li 会继承 ul 的样式属性。\n\n#### 10. 如何居中 div \\ 浮动 \\ 绝对定位元素？\n\n对于定宽的非浮动元素我们可以在 CSS 中用 `margin: 0 auto;` 进行水平居中；对于浮动元素可以父子元素同时向一个方向浮动，父元素设置 `left: 50%;`\n\n#### 11. position 的值 relative 和 absolute 定位原点是？\n\n相对定位是“相对于”元素在文档中的初始位置，而绝对定位是“相对于”最近的已定位祖先元素，如果不存在已定位的祖先元素，那么“相对于”最初的包含块。\n\n#### 12. ::before 和 :after 中的双冒号与单冒号有什么区别？\n\n两个冒号和一个冒号的作用其实一致的，只是在 CSS3 中为了区分**伪类选择器**和**伪元素选择器**，在语义上更清晰明了；\n\n**伪类选择器：**即伪类的效果可以通过添加一个实际的类来达到；\n\n* `:hover`；\n* `:link`；\n* `:active`；\n* `:target`；\n* `:not(selector)`；\n* `:focus`；\n\n**伪元素选择器：**即伪元素的效果是需要通过添加一个实际的元素才能达到的；\n\n* `::first-letter`；\n* `::first-line`；\n* `::before`；\n* `::after`；\n* `::selection`；\n\n#### 13. transform 属性的几种常用方法：\n\nrotate 旋转、translate 平移、skew 倾斜、scale 缩放以及各个方法对应的 3D 版本。\n\n* `transform-origin`：属性设置动作原点；\n* `perspective-origin`：属性设置透视方位；\n* `perspective`：设置透视角度；\n\n#### 14. 常用的图片格式？\n\n* PNG 可以存储 Alpha 通道，失真小，没锯齿，无损压缩，一种是 Index（体积较小），一种是 RGB，体积较大；\n* GIF 可以存储动画；\n* JPEG 图片色彩更加丰富，但是有损压缩，不适合多次读取储存；\n* WebP 是一种谷歌开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有JPEG的2/3；\n\n#### 15. style 标签写在 body 后与 body 前有什么区别？\n\nCSS 样式的加载顺序从上到下，同时应该符合样式的放置规范，外部. 内部. 内嵌。放在 body 里不符合规范也不利于代码维护。\n\n#### 16. font-style 属性的 oblique 和 italic 有什么区别？\n\nitalic 是斜体，是一种不同的字体，而 oblique 是一种仿斜体，是浏览器通过将普通字体通过变形而成的“斜体”，italic 选择字体族的 italic 变体，如果没有 italic 变体就妥协到 oblique 变体。如果字体族连 oblique 也未提供，则由浏览器合成倾斜的仿 oblique 字体。italic 和 oblique 在字体形态上有所不同。\n\n#### 17. 常见的移动端开发问题：\n\n应该有很多，这里只列出笔者遇到过的一部分：\n\n若父容器设置了 `transform` 属性，则其内部子元素的 `position: fixed;` 属性会失效；\n\n#### 18. 对 line-height 属性的理解：\n\n行高指的是文本行的基线间的距离，`line-height` 若使用百分比则实际像素值为所有继承的元素的 `font-size` 乘以这个百分比，是先计算然后转换为像素值；若使用直接像素值，则所有继承元素使用相同的 line-height 值；相对来说，用纯数字指定 line-height 比较好，可以动态改变行距；**段落中的行间距最好是本身 font-size 的1.5倍最好，浏览器默认行间距为1.14左右**。\n\n* **containing-boxes：**它包含了其他的 boxes，比如 p 本身就是一种；\n* **inline-boxes：**让显示的内容排成一行，比如 span 元素；没有标签包裹的文字为匿名 inline-boxes；\n* **line-boxes：**inline-boxes 在 containing-boxes 连接成了 line-boxed；\n* **content-area：**是围绕着文字的一种看不见的 boxes，高取决于 font-size；\n\nline-height 超出 font-size 部分的一半称为“半行间距”，它被平均的放到 content-area 的顶部和底部；\n\n#### 20. CSS 里的 visibility 的 collapse 属性值有什么作用和区别？\n\n该属性兼容性各个浏览器并不统一，对于一般的元素，它的表现跟 `hidden` 是一样的。但例外的是，如果这个元素是 table 相关的元素，它的表现却跟 `display: none` 一样。\n\n\n#### 21. 视差滚动的原理：\n\n视差滚动是指多层背景以不同的速度移动，形成立体的运动效果，带来非常出色的视觉体验。\n\n**实现原理：**主要利用了 `background-attachment: fixed;` 属性，随着页面的滚动轴背景图片不会移动。\n\n\n#### 22. display: inline-block 什么时候会显示间隙？\n\n浏览器的默认行为是把 inline 元素间的空白字符（空格. 换行. Tab）渲染成一个空格，这个问题不止出现在 li 元素上；\n\n**解决方案：**\n\n1. 所以把所有 li 放到同一行；\n2. 将这些被渲染成空格的字符 `font-size` 属性设置为 0；\n3. 设置 letter-spacing 为适当大小；\n\n#### 23. z-index 栈：\n\n`z-index` 只在设置了 `position` 属性（值非 static）的元素上生效；而**父元素的 `z-index` 会比子元素先生效；**\n\n#### 24. float、relative、absolute、fixed 基础重点：\n\n* **relative：**参照物为元素本身，即默认情况下在文档流中的位置；\n* **float：**元素默认宽度为内容宽度；半脱离文档流（元素脱离文档流，内容不脱离文档流，即一种“**文字环绕图片**”的效果）；\n* **absolute：**元素默认宽度为内容宽度；脱离文档流；参照物为第一个定位祖先（设置了 position 并且值不是 static 的元素）/ 根元素；如果设置了 absolute 的元素没有设置宽高，则 LRTB 四个属性可以将该元素自适应抻开；\n* **fixed：**元素默认宽度为内容宽度；脱离文档流；参照物为视窗；\n\nfloat 会导致原有的 inline-boxes 消失，\n\n#### 25. overflow:scroll 时不能平滑滚动的问题怎么处理？\n\n添加 `-webkit-overflow-scrolling: touch;` 属性。该属性创建了带有硬件加速的系统级控件，但比较耗费内存；也可以采用 iScroll 插件来解决这个问题。\n\n#### 26. 常见的浏览器兼容性问题有哪些？\n\nHTML5 的兼容性问题等（笔者公司不考虑 IE10 以下的浏览器）。\n\n#### 27. 元素竖向的百分比设定是相对于容器的高度吗?\n\n当按百分比设定一个元素的宽度时，它是相对于父容器的宽度计算的。但是，对于一些表示竖向距离的属性，例如 `padding-top`、`padding-bottom`、`margin-top` 以及 `margin-bottom` 等，当按百分比设定它们时，**依据的也是父容器的宽度**，而不是高度。\n\n#### 28. 两个 CSS 模型：\n\n一个是 box 盒状模型，对应 CSS 为 “（height / width）+ padding + margin”，另外一个是 line box 模型，对应样式为 “`line-height`”；\n\n#### 29. 弹性布局：\n\n* **弹性父容器：**display: flex;\n* **弹性元素：**父容器的直接子元素，并且没有脱离文档流（非 absolute 属性）。\n* **指定弹性容器内元素排列方向：**flex-direction: row | row-reverse | column | column-reverse\n* **指定弹性容器内元素换行方式：**flex-wrap: no-wrap | wrap | wrap-reverse\n* **指定弹性容器内元素排队和换行方式：**flex-flow: [flex-direction] [flex-wrap]\n* **指定弹性元素的排列权重（重的在后边）：**order: <数字>\n\n\n\n* **设置元素空余空间分配权重：**flex-grow: <数字>\n* **设置元素超出分配空间权重：**flex-shrink: <数字>\n* **设置元素在主轴方向的基础长度：**flex-basis: <数字>\n* **设置元素在主轴方向的弹性：**flex: [flex-grow] [flex-shrink] [flex-basis]\n\n\n\n* **指定弹性容器内元素的间隔方式：**justify-content: flex-start | flex-end | center | space-between | space-arount\n* **指定弹性容器内元素辅轴对齐方式：**align-items: flex-start | flex-end | center | stretch | baseline\n* **设置元素在主轴方向的对齐方式：**align-self: flex-start | flex-end | center | stretch | baseline\n* **指定弹性容器内元素的辅轴上行的对齐方式：**align-content: flex-start | flex-end | center | space-between | space-arount | stretch\n\n\n#### 30. font-family: serif sans-serif：\n\n* **衬线体 serif：**意思是在字的笔画开始. 结束的地方有额外的装饰，而且笔画的粗细会有所不同。\n* **非衬线体 sans-serif：**没有这些额外的装饰，而且笔画的粗细差不多。\n\n#### 31. DOMContentLoaded 和 load 的区别：\n\nDOM 文档的加载步骤为：\n\n1. 解析 HTML 结构；\n2. 加载外部脚本和样式表文件；\n3. 解析并执行脚本代码；\n4. DOM 树构建完成； // **DOMContentLoaded**；\n5. 加载图片等外部文件；\n6. 页面加载完毕； // **load**；\n\n#### 32. DOM 树上的各种操作：\n\n![](1.jpg)\n\n#### 33. children 和 childNodes 的区别？\n\n`children` 只会包含元素节点，不会包含文字节点。`childNodes` 会包含所有子节点。\n\n#### 34. nextElementSibling 和 nextSibling 的区别？\n\n`nextElementSibling` 只包含元素兄弟节点。`nextSibling` 会包含文字节点。\n\n#### 35. CSS DOM 概览：\n\n`window.getComputedStyle([element]);` // 可以获得一个元素计算后的样式 CSSStyleDeclaration 对象；\n\n![](2.png)\n\n\n#### 36. DOM 属性访问器访问属性和 “g/setAttribute” 访问属性的区别？\n\n* **DOM 属性访问器：**通用性差，扩展性差；但取到的是一个“**实用对象**”结构；\n* **g/setAttribute：**取到的只是字符串，通用性强；\n\n`element.dataset` 可以取到该 DOM 元素上所有的自定义属性，即以 “data-” 开头的属性。\n\n\n#### 37. DOM 事件触发、事件绑定与事件卸载：\n\n* **IE8 以上：**`addEventListener`、`removeEventListener`、`dispatchEvent`；W3C 标准；\n* **IE8 及以下：**`attachEvent`、`detachEvent`、`fireEvent`；没有捕获阶段；\n\n\n#### 38. onerror 事件的常用场景：\n\n在 img 标签加入 `onerror=\"this.src='default.png'\"` 可以设置图片出错时显示的默认图片。\n\n#### 39. HTML 模块化构建：\n\n![](3.jpg)\n\n#### 40. position 属性各个值的分层关系：\n\nstatic 不能通过 z-index 分层；relative、absolute 和 fixed 可以通过 z-index 分层。\n\n首先是遵循 DOM 规则，同级的后面居上。一般有定位属性的元素会高于无定位属性的同级元素。\n\n都有定位属性的同级元素，z-index 大者居上；\n\n如果是非同级的元素，则会忽略元素本身 z-index，取与对比元素同级的祖先元素的 z-index 属性，大者居上。\n\n#### 41. 如何高效的插入 HTML 到 DOM 树的指定位置？\n\n使用 `createDocumentFragment` 创建一个内存中的文档片段，将所有需要追加到页面的 HTML 都 `appendChild` 到这个文档片段，最后一次性的将该文档片段 appendChild 到 DOM 树上；由于拼接子元素的过程是在内存中进行的因此可以减少页面的回流和重绘；\n\n或使用 `insertAdjacentHTML([position], [text])` 直接向页面插入 HTML 片段。其中 position 分为四个值：beforebegin、afterbegin、beforeend 和 afterend；\n\n#### 42. em \\ rem \\ vh \\ vw \\ vmin \\ vmax \\ ex \\ ch：\n\n* **em：**现对于父元素的字体大小；\n* **rem：**相对于根元素 html 的字体大小；\n* **vh\\vw：**其中的 v 表示 viewpoint 视窗，所以这两个大小单位代表相对于当前视窗的大小，1vh\\vw 相当于百分之1的视窗高度\\宽度；\n* **vmin\\vmax：**同上，其中的 v 表示 viewpoint，vmin 取 vh\\vw 中两者较小的作为单位，vmax 则相反。\n* **ch：**常与等宽字体联合使用 “**Consolas，Monaco，monospace**”。1ch 表示一个0字符的宽度，因此只有在等宽字体的情况下，我们才能用 ch 来精确的调整字符的显示。\n* **ex：**相对长度单位。相对于字符 “x” 的高度。通常为字体高度的一半。利用 ex 可以实现内联图标与段落的垂直居中。\n","source":"_posts/前端常见技术点-CSS-DOM-布局.md","raw":"---\ntitle: 前端常见技术点 - CSS / DOM / 布局\nintro: 这里总结一下 Web 前端面试中 CSS 部分的常见面试问题，同时这些问题也是对一些基础的技术概念和思想的理解。对这些基本知识的掌握程度和深度决定了你的技术层级。高级工程师是必须掌握本文列出的这些知识点，资深工程师则要对这些基本概念的纵向深度进行挖掘，【问题解答全部原创，转载请注明来源】。\ncomments: true\ndate: 2016-12-13 00:16:19\ntags:\n- CSS\n- DOM\n---\n\n这里总结一下 Web 前端面试中 CSS 部分的常见面试问题，同时这些问题也是对一些基础的技术概念和思想的理解。对这些基本知识的掌握程度和深度决定了你的技术层级。高级工程师是必须掌握本文列出的这些知识点，资深工程师则要对这些基本概念的纵向深度进行挖掘，【问题解答全部原创，转载请注明来源】。\n\n### CSS 技术部分：\n\n#### 1. 标准 CSS 的盒子模型？与低版本 IE 的盒子模型有什么不同？\n\nIE 盒子模型的范围同标准 CSS 盒子模型一样，包括 margin、border、padding 以及 content 四部分。和标准 W3C 盒子模型不同的是：IE 盒子模型的 content 部分包含了 border 和 padding。两者分别对应于 `box-sizing` 属性的 `content-box` 和 `border-box` 两个值。\n\n#### 2. 手写动画你认为最小的时间间隔是多久？\n\n多数显示器默认频率是 60Hz，即1秒刷新60次，所以理论上最小间隔为 1/60＊1000ms ＝ **16.7ms**；\n\n#### 3. 在网页中的应该使用奇数还是偶数的字体？\n\n偶数字号相对更容易和 Web 设计的其他部分构成比例关系，也是为了兼容 Windows Vista 上的点阵宋体字体（只提供了偶数字体点阵）。其他方面笔者感觉，并没有区别。\n\n#### 4. 设置元素浮动后，该元素的 display 值是多少？\n\n自动变成 `display: block`。\n\n#### 5. 如何用 CSS 让页面里的字体变清晰？\n\n设置 `-webkit-font-smoothing: antialiased;`（抗锯齿）\n\n#### 6. 如何用 CSS 创建一个三角形？\n\n```css\nborder-top:solid 100px red;\nborder-left:solid 100px green;\nborder-right:solid 100px orange;\nborder-bottom:solid 100px blue;\nwidth: 0;\nheight: 0;\n```\n\n#### 7. 如何修改 Chrome 记住密码后自动填充表单的黄色背景？\n\n浏览器自动添加了 `input: -webkit-autofill` 这个私有属性。\n\n#### 8. 浏览器是怎样解析 CSS 选择器的？\n\nCSS 选择器是**从右往左解析**的，这样效率较高，从子元素向上寻找父元素的情况在大多数正常情况下都比正向从父元素查找子元素要快得多，从左到右的查找在大多数规则读到最后（最右）才会发现是不匹配的，这样会做费时耗能，最后有很多都是无用的。\n\n浏览器渲染过程：\n\n* HTML -> HTML 解析器 -> DOM 树；\n* 样式 -> 样式解析器 -> 样式规则；\n\nDOM 树和样式规则进行结合形成渲染树。\n\n#### 9. CSS 继承：\n\nCSS 样式继承性是指下级的样式属性会继承上级的属性，比如 li 会继承 ul 的样式属性。\n\n#### 10. 如何居中 div \\ 浮动 \\ 绝对定位元素？\n\n对于定宽的非浮动元素我们可以在 CSS 中用 `margin: 0 auto;` 进行水平居中；对于浮动元素可以父子元素同时向一个方向浮动，父元素设置 `left: 50%;`\n\n#### 11. position 的值 relative 和 absolute 定位原点是？\n\n相对定位是“相对于”元素在文档中的初始位置，而绝对定位是“相对于”最近的已定位祖先元素，如果不存在已定位的祖先元素，那么“相对于”最初的包含块。\n\n#### 12. ::before 和 :after 中的双冒号与单冒号有什么区别？\n\n两个冒号和一个冒号的作用其实一致的，只是在 CSS3 中为了区分**伪类选择器**和**伪元素选择器**，在语义上更清晰明了；\n\n**伪类选择器：**即伪类的效果可以通过添加一个实际的类来达到；\n\n* `:hover`；\n* `:link`；\n* `:active`；\n* `:target`；\n* `:not(selector)`；\n* `:focus`；\n\n**伪元素选择器：**即伪元素的效果是需要通过添加一个实际的元素才能达到的；\n\n* `::first-letter`；\n* `::first-line`；\n* `::before`；\n* `::after`；\n* `::selection`；\n\n#### 13. transform 属性的几种常用方法：\n\nrotate 旋转、translate 平移、skew 倾斜、scale 缩放以及各个方法对应的 3D 版本。\n\n* `transform-origin`：属性设置动作原点；\n* `perspective-origin`：属性设置透视方位；\n* `perspective`：设置透视角度；\n\n#### 14. 常用的图片格式？\n\n* PNG 可以存储 Alpha 通道，失真小，没锯齿，无损压缩，一种是 Index（体积较小），一种是 RGB，体积较大；\n* GIF 可以存储动画；\n* JPEG 图片色彩更加丰富，但是有损压缩，不适合多次读取储存；\n* WebP 是一种谷歌开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有JPEG的2/3；\n\n#### 15. style 标签写在 body 后与 body 前有什么区别？\n\nCSS 样式的加载顺序从上到下，同时应该符合样式的放置规范，外部. 内部. 内嵌。放在 body 里不符合规范也不利于代码维护。\n\n#### 16. font-style 属性的 oblique 和 italic 有什么区别？\n\nitalic 是斜体，是一种不同的字体，而 oblique 是一种仿斜体，是浏览器通过将普通字体通过变形而成的“斜体”，italic 选择字体族的 italic 变体，如果没有 italic 变体就妥协到 oblique 变体。如果字体族连 oblique 也未提供，则由浏览器合成倾斜的仿 oblique 字体。italic 和 oblique 在字体形态上有所不同。\n\n#### 17. 常见的移动端开发问题：\n\n应该有很多，这里只列出笔者遇到过的一部分：\n\n若父容器设置了 `transform` 属性，则其内部子元素的 `position: fixed;` 属性会失效；\n\n#### 18. 对 line-height 属性的理解：\n\n行高指的是文本行的基线间的距离，`line-height` 若使用百分比则实际像素值为所有继承的元素的 `font-size` 乘以这个百分比，是先计算然后转换为像素值；若使用直接像素值，则所有继承元素使用相同的 line-height 值；相对来说，用纯数字指定 line-height 比较好，可以动态改变行距；**段落中的行间距最好是本身 font-size 的1.5倍最好，浏览器默认行间距为1.14左右**。\n\n* **containing-boxes：**它包含了其他的 boxes，比如 p 本身就是一种；\n* **inline-boxes：**让显示的内容排成一行，比如 span 元素；没有标签包裹的文字为匿名 inline-boxes；\n* **line-boxes：**inline-boxes 在 containing-boxes 连接成了 line-boxed；\n* **content-area：**是围绕着文字的一种看不见的 boxes，高取决于 font-size；\n\nline-height 超出 font-size 部分的一半称为“半行间距”，它被平均的放到 content-area 的顶部和底部；\n\n#### 20. CSS 里的 visibility 的 collapse 属性值有什么作用和区别？\n\n该属性兼容性各个浏览器并不统一，对于一般的元素，它的表现跟 `hidden` 是一样的。但例外的是，如果这个元素是 table 相关的元素，它的表现却跟 `display: none` 一样。\n\n\n#### 21. 视差滚动的原理：\n\n视差滚动是指多层背景以不同的速度移动，形成立体的运动效果，带来非常出色的视觉体验。\n\n**实现原理：**主要利用了 `background-attachment: fixed;` 属性，随着页面的滚动轴背景图片不会移动。\n\n\n#### 22. display: inline-block 什么时候会显示间隙？\n\n浏览器的默认行为是把 inline 元素间的空白字符（空格. 换行. Tab）渲染成一个空格，这个问题不止出现在 li 元素上；\n\n**解决方案：**\n\n1. 所以把所有 li 放到同一行；\n2. 将这些被渲染成空格的字符 `font-size` 属性设置为 0；\n3. 设置 letter-spacing 为适当大小；\n\n#### 23. z-index 栈：\n\n`z-index` 只在设置了 `position` 属性（值非 static）的元素上生效；而**父元素的 `z-index` 会比子元素先生效；**\n\n#### 24. float、relative、absolute、fixed 基础重点：\n\n* **relative：**参照物为元素本身，即默认情况下在文档流中的位置；\n* **float：**元素默认宽度为内容宽度；半脱离文档流（元素脱离文档流，内容不脱离文档流，即一种“**文字环绕图片**”的效果）；\n* **absolute：**元素默认宽度为内容宽度；脱离文档流；参照物为第一个定位祖先（设置了 position 并且值不是 static 的元素）/ 根元素；如果设置了 absolute 的元素没有设置宽高，则 LRTB 四个属性可以将该元素自适应抻开；\n* **fixed：**元素默认宽度为内容宽度；脱离文档流；参照物为视窗；\n\nfloat 会导致原有的 inline-boxes 消失，\n\n#### 25. overflow:scroll 时不能平滑滚动的问题怎么处理？\n\n添加 `-webkit-overflow-scrolling: touch;` 属性。该属性创建了带有硬件加速的系统级控件，但比较耗费内存；也可以采用 iScroll 插件来解决这个问题。\n\n#### 26. 常见的浏览器兼容性问题有哪些？\n\nHTML5 的兼容性问题等（笔者公司不考虑 IE10 以下的浏览器）。\n\n#### 27. 元素竖向的百分比设定是相对于容器的高度吗?\n\n当按百分比设定一个元素的宽度时，它是相对于父容器的宽度计算的。但是，对于一些表示竖向距离的属性，例如 `padding-top`、`padding-bottom`、`margin-top` 以及 `margin-bottom` 等，当按百分比设定它们时，**依据的也是父容器的宽度**，而不是高度。\n\n#### 28. 两个 CSS 模型：\n\n一个是 box 盒状模型，对应 CSS 为 “（height / width）+ padding + margin”，另外一个是 line box 模型，对应样式为 “`line-height`”；\n\n#### 29. 弹性布局：\n\n* **弹性父容器：**display: flex;\n* **弹性元素：**父容器的直接子元素，并且没有脱离文档流（非 absolute 属性）。\n* **指定弹性容器内元素排列方向：**flex-direction: row | row-reverse | column | column-reverse\n* **指定弹性容器内元素换行方式：**flex-wrap: no-wrap | wrap | wrap-reverse\n* **指定弹性容器内元素排队和换行方式：**flex-flow: [flex-direction] [flex-wrap]\n* **指定弹性元素的排列权重（重的在后边）：**order: <数字>\n\n\n\n* **设置元素空余空间分配权重：**flex-grow: <数字>\n* **设置元素超出分配空间权重：**flex-shrink: <数字>\n* **设置元素在主轴方向的基础长度：**flex-basis: <数字>\n* **设置元素在主轴方向的弹性：**flex: [flex-grow] [flex-shrink] [flex-basis]\n\n\n\n* **指定弹性容器内元素的间隔方式：**justify-content: flex-start | flex-end | center | space-between | space-arount\n* **指定弹性容器内元素辅轴对齐方式：**align-items: flex-start | flex-end | center | stretch | baseline\n* **设置元素在主轴方向的对齐方式：**align-self: flex-start | flex-end | center | stretch | baseline\n* **指定弹性容器内元素的辅轴上行的对齐方式：**align-content: flex-start | flex-end | center | space-between | space-arount | stretch\n\n\n#### 30. font-family: serif sans-serif：\n\n* **衬线体 serif：**意思是在字的笔画开始. 结束的地方有额外的装饰，而且笔画的粗细会有所不同。\n* **非衬线体 sans-serif：**没有这些额外的装饰，而且笔画的粗细差不多。\n\n#### 31. DOMContentLoaded 和 load 的区别：\n\nDOM 文档的加载步骤为：\n\n1. 解析 HTML 结构；\n2. 加载外部脚本和样式表文件；\n3. 解析并执行脚本代码；\n4. DOM 树构建完成； // **DOMContentLoaded**；\n5. 加载图片等外部文件；\n6. 页面加载完毕； // **load**；\n\n#### 32. DOM 树上的各种操作：\n\n![](1.jpg)\n\n#### 33. children 和 childNodes 的区别？\n\n`children` 只会包含元素节点，不会包含文字节点。`childNodes` 会包含所有子节点。\n\n#### 34. nextElementSibling 和 nextSibling 的区别？\n\n`nextElementSibling` 只包含元素兄弟节点。`nextSibling` 会包含文字节点。\n\n#### 35. CSS DOM 概览：\n\n`window.getComputedStyle([element]);` // 可以获得一个元素计算后的样式 CSSStyleDeclaration 对象；\n\n![](2.png)\n\n\n#### 36. DOM 属性访问器访问属性和 “g/setAttribute” 访问属性的区别？\n\n* **DOM 属性访问器：**通用性差，扩展性差；但取到的是一个“**实用对象**”结构；\n* **g/setAttribute：**取到的只是字符串，通用性强；\n\n`element.dataset` 可以取到该 DOM 元素上所有的自定义属性，即以 “data-” 开头的属性。\n\n\n#### 37. DOM 事件触发、事件绑定与事件卸载：\n\n* **IE8 以上：**`addEventListener`、`removeEventListener`、`dispatchEvent`；W3C 标准；\n* **IE8 及以下：**`attachEvent`、`detachEvent`、`fireEvent`；没有捕获阶段；\n\n\n#### 38. onerror 事件的常用场景：\n\n在 img 标签加入 `onerror=\"this.src='default.png'\"` 可以设置图片出错时显示的默认图片。\n\n#### 39. HTML 模块化构建：\n\n![](3.jpg)\n\n#### 40. position 属性各个值的分层关系：\n\nstatic 不能通过 z-index 分层；relative、absolute 和 fixed 可以通过 z-index 分层。\n\n首先是遵循 DOM 规则，同级的后面居上。一般有定位属性的元素会高于无定位属性的同级元素。\n\n都有定位属性的同级元素，z-index 大者居上；\n\n如果是非同级的元素，则会忽略元素本身 z-index，取与对比元素同级的祖先元素的 z-index 属性，大者居上。\n\n#### 41. 如何高效的插入 HTML 到 DOM 树的指定位置？\n\n使用 `createDocumentFragment` 创建一个内存中的文档片段，将所有需要追加到页面的 HTML 都 `appendChild` 到这个文档片段，最后一次性的将该文档片段 appendChild 到 DOM 树上；由于拼接子元素的过程是在内存中进行的因此可以减少页面的回流和重绘；\n\n或使用 `insertAdjacentHTML([position], [text])` 直接向页面插入 HTML 片段。其中 position 分为四个值：beforebegin、afterbegin、beforeend 和 afterend；\n\n#### 42. em \\ rem \\ vh \\ vw \\ vmin \\ vmax \\ ex \\ ch：\n\n* **em：**现对于父元素的字体大小；\n* **rem：**相对于根元素 html 的字体大小；\n* **vh\\vw：**其中的 v 表示 viewpoint 视窗，所以这两个大小单位代表相对于当前视窗的大小，1vh\\vw 相当于百分之1的视窗高度\\宽度；\n* **vmin\\vmax：**同上，其中的 v 表示 viewpoint，vmin 取 vh\\vw 中两者较小的作为单位，vmax 则相反。\n* **ch：**常与等宽字体联合使用 “**Consolas，Monaco，monospace**”。1ch 表示一个0字符的宽度，因此只有在等宽字体的情况下，我们才能用 ch 来精确的调整字符的显示。\n* **ex：**相对长度单位。相对于字符 “x” 的高度。通常为字体高度的一半。利用 ex 可以实现内联图标与段落的垂直居中。\n","slug":"前端常见技术点-CSS-DOM-布局","published":1,"updated":"2019-02-10T07:52:43.050Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtat005wknp2hdv7ikv5","content":"<p>这里总结一下 Web 前端面试中 CSS 部分的常见面试问题，同时这些问题也是对一些基础的技术概念和思想的理解。对这些基本知识的掌握程度和深度决定了你的技术层级。高级工程师是必须掌握本文列出的这些知识点，资深工程师则要对这些基本概念的纵向深度进行挖掘，【问题解答全部原创，转载请注明来源】。</p>\n<h3 id=\"CSS-技术部分：\"><a href=\"#CSS-技术部分：\" class=\"headerlink\" title=\"CSS 技术部分：\"></a>CSS 技术部分：</h3><h4 id=\"1-标准-CSS-的盒子模型？与低版本-IE-的盒子模型有什么不同？\"><a href=\"#1-标准-CSS-的盒子模型？与低版本-IE-的盒子模型有什么不同？\" class=\"headerlink\" title=\"1. 标准 CSS 的盒子模型？与低版本 IE 的盒子模型有什么不同？\"></a>1. 标准 CSS 的盒子模型？与低版本 IE 的盒子模型有什么不同？</h4><p>IE 盒子模型的范围同标准 CSS 盒子模型一样，包括 margin、border、padding 以及 content 四部分。和标准 W3C 盒子模型不同的是：IE 盒子模型的 content 部分包含了 border 和 padding。两者分别对应于 <code>box-sizing</code> 属性的 <code>content-box</code> 和 <code>border-box</code> 两个值。</p>\n<h4 id=\"2-手写动画你认为最小的时间间隔是多久？\"><a href=\"#2-手写动画你认为最小的时间间隔是多久？\" class=\"headerlink\" title=\"2. 手写动画你认为最小的时间间隔是多久？\"></a>2. 手写动画你认为最小的时间间隔是多久？</h4><p>多数显示器默认频率是 60Hz，即1秒刷新60次，所以理论上最小间隔为 1/60＊1000ms ＝ <strong>16.7ms</strong>；</p>\n<h4 id=\"3-在网页中的应该使用奇数还是偶数的字体？\"><a href=\"#3-在网页中的应该使用奇数还是偶数的字体？\" class=\"headerlink\" title=\"3. 在网页中的应该使用奇数还是偶数的字体？\"></a>3. 在网页中的应该使用奇数还是偶数的字体？</h4><p>偶数字号相对更容易和 Web 设计的其他部分构成比例关系，也是为了兼容 Windows Vista 上的点阵宋体字体（只提供了偶数字体点阵）。其他方面笔者感觉，并没有区别。</p>\n<h4 id=\"4-设置元素浮动后，该元素的-display-值是多少？\"><a href=\"#4-设置元素浮动后，该元素的-display-值是多少？\" class=\"headerlink\" title=\"4. 设置元素浮动后，该元素的 display 值是多少？\"></a>4. 设置元素浮动后，该元素的 display 值是多少？</h4><p>自动变成 <code>display: block</code>。</p>\n<h4 id=\"5-如何用-CSS-让页面里的字体变清晰？\"><a href=\"#5-如何用-CSS-让页面里的字体变清晰？\" class=\"headerlink\" title=\"5. 如何用 CSS 让页面里的字体变清晰？\"></a>5. 如何用 CSS 让页面里的字体变清晰？</h4><p>设置 <code>-webkit-font-smoothing: antialiased;</code>（抗锯齿）</p>\n<h4 id=\"6-如何用-CSS-创建一个三角形？\"><a href=\"#6-如何用-CSS-创建一个三角形？\" class=\"headerlink\" title=\"6. 如何用 CSS 创建一个三角形？\"></a>6. 如何用 CSS 创建一个三角形？</h4><pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token property\">border-top</span><span class=\"token punctuation\">:</span>solid <span class=\"token number\">100</span>px red<span class=\"token punctuation\">;</span>\n<span class=\"token property\">border-left</span><span class=\"token punctuation\">:</span>solid <span class=\"token number\">100</span>px green<span class=\"token punctuation\">;</span>\n<span class=\"token property\">border-right</span><span class=\"token punctuation\">:</span>solid <span class=\"token number\">100</span>px orange<span class=\"token punctuation\">;</span>\n<span class=\"token property\">border-bottom</span><span class=\"token punctuation\">:</span>solid <span class=\"token number\">100</span>px blue<span class=\"token punctuation\">;</span>\n<span class=\"token property\">width</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token property\">height</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"7-如何修改-Chrome-记住密码后自动填充表单的黄色背景？\"><a href=\"#7-如何修改-Chrome-记住密码后自动填充表单的黄色背景？\" class=\"headerlink\" title=\"7. 如何修改 Chrome 记住密码后自动填充表单的黄色背景？\"></a>7. 如何修改 Chrome 记住密码后自动填充表单的黄色背景？</h4><p>浏览器自动添加了 <code>input: -webkit-autofill</code> 这个私有属性。</p>\n<h4 id=\"8-浏览器是怎样解析-CSS-选择器的？\"><a href=\"#8-浏览器是怎样解析-CSS-选择器的？\" class=\"headerlink\" title=\"8. 浏览器是怎样解析 CSS 选择器的？\"></a>8. 浏览器是怎样解析 CSS 选择器的？</h4><p>CSS 选择器是<strong>从右往左解析</strong>的，这样效率较高，从子元素向上寻找父元素的情况在大多数正常情况下都比正向从父元素查找子元素要快得多，从左到右的查找在大多数规则读到最后（最右）才会发现是不匹配的，这样会做费时耗能，最后有很多都是无用的。</p>\n<p>浏览器渲染过程：</p>\n<ul>\n<li>HTML -&gt; HTML 解析器 -&gt; DOM 树；</li>\n<li>样式 -&gt; 样式解析器 -&gt; 样式规则；</li>\n</ul>\n<p>DOM 树和样式规则进行结合形成渲染树。</p>\n<h4 id=\"9-CSS-继承：\"><a href=\"#9-CSS-继承：\" class=\"headerlink\" title=\"9. CSS 继承：\"></a>9. CSS 继承：</h4><p>CSS 样式继承性是指下级的样式属性会继承上级的属性，比如 li 会继承 ul 的样式属性。</p>\n<h4 id=\"10-如何居中-div-浮动-绝对定位元素？\"><a href=\"#10-如何居中-div-浮动-绝对定位元素？\" class=\"headerlink\" title=\"10. 如何居中 div \\ 浮动 \\ 绝对定位元素？\"></a>10. 如何居中 div \\ 浮动 \\ 绝对定位元素？</h4><p>对于定宽的非浮动元素我们可以在 CSS 中用 <code>margin: 0 auto;</code> 进行水平居中；对于浮动元素可以父子元素同时向一个方向浮动，父元素设置 <code>left: 50%;</code></p>\n<h4 id=\"11-position-的值-relative-和-absolute-定位原点是？\"><a href=\"#11-position-的值-relative-和-absolute-定位原点是？\" class=\"headerlink\" title=\"11. position 的值 relative 和 absolute 定位原点是？\"></a>11. position 的值 relative 和 absolute 定位原点是？</h4><p>相对定位是“相对于”元素在文档中的初始位置，而绝对定位是“相对于”最近的已定位祖先元素，如果不存在已定位的祖先元素，那么“相对于”最初的包含块。</p>\n<h4 id=\"12-before-和-after-中的双冒号与单冒号有什么区别？\"><a href=\"#12-before-和-after-中的双冒号与单冒号有什么区别？\" class=\"headerlink\" title=\"12. ::before 和 :after 中的双冒号与单冒号有什么区别？\"></a>12. ::before 和 :after 中的双冒号与单冒号有什么区别？</h4><p>两个冒号和一个冒号的作用其实一致的，只是在 CSS3 中为了区分<strong>伪类选择器</strong>和<strong>伪元素选择器</strong>，在语义上更清晰明了；</p>\n<p><strong>伪类选择器：</strong>即伪类的效果可以通过添加一个实际的类来达到；</p>\n<ul>\n<li><code>:hover</code>；</li>\n<li><code>:link</code>；</li>\n<li><code>:active</code>；</li>\n<li><code>:target</code>；</li>\n<li><code>:not(selector)</code>；</li>\n<li><code>:focus</code>；</li>\n</ul>\n<p><strong>伪元素选择器：</strong>即伪元素的效果是需要通过添加一个实际的元素才能达到的；</p>\n<ul>\n<li><code>::first-letter</code>；</li>\n<li><code>::first-line</code>；</li>\n<li><code>::before</code>；</li>\n<li><code>::after</code>；</li>\n<li><code>::selection</code>；</li>\n</ul>\n<h4 id=\"13-transform-属性的几种常用方法：\"><a href=\"#13-transform-属性的几种常用方法：\" class=\"headerlink\" title=\"13. transform 属性的几种常用方法：\"></a>13. transform 属性的几种常用方法：</h4><p>rotate 旋转、translate 平移、skew 倾斜、scale 缩放以及各个方法对应的 3D 版本。</p>\n<ul>\n<li><code>transform-origin</code>：属性设置动作原点；</li>\n<li><code>perspective-origin</code>：属性设置透视方位；</li>\n<li><code>perspective</code>：设置透视角度；</li>\n</ul>\n<h4 id=\"14-常用的图片格式？\"><a href=\"#14-常用的图片格式？\" class=\"headerlink\" title=\"14. 常用的图片格式？\"></a>14. 常用的图片格式？</h4><ul>\n<li>PNG 可以存储 Alpha 通道，失真小，没锯齿，无损压缩，一种是 Index（体积较小），一种是 RGB，体积较大；</li>\n<li>GIF 可以存储动画；</li>\n<li>JPEG 图片色彩更加丰富，但是有损压缩，不适合多次读取储存；</li>\n<li>WebP 是一种谷歌开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有JPEG的2/3；</li>\n</ul>\n<h4 id=\"15-style-标签写在-body-后与-body-前有什么区别？\"><a href=\"#15-style-标签写在-body-后与-body-前有什么区别？\" class=\"headerlink\" title=\"15. style 标签写在 body 后与 body 前有什么区别？\"></a>15. style 标签写在 body 后与 body 前有什么区别？</h4><p>CSS 样式的加载顺序从上到下，同时应该符合样式的放置规范，外部. 内部. 内嵌。放在 body 里不符合规范也不利于代码维护。</p>\n<h4 id=\"16-font-style-属性的-oblique-和-italic-有什么区别？\"><a href=\"#16-font-style-属性的-oblique-和-italic-有什么区别？\" class=\"headerlink\" title=\"16. font-style 属性的 oblique 和 italic 有什么区别？\"></a>16. font-style 属性的 oblique 和 italic 有什么区别？</h4><p>italic 是斜体，是一种不同的字体，而 oblique 是一种仿斜体，是浏览器通过将普通字体通过变形而成的“斜体”，italic 选择字体族的 italic 变体，如果没有 italic 变体就妥协到 oblique 变体。如果字体族连 oblique 也未提供，则由浏览器合成倾斜的仿 oblique 字体。italic 和 oblique 在字体形态上有所不同。</p>\n<h4 id=\"17-常见的移动端开发问题：\"><a href=\"#17-常见的移动端开发问题：\" class=\"headerlink\" title=\"17. 常见的移动端开发问题：\"></a>17. 常见的移动端开发问题：</h4><p>应该有很多，这里只列出笔者遇到过的一部分：</p>\n<p>若父容器设置了 <code>transform</code> 属性，则其内部子元素的 <code>position: fixed;</code> 属性会失效；</p>\n<h4 id=\"18-对-line-height-属性的理解：\"><a href=\"#18-对-line-height-属性的理解：\" class=\"headerlink\" title=\"18. 对 line-height 属性的理解：\"></a>18. 对 line-height 属性的理解：</h4><p>行高指的是文本行的基线间的距离，<code>line-height</code> 若使用百分比则实际像素值为所有继承的元素的 <code>font-size</code> 乘以这个百分比，是先计算然后转换为像素值；若使用直接像素值，则所有继承元素使用相同的 line-height 值；相对来说，用纯数字指定 line-height 比较好，可以动态改变行距；<strong>段落中的行间距最好是本身 font-size 的1.5倍最好，浏览器默认行间距为1.14左右</strong>。</p>\n<ul>\n<li><strong>containing-boxes：</strong>它包含了其他的 boxes，比如 p 本身就是一种；</li>\n<li><strong>inline-boxes：</strong>让显示的内容排成一行，比如 span 元素；没有标签包裹的文字为匿名 inline-boxes；</li>\n<li><strong>line-boxes：</strong>inline-boxes 在 containing-boxes 连接成了 line-boxed；</li>\n<li><strong>content-area：</strong>是围绕着文字的一种看不见的 boxes，高取决于 font-size；</li>\n</ul>\n<p>line-height 超出 font-size 部分的一半称为“半行间距”，它被平均的放到 content-area 的顶部和底部；</p>\n<h4 id=\"20-CSS-里的-visibility-的-collapse-属性值有什么作用和区别？\"><a href=\"#20-CSS-里的-visibility-的-collapse-属性值有什么作用和区别？\" class=\"headerlink\" title=\"20. CSS 里的 visibility 的 collapse 属性值有什么作用和区别？\"></a>20. CSS 里的 visibility 的 collapse 属性值有什么作用和区别？</h4><p>该属性兼容性各个浏览器并不统一，对于一般的元素，它的表现跟 <code>hidden</code> 是一样的。但例外的是，如果这个元素是 table 相关的元素，它的表现却跟 <code>display: none</code> 一样。</p>\n<h4 id=\"21-视差滚动的原理：\"><a href=\"#21-视差滚动的原理：\" class=\"headerlink\" title=\"21. 视差滚动的原理：\"></a>21. 视差滚动的原理：</h4><p>视差滚动是指多层背景以不同的速度移动，形成立体的运动效果，带来非常出色的视觉体验。</p>\n<p><strong>实现原理：</strong>主要利用了 <code>background-attachment: fixed;</code> 属性，随着页面的滚动轴背景图片不会移动。</p>\n<h4 id=\"22-display-inline-block-什么时候会显示间隙？\"><a href=\"#22-display-inline-block-什么时候会显示间隙？\" class=\"headerlink\" title=\"22. display: inline-block 什么时候会显示间隙？\"></a>22. display: inline-block 什么时候会显示间隙？</h4><p>浏览器的默认行为是把 inline 元素间的空白字符（空格. 换行. Tab）渲染成一个空格，这个问题不止出现在 li 元素上；</p>\n<p><strong>解决方案：</strong></p>\n<ol>\n<li>所以把所有 li 放到同一行；</li>\n<li>将这些被渲染成空格的字符 <code>font-size</code> 属性设置为 0；</li>\n<li>设置 letter-spacing 为适当大小；</li>\n</ol>\n<h4 id=\"23-z-index-栈：\"><a href=\"#23-z-index-栈：\" class=\"headerlink\" title=\"23. z-index 栈：\"></a>23. z-index 栈：</h4><p><code>z-index</code> 只在设置了 <code>position</code> 属性（值非 static）的元素上生效；而<strong>父元素的 <code>z-index</code> 会比子元素先生效；</strong></p>\n<h4 id=\"24-float、relative、absolute、fixed-基础重点：\"><a href=\"#24-float、relative、absolute、fixed-基础重点：\" class=\"headerlink\" title=\"24. float、relative、absolute、fixed 基础重点：\"></a>24. float、relative、absolute、fixed 基础重点：</h4><ul>\n<li><strong>relative：</strong>参照物为元素本身，即默认情况下在文档流中的位置；</li>\n<li><strong>float：</strong>元素默认宽度为内容宽度；半脱离文档流（元素脱离文档流，内容不脱离文档流，即一种“<strong>文字环绕图片</strong>”的效果）；</li>\n<li><strong>absolute：</strong>元素默认宽度为内容宽度；脱离文档流；参照物为第一个定位祖先（设置了 position 并且值不是 static 的元素）/ 根元素；如果设置了 absolute 的元素没有设置宽高，则 LRTB 四个属性可以将该元素自适应抻开；</li>\n<li><strong>fixed：</strong>元素默认宽度为内容宽度；脱离文档流；参照物为视窗；</li>\n</ul>\n<p>float 会导致原有的 inline-boxes 消失，</p>\n<h4 id=\"25-overflow-scroll-时不能平滑滚动的问题怎么处理？\"><a href=\"#25-overflow-scroll-时不能平滑滚动的问题怎么处理？\" class=\"headerlink\" title=\"25. overflow:scroll 时不能平滑滚动的问题怎么处理？\"></a>25. overflow:scroll 时不能平滑滚动的问题怎么处理？</h4><p>添加 <code>-webkit-overflow-scrolling: touch;</code> 属性。该属性创建了带有硬件加速的系统级控件，但比较耗费内存；也可以采用 iScroll 插件来解决这个问题。</p>\n<h4 id=\"26-常见的浏览器兼容性问题有哪些？\"><a href=\"#26-常见的浏览器兼容性问题有哪些？\" class=\"headerlink\" title=\"26. 常见的浏览器兼容性问题有哪些？\"></a>26. 常见的浏览器兼容性问题有哪些？</h4><p>HTML5 的兼容性问题等（笔者公司不考虑 IE10 以下的浏览器）。</p>\n<h4 id=\"27-元素竖向的百分比设定是相对于容器的高度吗\"><a href=\"#27-元素竖向的百分比设定是相对于容器的高度吗\" class=\"headerlink\" title=\"27. 元素竖向的百分比设定是相对于容器的高度吗?\"></a>27. 元素竖向的百分比设定是相对于容器的高度吗?</h4><p>当按百分比设定一个元素的宽度时，它是相对于父容器的宽度计算的。但是，对于一些表示竖向距离的属性，例如 <code>padding-top</code>、<code>padding-bottom</code>、<code>margin-top</code> 以及 <code>margin-bottom</code> 等，当按百分比设定它们时，<strong>依据的也是父容器的宽度</strong>，而不是高度。</p>\n<h4 id=\"28-两个-CSS-模型：\"><a href=\"#28-两个-CSS-模型：\" class=\"headerlink\" title=\"28. 两个 CSS 模型：\"></a>28. 两个 CSS 模型：</h4><p>一个是 box 盒状模型，对应 CSS 为 “（height / width）+ padding + margin”，另外一个是 line box 模型，对应样式为 “<code>line-height</code>”；</p>\n<h4 id=\"29-弹性布局：\"><a href=\"#29-弹性布局：\" class=\"headerlink\" title=\"29. 弹性布局：\"></a>29. 弹性布局：</h4><ul>\n<li><strong>弹性父容器：</strong>display: flex;</li>\n<li><strong>弹性元素：</strong>父容器的直接子元素，并且没有脱离文档流（非 absolute 属性）。</li>\n<li><strong>指定弹性容器内元素排列方向：</strong>flex-direction: row | row-reverse | column | column-reverse</li>\n<li><strong>指定弹性容器内元素换行方式：</strong>flex-wrap: no-wrap | wrap | wrap-reverse</li>\n<li><strong>指定弹性容器内元素排队和换行方式：</strong>flex-flow: [flex-direction] [flex-wrap]</li>\n<li><strong>指定弹性元素的排列权重（重的在后边）：</strong>order: &lt;数字&gt;</li>\n</ul>\n<ul>\n<li><strong>设置元素空余空间分配权重：</strong>flex-grow: &lt;数字&gt;</li>\n<li><strong>设置元素超出分配空间权重：</strong>flex-shrink: &lt;数字&gt;</li>\n<li><strong>设置元素在主轴方向的基础长度：</strong>flex-basis: &lt;数字&gt;</li>\n<li><strong>设置元素在主轴方向的弹性：</strong>flex: [flex-grow] [flex-shrink] [flex-basis]</li>\n</ul>\n<ul>\n<li><strong>指定弹性容器内元素的间隔方式：</strong>justify-content: flex-start | flex-end | center | space-between | space-arount</li>\n<li><strong>指定弹性容器内元素辅轴对齐方式：</strong>align-items: flex-start | flex-end | center | stretch | baseline</li>\n<li><strong>设置元素在主轴方向的对齐方式：</strong>align-self: flex-start | flex-end | center | stretch | baseline</li>\n<li><strong>指定弹性容器内元素的辅轴上行的对齐方式：</strong>align-content: flex-start | flex-end | center | space-between | space-arount | stretch</li>\n</ul>\n<h4 id=\"30-font-family-serif-sans-serif：\"><a href=\"#30-font-family-serif-sans-serif：\" class=\"headerlink\" title=\"30. font-family: serif sans-serif：\"></a>30. font-family: serif sans-serif：</h4><ul>\n<li><strong>衬线体 serif：</strong>意思是在字的笔画开始. 结束的地方有额外的装饰，而且笔画的粗细会有所不同。</li>\n<li><strong>非衬线体 sans-serif：</strong>没有这些额外的装饰，而且笔画的粗细差不多。</li>\n</ul>\n<h4 id=\"31-DOMContentLoaded-和-load-的区别：\"><a href=\"#31-DOMContentLoaded-和-load-的区别：\" class=\"headerlink\" title=\"31. DOMContentLoaded 和 load 的区别：\"></a>31. DOMContentLoaded 和 load 的区别：</h4><p>DOM 文档的加载步骤为：</p>\n<ol>\n<li>解析 HTML 结构；</li>\n<li>加载外部脚本和样式表文件；</li>\n<li>解析并执行脚本代码；</li>\n<li>DOM 树构建完成； // <strong>DOMContentLoaded</strong>；</li>\n<li>加载图片等外部文件；</li>\n<li>页面加载完毕； // <strong>load</strong>；</li>\n</ol>\n<h4 id=\"32-DOM-树上的各种操作：\"><a href=\"#32-DOM-树上的各种操作：\" class=\"headerlink\" title=\"32. DOM 树上的各种操作：\"></a>32. DOM 树上的各种操作：</h4><p><img src=\"1.jpg\" alt></p>\n<h4 id=\"33-children-和-childNodes-的区别？\"><a href=\"#33-children-和-childNodes-的区别？\" class=\"headerlink\" title=\"33. children 和 childNodes 的区别？\"></a>33. children 和 childNodes 的区别？</h4><p><code>children</code> 只会包含元素节点，不会包含文字节点。<code>childNodes</code> 会包含所有子节点。</p>\n<h4 id=\"34-nextElementSibling-和-nextSibling-的区别？\"><a href=\"#34-nextElementSibling-和-nextSibling-的区别？\" class=\"headerlink\" title=\"34. nextElementSibling 和 nextSibling 的区别？\"></a>34. nextElementSibling 和 nextSibling 的区别？</h4><p><code>nextElementSibling</code> 只包含元素兄弟节点。<code>nextSibling</code> 会包含文字节点。</p>\n<h4 id=\"35-CSS-DOM-概览：\"><a href=\"#35-CSS-DOM-概览：\" class=\"headerlink\" title=\"35. CSS DOM 概览：\"></a>35. CSS DOM 概览：</h4><p><code>window.getComputedStyle([element]);</code> // 可以获得一个元素计算后的样式 CSSStyleDeclaration 对象；</p>\n<p><img src=\"2.png\" alt></p>\n<h4 id=\"36-DOM-属性访问器访问属性和-“g-setAttribute”-访问属性的区别？\"><a href=\"#36-DOM-属性访问器访问属性和-“g-setAttribute”-访问属性的区别？\" class=\"headerlink\" title=\"36. DOM 属性访问器访问属性和 “g/setAttribute” 访问属性的区别？\"></a>36. DOM 属性访问器访问属性和 “g/setAttribute” 访问属性的区别？</h4><ul>\n<li><strong>DOM 属性访问器：</strong>通用性差，扩展性差；但取到的是一个“<strong>实用对象</strong>”结构；</li>\n<li><strong>g/setAttribute：</strong>取到的只是字符串，通用性强；</li>\n</ul>\n<p><code>element.dataset</code> 可以取到该 DOM 元素上所有的自定义属性，即以 “data-” 开头的属性。</p>\n<h4 id=\"37-DOM-事件触发、事件绑定与事件卸载：\"><a href=\"#37-DOM-事件触发、事件绑定与事件卸载：\" class=\"headerlink\" title=\"37. DOM 事件触发、事件绑定与事件卸载：\"></a>37. DOM 事件触发、事件绑定与事件卸载：</h4><ul>\n<li><strong>IE8 以上：</strong><code>addEventListener</code>、<code>removeEventListener</code>、<code>dispatchEvent</code>；W3C 标准；</li>\n<li><strong>IE8 及以下：</strong><code>attachEvent</code>、<code>detachEvent</code>、<code>fireEvent</code>；没有捕获阶段；</li>\n</ul>\n<h4 id=\"38-onerror-事件的常用场景：\"><a href=\"#38-onerror-事件的常用场景：\" class=\"headerlink\" title=\"38. onerror 事件的常用场景：\"></a>38. onerror 事件的常用场景：</h4><p>在 img 标签加入 <code>onerror=&quot;this.src=&#39;default.png&#39;&quot;</code> 可以设置图片出错时显示的默认图片。</p>\n<h4 id=\"39-HTML-模块化构建：\"><a href=\"#39-HTML-模块化构建：\" class=\"headerlink\" title=\"39. HTML 模块化构建：\"></a>39. HTML 模块化构建：</h4><p><img src=\"3.jpg\" alt></p>\n<h4 id=\"40-position-属性各个值的分层关系：\"><a href=\"#40-position-属性各个值的分层关系：\" class=\"headerlink\" title=\"40. position 属性各个值的分层关系：\"></a>40. position 属性各个值的分层关系：</h4><p>static 不能通过 z-index 分层；relative、absolute 和 fixed 可以通过 z-index 分层。</p>\n<p>首先是遵循 DOM 规则，同级的后面居上。一般有定位属性的元素会高于无定位属性的同级元素。</p>\n<p>都有定位属性的同级元素，z-index 大者居上；</p>\n<p>如果是非同级的元素，则会忽略元素本身 z-index，取与对比元素同级的祖先元素的 z-index 属性，大者居上。</p>\n<h4 id=\"41-如何高效的插入-HTML-到-DOM-树的指定位置？\"><a href=\"#41-如何高效的插入-HTML-到-DOM-树的指定位置？\" class=\"headerlink\" title=\"41. 如何高效的插入 HTML 到 DOM 树的指定位置？\"></a>41. 如何高效的插入 HTML 到 DOM 树的指定位置？</h4><p>使用 <code>createDocumentFragment</code> 创建一个内存中的文档片段，将所有需要追加到页面的 HTML 都 <code>appendChild</code> 到这个文档片段，最后一次性的将该文档片段 appendChild 到 DOM 树上；由于拼接子元素的过程是在内存中进行的因此可以减少页面的回流和重绘；</p>\n<p>或使用 <code>insertAdjacentHTML([position], [text])</code> 直接向页面插入 HTML 片段。其中 position 分为四个值：beforebegin、afterbegin、beforeend 和 afterend；</p>\n<h4 id=\"42-em-rem-vh-vw-vmin-vmax-ex-ch：\"><a href=\"#42-em-rem-vh-vw-vmin-vmax-ex-ch：\" class=\"headerlink\" title=\"42. em \\ rem \\ vh \\ vw \\ vmin \\ vmax \\ ex \\ ch：\"></a>42. em \\ rem \\ vh \\ vw \\ vmin \\ vmax \\ ex \\ ch：</h4><ul>\n<li><strong>em：</strong>现对于父元素的字体大小；</li>\n<li><strong>rem：</strong>相对于根元素 html 的字体大小；</li>\n<li><strong>vh\\vw：</strong>其中的 v 表示 viewpoint 视窗，所以这两个大小单位代表相对于当前视窗的大小，1vh\\vw 相当于百分之1的视窗高度\\宽度；</li>\n<li><strong>vmin\\vmax：</strong>同上，其中的 v 表示 viewpoint，vmin 取 vh\\vw 中两者较小的作为单位，vmax 则相反。</li>\n<li><strong>ch：</strong>常与等宽字体联合使用 “<strong>Consolas，Monaco，monospace</strong>”。1ch 表示一个0字符的宽度，因此只有在等宽字体的情况下，我们才能用 ch 来精确的调整字符的显示。</li>\n<li><strong>ex：</strong>相对长度单位。相对于字符 “x” 的高度。通常为字体高度的一半。利用 ex 可以实现内联图标与段落的垂直居中。</li>\n</ul>\n","site":{"data":{}},"id":"825cb4f7b0b4d25726be647025330f45","excerpt":"","more":"<p>这里总结一下 Web 前端面试中 CSS 部分的常见面试问题，同时这些问题也是对一些基础的技术概念和思想的理解。对这些基本知识的掌握程度和深度决定了你的技术层级。高级工程师是必须掌握本文列出的这些知识点，资深工程师则要对这些基本概念的纵向深度进行挖掘，【问题解答全部原创，转载请注明来源】。</p>\n<h3 id=\"CSS-技术部分：\"><a href=\"#CSS-技术部分：\" class=\"headerlink\" title=\"CSS 技术部分：\"></a>CSS 技术部分：</h3><h4 id=\"1-标准-CSS-的盒子模型？与低版本-IE-的盒子模型有什么不同？\"><a href=\"#1-标准-CSS-的盒子模型？与低版本-IE-的盒子模型有什么不同？\" class=\"headerlink\" title=\"1. 标准 CSS 的盒子模型？与低版本 IE 的盒子模型有什么不同？\"></a>1. 标准 CSS 的盒子模型？与低版本 IE 的盒子模型有什么不同？</h4><p>IE 盒子模型的范围同标准 CSS 盒子模型一样，包括 margin、border、padding 以及 content 四部分。和标准 W3C 盒子模型不同的是：IE 盒子模型的 content 部分包含了 border 和 padding。两者分别对应于 <code>box-sizing</code> 属性的 <code>content-box</code> 和 <code>border-box</code> 两个值。</p>\n<h4 id=\"2-手写动画你认为最小的时间间隔是多久？\"><a href=\"#2-手写动画你认为最小的时间间隔是多久？\" class=\"headerlink\" title=\"2. 手写动画你认为最小的时间间隔是多久？\"></a>2. 手写动画你认为最小的时间间隔是多久？</h4><p>多数显示器默认频率是 60Hz，即1秒刷新60次，所以理论上最小间隔为 1/60＊1000ms ＝ <strong>16.7ms</strong>；</p>\n<h4 id=\"3-在网页中的应该使用奇数还是偶数的字体？\"><a href=\"#3-在网页中的应该使用奇数还是偶数的字体？\" class=\"headerlink\" title=\"3. 在网页中的应该使用奇数还是偶数的字体？\"></a>3. 在网页中的应该使用奇数还是偶数的字体？</h4><p>偶数字号相对更容易和 Web 设计的其他部分构成比例关系，也是为了兼容 Windows Vista 上的点阵宋体字体（只提供了偶数字体点阵）。其他方面笔者感觉，并没有区别。</p>\n<h4 id=\"4-设置元素浮动后，该元素的-display-值是多少？\"><a href=\"#4-设置元素浮动后，该元素的-display-值是多少？\" class=\"headerlink\" title=\"4. 设置元素浮动后，该元素的 display 值是多少？\"></a>4. 设置元素浮动后，该元素的 display 值是多少？</h4><p>自动变成 <code>display: block</code>。</p>\n<h4 id=\"5-如何用-CSS-让页面里的字体变清晰？\"><a href=\"#5-如何用-CSS-让页面里的字体变清晰？\" class=\"headerlink\" title=\"5. 如何用 CSS 让页面里的字体变清晰？\"></a>5. 如何用 CSS 让页面里的字体变清晰？</h4><p>设置 <code>-webkit-font-smoothing: antialiased;</code>（抗锯齿）</p>\n<h4 id=\"6-如何用-CSS-创建一个三角形？\"><a href=\"#6-如何用-CSS-创建一个三角形？\" class=\"headerlink\" title=\"6. 如何用 CSS 创建一个三角形？\"></a>6. 如何用 CSS 创建一个三角形？</h4><pre><code class=\"css\">border-top:solid 100px red;\nborder-left:solid 100px green;\nborder-right:solid 100px orange;\nborder-bottom:solid 100px blue;\nwidth: 0;\nheight: 0;\n</code></pre>\n<h4 id=\"7-如何修改-Chrome-记住密码后自动填充表单的黄色背景？\"><a href=\"#7-如何修改-Chrome-记住密码后自动填充表单的黄色背景？\" class=\"headerlink\" title=\"7. 如何修改 Chrome 记住密码后自动填充表单的黄色背景？\"></a>7. 如何修改 Chrome 记住密码后自动填充表单的黄色背景？</h4><p>浏览器自动添加了 <code>input: -webkit-autofill</code> 这个私有属性。</p>\n<h4 id=\"8-浏览器是怎样解析-CSS-选择器的？\"><a href=\"#8-浏览器是怎样解析-CSS-选择器的？\" class=\"headerlink\" title=\"8. 浏览器是怎样解析 CSS 选择器的？\"></a>8. 浏览器是怎样解析 CSS 选择器的？</h4><p>CSS 选择器是<strong>从右往左解析</strong>的，这样效率较高，从子元素向上寻找父元素的情况在大多数正常情况下都比正向从父元素查找子元素要快得多，从左到右的查找在大多数规则读到最后（最右）才会发现是不匹配的，这样会做费时耗能，最后有很多都是无用的。</p>\n<p>浏览器渲染过程：</p>\n<ul>\n<li>HTML -&gt; HTML 解析器 -&gt; DOM 树；</li>\n<li>样式 -&gt; 样式解析器 -&gt; 样式规则；</li>\n</ul>\n<p>DOM 树和样式规则进行结合形成渲染树。</p>\n<h4 id=\"9-CSS-继承：\"><a href=\"#9-CSS-继承：\" class=\"headerlink\" title=\"9. CSS 继承：\"></a>9. CSS 继承：</h4><p>CSS 样式继承性是指下级的样式属性会继承上级的属性，比如 li 会继承 ul 的样式属性。</p>\n<h4 id=\"10-如何居中-div-浮动-绝对定位元素？\"><a href=\"#10-如何居中-div-浮动-绝对定位元素？\" class=\"headerlink\" title=\"10. 如何居中 div \\ 浮动 \\ 绝对定位元素？\"></a>10. 如何居中 div \\ 浮动 \\ 绝对定位元素？</h4><p>对于定宽的非浮动元素我们可以在 CSS 中用 <code>margin: 0 auto;</code> 进行水平居中；对于浮动元素可以父子元素同时向一个方向浮动，父元素设置 <code>left: 50%;</code></p>\n<h4 id=\"11-position-的值-relative-和-absolute-定位原点是？\"><a href=\"#11-position-的值-relative-和-absolute-定位原点是？\" class=\"headerlink\" title=\"11. position 的值 relative 和 absolute 定位原点是？\"></a>11. position 的值 relative 和 absolute 定位原点是？</h4><p>相对定位是“相对于”元素在文档中的初始位置，而绝对定位是“相对于”最近的已定位祖先元素，如果不存在已定位的祖先元素，那么“相对于”最初的包含块。</p>\n<h4 id=\"12-before-和-after-中的双冒号与单冒号有什么区别？\"><a href=\"#12-before-和-after-中的双冒号与单冒号有什么区别？\" class=\"headerlink\" title=\"12. ::before 和 :after 中的双冒号与单冒号有什么区别？\"></a>12. ::before 和 :after 中的双冒号与单冒号有什么区别？</h4><p>两个冒号和一个冒号的作用其实一致的，只是在 CSS3 中为了区分<strong>伪类选择器</strong>和<strong>伪元素选择器</strong>，在语义上更清晰明了；</p>\n<p><strong>伪类选择器：</strong>即伪类的效果可以通过添加一个实际的类来达到；</p>\n<ul>\n<li><code>:hover</code>；</li>\n<li><code>:link</code>；</li>\n<li><code>:active</code>；</li>\n<li><code>:target</code>；</li>\n<li><code>:not(selector)</code>；</li>\n<li><code>:focus</code>；</li>\n</ul>\n<p><strong>伪元素选择器：</strong>即伪元素的效果是需要通过添加一个实际的元素才能达到的；</p>\n<ul>\n<li><code>::first-letter</code>；</li>\n<li><code>::first-line</code>；</li>\n<li><code>::before</code>；</li>\n<li><code>::after</code>；</li>\n<li><code>::selection</code>；</li>\n</ul>\n<h4 id=\"13-transform-属性的几种常用方法：\"><a href=\"#13-transform-属性的几种常用方法：\" class=\"headerlink\" title=\"13. transform 属性的几种常用方法：\"></a>13. transform 属性的几种常用方法：</h4><p>rotate 旋转、translate 平移、skew 倾斜、scale 缩放以及各个方法对应的 3D 版本。</p>\n<ul>\n<li><code>transform-origin</code>：属性设置动作原点；</li>\n<li><code>perspective-origin</code>：属性设置透视方位；</li>\n<li><code>perspective</code>：设置透视角度；</li>\n</ul>\n<h4 id=\"14-常用的图片格式？\"><a href=\"#14-常用的图片格式？\" class=\"headerlink\" title=\"14. 常用的图片格式？\"></a>14. 常用的图片格式？</h4><ul>\n<li>PNG 可以存储 Alpha 通道，失真小，没锯齿，无损压缩，一种是 Index（体积较小），一种是 RGB，体积较大；</li>\n<li>GIF 可以存储动画；</li>\n<li>JPEG 图片色彩更加丰富，但是有损压缩，不适合多次读取储存；</li>\n<li>WebP 是一种谷歌开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有JPEG的2/3；</li>\n</ul>\n<h4 id=\"15-style-标签写在-body-后与-body-前有什么区别？\"><a href=\"#15-style-标签写在-body-后与-body-前有什么区别？\" class=\"headerlink\" title=\"15. style 标签写在 body 后与 body 前有什么区别？\"></a>15. style 标签写在 body 后与 body 前有什么区别？</h4><p>CSS 样式的加载顺序从上到下，同时应该符合样式的放置规范，外部. 内部. 内嵌。放在 body 里不符合规范也不利于代码维护。</p>\n<h4 id=\"16-font-style-属性的-oblique-和-italic-有什么区别？\"><a href=\"#16-font-style-属性的-oblique-和-italic-有什么区别？\" class=\"headerlink\" title=\"16. font-style 属性的 oblique 和 italic 有什么区别？\"></a>16. font-style 属性的 oblique 和 italic 有什么区别？</h4><p>italic 是斜体，是一种不同的字体，而 oblique 是一种仿斜体，是浏览器通过将普通字体通过变形而成的“斜体”，italic 选择字体族的 italic 变体，如果没有 italic 变体就妥协到 oblique 变体。如果字体族连 oblique 也未提供，则由浏览器合成倾斜的仿 oblique 字体。italic 和 oblique 在字体形态上有所不同。</p>\n<h4 id=\"17-常见的移动端开发问题：\"><a href=\"#17-常见的移动端开发问题：\" class=\"headerlink\" title=\"17. 常见的移动端开发问题：\"></a>17. 常见的移动端开发问题：</h4><p>应该有很多，这里只列出笔者遇到过的一部分：</p>\n<p>若父容器设置了 <code>transform</code> 属性，则其内部子元素的 <code>position: fixed;</code> 属性会失效；</p>\n<h4 id=\"18-对-line-height-属性的理解：\"><a href=\"#18-对-line-height-属性的理解：\" class=\"headerlink\" title=\"18. 对 line-height 属性的理解：\"></a>18. 对 line-height 属性的理解：</h4><p>行高指的是文本行的基线间的距离，<code>line-height</code> 若使用百分比则实际像素值为所有继承的元素的 <code>font-size</code> 乘以这个百分比，是先计算然后转换为像素值；若使用直接像素值，则所有继承元素使用相同的 line-height 值；相对来说，用纯数字指定 line-height 比较好，可以动态改变行距；<strong>段落中的行间距最好是本身 font-size 的1.5倍最好，浏览器默认行间距为1.14左右</strong>。</p>\n<ul>\n<li><strong>containing-boxes：</strong>它包含了其他的 boxes，比如 p 本身就是一种；</li>\n<li><strong>inline-boxes：</strong>让显示的内容排成一行，比如 span 元素；没有标签包裹的文字为匿名 inline-boxes；</li>\n<li><strong>line-boxes：</strong>inline-boxes 在 containing-boxes 连接成了 line-boxed；</li>\n<li><strong>content-area：</strong>是围绕着文字的一种看不见的 boxes，高取决于 font-size；</li>\n</ul>\n<p>line-height 超出 font-size 部分的一半称为“半行间距”，它被平均的放到 content-area 的顶部和底部；</p>\n<h4 id=\"20-CSS-里的-visibility-的-collapse-属性值有什么作用和区别？\"><a href=\"#20-CSS-里的-visibility-的-collapse-属性值有什么作用和区别？\" class=\"headerlink\" title=\"20. CSS 里的 visibility 的 collapse 属性值有什么作用和区别？\"></a>20. CSS 里的 visibility 的 collapse 属性值有什么作用和区别？</h4><p>该属性兼容性各个浏览器并不统一，对于一般的元素，它的表现跟 <code>hidden</code> 是一样的。但例外的是，如果这个元素是 table 相关的元素，它的表现却跟 <code>display: none</code> 一样。</p>\n<h4 id=\"21-视差滚动的原理：\"><a href=\"#21-视差滚动的原理：\" class=\"headerlink\" title=\"21. 视差滚动的原理：\"></a>21. 视差滚动的原理：</h4><p>视差滚动是指多层背景以不同的速度移动，形成立体的运动效果，带来非常出色的视觉体验。</p>\n<p><strong>实现原理：</strong>主要利用了 <code>background-attachment: fixed;</code> 属性，随着页面的滚动轴背景图片不会移动。</p>\n<h4 id=\"22-display-inline-block-什么时候会显示间隙？\"><a href=\"#22-display-inline-block-什么时候会显示间隙？\" class=\"headerlink\" title=\"22. display: inline-block 什么时候会显示间隙？\"></a>22. display: inline-block 什么时候会显示间隙？</h4><p>浏览器的默认行为是把 inline 元素间的空白字符（空格. 换行. Tab）渲染成一个空格，这个问题不止出现在 li 元素上；</p>\n<p><strong>解决方案：</strong></p>\n<ol>\n<li>所以把所有 li 放到同一行；</li>\n<li>将这些被渲染成空格的字符 <code>font-size</code> 属性设置为 0；</li>\n<li>设置 letter-spacing 为适当大小；</li>\n</ol>\n<h4 id=\"23-z-index-栈：\"><a href=\"#23-z-index-栈：\" class=\"headerlink\" title=\"23. z-index 栈：\"></a>23. z-index 栈：</h4><p><code>z-index</code> 只在设置了 <code>position</code> 属性（值非 static）的元素上生效；而<strong>父元素的 <code>z-index</code> 会比子元素先生效；</strong></p>\n<h4 id=\"24-float、relative、absolute、fixed-基础重点：\"><a href=\"#24-float、relative、absolute、fixed-基础重点：\" class=\"headerlink\" title=\"24. float、relative、absolute、fixed 基础重点：\"></a>24. float、relative、absolute、fixed 基础重点：</h4><ul>\n<li><strong>relative：</strong>参照物为元素本身，即默认情况下在文档流中的位置；</li>\n<li><strong>float：</strong>元素默认宽度为内容宽度；半脱离文档流（元素脱离文档流，内容不脱离文档流，即一种“<strong>文字环绕图片</strong>”的效果）；</li>\n<li><strong>absolute：</strong>元素默认宽度为内容宽度；脱离文档流；参照物为第一个定位祖先（设置了 position 并且值不是 static 的元素）/ 根元素；如果设置了 absolute 的元素没有设置宽高，则 LRTB 四个属性可以将该元素自适应抻开；</li>\n<li><strong>fixed：</strong>元素默认宽度为内容宽度；脱离文档流；参照物为视窗；</li>\n</ul>\n<p>float 会导致原有的 inline-boxes 消失，</p>\n<h4 id=\"25-overflow-scroll-时不能平滑滚动的问题怎么处理？\"><a href=\"#25-overflow-scroll-时不能平滑滚动的问题怎么处理？\" class=\"headerlink\" title=\"25. overflow:scroll 时不能平滑滚动的问题怎么处理？\"></a>25. overflow:scroll 时不能平滑滚动的问题怎么处理？</h4><p>添加 <code>-webkit-overflow-scrolling: touch;</code> 属性。该属性创建了带有硬件加速的系统级控件，但比较耗费内存；也可以采用 iScroll 插件来解决这个问题。</p>\n<h4 id=\"26-常见的浏览器兼容性问题有哪些？\"><a href=\"#26-常见的浏览器兼容性问题有哪些？\" class=\"headerlink\" title=\"26. 常见的浏览器兼容性问题有哪些？\"></a>26. 常见的浏览器兼容性问题有哪些？</h4><p>HTML5 的兼容性问题等（笔者公司不考虑 IE10 以下的浏览器）。</p>\n<h4 id=\"27-元素竖向的百分比设定是相对于容器的高度吗\"><a href=\"#27-元素竖向的百分比设定是相对于容器的高度吗\" class=\"headerlink\" title=\"27. 元素竖向的百分比设定是相对于容器的高度吗?\"></a>27. 元素竖向的百分比设定是相对于容器的高度吗?</h4><p>当按百分比设定一个元素的宽度时，它是相对于父容器的宽度计算的。但是，对于一些表示竖向距离的属性，例如 <code>padding-top</code>、<code>padding-bottom</code>、<code>margin-top</code> 以及 <code>margin-bottom</code> 等，当按百分比设定它们时，<strong>依据的也是父容器的宽度</strong>，而不是高度。</p>\n<h4 id=\"28-两个-CSS-模型：\"><a href=\"#28-两个-CSS-模型：\" class=\"headerlink\" title=\"28. 两个 CSS 模型：\"></a>28. 两个 CSS 模型：</h4><p>一个是 box 盒状模型，对应 CSS 为 “（height / width）+ padding + margin”，另外一个是 line box 模型，对应样式为 “<code>line-height</code>”；</p>\n<h4 id=\"29-弹性布局：\"><a href=\"#29-弹性布局：\" class=\"headerlink\" title=\"29. 弹性布局：\"></a>29. 弹性布局：</h4><ul>\n<li><strong>弹性父容器：</strong>display: flex;</li>\n<li><strong>弹性元素：</strong>父容器的直接子元素，并且没有脱离文档流（非 absolute 属性）。</li>\n<li><strong>指定弹性容器内元素排列方向：</strong>flex-direction: row | row-reverse | column | column-reverse</li>\n<li><strong>指定弹性容器内元素换行方式：</strong>flex-wrap: no-wrap | wrap | wrap-reverse</li>\n<li><strong>指定弹性容器内元素排队和换行方式：</strong>flex-flow: [flex-direction] [flex-wrap]</li>\n<li><strong>指定弹性元素的排列权重（重的在后边）：</strong>order: &lt;数字&gt;</li>\n</ul>\n<ul>\n<li><strong>设置元素空余空间分配权重：</strong>flex-grow: &lt;数字&gt;</li>\n<li><strong>设置元素超出分配空间权重：</strong>flex-shrink: &lt;数字&gt;</li>\n<li><strong>设置元素在主轴方向的基础长度：</strong>flex-basis: &lt;数字&gt;</li>\n<li><strong>设置元素在主轴方向的弹性：</strong>flex: [flex-grow] [flex-shrink] [flex-basis]</li>\n</ul>\n<ul>\n<li><strong>指定弹性容器内元素的间隔方式：</strong>justify-content: flex-start | flex-end | center | space-between | space-arount</li>\n<li><strong>指定弹性容器内元素辅轴对齐方式：</strong>align-items: flex-start | flex-end | center | stretch | baseline</li>\n<li><strong>设置元素在主轴方向的对齐方式：</strong>align-self: flex-start | flex-end | center | stretch | baseline</li>\n<li><strong>指定弹性容器内元素的辅轴上行的对齐方式：</strong>align-content: flex-start | flex-end | center | space-between | space-arount | stretch</li>\n</ul>\n<h4 id=\"30-font-family-serif-sans-serif：\"><a href=\"#30-font-family-serif-sans-serif：\" class=\"headerlink\" title=\"30. font-family: serif sans-serif：\"></a>30. font-family: serif sans-serif：</h4><ul>\n<li><strong>衬线体 serif：</strong>意思是在字的笔画开始. 结束的地方有额外的装饰，而且笔画的粗细会有所不同。</li>\n<li><strong>非衬线体 sans-serif：</strong>没有这些额外的装饰，而且笔画的粗细差不多。</li>\n</ul>\n<h4 id=\"31-DOMContentLoaded-和-load-的区别：\"><a href=\"#31-DOMContentLoaded-和-load-的区别：\" class=\"headerlink\" title=\"31. DOMContentLoaded 和 load 的区别：\"></a>31. DOMContentLoaded 和 load 的区别：</h4><p>DOM 文档的加载步骤为：</p>\n<ol>\n<li>解析 HTML 结构；</li>\n<li>加载外部脚本和样式表文件；</li>\n<li>解析并执行脚本代码；</li>\n<li>DOM 树构建完成； // <strong>DOMContentLoaded</strong>；</li>\n<li>加载图片等外部文件；</li>\n<li>页面加载完毕； // <strong>load</strong>；</li>\n</ol>\n<h4 id=\"32-DOM-树上的各种操作：\"><a href=\"#32-DOM-树上的各种操作：\" class=\"headerlink\" title=\"32. DOM 树上的各种操作：\"></a>32. DOM 树上的各种操作：</h4><p><img src=\"1.jpg\" alt></p>\n<h4 id=\"33-children-和-childNodes-的区别？\"><a href=\"#33-children-和-childNodes-的区别？\" class=\"headerlink\" title=\"33. children 和 childNodes 的区别？\"></a>33. children 和 childNodes 的区别？</h4><p><code>children</code> 只会包含元素节点，不会包含文字节点。<code>childNodes</code> 会包含所有子节点。</p>\n<h4 id=\"34-nextElementSibling-和-nextSibling-的区别？\"><a href=\"#34-nextElementSibling-和-nextSibling-的区别？\" class=\"headerlink\" title=\"34. nextElementSibling 和 nextSibling 的区别？\"></a>34. nextElementSibling 和 nextSibling 的区别？</h4><p><code>nextElementSibling</code> 只包含元素兄弟节点。<code>nextSibling</code> 会包含文字节点。</p>\n<h4 id=\"35-CSS-DOM-概览：\"><a href=\"#35-CSS-DOM-概览：\" class=\"headerlink\" title=\"35. CSS DOM 概览：\"></a>35. CSS DOM 概览：</h4><p><code>window.getComputedStyle([element]);</code> // 可以获得一个元素计算后的样式 CSSStyleDeclaration 对象；</p>\n<p><img src=\"2.png\" alt></p>\n<h4 id=\"36-DOM-属性访问器访问属性和-“g-setAttribute”-访问属性的区别？\"><a href=\"#36-DOM-属性访问器访问属性和-“g-setAttribute”-访问属性的区别？\" class=\"headerlink\" title=\"36. DOM 属性访问器访问属性和 “g/setAttribute” 访问属性的区别？\"></a>36. DOM 属性访问器访问属性和 “g/setAttribute” 访问属性的区别？</h4><ul>\n<li><strong>DOM 属性访问器：</strong>通用性差，扩展性差；但取到的是一个“<strong>实用对象</strong>”结构；</li>\n<li><strong>g/setAttribute：</strong>取到的只是字符串，通用性强；</li>\n</ul>\n<p><code>element.dataset</code> 可以取到该 DOM 元素上所有的自定义属性，即以 “data-” 开头的属性。</p>\n<h4 id=\"37-DOM-事件触发、事件绑定与事件卸载：\"><a href=\"#37-DOM-事件触发、事件绑定与事件卸载：\" class=\"headerlink\" title=\"37. DOM 事件触发、事件绑定与事件卸载：\"></a>37. DOM 事件触发、事件绑定与事件卸载：</h4><ul>\n<li><strong>IE8 以上：</strong><code>addEventListener</code>、<code>removeEventListener</code>、<code>dispatchEvent</code>；W3C 标准；</li>\n<li><strong>IE8 及以下：</strong><code>attachEvent</code>、<code>detachEvent</code>、<code>fireEvent</code>；没有捕获阶段；</li>\n</ul>\n<h4 id=\"38-onerror-事件的常用场景：\"><a href=\"#38-onerror-事件的常用场景：\" class=\"headerlink\" title=\"38. onerror 事件的常用场景：\"></a>38. onerror 事件的常用场景：</h4><p>在 img 标签加入 <code>onerror=&quot;this.src=&#39;default.png&#39;&quot;</code> 可以设置图片出错时显示的默认图片。</p>\n<h4 id=\"39-HTML-模块化构建：\"><a href=\"#39-HTML-模块化构建：\" class=\"headerlink\" title=\"39. HTML 模块化构建：\"></a>39. HTML 模块化构建：</h4><p><img src=\"3.jpg\" alt></p>\n<h4 id=\"40-position-属性各个值的分层关系：\"><a href=\"#40-position-属性各个值的分层关系：\" class=\"headerlink\" title=\"40. position 属性各个值的分层关系：\"></a>40. position 属性各个值的分层关系：</h4><p>static 不能通过 z-index 分层；relative、absolute 和 fixed 可以通过 z-index 分层。</p>\n<p>首先是遵循 DOM 规则，同级的后面居上。一般有定位属性的元素会高于无定位属性的同级元素。</p>\n<p>都有定位属性的同级元素，z-index 大者居上；</p>\n<p>如果是非同级的元素，则会忽略元素本身 z-index，取与对比元素同级的祖先元素的 z-index 属性，大者居上。</p>\n<h4 id=\"41-如何高效的插入-HTML-到-DOM-树的指定位置？\"><a href=\"#41-如何高效的插入-HTML-到-DOM-树的指定位置？\" class=\"headerlink\" title=\"41. 如何高效的插入 HTML 到 DOM 树的指定位置？\"></a>41. 如何高效的插入 HTML 到 DOM 树的指定位置？</h4><p>使用 <code>createDocumentFragment</code> 创建一个内存中的文档片段，将所有需要追加到页面的 HTML 都 <code>appendChild</code> 到这个文档片段，最后一次性的将该文档片段 appendChild 到 DOM 树上；由于拼接子元素的过程是在内存中进行的因此可以减少页面的回流和重绘；</p>\n<p>或使用 <code>insertAdjacentHTML([position], [text])</code> 直接向页面插入 HTML 片段。其中 position 分为四个值：beforebegin、afterbegin、beforeend 和 afterend；</p>\n<h4 id=\"42-em-rem-vh-vw-vmin-vmax-ex-ch：\"><a href=\"#42-em-rem-vh-vw-vmin-vmax-ex-ch：\" class=\"headerlink\" title=\"42. em \\ rem \\ vh \\ vw \\ vmin \\ vmax \\ ex \\ ch：\"></a>42. em \\ rem \\ vh \\ vw \\ vmin \\ vmax \\ ex \\ ch：</h4><ul>\n<li><strong>em：</strong>现对于父元素的字体大小；</li>\n<li><strong>rem：</strong>相对于根元素 html 的字体大小；</li>\n<li><strong>vh\\vw：</strong>其中的 v 表示 viewpoint 视窗，所以这两个大小单位代表相对于当前视窗的大小，1vh\\vw 相当于百分之1的视窗高度\\宽度；</li>\n<li><strong>vmin\\vmax：</strong>同上，其中的 v 表示 viewpoint，vmin 取 vh\\vw 中两者较小的作为单位，vmax 则相反。</li>\n<li><strong>ch：</strong>常与等宽字体联合使用 “<strong>Consolas，Monaco，monospace</strong>”。1ch 表示一个0字符的宽度，因此只有在等宽字体的情况下，我们才能用 ch 来精确的调整字符的显示。</li>\n<li><strong>ex：</strong>相对长度单位。相对于字符 “x” 的高度。通常为字体高度的一半。利用 ex 可以实现内联图标与段落的垂直居中。</li>\n</ul>\n"},{"title":"前端常见技术点 - HTML","intro":"这里总结一下 WEB 前端面试 HTML 部分的常见问题，同时这些问题也是对一些基础的技术概念和思想的理解。对这些基本知识的掌握程度和深度决定了你的技术层级。高级工程师是必须掌握本文列出的这些知识的，资深工程师则要对这些基本概念的纵向深度进行挖掘，【问题解答全部原创，转载请注明来源】。","comments":1,"date":"2016-12-12T16:16:24.000Z","_content":"\n这里总结一下 WEB 前端面试 HTML 部分的常见问题，同时这些问题也是对一些基础的技术概念和思想的理解。对这些基本知识的掌握程度和深度决定了你的技术层级。高级工程师是必须掌握本文列出的这些知识的，资深工程师则要对这些基本概念的纵向深度进行挖掘，【问题解答全部原创，转载请注明来源】。\n\n### HTML 技术部分：\n\n#### 1. !DOCTYPE 的作用？严格模式与混杂模式如何区分？有何意义?\n\n根据 “<!DOCTYPE>” 是否存在选择呈现模式，被称为 **<!DOCTYPE> 切换或 <!DOCTYPE> 侦测**。\n\n一个文档类型标记的目的是要：**告诉浏览器解析器，它应该使用什么样的文档或规范（DTD）来解析文档格式**。\n\n* **严格模式：**正确的 <!DOCTYPE> 标记，浏览器将按照标准渲染页面。\n* **混杂模式：**若 <!DOCTYPE> 标记不存在或格式不正确会导致文档以混杂模式呈现，该模式下页面将会以一种比较宽松的向后兼容的方式来显示。\n\n**意义：**当浏览器厂商开始创建与标准兼容的浏览器时，他们希望能够确保向后兼容性。这里我们可以用如下所示代码来判断当前文档的解析模式：\n\n```javascript\ndocument.compatMode === \"CSS1Compat\" ? \"标准模式\" : \"混杂模式\";\n```\n\n#### 2. HTML5 为什么只需要写 <!DOCTYPE HTML>？\n\nHTML5 不基于 SGML，因此不需要 <!DOCTYPE> 对 DTD 进行引用，但是需要其来规范浏览器行为。而 HMTL4.01 是基于 SGML 的。\n\n#### 3. 行内元素有哪些？块级元素有哪些？空元素有那些？\n\n* **行内：**span、strong、em、img 等；\n* **块元素：**div、p、h1-h6 等；\n* **空元素：**hr、br 等；\n* **行内块元素：**input、textarea、keygen、select、button 等；\n\n#### 4. 常见的浏览器内核\n\n* **Trident内核：**IE；\n* **Gecko内核：**Mozilla Firefox；\n* **WebKit内核：**Safari、Chrome、Edge；\n\n#### 5. title 与 h1 的区别、b 与 strong 的区别、i 与 em 的区别？\n\ntitle 在 SEO 的权重中比 h1 要高，strong 着重内容，b 无强调或着重意味的粗体；em 强调内容，i 无强调或着重意味的斜体。\n\n#### 6. 简述一下你对 HTML 语义化的理解？\n\n* 为了在没有 CSS 的情况下，页面也能呈现出很好地内容结构、代码结构；\n* 增强用户体验；\n* 利于页面的 SEO；\n* 方便其他设备解析；\n* 便于团队开发和维护，语义化更具有可读性；\n\n#### 7. HTML5 离线储存的工作原理？\n\n```html\n<!-- 为 <html> 标签添加如下属性 -->\nmanifest=\"index.manifest\"\n```\n\n```html\n<!-- index.manifest -->\nCACHE MANIFEST\n#version 1.3\nCACHE:\n\t/images/logo.png\nNETWORK:\n    *\n```\n\n```javascript\n// applicationCache 对象存储着很多与 Application Cache 有关的方法和属性；\nwindow.applicationCache\n```\n\n#### 8. 如何在页面上实现一个圆形的可点击区域？\n\n\n```html\n<img alt=\"Planets\" height=\"126\" src=\"planets.gif\" usemap=\"#planetmap\" width=\"145\" /><map name=\"planetmap\">\n  <area alt=\"Sun\" coords=\"0,0,82,126\" href=\"sun.htm\" shape=\"rect\" />\n  <area alt=\"Mercury\" coords=\"90,58,3\" href=\"mercur.htm\" shape=\"circle\" />\n  <area alt=\"Venus\" coords=\"124,58,8\" href=\"venus.htm\" shape=\"circle\" /></map>\n```\n\n#### 9. 如何实现浏览器内多个标签页之间的通信？\n\n利用本地的 Cookie，SessionStorage，LocalStorage，WebSql，Application Cache，IndexedDB 等。\n\n#### 10. HTML5 的 form 表单如何关闭自动完成功能？\n\n设置属性 `autocomplete` 为 \"off\" 以关闭自动补全功能。\n\n#### 11. label 标签的 for 属性有什么作用？\n\n`for` 属性规定 label 与哪个表单元素绑定。当用户点击 label 时，焦点会自动跳转都对应的 input 输入框上。\n\n#### 12. iframe 有哪些缺点？\n\n* 不利于页面的 SEO；\n* 网页结构化差；\n* 增加 HTTP 请求；\n\n#### 13. WebSocket 如何兼容低浏览器？\n\n使用 AS3 编写的 Flash 版本；或者使用轮询来代替 WebSocket。\n\n#### 14. 浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的？\n\n访问离线资源，同时检测 manifest 文件是否更新，如果更新了则从服务器拉取新的资源并缓存在本地 Cache。\n\n#### 15. 页面可见性（Page Visibility）API 有哪些用途？\n\n```javascript\n// 监听 visibilitychange 事件；\n// document.hidden 返回当前页可见还是不可见；\n// document.visibilityState 返回页面的可见状态；\n\n// 主要应用场景为页面不可见时自动暂停网页播放的视频，当可见时继续播放；\nvar audioElement = document.getElementById(\"audio_id\");\nfunction onVisibilityChanged(event) {\n  var hidden = event.target.webkitHidden;\n  if (hidden) {\n    // 伪代码；\n    audioElement.pause();\n  } else {\n    audioElement.play();\n  } \n}\nfunction load() {\n  audioElement.play();\n  audioElement.loop = true;\n  document.addEventListener(\"webkitvisibilitychange\", onVisibilityChanged, false);\n}\n```\n\n#### 16. Cookies、Session,、SessionStorage 和 LocalStorage 的区别？\n\nCookies 可以简单的理解为客户端浏览器的一种本地存储（4K）方式，对应于每一个不同的客户端都有一个不同的 “Session ID”，这个 ID 一般会存储在本地的 Cookie 中（也可以通过 URL 携带，但不安全）。并且在每次发送请求时携带上这个 Session ID 用来在服务器端区分用户身份；SessionStorage 是一种大容量（5M）的会话级别的本地存储方式；LocalStorage 是一种持久化的本地数据存储方式。所有的存储方式都需要同源（页面属于相同域名和端口）才能共享。\n\n#### 17. HTML5 Web Workers：\n\n可以把耗时操作放在独立的 Web Worker 中运行，这样不会阻塞整个页面的脚本执行。Workers 与主线程之间可以通过 `postMessage` 方法进行双向的通信。\n\n\n```javascript\nif(typeof Worker !== undefined) {\n  var worker = new Worker(\"./worker.js\");\n}\n\nworker.addEventListener(\"message\", function(msg) {\n  // deal with message from worker thread;\n  msg = eval(\"({}&&\" + msg.data + \")\");\n  if (!msg.result) {\n    worker.terminate();\n    console.log(\"Worker thread terminated!\")\n  }\n});\n\n// worker.js\n;(function() {\n  setTimeout(function() {\n    postMessage(JSON.stringify({result:false}));\n  }, 5000);\n\n  onmessage = function(evt) {\n    var d = evt.data;\n    postMessage(d);\n  }\n})();\n```\n","source":"_posts/前端常见技术点-HTML.md","raw":"---\ntitle: 前端常见技术点 - HTML\nintro: 这里总结一下 WEB 前端面试 HTML 部分的常见问题，同时这些问题也是对一些基础的技术概念和思想的理解。对这些基本知识的掌握程度和深度决定了你的技术层级。高级工程师是必须掌握本文列出的这些知识的，资深工程师则要对这些基本概念的纵向深度进行挖掘，【问题解答全部原创，转载请注明来源】。\ncomments: true\ndate: 2016-12-13 00:16:24\ntags:\n- HTML\n---\n\n这里总结一下 WEB 前端面试 HTML 部分的常见问题，同时这些问题也是对一些基础的技术概念和思想的理解。对这些基本知识的掌握程度和深度决定了你的技术层级。高级工程师是必须掌握本文列出的这些知识的，资深工程师则要对这些基本概念的纵向深度进行挖掘，【问题解答全部原创，转载请注明来源】。\n\n### HTML 技术部分：\n\n#### 1. !DOCTYPE 的作用？严格模式与混杂模式如何区分？有何意义?\n\n根据 “<!DOCTYPE>” 是否存在选择呈现模式，被称为 **<!DOCTYPE> 切换或 <!DOCTYPE> 侦测**。\n\n一个文档类型标记的目的是要：**告诉浏览器解析器，它应该使用什么样的文档或规范（DTD）来解析文档格式**。\n\n* **严格模式：**正确的 <!DOCTYPE> 标记，浏览器将按照标准渲染页面。\n* **混杂模式：**若 <!DOCTYPE> 标记不存在或格式不正确会导致文档以混杂模式呈现，该模式下页面将会以一种比较宽松的向后兼容的方式来显示。\n\n**意义：**当浏览器厂商开始创建与标准兼容的浏览器时，他们希望能够确保向后兼容性。这里我们可以用如下所示代码来判断当前文档的解析模式：\n\n```javascript\ndocument.compatMode === \"CSS1Compat\" ? \"标准模式\" : \"混杂模式\";\n```\n\n#### 2. HTML5 为什么只需要写 <!DOCTYPE HTML>？\n\nHTML5 不基于 SGML，因此不需要 <!DOCTYPE> 对 DTD 进行引用，但是需要其来规范浏览器行为。而 HMTL4.01 是基于 SGML 的。\n\n#### 3. 行内元素有哪些？块级元素有哪些？空元素有那些？\n\n* **行内：**span、strong、em、img 等；\n* **块元素：**div、p、h1-h6 等；\n* **空元素：**hr、br 等；\n* **行内块元素：**input、textarea、keygen、select、button 等；\n\n#### 4. 常见的浏览器内核\n\n* **Trident内核：**IE；\n* **Gecko内核：**Mozilla Firefox；\n* **WebKit内核：**Safari、Chrome、Edge；\n\n#### 5. title 与 h1 的区别、b 与 strong 的区别、i 与 em 的区别？\n\ntitle 在 SEO 的权重中比 h1 要高，strong 着重内容，b 无强调或着重意味的粗体；em 强调内容，i 无强调或着重意味的斜体。\n\n#### 6. 简述一下你对 HTML 语义化的理解？\n\n* 为了在没有 CSS 的情况下，页面也能呈现出很好地内容结构、代码结构；\n* 增强用户体验；\n* 利于页面的 SEO；\n* 方便其他设备解析；\n* 便于团队开发和维护，语义化更具有可读性；\n\n#### 7. HTML5 离线储存的工作原理？\n\n```html\n<!-- 为 <html> 标签添加如下属性 -->\nmanifest=\"index.manifest\"\n```\n\n```html\n<!-- index.manifest -->\nCACHE MANIFEST\n#version 1.3\nCACHE:\n\t/images/logo.png\nNETWORK:\n    *\n```\n\n```javascript\n// applicationCache 对象存储着很多与 Application Cache 有关的方法和属性；\nwindow.applicationCache\n```\n\n#### 8. 如何在页面上实现一个圆形的可点击区域？\n\n\n```html\n<img alt=\"Planets\" height=\"126\" src=\"planets.gif\" usemap=\"#planetmap\" width=\"145\" /><map name=\"planetmap\">\n  <area alt=\"Sun\" coords=\"0,0,82,126\" href=\"sun.htm\" shape=\"rect\" />\n  <area alt=\"Mercury\" coords=\"90,58,3\" href=\"mercur.htm\" shape=\"circle\" />\n  <area alt=\"Venus\" coords=\"124,58,8\" href=\"venus.htm\" shape=\"circle\" /></map>\n```\n\n#### 9. 如何实现浏览器内多个标签页之间的通信？\n\n利用本地的 Cookie，SessionStorage，LocalStorage，WebSql，Application Cache，IndexedDB 等。\n\n#### 10. HTML5 的 form 表单如何关闭自动完成功能？\n\n设置属性 `autocomplete` 为 \"off\" 以关闭自动补全功能。\n\n#### 11. label 标签的 for 属性有什么作用？\n\n`for` 属性规定 label 与哪个表单元素绑定。当用户点击 label 时，焦点会自动跳转都对应的 input 输入框上。\n\n#### 12. iframe 有哪些缺点？\n\n* 不利于页面的 SEO；\n* 网页结构化差；\n* 增加 HTTP 请求；\n\n#### 13. WebSocket 如何兼容低浏览器？\n\n使用 AS3 编写的 Flash 版本；或者使用轮询来代替 WebSocket。\n\n#### 14. 浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的？\n\n访问离线资源，同时检测 manifest 文件是否更新，如果更新了则从服务器拉取新的资源并缓存在本地 Cache。\n\n#### 15. 页面可见性（Page Visibility）API 有哪些用途？\n\n```javascript\n// 监听 visibilitychange 事件；\n// document.hidden 返回当前页可见还是不可见；\n// document.visibilityState 返回页面的可见状态；\n\n// 主要应用场景为页面不可见时自动暂停网页播放的视频，当可见时继续播放；\nvar audioElement = document.getElementById(\"audio_id\");\nfunction onVisibilityChanged(event) {\n  var hidden = event.target.webkitHidden;\n  if (hidden) {\n    // 伪代码；\n    audioElement.pause();\n  } else {\n    audioElement.play();\n  } \n}\nfunction load() {\n  audioElement.play();\n  audioElement.loop = true;\n  document.addEventListener(\"webkitvisibilitychange\", onVisibilityChanged, false);\n}\n```\n\n#### 16. Cookies、Session,、SessionStorage 和 LocalStorage 的区别？\n\nCookies 可以简单的理解为客户端浏览器的一种本地存储（4K）方式，对应于每一个不同的客户端都有一个不同的 “Session ID”，这个 ID 一般会存储在本地的 Cookie 中（也可以通过 URL 携带，但不安全）。并且在每次发送请求时携带上这个 Session ID 用来在服务器端区分用户身份；SessionStorage 是一种大容量（5M）的会话级别的本地存储方式；LocalStorage 是一种持久化的本地数据存储方式。所有的存储方式都需要同源（页面属于相同域名和端口）才能共享。\n\n#### 17. HTML5 Web Workers：\n\n可以把耗时操作放在独立的 Web Worker 中运行，这样不会阻塞整个页面的脚本执行。Workers 与主线程之间可以通过 `postMessage` 方法进行双向的通信。\n\n\n```javascript\nif(typeof Worker !== undefined) {\n  var worker = new Worker(\"./worker.js\");\n}\n\nworker.addEventListener(\"message\", function(msg) {\n  // deal with message from worker thread;\n  msg = eval(\"({}&&\" + msg.data + \")\");\n  if (!msg.result) {\n    worker.terminate();\n    console.log(\"Worker thread terminated!\")\n  }\n});\n\n// worker.js\n;(function() {\n  setTimeout(function() {\n    postMessage(JSON.stringify({result:false}));\n  }, 5000);\n\n  onmessage = function(evt) {\n    var d = evt.data;\n    postMessage(d);\n  }\n})();\n```\n","slug":"前端常见技术点-HTML","published":1,"updated":"2019-02-11T07:25:17.203Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtau005yknp2fwiagcbk","content":"<p>这里总结一下 WEB 前端面试 HTML 部分的常见问题，同时这些问题也是对一些基础的技术概念和思想的理解。对这些基本知识的掌握程度和深度决定了你的技术层级。高级工程师是必须掌握本文列出的这些知识的，资深工程师则要对这些基本概念的纵向深度进行挖掘，【问题解答全部原创，转载请注明来源】。</p>\n<h3 id=\"HTML-技术部分：\"><a href=\"#HTML-技术部分：\" class=\"headerlink\" title=\"HTML 技术部分：\"></a>HTML 技术部分：</h3><h4 id=\"1-DOCTYPE-的作用？严格模式与混杂模式如何区分？有何意义\"><a href=\"#1-DOCTYPE-的作用？严格模式与混杂模式如何区分？有何意义\" class=\"headerlink\" title=\"1. !DOCTYPE 的作用？严格模式与混杂模式如何区分？有何意义?\"></a>1. !DOCTYPE 的作用？严格模式与混杂模式如何区分？有何意义?</h4><p>根据 “&lt;!DOCTYPE&gt;” 是否存在选择呈现模式，被称为 <strong>&lt;!DOCTYPE&gt; 切换或 &lt;!DOCTYPE&gt; 侦测</strong>。</p>\n<p>一个文档类型标记的目的是要：<strong>告诉浏览器解析器，它应该使用什么样的文档或规范（DTD）来解析文档格式</strong>。</p>\n<ul>\n<li><strong>严格模式：</strong>正确的 &lt;!DOCTYPE&gt; 标记，浏览器将按照标准渲染页面。</li>\n<li><strong>混杂模式：</strong>若 &lt;!DOCTYPE&gt; 标记不存在或格式不正确会导致文档以混杂模式呈现，该模式下页面将会以一种比较宽松的向后兼容的方式来显示。</li>\n</ul>\n<p><strong>意义：</strong>当浏览器厂商开始创建与标准兼容的浏览器时，他们希望能够确保向后兼容性。这里我们可以用如下所示代码来判断当前文档的解析模式：</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\">document<span class=\"token punctuation\">.</span>compatMode <span class=\"token operator\">===</span> <span class=\"token string\">\"CSS1Compat\"</span> <span class=\"token operator\">?</span> <span class=\"token string\">\"标准模式\"</span> <span class=\"token punctuation\">:</span> <span class=\"token string\">\"混杂模式\"</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h4 id=\"2-HTML5-为什么只需要写-lt-DOCTYPE-HTML-gt-？\"><a href=\"#2-HTML5-为什么只需要写-lt-DOCTYPE-HTML-gt-？\" class=\"headerlink\" title=\"2. HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？\"></a>2. HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？</h4><p>HTML5 不基于 SGML，因此不需要 &lt;!DOCTYPE&gt; 对 DTD 进行引用，但是需要其来规范浏览器行为。而 HMTL4.01 是基于 SGML 的。</p>\n<h4 id=\"3-行内元素有哪些？块级元素有哪些？空元素有那些？\"><a href=\"#3-行内元素有哪些？块级元素有哪些？空元素有那些？\" class=\"headerlink\" title=\"3. 行内元素有哪些？块级元素有哪些？空元素有那些？\"></a>3. 行内元素有哪些？块级元素有哪些？空元素有那些？</h4><ul>\n<li><strong>行内：</strong>span、strong、em、img 等；</li>\n<li><strong>块元素：</strong>div、p、h1-h6 等；</li>\n<li><strong>空元素：</strong>hr、br 等；</li>\n<li><strong>行内块元素：</strong>input、textarea、keygen、select、button 等；</li>\n</ul>\n<h4 id=\"4-常见的浏览器内核\"><a href=\"#4-常见的浏览器内核\" class=\"headerlink\" title=\"4. 常见的浏览器内核\"></a>4. 常见的浏览器内核</h4><ul>\n<li><strong>Trident内核：</strong>IE；</li>\n<li><strong>Gecko内核：</strong>Mozilla Firefox；</li>\n<li><strong>WebKit内核：</strong>Safari、Chrome、Edge；</li>\n</ul>\n<h4 id=\"5-title-与-h1-的区别、b-与-strong-的区别、i-与-em-的区别？\"><a href=\"#5-title-与-h1-的区别、b-与-strong-的区别、i-与-em-的区别？\" class=\"headerlink\" title=\"5. title 与 h1 的区别、b 与 strong 的区别、i 与 em 的区别？\"></a>5. title 与 h1 的区别、b 与 strong 的区别、i 与 em 的区别？</h4><p>title 在 SEO 的权重中比 h1 要高，strong 着重内容，b 无强调或着重意味的粗体；em 强调内容，i 无强调或着重意味的斜体。</p>\n<h4 id=\"6-简述一下你对-HTML-语义化的理解？\"><a href=\"#6-简述一下你对-HTML-语义化的理解？\" class=\"headerlink\" title=\"6. 简述一下你对 HTML 语义化的理解？\"></a>6. 简述一下你对 HTML 语义化的理解？</h4><ul>\n<li>为了在没有 CSS 的情况下，页面也能呈现出很好地内容结构、代码结构；</li>\n<li>增强用户体验；</li>\n<li>利于页面的 SEO；</li>\n<li>方便其他设备解析；</li>\n<li>便于团队开发和维护，语义化更具有可读性；</li>\n</ul>\n<h4 id=\"7-HTML5-离线储存的工作原理？\"><a href=\"#7-HTML5-离线储存的工作原理？\" class=\"headerlink\" title=\"7. HTML5 离线储存的工作原理？\"></a>7. HTML5 离线储存的工作原理？</h4><pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token comment\" spellcheck=\"true\">&lt;!-- 为 &lt;html> 标签添加如下属性 --></span>\nmanifest=\"index.manifest\"\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token comment\" spellcheck=\"true\">&lt;!-- index.manifest --></span>\nCACHE MANIFEST\n#version 1.3\nCACHE:\n    /images/logo.png\nNETWORK:\n    *\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">// applicationCache 对象存储着很多与 Application Cache 有关的方法和属性；</span>\nwindow<span class=\"token punctuation\">.</span>applicationCache\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h4 id=\"8-如何在页面上实现一个圆形的可点击区域？\"><a href=\"#8-如何在页面上实现一个圆形的可点击区域？\" class=\"headerlink\" title=\"8. 如何在页面上实现一个圆形的可点击区域？\"></a>8. 如何在页面上实现一个圆形的可点击区域？</h4><pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>img</span> <span class=\"token attr-name\">alt</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>Planets<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">height</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>126<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>planets.gif<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">usemap</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>#planetmap<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">width</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>145<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>map</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>planetmap<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>area</span> <span class=\"token attr-name\">alt</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>Sun<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">coords</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>0,0,82,126<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">href</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>sun.htm<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">shape</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>rect<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>area</span> <span class=\"token attr-name\">alt</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>Mercury<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">coords</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>90,58,3<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">href</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>mercur.htm<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">shape</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>circle<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>area</span> <span class=\"token attr-name\">alt</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>Venus<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">coords</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>124,58,8<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">href</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>venus.htm<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">shape</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>circle<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>map</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"9-如何实现浏览器内多个标签页之间的通信？\"><a href=\"#9-如何实现浏览器内多个标签页之间的通信？\" class=\"headerlink\" title=\"9. 如何实现浏览器内多个标签页之间的通信？\"></a>9. 如何实现浏览器内多个标签页之间的通信？</h4><p>利用本地的 Cookie，SessionStorage，LocalStorage，WebSql，Application Cache，IndexedDB 等。</p>\n<h4 id=\"10-HTML5-的-form-表单如何关闭自动完成功能？\"><a href=\"#10-HTML5-的-form-表单如何关闭自动完成功能？\" class=\"headerlink\" title=\"10. HTML5 的 form 表单如何关闭自动完成功能？\"></a>10. HTML5 的 form 表单如何关闭自动完成功能？</h4><p>设置属性 <code>autocomplete</code> 为 “off” 以关闭自动补全功能。</p>\n<h4 id=\"11-label-标签的-for-属性有什么作用？\"><a href=\"#11-label-标签的-for-属性有什么作用？\" class=\"headerlink\" title=\"11. label 标签的 for 属性有什么作用？\"></a>11. label 标签的 for 属性有什么作用？</h4><p><code>for</code> 属性规定 label 与哪个表单元素绑定。当用户点击 label 时，焦点会自动跳转都对应的 input 输入框上。</p>\n<h4 id=\"12-iframe-有哪些缺点？\"><a href=\"#12-iframe-有哪些缺点？\" class=\"headerlink\" title=\"12. iframe 有哪些缺点？\"></a>12. iframe 有哪些缺点？</h4><ul>\n<li>不利于页面的 SEO；</li>\n<li>网页结构化差；</li>\n<li>增加 HTTP 请求；</li>\n</ul>\n<h4 id=\"13-WebSocket-如何兼容低浏览器？\"><a href=\"#13-WebSocket-如何兼容低浏览器？\" class=\"headerlink\" title=\"13. WebSocket 如何兼容低浏览器？\"></a>13. WebSocket 如何兼容低浏览器？</h4><p>使用 AS3 编写的 Flash 版本；或者使用轮询来代替 WebSocket。</p>\n<h4 id=\"14-浏览器是怎么对-HTML5-的离线储存资源进行管理和加载的？\"><a href=\"#14-浏览器是怎么对-HTML5-的离线储存资源进行管理和加载的？\" class=\"headerlink\" title=\"14. 浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的？\"></a>14. 浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的？</h4><p>访问离线资源，同时检测 manifest 文件是否更新，如果更新了则从服务器拉取新的资源并缓存在本地 Cache。</p>\n<h4 id=\"15-页面可见性（Page-Visibility）API-有哪些用途？\"><a href=\"#15-页面可见性（Page-Visibility）API-有哪些用途？\" class=\"headerlink\" title=\"15. 页面可见性（Page Visibility）API 有哪些用途？\"></a>15. 页面可见性（Page Visibility）API 有哪些用途？</h4><pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">// 监听 visibilitychange 事件；</span>\n<span class=\"token comment\" spellcheck=\"true\">// document.hidden 返回当前页可见还是不可见；</span>\n<span class=\"token comment\" spellcheck=\"true\">// document.visibilityState 返回页面的可见状态；</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 主要应用场景为页面不可见时自动暂停网页播放的视频，当可见时继续播放；</span>\n<span class=\"token keyword\">var</span> audioElement <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"audio_id\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">onVisibilityChanged</span><span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> hidden <span class=\"token operator\">=</span> event<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">.</span>webkitHidden<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>hidden<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 伪代码；</span>\n    audioElement<span class=\"token punctuation\">.</span><span class=\"token function\">pause</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    audioElement<span class=\"token punctuation\">.</span><span class=\"token function\">play</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> \n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">load</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  audioElement<span class=\"token punctuation\">.</span><span class=\"token function\">play</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  audioElement<span class=\"token punctuation\">.</span>loop <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  document<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"webkitvisibilitychange\"</span><span class=\"token punctuation\">,</span> onVisibilityChanged<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"16-Cookies、Session-、SessionStorage-和-LocalStorage-的区别？\"><a href=\"#16-Cookies、Session-、SessionStorage-和-LocalStorage-的区别？\" class=\"headerlink\" title=\"16. Cookies、Session,、SessionStorage 和 LocalStorage 的区别？\"></a>16. Cookies、Session,、SessionStorage 和 LocalStorage 的区别？</h4><p>Cookies 可以简单的理解为客户端浏览器的一种本地存储（4K）方式，对应于每一个不同的客户端都有一个不同的 “Session ID”，这个 ID 一般会存储在本地的 Cookie 中（也可以通过 URL 携带，但不安全）。并且在每次发送请求时携带上这个 Session ID 用来在服务器端区分用户身份；SessionStorage 是一种大容量（5M）的会话级别的本地存储方式；LocalStorage 是一种持久化的本地数据存储方式。所有的存储方式都需要同源（页面属于相同域名和端口）才能共享。</p>\n<h4 id=\"17-HTML5-Web-Workers：\"><a href=\"#17-HTML5-Web-Workers：\" class=\"headerlink\" title=\"17. HTML5 Web Workers：\"></a>17. HTML5 Web Workers：</h4><p>可以把耗时操作放在独立的 Web Worker 中运行，这样不会阻塞整个页面的脚本执行。Workers 与主线程之间可以通过 <code>postMessage</code> 方法进行双向的通信。</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> Worker <span class=\"token operator\">!==</span> undefined<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> worker <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Worker</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"./worker.js\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nworker<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"message\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// deal with message from worker thread;</span>\n  msg <span class=\"token operator\">=</span> <span class=\"token function\">eval</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"({}&amp;&amp;\"</span> <span class=\"token operator\">+</span> msg<span class=\"token punctuation\">.</span>data <span class=\"token operator\">+</span> <span class=\"token string\">\")\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>msg<span class=\"token punctuation\">.</span>result<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    worker<span class=\"token punctuation\">.</span><span class=\"token function\">terminate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Worker thread terminated!\"</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// worker.js</span>\n<span class=\"token punctuation\">;</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">postMessage</span><span class=\"token punctuation\">(</span>JSON<span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>result<span class=\"token punctuation\">:</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  onmessage <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>evt<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> d <span class=\"token operator\">=</span> evt<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">postMessage</span><span class=\"token punctuation\">(</span>d<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"id":"264cd48d11cbcf6266e15a472aaaf99a","excerpt":"","more":"<p>这里总结一下 WEB 前端面试 HTML 部分的常见问题，同时这些问题也是对一些基础的技术概念和思想的理解。对这些基本知识的掌握程度和深度决定了你的技术层级。高级工程师是必须掌握本文列出的这些知识的，资深工程师则要对这些基本概念的纵向深度进行挖掘，【问题解答全部原创，转载请注明来源】。</p>\n<h3 id=\"HTML-技术部分：\"><a href=\"#HTML-技术部分：\" class=\"headerlink\" title=\"HTML 技术部分：\"></a>HTML 技术部分：</h3><h4 id=\"1-DOCTYPE-的作用？严格模式与混杂模式如何区分？有何意义\"><a href=\"#1-DOCTYPE-的作用？严格模式与混杂模式如何区分？有何意义\" class=\"headerlink\" title=\"1. !DOCTYPE 的作用？严格模式与混杂模式如何区分？有何意义?\"></a>1. !DOCTYPE 的作用？严格模式与混杂模式如何区分？有何意义?</h4><p>根据 “&lt;!DOCTYPE&gt;” 是否存在选择呈现模式，被称为 <strong>&lt;!DOCTYPE&gt; 切换或 &lt;!DOCTYPE&gt; 侦测</strong>。</p>\n<p>一个文档类型标记的目的是要：<strong>告诉浏览器解析器，它应该使用什么样的文档或规范（DTD）来解析文档格式</strong>。</p>\n<ul>\n<li><strong>严格模式：</strong>正确的 &lt;!DOCTYPE&gt; 标记，浏览器将按照标准渲染页面。</li>\n<li><strong>混杂模式：</strong>若 &lt;!DOCTYPE&gt; 标记不存在或格式不正确会导致文档以混杂模式呈现，该模式下页面将会以一种比较宽松的向后兼容的方式来显示。</li>\n</ul>\n<p><strong>意义：</strong>当浏览器厂商开始创建与标准兼容的浏览器时，他们希望能够确保向后兼容性。这里我们可以用如下所示代码来判断当前文档的解析模式：</p>\n<pre><code class=\"javascript\">document.compatMode === &quot;CSS1Compat&quot; ? &quot;标准模式&quot; : &quot;混杂模式&quot;;\n</code></pre>\n<h4 id=\"2-HTML5-为什么只需要写-lt-DOCTYPE-HTML-gt-？\"><a href=\"#2-HTML5-为什么只需要写-lt-DOCTYPE-HTML-gt-？\" class=\"headerlink\" title=\"2. HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？\"></a>2. HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？</h4><p>HTML5 不基于 SGML，因此不需要 &lt;!DOCTYPE&gt; 对 DTD 进行引用，但是需要其来规范浏览器行为。而 HMTL4.01 是基于 SGML 的。</p>\n<h4 id=\"3-行内元素有哪些？块级元素有哪些？空元素有那些？\"><a href=\"#3-行内元素有哪些？块级元素有哪些？空元素有那些？\" class=\"headerlink\" title=\"3. 行内元素有哪些？块级元素有哪些？空元素有那些？\"></a>3. 行内元素有哪些？块级元素有哪些？空元素有那些？</h4><ul>\n<li><strong>行内：</strong>span、strong、em、img 等；</li>\n<li><strong>块元素：</strong>div、p、h1-h6 等；</li>\n<li><strong>空元素：</strong>hr、br 等；</li>\n<li><strong>行内块元素：</strong>input、textarea、keygen、select、button 等；</li>\n</ul>\n<h4 id=\"4-常见的浏览器内核\"><a href=\"#4-常见的浏览器内核\" class=\"headerlink\" title=\"4. 常见的浏览器内核\"></a>4. 常见的浏览器内核</h4><ul>\n<li><strong>Trident内核：</strong>IE；</li>\n<li><strong>Gecko内核：</strong>Mozilla Firefox；</li>\n<li><strong>WebKit内核：</strong>Safari、Chrome、Edge；</li>\n</ul>\n<h4 id=\"5-title-与-h1-的区别、b-与-strong-的区别、i-与-em-的区别？\"><a href=\"#5-title-与-h1-的区别、b-与-strong-的区别、i-与-em-的区别？\" class=\"headerlink\" title=\"5. title 与 h1 的区别、b 与 strong 的区别、i 与 em 的区别？\"></a>5. title 与 h1 的区别、b 与 strong 的区别、i 与 em 的区别？</h4><p>title 在 SEO 的权重中比 h1 要高，strong 着重内容，b 无强调或着重意味的粗体；em 强调内容，i 无强调或着重意味的斜体。</p>\n<h4 id=\"6-简述一下你对-HTML-语义化的理解？\"><a href=\"#6-简述一下你对-HTML-语义化的理解？\" class=\"headerlink\" title=\"6. 简述一下你对 HTML 语义化的理解？\"></a>6. 简述一下你对 HTML 语义化的理解？</h4><ul>\n<li>为了在没有 CSS 的情况下，页面也能呈现出很好地内容结构、代码结构；</li>\n<li>增强用户体验；</li>\n<li>利于页面的 SEO；</li>\n<li>方便其他设备解析；</li>\n<li>便于团队开发和维护，语义化更具有可读性；</li>\n</ul>\n<h4 id=\"7-HTML5-离线储存的工作原理？\"><a href=\"#7-HTML5-离线储存的工作原理？\" class=\"headerlink\" title=\"7. HTML5 离线储存的工作原理？\"></a>7. HTML5 离线储存的工作原理？</h4><pre><code class=\"html\">&lt;!-- 为 &lt;html&gt; 标签添加如下属性 --&gt;\nmanifest=&quot;index.manifest&quot;\n</code></pre>\n<pre><code class=\"html\">&lt;!-- index.manifest --&gt;\nCACHE MANIFEST\n#version 1.3\nCACHE:\n    /images/logo.png\nNETWORK:\n    *\n</code></pre>\n<pre><code class=\"javascript\">// applicationCache 对象存储着很多与 Application Cache 有关的方法和属性；\nwindow.applicationCache\n</code></pre>\n<h4 id=\"8-如何在页面上实现一个圆形的可点击区域？\"><a href=\"#8-如何在页面上实现一个圆形的可点击区域？\" class=\"headerlink\" title=\"8. 如何在页面上实现一个圆形的可点击区域？\"></a>8. 如何在页面上实现一个圆形的可点击区域？</h4><pre><code class=\"html\">&lt;img alt=&quot;Planets&quot; height=&quot;126&quot; src=&quot;planets.gif&quot; usemap=&quot;#planetmap&quot; width=&quot;145&quot; /&gt;&lt;map name=&quot;planetmap&quot;&gt;\n  &lt;area alt=&quot;Sun&quot; coords=&quot;0,0,82,126&quot; href=&quot;sun.htm&quot; shape=&quot;rect&quot; /&gt;\n  &lt;area alt=&quot;Mercury&quot; coords=&quot;90,58,3&quot; href=&quot;mercur.htm&quot; shape=&quot;circle&quot; /&gt;\n  &lt;area alt=&quot;Venus&quot; coords=&quot;124,58,8&quot; href=&quot;venus.htm&quot; shape=&quot;circle&quot; /&gt;&lt;/map&gt;\n</code></pre>\n<h4 id=\"9-如何实现浏览器内多个标签页之间的通信？\"><a href=\"#9-如何实现浏览器内多个标签页之间的通信？\" class=\"headerlink\" title=\"9. 如何实现浏览器内多个标签页之间的通信？\"></a>9. 如何实现浏览器内多个标签页之间的通信？</h4><p>利用本地的 Cookie，SessionStorage，LocalStorage，WebSql，Application Cache，IndexedDB 等。</p>\n<h4 id=\"10-HTML5-的-form-表单如何关闭自动完成功能？\"><a href=\"#10-HTML5-的-form-表单如何关闭自动完成功能？\" class=\"headerlink\" title=\"10. HTML5 的 form 表单如何关闭自动完成功能？\"></a>10. HTML5 的 form 表单如何关闭自动完成功能？</h4><p>设置属性 <code>autocomplete</code> 为 “off” 以关闭自动补全功能。</p>\n<h4 id=\"11-label-标签的-for-属性有什么作用？\"><a href=\"#11-label-标签的-for-属性有什么作用？\" class=\"headerlink\" title=\"11. label 标签的 for 属性有什么作用？\"></a>11. label 标签的 for 属性有什么作用？</h4><p><code>for</code> 属性规定 label 与哪个表单元素绑定。当用户点击 label 时，焦点会自动跳转都对应的 input 输入框上。</p>\n<h4 id=\"12-iframe-有哪些缺点？\"><a href=\"#12-iframe-有哪些缺点？\" class=\"headerlink\" title=\"12. iframe 有哪些缺点？\"></a>12. iframe 有哪些缺点？</h4><ul>\n<li>不利于页面的 SEO；</li>\n<li>网页结构化差；</li>\n<li>增加 HTTP 请求；</li>\n</ul>\n<h4 id=\"13-WebSocket-如何兼容低浏览器？\"><a href=\"#13-WebSocket-如何兼容低浏览器？\" class=\"headerlink\" title=\"13. WebSocket 如何兼容低浏览器？\"></a>13. WebSocket 如何兼容低浏览器？</h4><p>使用 AS3 编写的 Flash 版本；或者使用轮询来代替 WebSocket。</p>\n<h4 id=\"14-浏览器是怎么对-HTML5-的离线储存资源进行管理和加载的？\"><a href=\"#14-浏览器是怎么对-HTML5-的离线储存资源进行管理和加载的？\" class=\"headerlink\" title=\"14. 浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的？\"></a>14. 浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的？</h4><p>访问离线资源，同时检测 manifest 文件是否更新，如果更新了则从服务器拉取新的资源并缓存在本地 Cache。</p>\n<h4 id=\"15-页面可见性（Page-Visibility）API-有哪些用途？\"><a href=\"#15-页面可见性（Page-Visibility）API-有哪些用途？\" class=\"headerlink\" title=\"15. 页面可见性（Page Visibility）API 有哪些用途？\"></a>15. 页面可见性（Page Visibility）API 有哪些用途？</h4><pre><code class=\"javascript\">// 监听 visibilitychange 事件；\n// document.hidden 返回当前页可见还是不可见；\n// document.visibilityState 返回页面的可见状态；\n\n// 主要应用场景为页面不可见时自动暂停网页播放的视频，当可见时继续播放；\nvar audioElement = document.getElementById(&quot;audio_id&quot;);\nfunction onVisibilityChanged(event) {\n  var hidden = event.target.webkitHidden;\n  if (hidden) {\n    // 伪代码；\n    audioElement.pause();\n  } else {\n    audioElement.play();\n  } \n}\nfunction load() {\n  audioElement.play();\n  audioElement.loop = true;\n  document.addEventListener(&quot;webkitvisibilitychange&quot;, onVisibilityChanged, false);\n}\n</code></pre>\n<h4 id=\"16-Cookies、Session-、SessionStorage-和-LocalStorage-的区别？\"><a href=\"#16-Cookies、Session-、SessionStorage-和-LocalStorage-的区别？\" class=\"headerlink\" title=\"16. Cookies、Session,、SessionStorage 和 LocalStorage 的区别？\"></a>16. Cookies、Session,、SessionStorage 和 LocalStorage 的区别？</h4><p>Cookies 可以简单的理解为客户端浏览器的一种本地存储（4K）方式，对应于每一个不同的客户端都有一个不同的 “Session ID”，这个 ID 一般会存储在本地的 Cookie 中（也可以通过 URL 携带，但不安全）。并且在每次发送请求时携带上这个 Session ID 用来在服务器端区分用户身份；SessionStorage 是一种大容量（5M）的会话级别的本地存储方式；LocalStorage 是一种持久化的本地数据存储方式。所有的存储方式都需要同源（页面属于相同域名和端口）才能共享。</p>\n<h4 id=\"17-HTML5-Web-Workers：\"><a href=\"#17-HTML5-Web-Workers：\" class=\"headerlink\" title=\"17. HTML5 Web Workers：\"></a>17. HTML5 Web Workers：</h4><p>可以把耗时操作放在独立的 Web Worker 中运行，这样不会阻塞整个页面的脚本执行。Workers 与主线程之间可以通过 <code>postMessage</code> 方法进行双向的通信。</p>\n<pre><code class=\"javascript\">if(typeof Worker !== undefined) {\n  var worker = new Worker(&quot;./worker.js&quot;);\n}\n\nworker.addEventListener(&quot;message&quot;, function(msg) {\n  // deal with message from worker thread;\n  msg = eval(&quot;({}&amp;&amp;&quot; + msg.data + &quot;)&quot;);\n  if (!msg.result) {\n    worker.terminate();\n    console.log(&quot;Worker thread terminated!&quot;)\n  }\n});\n\n// worker.js\n;(function() {\n  setTimeout(function() {\n    postMessage(JSON.stringify({result:false}));\n  }, 5000);\n\n  onmessage = function(evt) {\n    var d = evt.data;\n    postMessage(d);\n  }\n})();\n</code></pre>\n"},{"title":"前端常见技术点 - JavaScript","intro":"这里总结一下 Web 前端面试 JavaScript 部分的常见面试问题，同时这些问题也是对一些基础的技术概念和思想的理解。对这些基本知识的掌握程度和深度决定了你的技术层级。高级工程师是必须掌握本文列出的这些知识的，资深工程师则要对这些基本概念的纵向深度进行挖掘，【问题解答全部原创，转载请注明来源】。","comments":1,"date":"2016-12-12T16:16:23.000Z","_content":"\n这里总结一下 Web 前端面试 JavaScript 部分的常见面试问题，同时这些问题也是对一些基础的技术概念和思想的理解。对这些基本知识的掌握程度和深度决定了你的技术层级。高级工程师是必须掌握本文列出的这些知识的，资深工程师则要对这些基本概念的纵向深度进行挖掘，【问题解答全部原创，转载请注明来源】。\n\n### JavaScript 技术部分：\n\n#### 1. JS 有几种类型的值？\n\n“堆”保存原始数据类型，“栈”保存引用数据类型。Stack 为自动分配的内存空间，它由系统自动释放；而 Heap 则是动态分配的内存，大小不定也不会自动释放。\n\n* **基本类型：**存放在栈内存中的简单数据段，数据大小确定，内存空间大小可以分配。\n* **引用类型：**存放在堆内存中的对象，变量实际保存的是一个指针，这个指针指向另一个位置。每个空间大小不一样，要根据情况开进行特定的分配。\n\n5种基本数据类型有 `undefined`、`null`、`boolean`、`number` 和 `string`，它们是直接按值存放的，所以可以直接访问。\n\n当我们需要访问引用类型（对象、数组、函数）的值时，首先需要从**栈中获得该对象的地址指针，然后再从堆内存中取得所需的数据**。\n\n#### 2. JS 如何实现继承？\n\n构造函数使用 call、apply 继承 prototype 原型模式。\n\n```javascript\nCat.prototype = new Animal();\nCat.prototype.constructor = Cat;\nvar cat1 = new Cat(\"大毛\", \"黄色\");\nalert(cat1.species); // 动物；\n```\n\n#### 3. Object.create 的核心原理？\n\n创建一个指定原型链的对象。\n\n```javascript\n// polyfill；\nfunction object(o) {\n  function F() {}\n  F.prototype = o;\n  return new F();\n}\n```\n\n#### 4. call、apply 和 ES5 中的 bind 的本质以及常用场景？\n\n`call`、`apply` 和 `bind` 的目的是为了动态改变 this，也就是改变函数的运行时上下文；\n\n**将伪数组改变为数组：**\n\n```javascript\nArray.prototype.slice.apply(document.getElementsByClassName(\"content\"), [1,2]);\nArray.prototype.slice.apply(arguments);\n```\n\n**bind 方法的 polyfill：**\n\n```javascript\nif (!(function() {}.bind)) {\n  Function.prototype.bind = function(context) {\n    var self = this, args = Array.prototype.slice.call(arguments);\n        \n    return function() {\n      // bind 第一个参数是 context，后面为参数；\n      return self.apply(context, args.slice(1));    \n    }\n  };\n}\n```\n\n#### 5. [\"1\", \"2\", \"3\"].map(parseInt) 语句的结果是什么？\n\n“[1, NaN, NaN]”；因为 `map` 函数的 callback 函数最多能够接受三个参数，第一个是当前数组元素，第二个是当前数组元素的索引，第三个为整个数组；而 parseInt 则可以接受两个参数，所以 [parseInt(1, 0), parseInt(2, 1), parseInt(3, 2)] 就变成了 [1 ,NaN, NaN]。\n\n#### 6. JS 中有一个函数，执行对象查找时永远不会去查找原型，该函数是？\n\n“hasOwnProperty”。\n\n#### 7. JS 如何在低版本浏览器解析 JSON 格式，并防止 JSON 劫持？\n\n在服务器返回的 JSON 字符串前加入 “{}&&” 可以防止 JSON 劫持。\n\n```javascript\neval(\"({}&&\" + '{\"result\":true,\"data\":[{\"id\":\"201\"},{\"id\":\"188\"},{\"id\":\"126\"}]}' + \")\");\n```\n\n\n#### 8. 页面编码和被请求的资源编码如果不一致如何处理？\n\n为外部引入的 JS 文件加入 `charset` 属性。\n\n```html\n<script type=\"text/javascript\" src=\"myscripts.js\" charset=\"UTF-8\"> \n```\n\n#### 9. JS 异步延迟加载的方式有哪些？\n\n```javascript\n// 放置在标签前(接近 HTML 文件底部)；\nfunction downloadJSAtOnload() {\n  var e = document.createElement(\"script\");\n  e.src = \"defer.js\";\n  document.body.appendChild(e);\n}\nif (window.addEventListener)\n  window.addEventListener(\"load\", downloadJSAtOnload, false);\nelse if (window.attachEvent)\n  window.attachEvent(\"onload\", downloadJSAtOnload);\nelse \n  window.onload = downloadJSAtOnload;\n```\n\n#### 10. new 操作符具体干了什么？\n\n```javascript\nvar person = {};\nperson.__proto__ = Person.prototype;\nPerson.call(person);\n```\n\n#### 11. window.event.srcElement 与 window.event.target 的区别？\n\nIE 浏览器支持 `window.event.srcElement`，而 Firefox 则支持 `window.event.target`。\n\n#### 12. 数组和对象有哪些原生方法，列举一下？\n\n* Array.prototype.slice；\n* Array.prototype.sort；\n* Object.prototype.toString；\n* Object.prototype.hasOwnProperty；\n\n#### 13. documen.write 和 innerHTML 的区别？\n\n`document.write` 直接把内容写入文档流，会清空当前文档的所有内容；而 `innerHTML` 只会更新所属元素。\n\n#### 14. 跨域问题：\n\n**JSONP：**\n\n利用 `<script \\>` 标签的 url 参数指定需要返回处理的 callback，服务器直接以调用 callback 函数的方式，将需要的 JSON 数据直接作为函数参数，动态生成所需的 JS 文件并在客户端加载；\n\n**CORS 跨域资源共享：**\n\n* **简单请求：**浏览器附带 Origin 字段，服务器检查请求，成功则返回 Access-Control-Allow-Origin 字段；\n* **非简单请求：**初次请求进行预检，浏览器发送 OPTIONS 请求，Access-Control-Max-Age 字段决定此次预检的有效期；\n* 如果需要发送 cookie，则 Access-Control-Allow-Origin 字段便不能设为星号，必须指定明确的、与请求网页源一致的域名；\n\n**HTML5 postMessage：**\n\n适用于多窗口间的消息传递，如：页面与内部 iframe 之间的消息传递。\n\n* **其他页面发送：**`window.postMessage(message, targetOrigin);` （这里的 window 为对目标窗口的引用）。\n* **当前页面监听：**`window.addEventListener(\"message\", function(event) { ... }, false);`\n\n#### 15. 如何判断当前脚本运行在浏览器还是 Node.js 环境中？\n\n判断当前环境是否有 `global` 对象（不绝对，可以伪造）；\n\n#### 16. Object.prototype.valueOf 和 Object.prototype.toString 的区别？\n\n* **valueOf：**返回最适合该对象类型的原始值；\n* **toString：**将该对象的原始值以字符串形式返回；\n\n在数值运算里，会优先调用 `valueOf`；在字符串运算里，会优先调用 `toString`；\n\n#### 17. AMD、CMD 与 CommonJS 规范的区别？\n\nAMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）。\n\nAMD 是 RequireJS 在推广过程中对模块定义的规范化产出。CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。AMD 是**提前执行**，CMD 是**延迟执行**。CMD 推崇**依赖就近**，AMD 推崇**依赖前置**。\n\n* **CommonJs：**{模块引用(require)} {模块定义(exports)} {模块标识(module)};（Node）\n* **AMD：**define([\"dep1\", \"dep2\"],function(dep1, dep2){...});（RequireJS）\n* **CMD：**define(function(require, exports, module){...});（SeaJS）\n\n#### 18. 移动端最小触控区域是多大？\n\nAndroid 的最小点击区域尺寸是 “48x48dp”。\n\n#### 19. 事件捕获和冒泡？\n\n先从外到内进行捕获事件，再从内到外进行冒泡事件。\n\n* **事件捕获：**当你使用事件捕获时，**父级元素先触发，子级元素后触发**；\n* **事件冒泡：**当你使用事件冒泡时，**子级元素先触发，父级元素后触发**；\n\n#### 20. 哪些操作会造成内存泄漏？\n\n（暂无答案）\n\n#### 21. 柯里化 currying：\n\n把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的并且返回一个接受余下的参数而且返回结果的新函数；给函数分步传递参数，每次函数接受部分参数后应用这些参数，并返回一个函数接受剩下的参数，这中间可嵌套多层这样的接受部分参数的函数，直至返回最后结果。\n\n#### 22. escape、encodeURI 与 encodeURIComponent 的区别？\n\n`escape` 除了 ASCII 字母，数字和特定的符号（- _ . ! ~ * \" ( )）外，对传进来的字符串**全部进行转义编码**。而 `encodeURI` 用于编码整个 URI，因为 URI 中的合法字符都不会被编码转换。`encodeURIComponent` 方法在编码单个 URIComponent 应当是最常用的，它可以将参数中的中文. 特殊字符进行转义，而不会影响整个 URL。\n\n#### 23. 静态作用域和动态作用域：\n\n**静态作用域：**又称词法作用域，按照作用域链来分析，是 JS 使用的作用域管理方式；在编译阶段就分析出环境中的变量引用。\n\n![](1.jpg)\n\n**动态作用域：**维护一个统一的作用域栈；在程序运行时才会分析出各个变量的引用。\n\n![](2.jpg)\n\n#### 24. 词法环境与作用域链：\n\n词法环境是在语句或者函数运行前就初始化好的，每一个词法环境都有一个指向上一次作用域的 **outer 指针**，词法环境的内部变量的赋值是在语句运行时进行的。在一个函数内一条语句用到的变量会沿着词法环境作用域链逐层向上寻找。\n\n**优先级：**函数定义 > 形参 > 变量定义。\n\n![](3.jpg)\n\n**函数定义和函数表达式在词法作用域的区别：**函数定义在程序运行前做静态分析时就已经被放到作用域链中了，而函数表达式（IIFE 的匿名函数也是一种函数表达式）同变量定义一样，只有在运行到它之前才会开始分析作用域，并放到整个作用域链当中。\n\n![](4.jpg)\n\n**闭包：**具体原理如下图所示。\n\n![](5.jpg)\n\n#### 25. XMLHttpRequest Level 2：\n\nIE 时代的 “XMLHttpRequest1.0” 存在的问题：\n\n1. 只支持文本数据的传输，不支持二进制数据；\n2. 无法独立跨域；\n3. 传送数据时没有进度信息；\n\nXMLHttpRequest Level 2 支持的特性：\n\n1. 可以设置HTTP请求的时限；\n2. 可以使用 FormData 对象管理表单数据；\n3. 可以上传文件；\n4. 可以请求不同域名下的数据（跨域请求）；\n5. 可以获取服务器端的二进制数据；\n6. 可以获得数据传输的进度信息；\n\n","source":"_posts/前端常见技术点-JavaScript.md","raw":"---\ntitle: 前端常见技术点 - JavaScript\nintro: 这里总结一下 Web 前端面试 JavaScript 部分的常见面试问题，同时这些问题也是对一些基础的技术概念和思想的理解。对这些基本知识的掌握程度和深度决定了你的技术层级。高级工程师是必须掌握本文列出的这些知识的，资深工程师则要对这些基本概念的纵向深度进行挖掘，【问题解答全部原创，转载请注明来源】。\ncomments: true\ndate: 2016-12-13 00:16:23\ntags:\n- JavaScript\n---\n\n这里总结一下 Web 前端面试 JavaScript 部分的常见面试问题，同时这些问题也是对一些基础的技术概念和思想的理解。对这些基本知识的掌握程度和深度决定了你的技术层级。高级工程师是必须掌握本文列出的这些知识的，资深工程师则要对这些基本概念的纵向深度进行挖掘，【问题解答全部原创，转载请注明来源】。\n\n### JavaScript 技术部分：\n\n#### 1. JS 有几种类型的值？\n\n“堆”保存原始数据类型，“栈”保存引用数据类型。Stack 为自动分配的内存空间，它由系统自动释放；而 Heap 则是动态分配的内存，大小不定也不会自动释放。\n\n* **基本类型：**存放在栈内存中的简单数据段，数据大小确定，内存空间大小可以分配。\n* **引用类型：**存放在堆内存中的对象，变量实际保存的是一个指针，这个指针指向另一个位置。每个空间大小不一样，要根据情况开进行特定的分配。\n\n5种基本数据类型有 `undefined`、`null`、`boolean`、`number` 和 `string`，它们是直接按值存放的，所以可以直接访问。\n\n当我们需要访问引用类型（对象、数组、函数）的值时，首先需要从**栈中获得该对象的地址指针，然后再从堆内存中取得所需的数据**。\n\n#### 2. JS 如何实现继承？\n\n构造函数使用 call、apply 继承 prototype 原型模式。\n\n```javascript\nCat.prototype = new Animal();\nCat.prototype.constructor = Cat;\nvar cat1 = new Cat(\"大毛\", \"黄色\");\nalert(cat1.species); // 动物；\n```\n\n#### 3. Object.create 的核心原理？\n\n创建一个指定原型链的对象。\n\n```javascript\n// polyfill；\nfunction object(o) {\n  function F() {}\n  F.prototype = o;\n  return new F();\n}\n```\n\n#### 4. call、apply 和 ES5 中的 bind 的本质以及常用场景？\n\n`call`、`apply` 和 `bind` 的目的是为了动态改变 this，也就是改变函数的运行时上下文；\n\n**将伪数组改变为数组：**\n\n```javascript\nArray.prototype.slice.apply(document.getElementsByClassName(\"content\"), [1,2]);\nArray.prototype.slice.apply(arguments);\n```\n\n**bind 方法的 polyfill：**\n\n```javascript\nif (!(function() {}.bind)) {\n  Function.prototype.bind = function(context) {\n    var self = this, args = Array.prototype.slice.call(arguments);\n        \n    return function() {\n      // bind 第一个参数是 context，后面为参数；\n      return self.apply(context, args.slice(1));    \n    }\n  };\n}\n```\n\n#### 5. [\"1\", \"2\", \"3\"].map(parseInt) 语句的结果是什么？\n\n“[1, NaN, NaN]”；因为 `map` 函数的 callback 函数最多能够接受三个参数，第一个是当前数组元素，第二个是当前数组元素的索引，第三个为整个数组；而 parseInt 则可以接受两个参数，所以 [parseInt(1, 0), parseInt(2, 1), parseInt(3, 2)] 就变成了 [1 ,NaN, NaN]。\n\n#### 6. JS 中有一个函数，执行对象查找时永远不会去查找原型，该函数是？\n\n“hasOwnProperty”。\n\n#### 7. JS 如何在低版本浏览器解析 JSON 格式，并防止 JSON 劫持？\n\n在服务器返回的 JSON 字符串前加入 “{}&&” 可以防止 JSON 劫持。\n\n```javascript\neval(\"({}&&\" + '{\"result\":true,\"data\":[{\"id\":\"201\"},{\"id\":\"188\"},{\"id\":\"126\"}]}' + \")\");\n```\n\n\n#### 8. 页面编码和被请求的资源编码如果不一致如何处理？\n\n为外部引入的 JS 文件加入 `charset` 属性。\n\n```html\n<script type=\"text/javascript\" src=\"myscripts.js\" charset=\"UTF-8\"> \n```\n\n#### 9. JS 异步延迟加载的方式有哪些？\n\n```javascript\n// 放置在标签前(接近 HTML 文件底部)；\nfunction downloadJSAtOnload() {\n  var e = document.createElement(\"script\");\n  e.src = \"defer.js\";\n  document.body.appendChild(e);\n}\nif (window.addEventListener)\n  window.addEventListener(\"load\", downloadJSAtOnload, false);\nelse if (window.attachEvent)\n  window.attachEvent(\"onload\", downloadJSAtOnload);\nelse \n  window.onload = downloadJSAtOnload;\n```\n\n#### 10. new 操作符具体干了什么？\n\n```javascript\nvar person = {};\nperson.__proto__ = Person.prototype;\nPerson.call(person);\n```\n\n#### 11. window.event.srcElement 与 window.event.target 的区别？\n\nIE 浏览器支持 `window.event.srcElement`，而 Firefox 则支持 `window.event.target`。\n\n#### 12. 数组和对象有哪些原生方法，列举一下？\n\n* Array.prototype.slice；\n* Array.prototype.sort；\n* Object.prototype.toString；\n* Object.prototype.hasOwnProperty；\n\n#### 13. documen.write 和 innerHTML 的区别？\n\n`document.write` 直接把内容写入文档流，会清空当前文档的所有内容；而 `innerHTML` 只会更新所属元素。\n\n#### 14. 跨域问题：\n\n**JSONP：**\n\n利用 `<script \\>` 标签的 url 参数指定需要返回处理的 callback，服务器直接以调用 callback 函数的方式，将需要的 JSON 数据直接作为函数参数，动态生成所需的 JS 文件并在客户端加载；\n\n**CORS 跨域资源共享：**\n\n* **简单请求：**浏览器附带 Origin 字段，服务器检查请求，成功则返回 Access-Control-Allow-Origin 字段；\n* **非简单请求：**初次请求进行预检，浏览器发送 OPTIONS 请求，Access-Control-Max-Age 字段决定此次预检的有效期；\n* 如果需要发送 cookie，则 Access-Control-Allow-Origin 字段便不能设为星号，必须指定明确的、与请求网页源一致的域名；\n\n**HTML5 postMessage：**\n\n适用于多窗口间的消息传递，如：页面与内部 iframe 之间的消息传递。\n\n* **其他页面发送：**`window.postMessage(message, targetOrigin);` （这里的 window 为对目标窗口的引用）。\n* **当前页面监听：**`window.addEventListener(\"message\", function(event) { ... }, false);`\n\n#### 15. 如何判断当前脚本运行在浏览器还是 Node.js 环境中？\n\n判断当前环境是否有 `global` 对象（不绝对，可以伪造）；\n\n#### 16. Object.prototype.valueOf 和 Object.prototype.toString 的区别？\n\n* **valueOf：**返回最适合该对象类型的原始值；\n* **toString：**将该对象的原始值以字符串形式返回；\n\n在数值运算里，会优先调用 `valueOf`；在字符串运算里，会优先调用 `toString`；\n\n#### 17. AMD、CMD 与 CommonJS 规范的区别？\n\nAMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）。\n\nAMD 是 RequireJS 在推广过程中对模块定义的规范化产出。CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。AMD 是**提前执行**，CMD 是**延迟执行**。CMD 推崇**依赖就近**，AMD 推崇**依赖前置**。\n\n* **CommonJs：**{模块引用(require)} {模块定义(exports)} {模块标识(module)};（Node）\n* **AMD：**define([\"dep1\", \"dep2\"],function(dep1, dep2){...});（RequireJS）\n* **CMD：**define(function(require, exports, module){...});（SeaJS）\n\n#### 18. 移动端最小触控区域是多大？\n\nAndroid 的最小点击区域尺寸是 “48x48dp”。\n\n#### 19. 事件捕获和冒泡？\n\n先从外到内进行捕获事件，再从内到外进行冒泡事件。\n\n* **事件捕获：**当你使用事件捕获时，**父级元素先触发，子级元素后触发**；\n* **事件冒泡：**当你使用事件冒泡时，**子级元素先触发，父级元素后触发**；\n\n#### 20. 哪些操作会造成内存泄漏？\n\n（暂无答案）\n\n#### 21. 柯里化 currying：\n\n把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的并且返回一个接受余下的参数而且返回结果的新函数；给函数分步传递参数，每次函数接受部分参数后应用这些参数，并返回一个函数接受剩下的参数，这中间可嵌套多层这样的接受部分参数的函数，直至返回最后结果。\n\n#### 22. escape、encodeURI 与 encodeURIComponent 的区别？\n\n`escape` 除了 ASCII 字母，数字和特定的符号（- _ . ! ~ * \" ( )）外，对传进来的字符串**全部进行转义编码**。而 `encodeURI` 用于编码整个 URI，因为 URI 中的合法字符都不会被编码转换。`encodeURIComponent` 方法在编码单个 URIComponent 应当是最常用的，它可以将参数中的中文. 特殊字符进行转义，而不会影响整个 URL。\n\n#### 23. 静态作用域和动态作用域：\n\n**静态作用域：**又称词法作用域，按照作用域链来分析，是 JS 使用的作用域管理方式；在编译阶段就分析出环境中的变量引用。\n\n![](1.jpg)\n\n**动态作用域：**维护一个统一的作用域栈；在程序运行时才会分析出各个变量的引用。\n\n![](2.jpg)\n\n#### 24. 词法环境与作用域链：\n\n词法环境是在语句或者函数运行前就初始化好的，每一个词法环境都有一个指向上一次作用域的 **outer 指针**，词法环境的内部变量的赋值是在语句运行时进行的。在一个函数内一条语句用到的变量会沿着词法环境作用域链逐层向上寻找。\n\n**优先级：**函数定义 > 形参 > 变量定义。\n\n![](3.jpg)\n\n**函数定义和函数表达式在词法作用域的区别：**函数定义在程序运行前做静态分析时就已经被放到作用域链中了，而函数表达式（IIFE 的匿名函数也是一种函数表达式）同变量定义一样，只有在运行到它之前才会开始分析作用域，并放到整个作用域链当中。\n\n![](4.jpg)\n\n**闭包：**具体原理如下图所示。\n\n![](5.jpg)\n\n#### 25. XMLHttpRequest Level 2：\n\nIE 时代的 “XMLHttpRequest1.0” 存在的问题：\n\n1. 只支持文本数据的传输，不支持二进制数据；\n2. 无法独立跨域；\n3. 传送数据时没有进度信息；\n\nXMLHttpRequest Level 2 支持的特性：\n\n1. 可以设置HTTP请求的时限；\n2. 可以使用 FormData 对象管理表单数据；\n3. 可以上传文件；\n4. 可以请求不同域名下的数据（跨域请求）；\n5. 可以获取服务器端的二进制数据；\n6. 可以获得数据传输的进度信息；\n\n","slug":"前端常见技术点-JavaScript","published":1,"updated":"2019-02-11T06:47:43.988Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtav0061knp25nqnf2ud","content":"<p>这里总结一下 Web 前端面试 JavaScript 部分的常见面试问题，同时这些问题也是对一些基础的技术概念和思想的理解。对这些基本知识的掌握程度和深度决定了你的技术层级。高级工程师是必须掌握本文列出的这些知识的，资深工程师则要对这些基本概念的纵向深度进行挖掘，【问题解答全部原创，转载请注明来源】。</p>\n<h3 id=\"JavaScript-技术部分：\"><a href=\"#JavaScript-技术部分：\" class=\"headerlink\" title=\"JavaScript 技术部分：\"></a>JavaScript 技术部分：</h3><h4 id=\"1-JS-有几种类型的值？\"><a href=\"#1-JS-有几种类型的值？\" class=\"headerlink\" title=\"1. JS 有几种类型的值？\"></a>1. JS 有几种类型的值？</h4><p>“堆”保存原始数据类型，“栈”保存引用数据类型。Stack 为自动分配的内存空间，它由系统自动释放；而 Heap 则是动态分配的内存，大小不定也不会自动释放。</p>\n<ul>\n<li><strong>基本类型：</strong>存放在栈内存中的简单数据段，数据大小确定，内存空间大小可以分配。</li>\n<li><strong>引用类型：</strong>存放在堆内存中的对象，变量实际保存的是一个指针，这个指针指向另一个位置。每个空间大小不一样，要根据情况开进行特定的分配。</li>\n</ul>\n<p>5种基本数据类型有 <code>undefined</code>、<code>null</code>、<code>boolean</code>、<code>number</code> 和 <code>string</code>，它们是直接按值存放的，所以可以直接访问。</p>\n<p>当我们需要访问引用类型（对象、数组、函数）的值时，首先需要从<strong>栈中获得该对象的地址指针，然后再从堆内存中取得所需的数据</strong>。</p>\n<h4 id=\"2-JS-如何实现继承？\"><a href=\"#2-JS-如何实现继承？\" class=\"headerlink\" title=\"2. JS 如何实现继承？\"></a>2. JS 如何实现继承？</h4><p>构造函数使用 call、apply 继承 prototype 原型模式。</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\">Cat<span class=\"token punctuation\">.</span>prototype <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Animal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nCat<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>constructor <span class=\"token operator\">=</span> Cat<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> cat1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Cat</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"大毛\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"黄色\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>cat1<span class=\"token punctuation\">.</span>species<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 动物；</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"3-Object-create-的核心原理？\"><a href=\"#3-Object-create-的核心原理？\" class=\"headerlink\" title=\"3. Object.create 的核心原理？\"></a>3. Object.create 的核心原理？</h4><p>创建一个指定原型链的对象。</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">// polyfill；</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">object</span><span class=\"token punctuation\">(</span>o<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">F</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n  F<span class=\"token punctuation\">.</span>prototype <span class=\"token operator\">=</span> o<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">F</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"4-call、apply-和-ES5-中的-bind-的本质以及常用场景？\"><a href=\"#4-call、apply-和-ES5-中的-bind-的本质以及常用场景？\" class=\"headerlink\" title=\"4. call、apply 和 ES5 中的 bind 的本质以及常用场景？\"></a>4. call、apply 和 ES5 中的 bind 的本质以及常用场景？</h4><p><code>call</code>、<code>apply</code> 和 <code>bind</code> 的目的是为了动态改变 this，也就是改变函数的运行时上下文；</p>\n<p><strong>将伪数组改变为数组：</strong></p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\">Array<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>slice<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementsByClassName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"content\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nArray<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>slice<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>arguments<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p><strong>bind 方法的 polyfill：</strong></p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">.</span>bind<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  Function<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>bind <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> self <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> args <span class=\"token operator\">=</span> Array<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>slice<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>arguments<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// bind 第一个参数是 context，后面为参数；</span>\n      <span class=\"token keyword\">return</span> self<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    \n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"5-“1”-“2”-“3”-map-parseInt-语句的结果是什么？\"><a href=\"#5-“1”-“2”-“3”-map-parseInt-语句的结果是什么？\" class=\"headerlink\" title=\"5. [“1”, “2”, “3”].map(parseInt) 语句的结果是什么？\"></a>5. [“1”, “2”, “3”].map(parseInt) 语句的结果是什么？</h4><p>“[1, NaN, NaN]”；因为 <code>map</code> 函数的 callback 函数最多能够接受三个参数，第一个是当前数组元素，第二个是当前数组元素的索引，第三个为整个数组；而 parseInt 则可以接受两个参数，所以 [parseInt(1, 0), parseInt(2, 1), parseInt(3, 2)] 就变成了 [1 ,NaN, NaN]。</p>\n<h4 id=\"6-JS-中有一个函数，执行对象查找时永远不会去查找原型，该函数是？\"><a href=\"#6-JS-中有一个函数，执行对象查找时永远不会去查找原型，该函数是？\" class=\"headerlink\" title=\"6. JS 中有一个函数，执行对象查找时永远不会去查找原型，该函数是？\"></a>6. JS 中有一个函数，执行对象查找时永远不会去查找原型，该函数是？</h4><p>“hasOwnProperty”。</p>\n<h4 id=\"7-JS-如何在低版本浏览器解析-JSON-格式，并防止-JSON-劫持？\"><a href=\"#7-JS-如何在低版本浏览器解析-JSON-格式，并防止-JSON-劫持？\" class=\"headerlink\" title=\"7. JS 如何在低版本浏览器解析 JSON 格式，并防止 JSON 劫持？\"></a>7. JS 如何在低版本浏览器解析 JSON 格式，并防止 JSON 劫持？</h4><p>在服务器返回的 JSON 字符串前加入 “{}&amp;&amp;” 可以防止 JSON 劫持。</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">eval</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"({}&amp;&amp;\"</span> <span class=\"token operator\">+</span> <span class=\"token string\">'{\"result\":true,\"data\":[{\"id\":\"201\"},{\"id\":\"188\"},{\"id\":\"126\"}]}'</span> <span class=\"token operator\">+</span> <span class=\"token string\">\")\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h4 id=\"8-页面编码和被请求的资源编码如果不一致如何处理？\"><a href=\"#8-页面编码和被请求的资源编码如果不一致如何处理？\" class=\"headerlink\" title=\"8. 页面编码和被请求的资源编码如果不一致如何处理？\"></a>8. 页面编码和被请求的资源编码如果不一致如何处理？</h4><p>为外部引入的 JS 文件加入 <code>charset</code> 属性。</p>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>text/javascript<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>myscripts.js<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">charset</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>UTF-8<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span> \n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h4 id=\"9-JS-异步延迟加载的方式有哪些？\"><a href=\"#9-JS-异步延迟加载的方式有哪些？\" class=\"headerlink\" title=\"9. JS 异步延迟加载的方式有哪些？\"></a>9. JS 异步延迟加载的方式有哪些？</h4><pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">// 放置在标签前(接近 HTML 文件底部)；</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">downloadJSAtOnload</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> e <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"script\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  e<span class=\"token punctuation\">.</span>src <span class=\"token operator\">=</span> <span class=\"token string\">\"defer.js\"</span><span class=\"token punctuation\">;</span>\n  document<span class=\"token punctuation\">.</span>body<span class=\"token punctuation\">.</span><span class=\"token function\">appendChild</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">.</span>addEventListener<span class=\"token punctuation\">)</span>\n  window<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"load\"</span><span class=\"token punctuation\">,</span> downloadJSAtOnload<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">.</span>attachEvent<span class=\"token punctuation\">)</span>\n  window<span class=\"token punctuation\">.</span><span class=\"token function\">attachEvent</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"onload\"</span><span class=\"token punctuation\">,</span> downloadJSAtOnload<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">else</span> \n  window<span class=\"token punctuation\">.</span>onload <span class=\"token operator\">=</span> downloadJSAtOnload<span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"10-new-操作符具体干了什么？\"><a href=\"#10-new-操作符具体干了什么？\" class=\"headerlink\" title=\"10. new 操作符具体干了什么？\"></a>10. new 操作符具体干了什么？</h4><pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> person <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nperson<span class=\"token punctuation\">.</span>__proto__ <span class=\"token operator\">=</span> Person<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">;</span>\nPerson<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"11-window-event-srcElement-与-window-event-target-的区别？\"><a href=\"#11-window-event-srcElement-与-window-event-target-的区别？\" class=\"headerlink\" title=\"11. window.event.srcElement 与 window.event.target 的区别？\"></a>11. window.event.srcElement 与 window.event.target 的区别？</h4><p>IE 浏览器支持 <code>window.event.srcElement</code>，而 Firefox 则支持 <code>window.event.target</code>。</p>\n<h4 id=\"12-数组和对象有哪些原生方法，列举一下？\"><a href=\"#12-数组和对象有哪些原生方法，列举一下？\" class=\"headerlink\" title=\"12. 数组和对象有哪些原生方法，列举一下？\"></a>12. 数组和对象有哪些原生方法，列举一下？</h4><ul>\n<li>Array.prototype.slice；</li>\n<li>Array.prototype.sort；</li>\n<li>Object.prototype.toString；</li>\n<li>Object.prototype.hasOwnProperty；</li>\n</ul>\n<h4 id=\"13-documen-write-和-innerHTML-的区别？\"><a href=\"#13-documen-write-和-innerHTML-的区别？\" class=\"headerlink\" title=\"13. documen.write 和 innerHTML 的区别？\"></a>13. documen.write 和 innerHTML 的区别？</h4><p><code>document.write</code> 直接把内容写入文档流，会清空当前文档的所有内容；而 <code>innerHTML</code> 只会更新所属元素。</p>\n<h4 id=\"14-跨域问题：\"><a href=\"#14-跨域问题：\" class=\"headerlink\" title=\"14. 跨域问题：\"></a>14. 跨域问题：</h4><p><strong>JSONP：</strong></p>\n<p>利用 <code>&lt;script \\&gt;</code> 标签的 url 参数指定需要返回处理的 callback，服务器直接以调用 callback 函数的方式，将需要的 JSON 数据直接作为函数参数，动态生成所需的 JS 文件并在客户端加载；</p>\n<p><strong>CORS 跨域资源共享：</strong></p>\n<ul>\n<li><strong>简单请求：</strong>浏览器附带 Origin 字段，服务器检查请求，成功则返回 Access-Control-Allow-Origin 字段；</li>\n<li><strong>非简单请求：</strong>初次请求进行预检，浏览器发送 OPTIONS 请求，Access-Control-Max-Age 字段决定此次预检的有效期；</li>\n<li>如果需要发送 cookie，则 Access-Control-Allow-Origin 字段便不能设为星号，必须指定明确的、与请求网页源一致的域名；</li>\n</ul>\n<p><strong>HTML5 postMessage：</strong></p>\n<p>适用于多窗口间的消息传递，如：页面与内部 iframe 之间的消息传递。</p>\n<ul>\n<li><strong>其他页面发送：</strong><code>window.postMessage(message, targetOrigin);</code> （这里的 window 为对目标窗口的引用）。</li>\n<li><strong>当前页面监听：</strong><code>window.addEventListener(&quot;message&quot;, function(event) { ... }, false);</code></li>\n</ul>\n<h4 id=\"15-如何判断当前脚本运行在浏览器还是-Node-js-环境中？\"><a href=\"#15-如何判断当前脚本运行在浏览器还是-Node-js-环境中？\" class=\"headerlink\" title=\"15. 如何判断当前脚本运行在浏览器还是 Node.js 环境中？\"></a>15. 如何判断当前脚本运行在浏览器还是 Node.js 环境中？</h4><p>判断当前环境是否有 <code>global</code> 对象（不绝对，可以伪造）；</p>\n<h4 id=\"16-Object-prototype-valueOf-和-Object-prototype-toString-的区别？\"><a href=\"#16-Object-prototype-valueOf-和-Object-prototype-toString-的区别？\" class=\"headerlink\" title=\"16. Object.prototype.valueOf 和 Object.prototype.toString 的区别？\"></a>16. Object.prototype.valueOf 和 Object.prototype.toString 的区别？</h4><ul>\n<li><strong>valueOf：</strong>返回最适合该对象类型的原始值；</li>\n<li><strong>toString：</strong>将该对象的原始值以字符串形式返回；</li>\n</ul>\n<p>在数值运算里，会优先调用 <code>valueOf</code>；在字符串运算里，会优先调用 <code>toString</code>；</p>\n<h4 id=\"17-AMD、CMD-与-CommonJS-规范的区别？\"><a href=\"#17-AMD、CMD-与-CommonJS-规范的区别？\" class=\"headerlink\" title=\"17. AMD、CMD 与 CommonJS 规范的区别？\"></a>17. AMD、CMD 与 CommonJS 规范的区别？</h4><p>AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）。</p>\n<p>AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。AMD 是<strong>提前执行</strong>，CMD 是<strong>延迟执行</strong>。CMD 推崇<strong>依赖就近</strong>，AMD 推崇<strong>依赖前置</strong>。</p>\n<ul>\n<li><strong>CommonJs：</strong>{模块引用(require)} {模块定义(exports)} {模块标识(module)};（Node）</li>\n<li><strong>AMD：</strong>define([“dep1”, “dep2”],function(dep1, dep2){…});（RequireJS）</li>\n<li><strong>CMD：</strong>define(function(require, exports, module){…});（SeaJS）</li>\n</ul>\n<h4 id=\"18-移动端最小触控区域是多大？\"><a href=\"#18-移动端最小触控区域是多大？\" class=\"headerlink\" title=\"18. 移动端最小触控区域是多大？\"></a>18. 移动端最小触控区域是多大？</h4><p>Android 的最小点击区域尺寸是 “48x48dp”。</p>\n<h4 id=\"19-事件捕获和冒泡？\"><a href=\"#19-事件捕获和冒泡？\" class=\"headerlink\" title=\"19. 事件捕获和冒泡？\"></a>19. 事件捕获和冒泡？</h4><p>先从外到内进行捕获事件，再从内到外进行冒泡事件。</p>\n<ul>\n<li><strong>事件捕获：</strong>当你使用事件捕获时，<strong>父级元素先触发，子级元素后触发</strong>；</li>\n<li><strong>事件冒泡：</strong>当你使用事件冒泡时，<strong>子级元素先触发，父级元素后触发</strong>；</li>\n</ul>\n<h4 id=\"20-哪些操作会造成内存泄漏？\"><a href=\"#20-哪些操作会造成内存泄漏？\" class=\"headerlink\" title=\"20. 哪些操作会造成内存泄漏？\"></a>20. 哪些操作会造成内存泄漏？</h4><p>（暂无答案）</p>\n<h4 id=\"21-柯里化-currying：\"><a href=\"#21-柯里化-currying：\" class=\"headerlink\" title=\"21. 柯里化 currying：\"></a>21. 柯里化 currying：</h4><p>把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的并且返回一个接受余下的参数而且返回结果的新函数；给函数分步传递参数，每次函数接受部分参数后应用这些参数，并返回一个函数接受剩下的参数，这中间可嵌套多层这样的接受部分参数的函数，直至返回最后结果。</p>\n<h4 id=\"22-escape、encodeURI-与-encodeURIComponent-的区别？\"><a href=\"#22-escape、encodeURI-与-encodeURIComponent-的区别？\" class=\"headerlink\" title=\"22. escape、encodeURI 与 encodeURIComponent 的区别？\"></a>22. escape、encodeURI 与 encodeURIComponent 的区别？</h4><p><code>escape</code> 除了 ASCII 字母，数字和特定的符号（- _ . ! ~ * “ ( )）外，对传进来的字符串<strong>全部进行转义编码</strong>。而 <code>encodeURI</code> 用于编码整个 URI，因为 URI 中的合法字符都不会被编码转换。<code>encodeURIComponent</code> 方法在编码单个 URIComponent 应当是最常用的，它可以将参数中的中文. 特殊字符进行转义，而不会影响整个 URL。</p>\n<h4 id=\"23-静态作用域和动态作用域：\"><a href=\"#23-静态作用域和动态作用域：\" class=\"headerlink\" title=\"23. 静态作用域和动态作用域：\"></a>23. 静态作用域和动态作用域：</h4><p><strong>静态作用域：</strong>又称词法作用域，按照作用域链来分析，是 JS 使用的作用域管理方式；在编译阶段就分析出环境中的变量引用。</p>\n<p><img src=\"1.jpg\" alt></p>\n<p><strong>动态作用域：</strong>维护一个统一的作用域栈；在程序运行时才会分析出各个变量的引用。</p>\n<p><img src=\"2.jpg\" alt></p>\n<h4 id=\"24-词法环境与作用域链：\"><a href=\"#24-词法环境与作用域链：\" class=\"headerlink\" title=\"24. 词法环境与作用域链：\"></a>24. 词法环境与作用域链：</h4><p>词法环境是在语句或者函数运行前就初始化好的，每一个词法环境都有一个指向上一次作用域的 <strong>outer 指针</strong>，词法环境的内部变量的赋值是在语句运行时进行的。在一个函数内一条语句用到的变量会沿着词法环境作用域链逐层向上寻找。</p>\n<p><strong>优先级：</strong>函数定义 &gt; 形参 &gt; 变量定义。</p>\n<p><img src=\"3.jpg\" alt></p>\n<p><strong>函数定义和函数表达式在词法作用域的区别：</strong>函数定义在程序运行前做静态分析时就已经被放到作用域链中了，而函数表达式（IIFE 的匿名函数也是一种函数表达式）同变量定义一样，只有在运行到它之前才会开始分析作用域，并放到整个作用域链当中。</p>\n<p><img src=\"4.jpg\" alt></p>\n<p><strong>闭包：</strong>具体原理如下图所示。</p>\n<p><img src=\"5.jpg\" alt></p>\n<h4 id=\"25-XMLHttpRequest-Level-2：\"><a href=\"#25-XMLHttpRequest-Level-2：\" class=\"headerlink\" title=\"25. XMLHttpRequest Level 2：\"></a>25. XMLHttpRequest Level 2：</h4><p>IE 时代的 “XMLHttpRequest1.0” 存在的问题：</p>\n<ol>\n<li>只支持文本数据的传输，不支持二进制数据；</li>\n<li>无法独立跨域；</li>\n<li>传送数据时没有进度信息；</li>\n</ol>\n<p>XMLHttpRequest Level 2 支持的特性：</p>\n<ol>\n<li>可以设置HTTP请求的时限；</li>\n<li>可以使用 FormData 对象管理表单数据；</li>\n<li>可以上传文件；</li>\n<li>可以请求不同域名下的数据（跨域请求）；</li>\n<li>可以获取服务器端的二进制数据；</li>\n<li>可以获得数据传输的进度信息；</li>\n</ol>\n","site":{"data":{}},"id":"da337e2b2908a15edf507b7b50ab76a2","excerpt":"","more":"<p>这里总结一下 Web 前端面试 JavaScript 部分的常见面试问题，同时这些问题也是对一些基础的技术概念和思想的理解。对这些基本知识的掌握程度和深度决定了你的技术层级。高级工程师是必须掌握本文列出的这些知识的，资深工程师则要对这些基本概念的纵向深度进行挖掘，【问题解答全部原创，转载请注明来源】。</p>\n<h3 id=\"JavaScript-技术部分：\"><a href=\"#JavaScript-技术部分：\" class=\"headerlink\" title=\"JavaScript 技术部分：\"></a>JavaScript 技术部分：</h3><h4 id=\"1-JS-有几种类型的值？\"><a href=\"#1-JS-有几种类型的值？\" class=\"headerlink\" title=\"1. JS 有几种类型的值？\"></a>1. JS 有几种类型的值？</h4><p>“堆”保存原始数据类型，“栈”保存引用数据类型。Stack 为自动分配的内存空间，它由系统自动释放；而 Heap 则是动态分配的内存，大小不定也不会自动释放。</p>\n<ul>\n<li><strong>基本类型：</strong>存放在栈内存中的简单数据段，数据大小确定，内存空间大小可以分配。</li>\n<li><strong>引用类型：</strong>存放在堆内存中的对象，变量实际保存的是一个指针，这个指针指向另一个位置。每个空间大小不一样，要根据情况开进行特定的分配。</li>\n</ul>\n<p>5种基本数据类型有 <code>undefined</code>、<code>null</code>、<code>boolean</code>、<code>number</code> 和 <code>string</code>，它们是直接按值存放的，所以可以直接访问。</p>\n<p>当我们需要访问引用类型（对象、数组、函数）的值时，首先需要从<strong>栈中获得该对象的地址指针，然后再从堆内存中取得所需的数据</strong>。</p>\n<h4 id=\"2-JS-如何实现继承？\"><a href=\"#2-JS-如何实现继承？\" class=\"headerlink\" title=\"2. JS 如何实现继承？\"></a>2. JS 如何实现继承？</h4><p>构造函数使用 call、apply 继承 prototype 原型模式。</p>\n<pre><code class=\"javascript\">Cat.prototype = new Animal();\nCat.prototype.constructor = Cat;\nvar cat1 = new Cat(&quot;大毛&quot;, &quot;黄色&quot;);\nalert(cat1.species); // 动物；\n</code></pre>\n<h4 id=\"3-Object-create-的核心原理？\"><a href=\"#3-Object-create-的核心原理？\" class=\"headerlink\" title=\"3. Object.create 的核心原理？\"></a>3. Object.create 的核心原理？</h4><p>创建一个指定原型链的对象。</p>\n<pre><code class=\"javascript\">// polyfill；\nfunction object(o) {\n  function F() {}\n  F.prototype = o;\n  return new F();\n}\n</code></pre>\n<h4 id=\"4-call、apply-和-ES5-中的-bind-的本质以及常用场景？\"><a href=\"#4-call、apply-和-ES5-中的-bind-的本质以及常用场景？\" class=\"headerlink\" title=\"4. call、apply 和 ES5 中的 bind 的本质以及常用场景？\"></a>4. call、apply 和 ES5 中的 bind 的本质以及常用场景？</h4><p><code>call</code>、<code>apply</code> 和 <code>bind</code> 的目的是为了动态改变 this，也就是改变函数的运行时上下文；</p>\n<p><strong>将伪数组改变为数组：</strong></p>\n<pre><code class=\"javascript\">Array.prototype.slice.apply(document.getElementsByClassName(&quot;content&quot;), [1,2]);\nArray.prototype.slice.apply(arguments);\n</code></pre>\n<p><strong>bind 方法的 polyfill：</strong></p>\n<pre><code class=\"javascript\">if (!(function() {}.bind)) {\n  Function.prototype.bind = function(context) {\n    var self = this, args = Array.prototype.slice.call(arguments);\n\n    return function() {\n      // bind 第一个参数是 context，后面为参数；\n      return self.apply(context, args.slice(1));    \n    }\n  };\n}\n</code></pre>\n<h4 id=\"5-“1”-“2”-“3”-map-parseInt-语句的结果是什么？\"><a href=\"#5-“1”-“2”-“3”-map-parseInt-语句的结果是什么？\" class=\"headerlink\" title=\"5. [“1”, “2”, “3”].map(parseInt) 语句的结果是什么？\"></a>5. [“1”, “2”, “3”].map(parseInt) 语句的结果是什么？</h4><p>“[1, NaN, NaN]”；因为 <code>map</code> 函数的 callback 函数最多能够接受三个参数，第一个是当前数组元素，第二个是当前数组元素的索引，第三个为整个数组；而 parseInt 则可以接受两个参数，所以 [parseInt(1, 0), parseInt(2, 1), parseInt(3, 2)] 就变成了 [1 ,NaN, NaN]。</p>\n<h4 id=\"6-JS-中有一个函数，执行对象查找时永远不会去查找原型，该函数是？\"><a href=\"#6-JS-中有一个函数，执行对象查找时永远不会去查找原型，该函数是？\" class=\"headerlink\" title=\"6. JS 中有一个函数，执行对象查找时永远不会去查找原型，该函数是？\"></a>6. JS 中有一个函数，执行对象查找时永远不会去查找原型，该函数是？</h4><p>“hasOwnProperty”。</p>\n<h4 id=\"7-JS-如何在低版本浏览器解析-JSON-格式，并防止-JSON-劫持？\"><a href=\"#7-JS-如何在低版本浏览器解析-JSON-格式，并防止-JSON-劫持？\" class=\"headerlink\" title=\"7. JS 如何在低版本浏览器解析 JSON 格式，并防止 JSON 劫持？\"></a>7. JS 如何在低版本浏览器解析 JSON 格式，并防止 JSON 劫持？</h4><p>在服务器返回的 JSON 字符串前加入 “{}&amp;&amp;” 可以防止 JSON 劫持。</p>\n<pre><code class=\"javascript\">eval(&quot;({}&amp;&amp;&quot; + &#39;{&quot;result&quot;:true,&quot;data&quot;:[{&quot;id&quot;:&quot;201&quot;},{&quot;id&quot;:&quot;188&quot;},{&quot;id&quot;:&quot;126&quot;}]}&#39; + &quot;)&quot;);\n</code></pre>\n<h4 id=\"8-页面编码和被请求的资源编码如果不一致如何处理？\"><a href=\"#8-页面编码和被请求的资源编码如果不一致如何处理？\" class=\"headerlink\" title=\"8. 页面编码和被请求的资源编码如果不一致如何处理？\"></a>8. 页面编码和被请求的资源编码如果不一致如何处理？</h4><p>为外部引入的 JS 文件加入 <code>charset</code> 属性。</p>\n<pre><code class=\"html\">&lt;script type=&quot;text/javascript&quot; src=&quot;myscripts.js&quot; charset=&quot;UTF-8&quot;&gt; \n</code></pre>\n<h4 id=\"9-JS-异步延迟加载的方式有哪些？\"><a href=\"#9-JS-异步延迟加载的方式有哪些？\" class=\"headerlink\" title=\"9. JS 异步延迟加载的方式有哪些？\"></a>9. JS 异步延迟加载的方式有哪些？</h4><pre><code class=\"javascript\">// 放置在标签前(接近 HTML 文件底部)；\nfunction downloadJSAtOnload() {\n  var e = document.createElement(&quot;script&quot;);\n  e.src = &quot;defer.js&quot;;\n  document.body.appendChild(e);\n}\nif (window.addEventListener)\n  window.addEventListener(&quot;load&quot;, downloadJSAtOnload, false);\nelse if (window.attachEvent)\n  window.attachEvent(&quot;onload&quot;, downloadJSAtOnload);\nelse \n  window.onload = downloadJSAtOnload;\n</code></pre>\n<h4 id=\"10-new-操作符具体干了什么？\"><a href=\"#10-new-操作符具体干了什么？\" class=\"headerlink\" title=\"10. new 操作符具体干了什么？\"></a>10. new 操作符具体干了什么？</h4><pre><code class=\"javascript\">var person = {};\nperson.__proto__ = Person.prototype;\nPerson.call(person);\n</code></pre>\n<h4 id=\"11-window-event-srcElement-与-window-event-target-的区别？\"><a href=\"#11-window-event-srcElement-与-window-event-target-的区别？\" class=\"headerlink\" title=\"11. window.event.srcElement 与 window.event.target 的区别？\"></a>11. window.event.srcElement 与 window.event.target 的区别？</h4><p>IE 浏览器支持 <code>window.event.srcElement</code>，而 Firefox 则支持 <code>window.event.target</code>。</p>\n<h4 id=\"12-数组和对象有哪些原生方法，列举一下？\"><a href=\"#12-数组和对象有哪些原生方法，列举一下？\" class=\"headerlink\" title=\"12. 数组和对象有哪些原生方法，列举一下？\"></a>12. 数组和对象有哪些原生方法，列举一下？</h4><ul>\n<li>Array.prototype.slice；</li>\n<li>Array.prototype.sort；</li>\n<li>Object.prototype.toString；</li>\n<li>Object.prototype.hasOwnProperty；</li>\n</ul>\n<h4 id=\"13-documen-write-和-innerHTML-的区别？\"><a href=\"#13-documen-write-和-innerHTML-的区别？\" class=\"headerlink\" title=\"13. documen.write 和 innerHTML 的区别？\"></a>13. documen.write 和 innerHTML 的区别？</h4><p><code>document.write</code> 直接把内容写入文档流，会清空当前文档的所有内容；而 <code>innerHTML</code> 只会更新所属元素。</p>\n<h4 id=\"14-跨域问题：\"><a href=\"#14-跨域问题：\" class=\"headerlink\" title=\"14. 跨域问题：\"></a>14. 跨域问题：</h4><p><strong>JSONP：</strong></p>\n<p>利用 <code>&lt;script \\&gt;</code> 标签的 url 参数指定需要返回处理的 callback，服务器直接以调用 callback 函数的方式，将需要的 JSON 数据直接作为函数参数，动态生成所需的 JS 文件并在客户端加载；</p>\n<p><strong>CORS 跨域资源共享：</strong></p>\n<ul>\n<li><strong>简单请求：</strong>浏览器附带 Origin 字段，服务器检查请求，成功则返回 Access-Control-Allow-Origin 字段；</li>\n<li><strong>非简单请求：</strong>初次请求进行预检，浏览器发送 OPTIONS 请求，Access-Control-Max-Age 字段决定此次预检的有效期；</li>\n<li>如果需要发送 cookie，则 Access-Control-Allow-Origin 字段便不能设为星号，必须指定明确的、与请求网页源一致的域名；</li>\n</ul>\n<p><strong>HTML5 postMessage：</strong></p>\n<p>适用于多窗口间的消息传递，如：页面与内部 iframe 之间的消息传递。</p>\n<ul>\n<li><strong>其他页面发送：</strong><code>window.postMessage(message, targetOrigin);</code> （这里的 window 为对目标窗口的引用）。</li>\n<li><strong>当前页面监听：</strong><code>window.addEventListener(&quot;message&quot;, function(event) { ... }, false);</code></li>\n</ul>\n<h4 id=\"15-如何判断当前脚本运行在浏览器还是-Node-js-环境中？\"><a href=\"#15-如何判断当前脚本运行在浏览器还是-Node-js-环境中？\" class=\"headerlink\" title=\"15. 如何判断当前脚本运行在浏览器还是 Node.js 环境中？\"></a>15. 如何判断当前脚本运行在浏览器还是 Node.js 环境中？</h4><p>判断当前环境是否有 <code>global</code> 对象（不绝对，可以伪造）；</p>\n<h4 id=\"16-Object-prototype-valueOf-和-Object-prototype-toString-的区别？\"><a href=\"#16-Object-prototype-valueOf-和-Object-prototype-toString-的区别？\" class=\"headerlink\" title=\"16. Object.prototype.valueOf 和 Object.prototype.toString 的区别？\"></a>16. Object.prototype.valueOf 和 Object.prototype.toString 的区别？</h4><ul>\n<li><strong>valueOf：</strong>返回最适合该对象类型的原始值；</li>\n<li><strong>toString：</strong>将该对象的原始值以字符串形式返回；</li>\n</ul>\n<p>在数值运算里，会优先调用 <code>valueOf</code>；在字符串运算里，会优先调用 <code>toString</code>；</p>\n<h4 id=\"17-AMD、CMD-与-CommonJS-规范的区别？\"><a href=\"#17-AMD、CMD-与-CommonJS-规范的区别？\" class=\"headerlink\" title=\"17. AMD、CMD 与 CommonJS 规范的区别？\"></a>17. AMD、CMD 与 CommonJS 规范的区别？</h4><p>AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）。</p>\n<p>AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。AMD 是<strong>提前执行</strong>，CMD 是<strong>延迟执行</strong>。CMD 推崇<strong>依赖就近</strong>，AMD 推崇<strong>依赖前置</strong>。</p>\n<ul>\n<li><strong>CommonJs：</strong>{模块引用(require)} {模块定义(exports)} {模块标识(module)};（Node）</li>\n<li><strong>AMD：</strong>define([“dep1”, “dep2”],function(dep1, dep2){…});（RequireJS）</li>\n<li><strong>CMD：</strong>define(function(require, exports, module){…});（SeaJS）</li>\n</ul>\n<h4 id=\"18-移动端最小触控区域是多大？\"><a href=\"#18-移动端最小触控区域是多大？\" class=\"headerlink\" title=\"18. 移动端最小触控区域是多大？\"></a>18. 移动端最小触控区域是多大？</h4><p>Android 的最小点击区域尺寸是 “48x48dp”。</p>\n<h4 id=\"19-事件捕获和冒泡？\"><a href=\"#19-事件捕获和冒泡？\" class=\"headerlink\" title=\"19. 事件捕获和冒泡？\"></a>19. 事件捕获和冒泡？</h4><p>先从外到内进行捕获事件，再从内到外进行冒泡事件。</p>\n<ul>\n<li><strong>事件捕获：</strong>当你使用事件捕获时，<strong>父级元素先触发，子级元素后触发</strong>；</li>\n<li><strong>事件冒泡：</strong>当你使用事件冒泡时，<strong>子级元素先触发，父级元素后触发</strong>；</li>\n</ul>\n<h4 id=\"20-哪些操作会造成内存泄漏？\"><a href=\"#20-哪些操作会造成内存泄漏？\" class=\"headerlink\" title=\"20. 哪些操作会造成内存泄漏？\"></a>20. 哪些操作会造成内存泄漏？</h4><p>（暂无答案）</p>\n<h4 id=\"21-柯里化-currying：\"><a href=\"#21-柯里化-currying：\" class=\"headerlink\" title=\"21. 柯里化 currying：\"></a>21. 柯里化 currying：</h4><p>把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的并且返回一个接受余下的参数而且返回结果的新函数；给函数分步传递参数，每次函数接受部分参数后应用这些参数，并返回一个函数接受剩下的参数，这中间可嵌套多层这样的接受部分参数的函数，直至返回最后结果。</p>\n<h4 id=\"22-escape、encodeURI-与-encodeURIComponent-的区别？\"><a href=\"#22-escape、encodeURI-与-encodeURIComponent-的区别？\" class=\"headerlink\" title=\"22. escape、encodeURI 与 encodeURIComponent 的区别？\"></a>22. escape、encodeURI 与 encodeURIComponent 的区别？</h4><p><code>escape</code> 除了 ASCII 字母，数字和特定的符号（- _ . ! ~ * “ ( )）外，对传进来的字符串<strong>全部进行转义编码</strong>。而 <code>encodeURI</code> 用于编码整个 URI，因为 URI 中的合法字符都不会被编码转换。<code>encodeURIComponent</code> 方法在编码单个 URIComponent 应当是最常用的，它可以将参数中的中文. 特殊字符进行转义，而不会影响整个 URL。</p>\n<h4 id=\"23-静态作用域和动态作用域：\"><a href=\"#23-静态作用域和动态作用域：\" class=\"headerlink\" title=\"23. 静态作用域和动态作用域：\"></a>23. 静态作用域和动态作用域：</h4><p><strong>静态作用域：</strong>又称词法作用域，按照作用域链来分析，是 JS 使用的作用域管理方式；在编译阶段就分析出环境中的变量引用。</p>\n<p><img src=\"1.jpg\" alt></p>\n<p><strong>动态作用域：</strong>维护一个统一的作用域栈；在程序运行时才会分析出各个变量的引用。</p>\n<p><img src=\"2.jpg\" alt></p>\n<h4 id=\"24-词法环境与作用域链：\"><a href=\"#24-词法环境与作用域链：\" class=\"headerlink\" title=\"24. 词法环境与作用域链：\"></a>24. 词法环境与作用域链：</h4><p>词法环境是在语句或者函数运行前就初始化好的，每一个词法环境都有一个指向上一次作用域的 <strong>outer 指针</strong>，词法环境的内部变量的赋值是在语句运行时进行的。在一个函数内一条语句用到的变量会沿着词法环境作用域链逐层向上寻找。</p>\n<p><strong>优先级：</strong>函数定义 &gt; 形参 &gt; 变量定义。</p>\n<p><img src=\"3.jpg\" alt></p>\n<p><strong>函数定义和函数表达式在词法作用域的区别：</strong>函数定义在程序运行前做静态分析时就已经被放到作用域链中了，而函数表达式（IIFE 的匿名函数也是一种函数表达式）同变量定义一样，只有在运行到它之前才会开始分析作用域，并放到整个作用域链当中。</p>\n<p><img src=\"4.jpg\" alt></p>\n<p><strong>闭包：</strong>具体原理如下图所示。</p>\n<p><img src=\"5.jpg\" alt></p>\n<h4 id=\"25-XMLHttpRequest-Level-2：\"><a href=\"#25-XMLHttpRequest-Level-2：\" class=\"headerlink\" title=\"25. XMLHttpRequest Level 2：\"></a>25. XMLHttpRequest Level 2：</h4><p>IE 时代的 “XMLHttpRequest1.0” 存在的问题：</p>\n<ol>\n<li>只支持文本数据的传输，不支持二进制数据；</li>\n<li>无法独立跨域；</li>\n<li>传送数据时没有进度信息；</li>\n</ol>\n<p>XMLHttpRequest Level 2 支持的特性：</p>\n<ol>\n<li>可以设置HTTP请求的时限；</li>\n<li>可以使用 FormData 对象管理表单数据；</li>\n<li>可以上传文件；</li>\n<li>可以请求不同域名下的数据（跨域请求）；</li>\n<li>可以获取服务器端的二进制数据；</li>\n<li>可以获得数据传输的进度信息；</li>\n</ol>\n"},{"title":"前端那些事儿 - Console 对象","intro":"我们在日常的 Web 前端开发中经常会遇到需要进行 JavaScript（后面简称 JS） 代码调试的需求，大部分的 JS 初学者可能会选择使用 alert() 方法来打印变量或者对象本身的值来进行调试，但这样却并不能看到对象的具体内容。","comments":1,"date":"2016-02-09T02:56:11.000Z","_content":"\n我们在日常的 Web 前端开发中经常会遇到需要进行 JavaScript（后面简称 JS）代码调试的需求，大#部分的 JS 初学者可能会选择使用 `alert()` 方法来打印变量或者对象本身的值来进行调试，但这样却并不能看到对象的具体内容。\n\n各大浏览器厂商为了便于开发者进行调试，在各个浏览器内核中引入了 `Console` 对象以便于进行 JS 代码的调试。Console 对象并不是标准的 Javascript 内置对象，所以各个浏览器对 Console 对象支持的方法细节各不相同。我们这里会介绍几个常用的 Console 对象方法，这些方法可以大大简化或者方便开发者对于大量复杂 JS 代码的调试流程。\n\n1. Console.log()：\n\n​`Console.log()` 方法可以用来打印变量或者对象的内容。对于对象类型，`Console.log()` 方法会打印出整个对象的结构甚至 Prototype 原型链上的内容，所有的 Console 对象其方法均不会阻塞 JS 代码的正常执行流程，调试和运行状态分离。你甚至可以在任何时候在浏览器的 Console 控制台窗口内调用 Console 对象的该方法来打印所有可以引用的全局变量和对象。\n\n2. Console.error() / Console.debug() / Console.info() / Console.warn()：\n\nConsole 对象的这四个方法和 `Console.log()` 的用法和效果基本一样，只不过其在浏览器 Console 控制台内输出的文字颜色和形式会略有不同，如下图所示。\n\n![](1.png)\n\n3. Console.assert(expression[, object, ...])：\n\n`Console.assert()` 十分类似单元测试里的断言，当 expression 返回为 `false` 时会在 Console 中打印第二个参数（对象，变量，值均可）的值，如下图所示。\n\n![](2.png)\n\n4. Console.clear()：\n\n`Console.clear()` 方法会清空浏览器 Console 控制台内的所有信息。\n\n5. Console.time(name) / Console.timeEnd(name)：\n\n`Console.time()` 和 `Console.timeEnd()` 方法需要配合使用来获取一段 JS 代码的实际运行时间，示例如下。\n\n![](3.png)\n\n6. Console.profile(name) / Console.profileEnd(name)：\n\n`Console.profile()` 和 `Console.profileEnd()` 方法需要配合使用来获取一段 JS 代码的运行时详细情况，浏览器会调用分析器来分析 JS 代码的运行情况，示例如下。\n\n![](4.png)\n\n7. Console.count([title])：\n\n`Console.count()` 用于统计当前代码段被执行过的次数。\n\n![](5.png)\n","source":"_posts/前端那些事儿-Console-对象.md","raw":"---\ntitle: 前端那些事儿 - Console 对象\nintro: 我们在日常的 Web 前端开发中经常会遇到需要进行 JavaScript（后面简称 JS） 代码调试的需求，大部分的 JS 初学者可能会选择使用 alert() 方法来打印变量或者对象本身的值来进行调试，但这样却并不能看到对象的具体内容。\ncomments: true\ndate: 2016-02-09 10:56:11\ntags:\n- JavaScript\n---\n\n我们在日常的 Web 前端开发中经常会遇到需要进行 JavaScript（后面简称 JS）代码调试的需求，大#部分的 JS 初学者可能会选择使用 `alert()` 方法来打印变量或者对象本身的值来进行调试，但这样却并不能看到对象的具体内容。\n\n各大浏览器厂商为了便于开发者进行调试，在各个浏览器内核中引入了 `Console` 对象以便于进行 JS 代码的调试。Console 对象并不是标准的 Javascript 内置对象，所以各个浏览器对 Console 对象支持的方法细节各不相同。我们这里会介绍几个常用的 Console 对象方法，这些方法可以大大简化或者方便开发者对于大量复杂 JS 代码的调试流程。\n\n1. Console.log()：\n\n​`Console.log()` 方法可以用来打印变量或者对象的内容。对于对象类型，`Console.log()` 方法会打印出整个对象的结构甚至 Prototype 原型链上的内容，所有的 Console 对象其方法均不会阻塞 JS 代码的正常执行流程，调试和运行状态分离。你甚至可以在任何时候在浏览器的 Console 控制台窗口内调用 Console 对象的该方法来打印所有可以引用的全局变量和对象。\n\n2. Console.error() / Console.debug() / Console.info() / Console.warn()：\n\nConsole 对象的这四个方法和 `Console.log()` 的用法和效果基本一样，只不过其在浏览器 Console 控制台内输出的文字颜色和形式会略有不同，如下图所示。\n\n![](1.png)\n\n3. Console.assert(expression[, object, ...])：\n\n`Console.assert()` 十分类似单元测试里的断言，当 expression 返回为 `false` 时会在 Console 中打印第二个参数（对象，变量，值均可）的值，如下图所示。\n\n![](2.png)\n\n4. Console.clear()：\n\n`Console.clear()` 方法会清空浏览器 Console 控制台内的所有信息。\n\n5. Console.time(name) / Console.timeEnd(name)：\n\n`Console.time()` 和 `Console.timeEnd()` 方法需要配合使用来获取一段 JS 代码的实际运行时间，示例如下。\n\n![](3.png)\n\n6. Console.profile(name) / Console.profileEnd(name)：\n\n`Console.profile()` 和 `Console.profileEnd()` 方法需要配合使用来获取一段 JS 代码的运行时详细情况，浏览器会调用分析器来分析 JS 代码的运行情况，示例如下。\n\n![](4.png)\n\n7. Console.count([title])：\n\n`Console.count()` 用于统计当前代码段被执行过的次数。\n\n![](5.png)\n","slug":"前端那些事儿-Console-对象","published":1,"updated":"2019-02-05T08:53:48.653Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtaw0063knp223lj5qyw","content":"<p>我们在日常的 Web 前端开发中经常会遇到需要进行 JavaScript（后面简称 JS）代码调试的需求，大#部分的 JS 初学者可能会选择使用 <code>alert()</code> 方法来打印变量或者对象本身的值来进行调试，但这样却并不能看到对象的具体内容。</p>\n<p>各大浏览器厂商为了便于开发者进行调试，在各个浏览器内核中引入了 <code>Console</code> 对象以便于进行 JS 代码的调试。Console 对象并不是标准的 Javascript 内置对象，所以各个浏览器对 Console 对象支持的方法细节各不相同。我们这里会介绍几个常用的 Console 对象方法，这些方法可以大大简化或者方便开发者对于大量复杂 JS 代码的调试流程。</p>\n<ol>\n<li>Console.log()：</li>\n</ol>\n<p>​<code>Console.log()</code> 方法可以用来打印变量或者对象的内容。对于对象类型，<code>Console.log()</code> 方法会打印出整个对象的结构甚至 Prototype 原型链上的内容，所有的 Console 对象其方法均不会阻塞 JS 代码的正常执行流程，调试和运行状态分离。你甚至可以在任何时候在浏览器的 Console 控制台窗口内调用 Console 对象的该方法来打印所有可以引用的全局变量和对象。</p>\n<ol start=\"2\">\n<li>Console.error() / Console.debug() / Console.info() / Console.warn()：</li>\n</ol>\n<p>Console 对象的这四个方法和 <code>Console.log()</code> 的用法和效果基本一样，只不过其在浏览器 Console 控制台内输出的文字颜色和形式会略有不同，如下图所示。</p>\n<p><img src=\"1.png\" alt></p>\n<ol start=\"3\">\n<li>Console.assert(expression[, object, …])：</li>\n</ol>\n<p><code>Console.assert()</code> 十分类似单元测试里的断言，当 expression 返回为 <code>false</code> 时会在 Console 中打印第二个参数（对象，变量，值均可）的值，如下图所示。</p>\n<p><img src=\"2.png\" alt></p>\n<ol start=\"4\">\n<li>Console.clear()：</li>\n</ol>\n<p><code>Console.clear()</code> 方法会清空浏览器 Console 控制台内的所有信息。</p>\n<ol start=\"5\">\n<li>Console.time(name) / Console.timeEnd(name)：</li>\n</ol>\n<p><code>Console.time()</code> 和 <code>Console.timeEnd()</code> 方法需要配合使用来获取一段 JS 代码的实际运行时间，示例如下。</p>\n<p><img src=\"3.png\" alt></p>\n<ol start=\"6\">\n<li>Console.profile(name) / Console.profileEnd(name)：</li>\n</ol>\n<p><code>Console.profile()</code> 和 <code>Console.profileEnd()</code> 方法需要配合使用来获取一段 JS 代码的运行时详细情况，浏览器会调用分析器来分析 JS 代码的运行情况，示例如下。</p>\n<p><img src=\"4.png\" alt></p>\n<ol start=\"7\">\n<li>Console.count([title])：</li>\n</ol>\n<p><code>Console.count()</code> 用于统计当前代码段被执行过的次数。</p>\n<p><img src=\"5.png\" alt></p>\n","site":{"data":{}},"id":"b0597e7233261612f1f850c3ecc81e1e","excerpt":"","more":"<p>我们在日常的 Web 前端开发中经常会遇到需要进行 JavaScript（后面简称 JS）代码调试的需求，大#部分的 JS 初学者可能会选择使用 <code>alert()</code> 方法来打印变量或者对象本身的值来进行调试，但这样却并不能看到对象的具体内容。</p>\n<p>各大浏览器厂商为了便于开发者进行调试，在各个浏览器内核中引入了 <code>Console</code> 对象以便于进行 JS 代码的调试。Console 对象并不是标准的 Javascript 内置对象，所以各个浏览器对 Console 对象支持的方法细节各不相同。我们这里会介绍几个常用的 Console 对象方法，这些方法可以大大简化或者方便开发者对于大量复杂 JS 代码的调试流程。</p>\n<ol>\n<li>Console.log()：</li>\n</ol>\n<p>​<code>Console.log()</code> 方法可以用来打印变量或者对象的内容。对于对象类型，<code>Console.log()</code> 方法会打印出整个对象的结构甚至 Prototype 原型链上的内容，所有的 Console 对象其方法均不会阻塞 JS 代码的正常执行流程，调试和运行状态分离。你甚至可以在任何时候在浏览器的 Console 控制台窗口内调用 Console 对象的该方法来打印所有可以引用的全局变量和对象。</p>\n<ol start=\"2\">\n<li>Console.error() / Console.debug() / Console.info() / Console.warn()：</li>\n</ol>\n<p>Console 对象的这四个方法和 <code>Console.log()</code> 的用法和效果基本一样，只不过其在浏览器 Console 控制台内输出的文字颜色和形式会略有不同，如下图所示。</p>\n<p><img src=\"1.png\" alt></p>\n<ol start=\"3\">\n<li>Console.assert(expression[, object, …])：</li>\n</ol>\n<p><code>Console.assert()</code> 十分类似单元测试里的断言，当 expression 返回为 <code>false</code> 时会在 Console 中打印第二个参数（对象，变量，值均可）的值，如下图所示。</p>\n<p><img src=\"2.png\" alt></p>\n<ol start=\"4\">\n<li>Console.clear()：</li>\n</ol>\n<p><code>Console.clear()</code> 方法会清空浏览器 Console 控制台内的所有信息。</p>\n<ol start=\"5\">\n<li>Console.time(name) / Console.timeEnd(name)：</li>\n</ol>\n<p><code>Console.time()</code> 和 <code>Console.timeEnd()</code> 方法需要配合使用来获取一段 JS 代码的实际运行时间，示例如下。</p>\n<p><img src=\"3.png\" alt></p>\n<ol start=\"6\">\n<li>Console.profile(name) / Console.profileEnd(name)：</li>\n</ol>\n<p><code>Console.profile()</code> 和 <code>Console.profileEnd()</code> 方法需要配合使用来获取一段 JS 代码的运行时详细情况，浏览器会调用分析器来分析 JS 代码的运行情况，示例如下。</p>\n<p><img src=\"4.png\" alt></p>\n<ol start=\"7\">\n<li>Console.count([title])：</li>\n</ol>\n<p><code>Console.count()</code> 用于统计当前代码段被执行过的次数。</p>\n<p><img src=\"5.png\" alt></p>\n"},{"title":"前端那些事儿 - JavaScript 函数之 IIFE","intro":"说到 JavaScript（后面简称 “JS”）的函数，大家肯定都很熟悉，平时写 JS 代码的时候经常会用到自定义函数，简直再熟悉不过。那如果我说到 JS 里的 IIFE，你是否还会像对了解 JS 函数那样熟悉 IIFE 呢？","comments":1,"date":"2015-11-30T12:57:46.000Z","_content":"\n说到 JavaScript（后面简称 “JS”）的函数，大家肯定都很熟悉，平时写 JS 代码的时候经常会用到自定义函数，简直再熟悉不过。那如果我说到 JS 里的 IIFE，你是否还会像对了解 JS 函数那样熟悉 IIFE 呢？\n\n英文的 IIFE(Immediately-Invoked Function Expression) 直译过来就是 - “立即调用函数表达式”，简单的理解就是当函数定义完之后会立即执行，如果我把 IIFE 翻译成“自执行的匿名函数 (Self-Executing Anonymous Function)” 你可能就会熟悉了。IIFE 这个名字是由 jQuery 的插件大牛 Ben Alman 推荐的一个对 JS 自运行匿名函数的更准确的叫法，相比“JS 自执行的匿名函数”，这种叫法也更加清晰和准确。\n\n那么什么是 IIFE 呢？首先让我们来看看什么是 JS 的匿名函数：\n\n```javascript\nfunction () {\n  console.debug(\"anonymous\");\n}\n```\n\n上边代码给出的就是一个 JS 的匿名函数。顾名思义，匿名函数就是没有名字的函数。但是上述代码却不能够被解释器正确执行，因为对于 JS 的匿名函数在使用之前必须要先进行**赋值**（返回给变量或者当作返回值返回，也就是所谓的闭包）如下所示：\n\n```javascript\nvar myFunc = function() {\n  console.debug(\"anonymous\");\n}\n//调用\nmyFunc();\n\n//闭包\nfunction f1() {\n  var n = 999;\n  function f2() {\n    alert(n);\n  }\n  return f2;\n}\n//调用\nvar result = f1();\nresult();\n```\n\n那么，什么是 IIFE，其实很容易理解。IIFE 就是一个能够在声明之后立即被解释运行的 JS 匿名函数。我们一般有三种常用的方式来声明一个 IIFE 函数，给出如下:\n\n```javascript\n(function(params) {\n  console.log(\"This is My IIFE.\");\n}(params));\n\n(function(params) {\n  console.log(\"This is My IIFE.\");\n})(params);\n\n!function(params) {\n  console.log(\"This is My IIFE.\");\n}(params);\n```\n\nIIFE 就是定义之后可以立即执行的函数，比如通过以上三种方式定义的 IIFE 函数，浏览器都可以在解释到这些函数代码块时自动在**函数所在的空间**内部同时解释运行方法定义内部的代码。为了解释以上的代码为什么可以自动解释执行，我们还需要了解以下概念：函数声明和函数表达式。\n\n函数声明，顾名思义就是声明一个函数。函数声明有一个非常明显的特性：函数声明提升特性（Function Declaration Hoisting）,意思就是在解释执行代码之前会先读取函数声明。这就意味着可以把函数声明放在调用它的语句后面。比如像这样：\n\n```javascript\n// 先调用，再定义；\nmyFunc();\nvar myFunc = function() {\n  console.debug(\"anonymous\");\n}\n```\n\n而函数表达式，顾名思义就是一个带有函数定义部分的 JS 表达式，比如通常我们所说的表达式都是这个样子的：\n\n```javascript\n(a > b ? a : b);\n```\n\n表达式不需要定义，可以直接解释执行，而且每一个表达式都会返回一个 JS 的类型对象，这个对象可以是 Integer，可以是 Boolean，甚至是一个内存中的函数对象，而 IIFE 正是利用了表达式的这一个特性做到了自运行。比如下面列出的这种我们上文提到的常用的 IIFE 函数构造方法：\n```javascript\n(function(params) {\n  console.log(\"This is My IIFE.\");\n})(params);\n\n// (function(params) { console.log(\"This is My IIFE.\"); }) (1)\n// (params); (2)\n```\n\n整个 IIFE 函数可以分成两部分，第一部分(1)中的小括号作为函数表达式，整个表达式会返回一个函数对象，第二部分(2)中的整个小括号则被解释器解释为调用了此返回的函数对象，并在小括号内传入了参数。而两个部分合起来，对于解释器来说就相当于直接调用了函数本身。所以实际上只要能够满足构成函数表达式加括号（参数）的形式就可以成功调用函数表达式的函数。比如以下列出的代码块都可以成功调用函数体内的代码。\n\n```javascript\n(function(a){\n  console.log(a);   \n})(\"MY IIFE\");\n  \n(function(a){\n  console.log(a);  \n}(\"MY IIFE\"));\n  \n!function(a){\n  console.log(a);  \n}(\"MY IIFE\");\n  \n+function(a){\n  console.log(a);   \n}(\"MY IIFE\");\n  \n-function(a){\n  console.log(a);   \n}(\"MY IIFE\");\n  \nvar fn=function(a){\n  console.log(a);  \n}(\"MY IIFE\");\n```\n\n另外值得注意的是，括号的混合使用有双重意义：它可以用来执行一个函数，还可以做为分组运算符来对表达式求值。比如使用圆括号或方括号的话，可以在行首加一个分号，避免表达式被误用：\n\n```javascript\n;(function(params) {\n  console.log(\"This is My IIFE.\");\n})(params);\n```\n\n那么使用 IIFE 的好处是什么呢？JS 中没有私有作用域的概念，如果在多人开发的项目上，你在全局或局部作用域中声明了一些变量，可能会被其他人不小心用同名的变量给覆盖掉，根据 JS 函数作用域链的特性，可以使用这种技术来模仿一个私有作用域，用匿名函数作为一个“容器”，“容器”内部可以访问外部的变量，而外部环境则不能访问“容器”内部的变量，所以 `(function(){ … })()` 内部定义的变量不会和外部的变量发生冲突，也被称为“匿名包裹器”或“命名空间”。\n\n比如 JQuery 使用的就是这种方法，将 JQuery 代码包裹在 IIFE 函数中，当在全局作用域中调用 JQuery 代码时，就可以达到保护 JQuery 内部变量的作用了。","source":"_posts/前端那些事儿-JavaScript-函数之-IIFE.md","raw":"---\ntitle: 前端那些事儿 - JavaScript 函数之 IIFE\nintro: 说到 JavaScript（后面简称 “JS”）的函数，大家肯定都很熟悉，平时写 JS 代码的时候经常会用到自定义函数，简直再熟悉不过。那如果我说到 JS 里的 IIFE，你是否还会像对了解 JS 函数那样熟悉 IIFE 呢？\ncomments: true\ndate: 2015-11-30 20:57:46\ntags:\n- JavaScript\n---\n\n说到 JavaScript（后面简称 “JS”）的函数，大家肯定都很熟悉，平时写 JS 代码的时候经常会用到自定义函数，简直再熟悉不过。那如果我说到 JS 里的 IIFE，你是否还会像对了解 JS 函数那样熟悉 IIFE 呢？\n\n英文的 IIFE(Immediately-Invoked Function Expression) 直译过来就是 - “立即调用函数表达式”，简单的理解就是当函数定义完之后会立即执行，如果我把 IIFE 翻译成“自执行的匿名函数 (Self-Executing Anonymous Function)” 你可能就会熟悉了。IIFE 这个名字是由 jQuery 的插件大牛 Ben Alman 推荐的一个对 JS 自运行匿名函数的更准确的叫法，相比“JS 自执行的匿名函数”，这种叫法也更加清晰和准确。\n\n那么什么是 IIFE 呢？首先让我们来看看什么是 JS 的匿名函数：\n\n```javascript\nfunction () {\n  console.debug(\"anonymous\");\n}\n```\n\n上边代码给出的就是一个 JS 的匿名函数。顾名思义，匿名函数就是没有名字的函数。但是上述代码却不能够被解释器正确执行，因为对于 JS 的匿名函数在使用之前必须要先进行**赋值**（返回给变量或者当作返回值返回，也就是所谓的闭包）如下所示：\n\n```javascript\nvar myFunc = function() {\n  console.debug(\"anonymous\");\n}\n//调用\nmyFunc();\n\n//闭包\nfunction f1() {\n  var n = 999;\n  function f2() {\n    alert(n);\n  }\n  return f2;\n}\n//调用\nvar result = f1();\nresult();\n```\n\n那么，什么是 IIFE，其实很容易理解。IIFE 就是一个能够在声明之后立即被解释运行的 JS 匿名函数。我们一般有三种常用的方式来声明一个 IIFE 函数，给出如下:\n\n```javascript\n(function(params) {\n  console.log(\"This is My IIFE.\");\n}(params));\n\n(function(params) {\n  console.log(\"This is My IIFE.\");\n})(params);\n\n!function(params) {\n  console.log(\"This is My IIFE.\");\n}(params);\n```\n\nIIFE 就是定义之后可以立即执行的函数，比如通过以上三种方式定义的 IIFE 函数，浏览器都可以在解释到这些函数代码块时自动在**函数所在的空间**内部同时解释运行方法定义内部的代码。为了解释以上的代码为什么可以自动解释执行，我们还需要了解以下概念：函数声明和函数表达式。\n\n函数声明，顾名思义就是声明一个函数。函数声明有一个非常明显的特性：函数声明提升特性（Function Declaration Hoisting）,意思就是在解释执行代码之前会先读取函数声明。这就意味着可以把函数声明放在调用它的语句后面。比如像这样：\n\n```javascript\n// 先调用，再定义；\nmyFunc();\nvar myFunc = function() {\n  console.debug(\"anonymous\");\n}\n```\n\n而函数表达式，顾名思义就是一个带有函数定义部分的 JS 表达式，比如通常我们所说的表达式都是这个样子的：\n\n```javascript\n(a > b ? a : b);\n```\n\n表达式不需要定义，可以直接解释执行，而且每一个表达式都会返回一个 JS 的类型对象，这个对象可以是 Integer，可以是 Boolean，甚至是一个内存中的函数对象，而 IIFE 正是利用了表达式的这一个特性做到了自运行。比如下面列出的这种我们上文提到的常用的 IIFE 函数构造方法：\n```javascript\n(function(params) {\n  console.log(\"This is My IIFE.\");\n})(params);\n\n// (function(params) { console.log(\"This is My IIFE.\"); }) (1)\n// (params); (2)\n```\n\n整个 IIFE 函数可以分成两部分，第一部分(1)中的小括号作为函数表达式，整个表达式会返回一个函数对象，第二部分(2)中的整个小括号则被解释器解释为调用了此返回的函数对象，并在小括号内传入了参数。而两个部分合起来，对于解释器来说就相当于直接调用了函数本身。所以实际上只要能够满足构成函数表达式加括号（参数）的形式就可以成功调用函数表达式的函数。比如以下列出的代码块都可以成功调用函数体内的代码。\n\n```javascript\n(function(a){\n  console.log(a);   \n})(\"MY IIFE\");\n  \n(function(a){\n  console.log(a);  \n}(\"MY IIFE\"));\n  \n!function(a){\n  console.log(a);  \n}(\"MY IIFE\");\n  \n+function(a){\n  console.log(a);   \n}(\"MY IIFE\");\n  \n-function(a){\n  console.log(a);   \n}(\"MY IIFE\");\n  \nvar fn=function(a){\n  console.log(a);  \n}(\"MY IIFE\");\n```\n\n另外值得注意的是，括号的混合使用有双重意义：它可以用来执行一个函数，还可以做为分组运算符来对表达式求值。比如使用圆括号或方括号的话，可以在行首加一个分号，避免表达式被误用：\n\n```javascript\n;(function(params) {\n  console.log(\"This is My IIFE.\");\n})(params);\n```\n\n那么使用 IIFE 的好处是什么呢？JS 中没有私有作用域的概念，如果在多人开发的项目上，你在全局或局部作用域中声明了一些变量，可能会被其他人不小心用同名的变量给覆盖掉，根据 JS 函数作用域链的特性，可以使用这种技术来模仿一个私有作用域，用匿名函数作为一个“容器”，“容器”内部可以访问外部的变量，而外部环境则不能访问“容器”内部的变量，所以 `(function(){ … })()` 内部定义的变量不会和外部的变量发生冲突，也被称为“匿名包裹器”或“命名空间”。\n\n比如 JQuery 使用的就是这种方法，将 JQuery 代码包裹在 IIFE 函数中，当在全局作用域中调用 JQuery 代码时，就可以达到保护 JQuery 内部变量的作用了。","slug":"前端那些事儿-JavaScript-函数之-IIFE","published":1,"updated":"2019-02-05T07:56:32.572Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtax0066knp28vo77yr8","content":"<p>说到 JavaScript（后面简称 “JS”）的函数，大家肯定都很熟悉，平时写 JS 代码的时候经常会用到自定义函数，简直再熟悉不过。那如果我说到 JS 里的 IIFE，你是否还会像对了解 JS 函数那样熟悉 IIFE 呢？</p>\n<p>英文的 IIFE(Immediately-Invoked Function Expression) 直译过来就是 - “立即调用函数表达式”，简单的理解就是当函数定义完之后会立即执行，如果我把 IIFE 翻译成“自执行的匿名函数 (Self-Executing Anonymous Function)” 你可能就会熟悉了。IIFE 这个名字是由 jQuery 的插件大牛 Ben Alman 推荐的一个对 JS 自运行匿名函数的更准确的叫法，相比“JS 自执行的匿名函数”，这种叫法也更加清晰和准确。</p>\n<p>那么什么是 IIFE 呢？首先让我们来看看什么是 JS 的匿名函数：</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">debug</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"anonymous\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>上边代码给出的就是一个 JS 的匿名函数。顾名思义，匿名函数就是没有名字的函数。但是上述代码却不能够被解释器正确执行，因为对于 JS 的匿名函数在使用之前必须要先进行<strong>赋值</strong>（返回给变量或者当作返回值返回，也就是所谓的闭包）如下所示：</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> myFunc <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">debug</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"anonymous\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">//调用</span>\n<span class=\"token function\">myFunc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//闭包</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">f1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> n <span class=\"token operator\">=</span> <span class=\"token number\">999</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">f2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> f2<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">//调用</span>\n<span class=\"token keyword\">var</span> result <span class=\"token operator\">=</span> <span class=\"token function\">f1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">result</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>那么，什么是 IIFE，其实很容易理解。IIFE 就是一个能够在声明之后立即被解释运行的 JS 匿名函数。我们一般有三种常用的方式来声明一个 IIFE 函数，给出如下:</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>params<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"This is My IIFE.\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span>params<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>params<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"This is My IIFE.\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>params<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token operator\">!</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>params<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"This is My IIFE.\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span>params<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>IIFE 就是定义之后可以立即执行的函数，比如通过以上三种方式定义的 IIFE 函数，浏览器都可以在解释到这些函数代码块时自动在<strong>函数所在的空间</strong>内部同时解释运行方法定义内部的代码。为了解释以上的代码为什么可以自动解释执行，我们还需要了解以下概念：函数声明和函数表达式。</p>\n<p>函数声明，顾名思义就是声明一个函数。函数声明有一个非常明显的特性：函数声明提升特性（Function Declaration Hoisting）,意思就是在解释执行代码之前会先读取函数声明。这就意味着可以把函数声明放在调用它的语句后面。比如像这样：</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">// 先调用，再定义；</span>\n<span class=\"token function\">myFunc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> myFunc <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">debug</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"anonymous\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>而函数表达式，顾名思义就是一个带有函数定义部分的 JS 表达式，比如通常我们所说的表达式都是这个样子的：</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token punctuation\">(</span>a <span class=\"token operator\">></span> b <span class=\"token operator\">?</span> a <span class=\"token punctuation\">:</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>表达式不需要定义，可以直接解释执行，而且每一个表达式都会返回一个 JS 的类型对象，这个对象可以是 Integer，可以是 Boolean，甚至是一个内存中的函数对象，而 IIFE 正是利用了表达式的这一个特性做到了自运行。比如下面列出的这种我们上文提到的常用的 IIFE 函数构造方法：</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>params<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"This is My IIFE.\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>params<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// (function(params) { console.log(\"This is My IIFE.\"); }) (1)</span>\n<span class=\"token comment\" spellcheck=\"true\">// (params); (2)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>整个 IIFE 函数可以分成两部分，第一部分(1)中的小括号作为函数表达式，整个表达式会返回一个函数对象，第二部分(2)中的整个小括号则被解释器解释为调用了此返回的函数对象，并在小括号内传入了参数。而两个部分合起来，对于解释器来说就相当于直接调用了函数本身。所以实际上只要能够满足构成函数表达式加括号（参数）的形式就可以成功调用函数表达式的函数。比如以下列出的代码块都可以成功调用函数体内的代码。</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"MY IIFE\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"MY IIFE\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token operator\">!</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"MY IIFE\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token operator\">+</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"MY IIFE\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token operator\">-</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"MY IIFE\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> fn<span class=\"token operator\">=</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"MY IIFE\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>另外值得注意的是，括号的混合使用有双重意义：它可以用来执行一个函数，还可以做为分组运算符来对表达式求值。比如使用圆括号或方括号的话，可以在行首加一个分号，避免表达式被误用：</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token punctuation\">;</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>params<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"This is My IIFE.\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>params<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>那么使用 IIFE 的好处是什么呢？JS 中没有私有作用域的概念，如果在多人开发的项目上，你在全局或局部作用域中声明了一些变量，可能会被其他人不小心用同名的变量给覆盖掉，根据 JS 函数作用域链的特性，可以使用这种技术来模仿一个私有作用域，用匿名函数作为一个“容器”，“容器”内部可以访问外部的变量，而外部环境则不能访问“容器”内部的变量，所以 <code>(function(){ … })()</code> 内部定义的变量不会和外部的变量发生冲突，也被称为“匿名包裹器”或“命名空间”。</p>\n<p>比如 JQuery 使用的就是这种方法，将 JQuery 代码包裹在 IIFE 函数中，当在全局作用域中调用 JQuery 代码时，就可以达到保护 JQuery 内部变量的作用了。</p>\n","site":{"data":{}},"id":"120218a36ae7d856b2db611a41396808","excerpt":"","more":"<p>说到 JavaScript（后面简称 “JS”）的函数，大家肯定都很熟悉，平时写 JS 代码的时候经常会用到自定义函数，简直再熟悉不过。那如果我说到 JS 里的 IIFE，你是否还会像对了解 JS 函数那样熟悉 IIFE 呢？</p>\n<p>英文的 IIFE(Immediately-Invoked Function Expression) 直译过来就是 - “立即调用函数表达式”，简单的理解就是当函数定义完之后会立即执行，如果我把 IIFE 翻译成“自执行的匿名函数 (Self-Executing Anonymous Function)” 你可能就会熟悉了。IIFE 这个名字是由 jQuery 的插件大牛 Ben Alman 推荐的一个对 JS 自运行匿名函数的更准确的叫法，相比“JS 自执行的匿名函数”，这种叫法也更加清晰和准确。</p>\n<p>那么什么是 IIFE 呢？首先让我们来看看什么是 JS 的匿名函数：</p>\n<pre><code class=\"javascript\">function () {\n  console.debug(&quot;anonymous&quot;);\n}\n</code></pre>\n<p>上边代码给出的就是一个 JS 的匿名函数。顾名思义，匿名函数就是没有名字的函数。但是上述代码却不能够被解释器正确执行，因为对于 JS 的匿名函数在使用之前必须要先进行<strong>赋值</strong>（返回给变量或者当作返回值返回，也就是所谓的闭包）如下所示：</p>\n<pre><code class=\"javascript\">var myFunc = function() {\n  console.debug(&quot;anonymous&quot;);\n}\n//调用\nmyFunc();\n\n//闭包\nfunction f1() {\n  var n = 999;\n  function f2() {\n    alert(n);\n  }\n  return f2;\n}\n//调用\nvar result = f1();\nresult();\n</code></pre>\n<p>那么，什么是 IIFE，其实很容易理解。IIFE 就是一个能够在声明之后立即被解释运行的 JS 匿名函数。我们一般有三种常用的方式来声明一个 IIFE 函数，给出如下:</p>\n<pre><code class=\"javascript\">(function(params) {\n  console.log(&quot;This is My IIFE.&quot;);\n}(params));\n\n(function(params) {\n  console.log(&quot;This is My IIFE.&quot;);\n})(params);\n\n!function(params) {\n  console.log(&quot;This is My IIFE.&quot;);\n}(params);\n</code></pre>\n<p>IIFE 就是定义之后可以立即执行的函数，比如通过以上三种方式定义的 IIFE 函数，浏览器都可以在解释到这些函数代码块时自动在<strong>函数所在的空间</strong>内部同时解释运行方法定义内部的代码。为了解释以上的代码为什么可以自动解释执行，我们还需要了解以下概念：函数声明和函数表达式。</p>\n<p>函数声明，顾名思义就是声明一个函数。函数声明有一个非常明显的特性：函数声明提升特性（Function Declaration Hoisting）,意思就是在解释执行代码之前会先读取函数声明。这就意味着可以把函数声明放在调用它的语句后面。比如像这样：</p>\n<pre><code class=\"javascript\">// 先调用，再定义；\nmyFunc();\nvar myFunc = function() {\n  console.debug(&quot;anonymous&quot;);\n}\n</code></pre>\n<p>而函数表达式，顾名思义就是一个带有函数定义部分的 JS 表达式，比如通常我们所说的表达式都是这个样子的：</p>\n<pre><code class=\"javascript\">(a &gt; b ? a : b);\n</code></pre>\n<p>表达式不需要定义，可以直接解释执行，而且每一个表达式都会返回一个 JS 的类型对象，这个对象可以是 Integer，可以是 Boolean，甚至是一个内存中的函数对象，而 IIFE 正是利用了表达式的这一个特性做到了自运行。比如下面列出的这种我们上文提到的常用的 IIFE 函数构造方法：</p>\n<pre><code class=\"javascript\">(function(params) {\n  console.log(&quot;This is My IIFE.&quot;);\n})(params);\n\n// (function(params) { console.log(&quot;This is My IIFE.&quot;); }) (1)\n// (params); (2)\n</code></pre>\n<p>整个 IIFE 函数可以分成两部分，第一部分(1)中的小括号作为函数表达式，整个表达式会返回一个函数对象，第二部分(2)中的整个小括号则被解释器解释为调用了此返回的函数对象，并在小括号内传入了参数。而两个部分合起来，对于解释器来说就相当于直接调用了函数本身。所以实际上只要能够满足构成函数表达式加括号（参数）的形式就可以成功调用函数表达式的函数。比如以下列出的代码块都可以成功调用函数体内的代码。</p>\n<pre><code class=\"javascript\">(function(a){\n  console.log(a);   \n})(&quot;MY IIFE&quot;);\n\n(function(a){\n  console.log(a);  \n}(&quot;MY IIFE&quot;));\n\n!function(a){\n  console.log(a);  \n}(&quot;MY IIFE&quot;);\n\n+function(a){\n  console.log(a);   \n}(&quot;MY IIFE&quot;);\n\n-function(a){\n  console.log(a);   \n}(&quot;MY IIFE&quot;);\n\nvar fn=function(a){\n  console.log(a);  \n}(&quot;MY IIFE&quot;);\n</code></pre>\n<p>另外值得注意的是，括号的混合使用有双重意义：它可以用来执行一个函数，还可以做为分组运算符来对表达式求值。比如使用圆括号或方括号的话，可以在行首加一个分号，避免表达式被误用：</p>\n<pre><code class=\"javascript\">;(function(params) {\n  console.log(&quot;This is My IIFE.&quot;);\n})(params);\n</code></pre>\n<p>那么使用 IIFE 的好处是什么呢？JS 中没有私有作用域的概念，如果在多人开发的项目上，你在全局或局部作用域中声明了一些变量，可能会被其他人不小心用同名的变量给覆盖掉，根据 JS 函数作用域链的特性，可以使用这种技术来模仿一个私有作用域，用匿名函数作为一个“容器”，“容器”内部可以访问外部的变量，而外部环境则不能访问“容器”内部的变量，所以 <code>(function(){ … })()</code> 内部定义的变量不会和外部的变量发生冲突，也被称为“匿名包裹器”或“命名空间”。</p>\n<p>比如 JQuery 使用的就是这种方法，将 JQuery 代码包裹在 IIFE 函数中，当在全局作用域中调用 JQuery 代码时，就可以达到保护 JQuery 内部变量的作用了。</p>\n"},{"title":"前端那些事儿 - URL 对象","intro":"在 W3C 最新的 “File API Editor's Draft, 19 April 2016” 草案中已经明确定义了“URL 对象”的相关属性和方法。“URL 对象”提供了一些专用的属性和方法以用来创建和处理 URL 相关的信息。本文列出了一些基本用法和介绍，在投入生产环境中使用时一定要先关注其**浏览器兼容性列表**，以防止出现兼容性问题。","comments":1,"date":"2016-05-12T01:28:58.000Z","_content":"\n在 W3C 最新的 “File API Editor's Draft, 19 April 2016” 草案中已经明确定义了“URL 对象”的相关属性和方法。“URL 对象”提供了一些专用的属性和方法以用来创建和处理 URL 相关的信息。本文列出了一些基本用法和介绍，在投入生产环境中使用时一定要先关注其**浏览器兼容性列表**，以防止出现兼容性问题。\n\n**1. URL 构造方法：**\n\n```javascript\nurl = new URL(urlString, [baseURLstring]);\n\nurl = new URL(urlString, baseURLobject);\n```\n\n其中第一个参数 `urlString` 为字符串类型，表示所构造的 URL 对象中的相对路径或绝对路径（若传入绝对路径，则 URL 构造函数会忽略第二个参数表示的基路径），第二个参数 `baseURLstring` 同样为字符串类型，代表所构造 URL 对象的基路径，即第一级目录的路径。若第二个参数选择传入一个 **baseURLobject** 对象，则其结果同传入 **baseURLstring** 实际上是一致的。因为对于 **baseURLobject** 来说，其本质是一个 URL 对象，当调用 `baseURLobject.toString()` 或者 `baseURLobject.toLlocalString()` 方法时会返回一个当前 URL 对象的字符串表示，这同直接传入一个字符串类型的 **baseURLstring** 参数来说是一样的。以下为一些例子：\n\n```javascript\nvar urlA = new URL(\"/\", \"https://www.yhspy.com/\");\nconsole.log(urlA.toString());  // 输出 “https://www.yhspy.com/”；\n\nvar urlB = new URL(\"https://www.yhspy.com/\", \"https://developers.mozilla.com\");\nconsole.log(urlB.toString());  // 输出 “https://www.yhspy.com/”；\n\nvar urlC = new URL(\"/about/\", urlB);\nconsole.log(urlC.toString());  // 输出 “https://www.yhspy.com/about/”；\n```\n\n**2. 静态方法：** URL.createObjectURL(*blob*)：\n\n该方法用来从一个 File 对象或一个 Blob 对象中创建对应该资源的 URL 对象。你可以理解为 `URL.createObjectURL(blob)` 方法会自动帮你从一个 File 对象或者一个 Blob 对象中创建一个对应该资源的引用，而通过该引用你可以直接在诸如 `<img>` 标签中的 `src` 属性里使用该引用对应的资源实体。\n\n**3. 静态方法： ** URL.revokeObjectURL(*blob*)：\n\n对于每一个使用 `URL.createObjectURL(blob)` 方法创建的资源引用来说，当 File 或 Blob 资源不再使用时一定要通过 `URL.revokeObjectURL(blob)` 及时地进行释放，该方法会通知浏览器哪些 URL 引用资源不再使用，以便及时的清理和释放内存。\n\n**4. 例子：**\n\n```javascript\n// 获取 URL 对象；\nwindow.URL = window.URL || window.webkitURL;\n// 初始化 XHR 对象，使用 AJAX；\nvar xhr = new XMLHttpRequest();    \n\nxhr.open(\"get\", \"/img/image.jpg\", true);\n// 以 Blob 格式返回数据；\nxhr.responseType = \"blob\";\n\nxhr.onload = function() {\n  if (this.status == 200) {\n    var blob = this.response;\n    var img = document.createElement(\"img\");\n    img.onload = function(e) {\n        window.URL.revokeObjectURL(img.src); // 释放 URL 对象的引用；\n    };\n\n    // 创建对应于 Blob 资源的 URL 引用；\n    img.src = window.URL.createObjectURL(blob);\n    console.log(img.src); // 输出 “blob:https://www.yhspy.com/a94989f8-677b-4819-86ad-efee0fc377a4”；\n    // ...  \n  }\n}\nxhr.send();\n```\n\n**5. 浏览器兼容性列表：**\n\n* Chrome 8.0；\n* Firefox(Gecko) 4.0；\n* IE 10.0；\n* Opera 15.0；\n* bSafari(WebKit) 6.0/7.0；\n\n\n","source":"_posts/前端那些事儿-URL-对象.md","raw":"---\ntitle: 前端那些事儿 - URL 对象\nintro: 在 W3C 最新的 “File API Editor's Draft, 19 April 2016” 草案中已经明确定义了“URL 对象”的相关属性和方法。“URL 对象”提供了一些专用的属性和方法以用来创建和处理 URL 相关的信息。本文列出了一些基本用法和介绍，在投入生产环境中使用时一定要先关注其**浏览器兼容性列表**，以防止出现兼容性问题。\ncomments: true\ndate: 2016-05-12 09:28:58\ntags:\n- JavaScript\n---\n\n在 W3C 最新的 “File API Editor's Draft, 19 April 2016” 草案中已经明确定义了“URL 对象”的相关属性和方法。“URL 对象”提供了一些专用的属性和方法以用来创建和处理 URL 相关的信息。本文列出了一些基本用法和介绍，在投入生产环境中使用时一定要先关注其**浏览器兼容性列表**，以防止出现兼容性问题。\n\n**1. URL 构造方法：**\n\n```javascript\nurl = new URL(urlString, [baseURLstring]);\n\nurl = new URL(urlString, baseURLobject);\n```\n\n其中第一个参数 `urlString` 为字符串类型，表示所构造的 URL 对象中的相对路径或绝对路径（若传入绝对路径，则 URL 构造函数会忽略第二个参数表示的基路径），第二个参数 `baseURLstring` 同样为字符串类型，代表所构造 URL 对象的基路径，即第一级目录的路径。若第二个参数选择传入一个 **baseURLobject** 对象，则其结果同传入 **baseURLstring** 实际上是一致的。因为对于 **baseURLobject** 来说，其本质是一个 URL 对象，当调用 `baseURLobject.toString()` 或者 `baseURLobject.toLlocalString()` 方法时会返回一个当前 URL 对象的字符串表示，这同直接传入一个字符串类型的 **baseURLstring** 参数来说是一样的。以下为一些例子：\n\n```javascript\nvar urlA = new URL(\"/\", \"https://www.yhspy.com/\");\nconsole.log(urlA.toString());  // 输出 “https://www.yhspy.com/”；\n\nvar urlB = new URL(\"https://www.yhspy.com/\", \"https://developers.mozilla.com\");\nconsole.log(urlB.toString());  // 输出 “https://www.yhspy.com/”；\n\nvar urlC = new URL(\"/about/\", urlB);\nconsole.log(urlC.toString());  // 输出 “https://www.yhspy.com/about/”；\n```\n\n**2. 静态方法：** URL.createObjectURL(*blob*)：\n\n该方法用来从一个 File 对象或一个 Blob 对象中创建对应该资源的 URL 对象。你可以理解为 `URL.createObjectURL(blob)` 方法会自动帮你从一个 File 对象或者一个 Blob 对象中创建一个对应该资源的引用，而通过该引用你可以直接在诸如 `<img>` 标签中的 `src` 属性里使用该引用对应的资源实体。\n\n**3. 静态方法： ** URL.revokeObjectURL(*blob*)：\n\n对于每一个使用 `URL.createObjectURL(blob)` 方法创建的资源引用来说，当 File 或 Blob 资源不再使用时一定要通过 `URL.revokeObjectURL(blob)` 及时地进行释放，该方法会通知浏览器哪些 URL 引用资源不再使用，以便及时的清理和释放内存。\n\n**4. 例子：**\n\n```javascript\n// 获取 URL 对象；\nwindow.URL = window.URL || window.webkitURL;\n// 初始化 XHR 对象，使用 AJAX；\nvar xhr = new XMLHttpRequest();    \n\nxhr.open(\"get\", \"/img/image.jpg\", true);\n// 以 Blob 格式返回数据；\nxhr.responseType = \"blob\";\n\nxhr.onload = function() {\n  if (this.status == 200) {\n    var blob = this.response;\n    var img = document.createElement(\"img\");\n    img.onload = function(e) {\n        window.URL.revokeObjectURL(img.src); // 释放 URL 对象的引用；\n    };\n\n    // 创建对应于 Blob 资源的 URL 引用；\n    img.src = window.URL.createObjectURL(blob);\n    console.log(img.src); // 输出 “blob:https://www.yhspy.com/a94989f8-677b-4819-86ad-efee0fc377a4”；\n    // ...  \n  }\n}\nxhr.send();\n```\n\n**5. 浏览器兼容性列表：**\n\n* Chrome 8.0；\n* Firefox(Gecko) 4.0；\n* IE 10.0；\n* Opera 15.0；\n* bSafari(WebKit) 6.0/7.0；\n\n\n","slug":"前端那些事儿-URL-对象","published":1,"updated":"2019-02-07T00:30:36.306Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtax0068knp26vn2sg4l","content":"<p>在 W3C 最新的 “File API Editor’s Draft, 19 April 2016” 草案中已经明确定义了“URL 对象”的相关属性和方法。“URL 对象”提供了一些专用的属性和方法以用来创建和处理 URL 相关的信息。本文列出了一些基本用法和介绍，在投入生产环境中使用时一定要先关注其<strong>浏览器兼容性列表</strong>，以防止出现兼容性问题。</p>\n<p><strong>1. URL 构造方法：</strong></p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\">url <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">URL</span><span class=\"token punctuation\">(</span>urlString<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>baseURLstring<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nurl <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">URL</span><span class=\"token punctuation\">(</span>urlString<span class=\"token punctuation\">,</span> baseURLobject<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>其中第一个参数 <code>urlString</code> 为字符串类型，表示所构造的 URL 对象中的相对路径或绝对路径（若传入绝对路径，则 URL 构造函数会忽略第二个参数表示的基路径），第二个参数 <code>baseURLstring</code> 同样为字符串类型，代表所构造 URL 对象的基路径，即第一级目录的路径。若第二个参数选择传入一个 <strong>baseURLobject</strong> 对象，则其结果同传入 <strong>baseURLstring</strong> 实际上是一致的。因为对于 <strong>baseURLobject</strong> 来说，其本质是一个 URL 对象，当调用 <code>baseURLobject.toString()</code> 或者 <code>baseURLobject.toLlocalString()</code> 方法时会返回一个当前 URL 对象的字符串表示，这同直接传入一个字符串类型的 <strong>baseURLstring</strong> 参数来说是一样的。以下为一些例子：</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> urlA <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">URL</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"https://www.yhspy.com/\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>urlA<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 输出 “https://www.yhspy.com/”；</span>\n\n<span class=\"token keyword\">var</span> urlB <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">URL</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"https://www.yhspy.com/\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"https://developers.mozilla.com\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>urlB<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 输出 “https://www.yhspy.com/”；</span>\n\n<span class=\"token keyword\">var</span> urlC <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">URL</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/about/\"</span><span class=\"token punctuation\">,</span> urlB<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>urlC<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 输出 “https://www.yhspy.com/about/”；</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>2. 静态方法：</strong> URL.createObjectURL(<em>blob</em>)：</p>\n<p>该方法用来从一个 File 对象或一个 Blob 对象中创建对应该资源的 URL 对象。你可以理解为 <code>URL.createObjectURL(blob)</code> 方法会自动帮你从一个 File 对象或者一个 Blob 对象中创建一个对应该资源的引用，而通过该引用你可以直接在诸如 <code>&lt;img&gt;</code> 标签中的 <code>src</code> 属性里使用该引用对应的资源实体。</p>\n<p><strong>3. 静态方法： </strong> URL.revokeObjectURL(<em>blob</em>)：</p>\n<p>对于每一个使用 <code>URL.createObjectURL(blob)</code> 方法创建的资源引用来说，当 File 或 Blob 资源不再使用时一定要通过 <code>URL.revokeObjectURL(blob)</code> 及时地进行释放，该方法会通知浏览器哪些 URL 引用资源不再使用，以便及时的清理和释放内存。</p>\n<p><strong>4. 例子：</strong></p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">// 获取 URL 对象；</span>\nwindow<span class=\"token punctuation\">.</span>URL <span class=\"token operator\">=</span> window<span class=\"token punctuation\">.</span>URL <span class=\"token operator\">||</span> window<span class=\"token punctuation\">.</span>webkitURL<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// 初始化 XHR 对象，使用 AJAX；</span>\n<span class=\"token keyword\">var</span> xhr <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">XMLHttpRequest</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    \n\nxhr<span class=\"token punctuation\">.</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"get\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"/img/image.jpg\"</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// 以 Blob 格式返回数据；</span>\nxhr<span class=\"token punctuation\">.</span>responseType <span class=\"token operator\">=</span> <span class=\"token string\">\"blob\"</span><span class=\"token punctuation\">;</span>\n\nxhr<span class=\"token punctuation\">.</span>onload <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>status <span class=\"token operator\">==</span> <span class=\"token number\">200</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> blob <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>response<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> img <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"img\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    img<span class=\"token punctuation\">.</span>onload <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        window<span class=\"token punctuation\">.</span>URL<span class=\"token punctuation\">.</span><span class=\"token function\">revokeObjectURL</span><span class=\"token punctuation\">(</span>img<span class=\"token punctuation\">.</span>src<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 释放 URL 对象的引用；</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 创建对应于 Blob 资源的 URL 引用；</span>\n    img<span class=\"token punctuation\">.</span>src <span class=\"token operator\">=</span> window<span class=\"token punctuation\">.</span>URL<span class=\"token punctuation\">.</span><span class=\"token function\">createObjectURL</span><span class=\"token punctuation\">(</span>blob<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>img<span class=\"token punctuation\">.</span>src<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 输出 “blob:https://www.yhspy.com/a94989f8-677b-4819-86ad-efee0fc377a4”；</span>\n    <span class=\"token comment\" spellcheck=\"true\">// ...  </span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\nxhr<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>5. 浏览器兼容性列表：</strong></p>\n<ul>\n<li>Chrome 8.0；</li>\n<li>Firefox(Gecko) 4.0；</li>\n<li>IE 10.0；</li>\n<li>Opera 15.0；</li>\n<li>bSafari(WebKit) 6.0/7.0；</li>\n</ul>\n","site":{"data":{}},"id":"18eb40abc00500ac2190709782d6848c","excerpt":"","more":"<p>在 W3C 最新的 “File API Editor’s Draft, 19 April 2016” 草案中已经明确定义了“URL 对象”的相关属性和方法。“URL 对象”提供了一些专用的属性和方法以用来创建和处理 URL 相关的信息。本文列出了一些基本用法和介绍，在投入生产环境中使用时一定要先关注其<strong>浏览器兼容性列表</strong>，以防止出现兼容性问题。</p>\n<p><strong>1. URL 构造方法：</strong></p>\n<pre><code class=\"javascript\">url = new URL(urlString, [baseURLstring]);\n\nurl = new URL(urlString, baseURLobject);\n</code></pre>\n<p>其中第一个参数 <code>urlString</code> 为字符串类型，表示所构造的 URL 对象中的相对路径或绝对路径（若传入绝对路径，则 URL 构造函数会忽略第二个参数表示的基路径），第二个参数 <code>baseURLstring</code> 同样为字符串类型，代表所构造 URL 对象的基路径，即第一级目录的路径。若第二个参数选择传入一个 <strong>baseURLobject</strong> 对象，则其结果同传入 <strong>baseURLstring</strong> 实际上是一致的。因为对于 <strong>baseURLobject</strong> 来说，其本质是一个 URL 对象，当调用 <code>baseURLobject.toString()</code> 或者 <code>baseURLobject.toLlocalString()</code> 方法时会返回一个当前 URL 对象的字符串表示，这同直接传入一个字符串类型的 <strong>baseURLstring</strong> 参数来说是一样的。以下为一些例子：</p>\n<pre><code class=\"javascript\">var urlA = new URL(&quot;/&quot;, &quot;https://www.yhspy.com/&quot;);\nconsole.log(urlA.toString());  // 输出 “https://www.yhspy.com/”；\n\nvar urlB = new URL(&quot;https://www.yhspy.com/&quot;, &quot;https://developers.mozilla.com&quot;);\nconsole.log(urlB.toString());  // 输出 “https://www.yhspy.com/”；\n\nvar urlC = new URL(&quot;/about/&quot;, urlB);\nconsole.log(urlC.toString());  // 输出 “https://www.yhspy.com/about/”；\n</code></pre>\n<p><strong>2. 静态方法：</strong> URL.createObjectURL(<em>blob</em>)：</p>\n<p>该方法用来从一个 File 对象或一个 Blob 对象中创建对应该资源的 URL 对象。你可以理解为 <code>URL.createObjectURL(blob)</code> 方法会自动帮你从一个 File 对象或者一个 Blob 对象中创建一个对应该资源的引用，而通过该引用你可以直接在诸如 <code>&lt;img&gt;</code> 标签中的 <code>src</code> 属性里使用该引用对应的资源实体。</p>\n<p><strong>3. 静态方法： </strong> URL.revokeObjectURL(<em>blob</em>)：</p>\n<p>对于每一个使用 <code>URL.createObjectURL(blob)</code> 方法创建的资源引用来说，当 File 或 Blob 资源不再使用时一定要通过 <code>URL.revokeObjectURL(blob)</code> 及时地进行释放，该方法会通知浏览器哪些 URL 引用资源不再使用，以便及时的清理和释放内存。</p>\n<p><strong>4. 例子：</strong></p>\n<pre><code class=\"javascript\">// 获取 URL 对象；\nwindow.URL = window.URL || window.webkitURL;\n// 初始化 XHR 对象，使用 AJAX；\nvar xhr = new XMLHttpRequest();    \n\nxhr.open(&quot;get&quot;, &quot;/img/image.jpg&quot;, true);\n// 以 Blob 格式返回数据；\nxhr.responseType = &quot;blob&quot;;\n\nxhr.onload = function() {\n  if (this.status == 200) {\n    var blob = this.response;\n    var img = document.createElement(&quot;img&quot;);\n    img.onload = function(e) {\n        window.URL.revokeObjectURL(img.src); // 释放 URL 对象的引用；\n    };\n\n    // 创建对应于 Blob 资源的 URL 引用；\n    img.src = window.URL.createObjectURL(blob);\n    console.log(img.src); // 输出 “blob:https://www.yhspy.com/a94989f8-677b-4819-86ad-efee0fc377a4”；\n    // ...  \n  }\n}\nxhr.send();\n</code></pre>\n<p><strong>5. 浏览器兼容性列表：</strong></p>\n<ul>\n<li>Chrome 8.0；</li>\n<li>Firefox(Gecko) 4.0；</li>\n<li>IE 10.0；</li>\n<li>Opera 15.0；</li>\n<li>bSafari(WebKit) 6.0/7.0；</li>\n</ul>\n"},{"title":"前端那些事儿 - 表单域的 MIME 编码","intro":"表单是我们在前端开发中最经常使用的 HTML 控件之一。表单可以用来提交用户输入的信息，比如用户名和密码，甚至用户的头像以及声音。但是这些信息的种类却多种多样，那么在表的单提交过程中浏览器是怎样处理这些用户信息的呢？","comments":1,"date":"2015-11-24T10:10:07.000Z","_content":"\n表单是我们在前端开发中最经常使用的 HTML 控件之一。表单可以用来提交用户输入的信息，比如用户名和密码，甚至用户的头像以及声音。但是这些信息的种类却多种多样，那么在表的单提交过程中浏览器是怎样处理这些用户信息的呢？\n\n其实在用户提交表单时，浏览器会根据用户所提交表单的内容类型来对表单进行不同的编码。我们也称其为表单的 MIME(Multipurpose Internet Mail Extensions) 编码。MIME 翻译过来就是“多功能 Internet 邮件扩充服务”，它是一种多用途网际邮件扩充协议，最早在1992年应用于电子邮件系统，后来逐渐也应用到浏览器。服务器会将它们发送的多媒体数据类型告诉浏览器，而通知手段就是设置该多媒体数据的 MIME 编码类型，从而让浏览器知道接收到的信息哪些是 MP3 文件，哪些是 Shockwave 文件等。\n\n相反的，浏览器在向服务器发送数据的时候也需要指定表单内容的 MIME 编码类型，但相对于服务器众多的编码类型，浏览器的 MIME 编码类型主要有三种：\n\n* application/x-www-form-urlencoded；\n* multipart/form-data；\n* text/plain；\n\n\n第一种 “application/x-www-form-urlencoded” 为浏览器默认的标准编码类型，用于编码常用的“键值对”数据，比如 `radio`、`checkbox` 以及 `textarea` 等表单元素的信息便可以用元素的 `name` 和 `value` 属性来组成“键值对”以表示数据。而第二种 “multipart/form-data” 主要用于编码文件类型的数据，即表单域里诸如 `<input type=\"file\">` 元素所提交的数据。而第三种 “text/plain” 则主要用于编码纯文本数据（不含表单元素的纯文本），并不常用。\n\n![](1.jpg)\n\n当浏览器使用 “application/x-www-form-urlencoded” 编码以 GET 方式发送数据时，浏览器会用 “x-www-form-urlencoded” 的编码方式把表单域内的数据转换成一个字符串（类似：name1=value1&name2=value2 ...），接下来把这个字符串通过“?”连接到整个 URL 的最后，然后来加载这个拼接后的 URL。当发送数据的方式为 POST 时，浏览器会把表单域的数据封装到 HTTP 请求的请求体中，并在请求头中指明请求内容的编码类型（Content-Type 字段）和请求体的数据分隔符（Boundary 字段）随后发送到服务器。对于请求头中的编码类型，如果表单域没有 `<input type=\"file\">` 控件，浏览器标注为 “application/x-www-form-urlencoded”。否则会标注为 “multipart/form-data”。\n\n![](2.jpg)\n\n\n对于以 POST 方式发送的含有 `<input type=\"file\">` 控件的表单时，浏览器会把整个表单以控件为单位进行分割，并为每个部分加上 Content-Disposition (对应 form-data 或者 file 类型)，Content-Type (默认为 text/plain，或者为 application/octet-stream 八进制流，一般为文件类型)，name (各个控件的 name 属性)等信息，并为每一段控件的数据加上分割符 (Boundary)。\n\n写在最后，别忘了当表单内部需要提交文件类型数据时别忘了在 form 便签内添加 `enctype=\"multipart/form-data\"` 。\n","source":"_posts/前端那些事儿-表单域的-MIME-编码.md","raw":"---\ntitle: 前端那些事儿 - 表单域的 MIME 编码\nintro: 表单是我们在前端开发中最经常使用的 HTML 控件之一。表单可以用来提交用户输入的信息，比如用户名和密码，甚至用户的头像以及声音。但是这些信息的种类却多种多样，那么在表的单提交过程中浏览器是怎样处理这些用户信息的呢？\ncomments: true\ndate: 2015-11-24 18:10:07\ntags:\n- Web\n---\n\n表单是我们在前端开发中最经常使用的 HTML 控件之一。表单可以用来提交用户输入的信息，比如用户名和密码，甚至用户的头像以及声音。但是这些信息的种类却多种多样，那么在表的单提交过程中浏览器是怎样处理这些用户信息的呢？\n\n其实在用户提交表单时，浏览器会根据用户所提交表单的内容类型来对表单进行不同的编码。我们也称其为表单的 MIME(Multipurpose Internet Mail Extensions) 编码。MIME 翻译过来就是“多功能 Internet 邮件扩充服务”，它是一种多用途网际邮件扩充协议，最早在1992年应用于电子邮件系统，后来逐渐也应用到浏览器。服务器会将它们发送的多媒体数据类型告诉浏览器，而通知手段就是设置该多媒体数据的 MIME 编码类型，从而让浏览器知道接收到的信息哪些是 MP3 文件，哪些是 Shockwave 文件等。\n\n相反的，浏览器在向服务器发送数据的时候也需要指定表单内容的 MIME 编码类型，但相对于服务器众多的编码类型，浏览器的 MIME 编码类型主要有三种：\n\n* application/x-www-form-urlencoded；\n* multipart/form-data；\n* text/plain；\n\n\n第一种 “application/x-www-form-urlencoded” 为浏览器默认的标准编码类型，用于编码常用的“键值对”数据，比如 `radio`、`checkbox` 以及 `textarea` 等表单元素的信息便可以用元素的 `name` 和 `value` 属性来组成“键值对”以表示数据。而第二种 “multipart/form-data” 主要用于编码文件类型的数据，即表单域里诸如 `<input type=\"file\">` 元素所提交的数据。而第三种 “text/plain” 则主要用于编码纯文本数据（不含表单元素的纯文本），并不常用。\n\n![](1.jpg)\n\n当浏览器使用 “application/x-www-form-urlencoded” 编码以 GET 方式发送数据时，浏览器会用 “x-www-form-urlencoded” 的编码方式把表单域内的数据转换成一个字符串（类似：name1=value1&name2=value2 ...），接下来把这个字符串通过“?”连接到整个 URL 的最后，然后来加载这个拼接后的 URL。当发送数据的方式为 POST 时，浏览器会把表单域的数据封装到 HTTP 请求的请求体中，并在请求头中指明请求内容的编码类型（Content-Type 字段）和请求体的数据分隔符（Boundary 字段）随后发送到服务器。对于请求头中的编码类型，如果表单域没有 `<input type=\"file\">` 控件，浏览器标注为 “application/x-www-form-urlencoded”。否则会标注为 “multipart/form-data”。\n\n![](2.jpg)\n\n\n对于以 POST 方式发送的含有 `<input type=\"file\">` 控件的表单时，浏览器会把整个表单以控件为单位进行分割，并为每个部分加上 Content-Disposition (对应 form-data 或者 file 类型)，Content-Type (默认为 text/plain，或者为 application/octet-stream 八进制流，一般为文件类型)，name (各个控件的 name 属性)等信息，并为每一段控件的数据加上分割符 (Boundary)。\n\n写在最后，别忘了当表单内部需要提交文件类型数据时别忘了在 form 便签内添加 `enctype=\"multipart/form-data\"` 。\n","slug":"前端那些事儿-表单域的-MIME-编码","published":1,"updated":"2019-02-05T07:43:53.371Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtay006bknp258xt8yid","content":"<p>表单是我们在前端开发中最经常使用的 HTML 控件之一。表单可以用来提交用户输入的信息，比如用户名和密码，甚至用户的头像以及声音。但是这些信息的种类却多种多样，那么在表的单提交过程中浏览器是怎样处理这些用户信息的呢？</p>\n<p>其实在用户提交表单时，浏览器会根据用户所提交表单的内容类型来对表单进行不同的编码。我们也称其为表单的 MIME(Multipurpose Internet Mail Extensions) 编码。MIME 翻译过来就是“多功能 Internet 邮件扩充服务”，它是一种多用途网际邮件扩充协议，最早在1992年应用于电子邮件系统，后来逐渐也应用到浏览器。服务器会将它们发送的多媒体数据类型告诉浏览器，而通知手段就是设置该多媒体数据的 MIME 编码类型，从而让浏览器知道接收到的信息哪些是 MP3 文件，哪些是 Shockwave 文件等。</p>\n<p>相反的，浏览器在向服务器发送数据的时候也需要指定表单内容的 MIME 编码类型，但相对于服务器众多的编码类型，浏览器的 MIME 编码类型主要有三种：</p>\n<ul>\n<li>application/x-www-form-urlencoded；</li>\n<li>multipart/form-data；</li>\n<li>text/plain；</li>\n</ul>\n<p>第一种 “application/x-www-form-urlencoded” 为浏览器默认的标准编码类型，用于编码常用的“键值对”数据，比如 <code>radio</code>、<code>checkbox</code> 以及 <code>textarea</code> 等表单元素的信息便可以用元素的 <code>name</code> 和 <code>value</code> 属性来组成“键值对”以表示数据。而第二种 “multipart/form-data” 主要用于编码文件类型的数据，即表单域里诸如 <code>&lt;input type=&quot;file&quot;&gt;</code> 元素所提交的数据。而第三种 “text/plain” 则主要用于编码纯文本数据（不含表单元素的纯文本），并不常用。</p>\n<p><img src=\"1.jpg\" alt></p>\n<p>当浏览器使用 “application/x-www-form-urlencoded” 编码以 GET 方式发送数据时，浏览器会用 “x-www-form-urlencoded” 的编码方式把表单域内的数据转换成一个字符串（类似：name1=value1&amp;name2=value2 …），接下来把这个字符串通过“?”连接到整个 URL 的最后，然后来加载这个拼接后的 URL。当发送数据的方式为 POST 时，浏览器会把表单域的数据封装到 HTTP 请求的请求体中，并在请求头中指明请求内容的编码类型（Content-Type 字段）和请求体的数据分隔符（Boundary 字段）随后发送到服务器。对于请求头中的编码类型，如果表单域没有 <code>&lt;input type=&quot;file&quot;&gt;</code> 控件，浏览器标注为 “application/x-www-form-urlencoded”。否则会标注为 “multipart/form-data”。</p>\n<p><img src=\"2.jpg\" alt></p>\n<p>对于以 POST 方式发送的含有 <code>&lt;input type=&quot;file&quot;&gt;</code> 控件的表单时，浏览器会把整个表单以控件为单位进行分割，并为每个部分加上 Content-Disposition (对应 form-data 或者 file 类型)，Content-Type (默认为 text/plain，或者为 application/octet-stream 八进制流，一般为文件类型)，name (各个控件的 name 属性)等信息，并为每一段控件的数据加上分割符 (Boundary)。</p>\n<p>写在最后，别忘了当表单内部需要提交文件类型数据时别忘了在 form 便签内添加 <code>enctype=&quot;multipart/form-data&quot;</code> 。</p>\n","site":{"data":{}},"id":"2b143e7004b0f613d5d83a4622fa2421","excerpt":"","more":"<p>表单是我们在前端开发中最经常使用的 HTML 控件之一。表单可以用来提交用户输入的信息，比如用户名和密码，甚至用户的头像以及声音。但是这些信息的种类却多种多样，那么在表的单提交过程中浏览器是怎样处理这些用户信息的呢？</p>\n<p>其实在用户提交表单时，浏览器会根据用户所提交表单的内容类型来对表单进行不同的编码。我们也称其为表单的 MIME(Multipurpose Internet Mail Extensions) 编码。MIME 翻译过来就是“多功能 Internet 邮件扩充服务”，它是一种多用途网际邮件扩充协议，最早在1992年应用于电子邮件系统，后来逐渐也应用到浏览器。服务器会将它们发送的多媒体数据类型告诉浏览器，而通知手段就是设置该多媒体数据的 MIME 编码类型，从而让浏览器知道接收到的信息哪些是 MP3 文件，哪些是 Shockwave 文件等。</p>\n<p>相反的，浏览器在向服务器发送数据的时候也需要指定表单内容的 MIME 编码类型，但相对于服务器众多的编码类型，浏览器的 MIME 编码类型主要有三种：</p>\n<ul>\n<li>application/x-www-form-urlencoded；</li>\n<li>multipart/form-data；</li>\n<li>text/plain；</li>\n</ul>\n<p>第一种 “application/x-www-form-urlencoded” 为浏览器默认的标准编码类型，用于编码常用的“键值对”数据，比如 <code>radio</code>、<code>checkbox</code> 以及 <code>textarea</code> 等表单元素的信息便可以用元素的 <code>name</code> 和 <code>value</code> 属性来组成“键值对”以表示数据。而第二种 “multipart/form-data” 主要用于编码文件类型的数据，即表单域里诸如 <code>&lt;input type=&quot;file&quot;&gt;</code> 元素所提交的数据。而第三种 “text/plain” 则主要用于编码纯文本数据（不含表单元素的纯文本），并不常用。</p>\n<p><img src=\"1.jpg\" alt></p>\n<p>当浏览器使用 “application/x-www-form-urlencoded” 编码以 GET 方式发送数据时，浏览器会用 “x-www-form-urlencoded” 的编码方式把表单域内的数据转换成一个字符串（类似：name1=value1&amp;name2=value2 …），接下来把这个字符串通过“?”连接到整个 URL 的最后，然后来加载这个拼接后的 URL。当发送数据的方式为 POST 时，浏览器会把表单域的数据封装到 HTTP 请求的请求体中，并在请求头中指明请求内容的编码类型（Content-Type 字段）和请求体的数据分隔符（Boundary 字段）随后发送到服务器。对于请求头中的编码类型，如果表单域没有 <code>&lt;input type=&quot;file&quot;&gt;</code> 控件，浏览器标注为 “application/x-www-form-urlencoded”。否则会标注为 “multipart/form-data”。</p>\n<p><img src=\"2.jpg\" alt></p>\n<p>对于以 POST 方式发送的含有 <code>&lt;input type=&quot;file&quot;&gt;</code> 控件的表单时，浏览器会把整个表单以控件为单位进行分割，并为每个部分加上 Content-Disposition (对应 form-data 或者 file 类型)，Content-Type (默认为 text/plain，或者为 application/octet-stream 八进制流，一般为文件类型)，name (各个控件的 name 属性)等信息，并为每一段控件的数据加上分割符 (Boundary)。</p>\n<p>写在最后，别忘了当表单内部需要提交文件类型数据时别忘了在 form 便签内添加 <code>enctype=&quot;multipart/form-data&quot;</code> 。</p>\n"},{"title":"前端那些事儿 - 三字节 BOM 头","intro":"今天在修复一个后台 BUG 的时候遇到了很奇怪的问题，从服务器端返回来的数据是 JSON 格式的，并且打印以及 Base64 编码解码之后均为正确的 JSON 字符串格式，但偏偏 PHP 内置的 JSON_decode 函数却无法正常解码，一直返回空的解析结果。遂借此机会研究了一番，发现这其中的一些不为人知的秘密。","comments":1,"date":"2016-01-06T08:10:17.000Z","_content":"\n今天在修复一个后台 BUG 的时候遇到了很奇怪的问题，从服务器端返回来的数据是 JSON 格式的，并且打印以及 Base64 编码解码之后均为正确的 JSON 字符串格式，但偏偏 PHP 内置的 `JSON_decode` 函数却无法正常解码，一直返回空的解析结果。遂借此机会研究了一番，发现这其中的一些不为人知的秘密。\n\n于是，查询了 PHP 官网文档，发现 `JSON_decode` 函数对解析的 JSON 字符串有着严格的要求：\n\n1. JSON 字符串必须是以 UTF8 格式编码的；\n2. 字符串格式必须完整准确，最后的元素不能有逗号存在；\n3. 所有元素必须使用双引号；\n4. 元素中不能含有控制或转义字符；\n\n接下来对应着文档的标准 JSON 字符串格式要求，我们可以逐条进行测试：\n\n```php\n<?php\n    // 使用 utf8_encode 方法编码 JSON 字符串；\n    $result = JSON_decode(utf8_encode($response), true);\n```\n\n使用 UTF8 编码 JSON 字符串并没有解决问题，发现输出的 UTF8 编码过的 JSON 字符串最前端部分存在乱码。对于 JSON 字符串的格式是否正确和是否使用双引号可以通过 `print_r` 函数把响应数据打印到页面直接观察来得到。接下来去掉 JSON 字符串中的控制和转义字符。\n\n```php\n<?php\n    // 去掉 JSON 字符串中的换行符(\"\\\\\"换成\"\\\")；\n    $order = array(\"\\\\r\\\\n\", \"\\\\r\", \"\\\\n\");\n    str_replace($order, '', $response);\n```\n\n至此，问题依然没有解决，接下来还是从之前发现的 UTF8 编码后 JSON 字符串存在乱码入手。乱码位于 JSON 字符串的最前端，并且是在经过 UTF8 编码之后产生的。`utf8_encode` 方法也会将不可见的标识或控制字符进行编码。因此怀疑是存在隐藏的标识字符或者控制字符。\n\n大家都知道，PHP 对 BOM头 并不能很好的识别，所以很多时候 PHP 在解析含有 BOM 头的页面时，常常会将 BOM 的三个字符输出到页面中，导致解析出现问题。那么 BOM 到底是什么呢？\n\n**以下内容来自百度百科**：\n\nUnicode 规范中有一个 BOM 的概念。BOM(Byte Order Mark)，翻译过来就是“字节序标记“。在这里找到一段关于 BOM 的说明：\n\n在 UCS 编码中有一个叫做 \"ZERO WIDTH NO-BREAK SPACE\" 的字符，它的编码是 FEFF。而 FFFE 在 UCS 中是不存在的字符，所以不应该出现在实际的数据传输过程中。UCS 规范建议我们在传输字节流前，先传输字符 \"ZERO WIDTH NO-BREAK SPACE\"。这样如果接收者收到 FEFF，就表明这个字节流是 “Big-Endian“ 的；如果收到 FFFE，就表明这个字节流是 “Little-Endian” 的。因此字符 \"ZERO WIDTH NO-BREAK SPACE\" 又被称作 BOM。\n\nUTF-8 不需要 BOM 来表明字节顺序，但可以用 BOM 来表明编码方式。字符 \"ZERO WIDTH NO-BREAK SPACE\" 的 UTF-8 编码是 “EF BB BF”。所以如果接收者收到以 “EF BB BF” 开头的字节流，就知道这是 UTF-8 编码了。\n\nWindows 记事本就是使用 BOM 来标记文本文件的编码方式的。\n\nUTF-8 编码的文件中，BOM 占三个字节。如果用记事本把一个文本文件另存为 UTF-8 编码方式的话，再用 UE 打开这个文件，切换到十六进制编辑状态就可以看到开头的 FFFE 了。这是个标识 UTF-8 编码文件的好办法，软件通过 BOM 来识别这个文件是否是 UTF-8 编码，很多软件还要求读入的文件必须带 BOM。可是，还是有很多软件不能识别 BOM。我在研究 Firefox 的时候就知道，在 Firefox 早期的版本里，扩展是不能有 BOM 的，不过 Firefox 自从 1.5 以后的版本已经开始支持 BOM 了。如今又发现，PHP 也不支持 BOM。\n\nPHP 在设计时就没有考虑 BOM 的问题，也就是说他不会忽略 UTF-8 编码的文件开头 BOM 的那三个字符。由于必须在 “<?” 或者 “<?php” 标记后面的代码才会被作为 PHP 代码执行，所以这三个字符将会直接输出。如果插件的文件有这个问题，将会导致在后台页面里激活或者不激活插件后显示白屏，如果是模版文件有这个问题，将会导致这三个字符直接输出，造成页面上方有一个小空行。国外的英文插件和模版一般都是用的 ASCⅡ 码的编码方式，不会有 BOM，只有国内的插件和模版会由于作者的不知情造成问题。还有，大家修改模版的时候，由于输出页面使用 UTF-8 编码，那么修改模版的时候如果有加入中文字符的话，必须把文件转成 UTF-8 编码才能正常显示，这个时候如果所使用的编辑器自动加上了 BOM 的话，将会造成在页面上输出这三个字符，显示效果就要看浏览器了，一般是一个空行或是一个乱码。\n\n简单的说，BOM 头就是用来表示文件编码方式几个字符，而在 UTF8 编码的文件中，BOM 头有三个字符，分别是：`0xEF 0xBB 0xBF`。\n\n```php\n<?php\n    // 去掉 BOM 头字符；\n    $result = JSON_decode(trim($response, chr(239).chr(187).chr(191)),true);\n```\n\n至此，终于找到了问题所在。其实我们在调试过程中并不需要这么麻烦，直接通过 `JSON_last_error` 函数即可获得最后一次 `JSON_decode` 函数执行失败的原因。\n\n最后，封装一个完备的 `JSON_decode` 函数：\n\n```php\n<?php\n    public function JSONDecode($content) {\n        // 去空格和占位符(\"\\\\\"换成\"\\\")；\n        $order = array(\"\\\\r\\\\n\", \"\\\\r\", \"\\\\n\");\n        str_replace($order, '', $content);\n        // 去掉 BOM 头；\n        $content = trim($response, chr(239).chr(187).chr(191));\n        // 使用 UTF-8 编码；\n        $content = utf8_encode($response);\n        // 解析并返回生成的数组；\n        return JSON_decode($content, true);\n    }\n```\n\n","source":"_posts/前端那些事儿-三字节-BOM-头.md","raw":"---\ntitle: 前端那些事儿 - 三字节 BOM 头\nintro: 今天在修复一个后台 BUG 的时候遇到了很奇怪的问题，从服务器端返回来的数据是 JSON 格式的，并且打印以及 Base64 编码解码之后均为正确的 JSON 字符串格式，但偏偏 PHP 内置的 JSON_decode 函数却无法正常解码，一直返回空的解析结果。遂借此机会研究了一番，发现这其中的一些不为人知的秘密。\ncomments: true\ndate: 2016-01-06 16:10:17\ntags:\n- Web\n---\n\n今天在修复一个后台 BUG 的时候遇到了很奇怪的问题，从服务器端返回来的数据是 JSON 格式的，并且打印以及 Base64 编码解码之后均为正确的 JSON 字符串格式，但偏偏 PHP 内置的 `JSON_decode` 函数却无法正常解码，一直返回空的解析结果。遂借此机会研究了一番，发现这其中的一些不为人知的秘密。\n\n于是，查询了 PHP 官网文档，发现 `JSON_decode` 函数对解析的 JSON 字符串有着严格的要求：\n\n1. JSON 字符串必须是以 UTF8 格式编码的；\n2. 字符串格式必须完整准确，最后的元素不能有逗号存在；\n3. 所有元素必须使用双引号；\n4. 元素中不能含有控制或转义字符；\n\n接下来对应着文档的标准 JSON 字符串格式要求，我们可以逐条进行测试：\n\n```php\n<?php\n    // 使用 utf8_encode 方法编码 JSON 字符串；\n    $result = JSON_decode(utf8_encode($response), true);\n```\n\n使用 UTF8 编码 JSON 字符串并没有解决问题，发现输出的 UTF8 编码过的 JSON 字符串最前端部分存在乱码。对于 JSON 字符串的格式是否正确和是否使用双引号可以通过 `print_r` 函数把响应数据打印到页面直接观察来得到。接下来去掉 JSON 字符串中的控制和转义字符。\n\n```php\n<?php\n    // 去掉 JSON 字符串中的换行符(\"\\\\\"换成\"\\\")；\n    $order = array(\"\\\\r\\\\n\", \"\\\\r\", \"\\\\n\");\n    str_replace($order, '', $response);\n```\n\n至此，问题依然没有解决，接下来还是从之前发现的 UTF8 编码后 JSON 字符串存在乱码入手。乱码位于 JSON 字符串的最前端，并且是在经过 UTF8 编码之后产生的。`utf8_encode` 方法也会将不可见的标识或控制字符进行编码。因此怀疑是存在隐藏的标识字符或者控制字符。\n\n大家都知道，PHP 对 BOM头 并不能很好的识别，所以很多时候 PHP 在解析含有 BOM 头的页面时，常常会将 BOM 的三个字符输出到页面中，导致解析出现问题。那么 BOM 到底是什么呢？\n\n**以下内容来自百度百科**：\n\nUnicode 规范中有一个 BOM 的概念。BOM(Byte Order Mark)，翻译过来就是“字节序标记“。在这里找到一段关于 BOM 的说明：\n\n在 UCS 编码中有一个叫做 \"ZERO WIDTH NO-BREAK SPACE\" 的字符，它的编码是 FEFF。而 FFFE 在 UCS 中是不存在的字符，所以不应该出现在实际的数据传输过程中。UCS 规范建议我们在传输字节流前，先传输字符 \"ZERO WIDTH NO-BREAK SPACE\"。这样如果接收者收到 FEFF，就表明这个字节流是 “Big-Endian“ 的；如果收到 FFFE，就表明这个字节流是 “Little-Endian” 的。因此字符 \"ZERO WIDTH NO-BREAK SPACE\" 又被称作 BOM。\n\nUTF-8 不需要 BOM 来表明字节顺序，但可以用 BOM 来表明编码方式。字符 \"ZERO WIDTH NO-BREAK SPACE\" 的 UTF-8 编码是 “EF BB BF”。所以如果接收者收到以 “EF BB BF” 开头的字节流，就知道这是 UTF-8 编码了。\n\nWindows 记事本就是使用 BOM 来标记文本文件的编码方式的。\n\nUTF-8 编码的文件中，BOM 占三个字节。如果用记事本把一个文本文件另存为 UTF-8 编码方式的话，再用 UE 打开这个文件，切换到十六进制编辑状态就可以看到开头的 FFFE 了。这是个标识 UTF-8 编码文件的好办法，软件通过 BOM 来识别这个文件是否是 UTF-8 编码，很多软件还要求读入的文件必须带 BOM。可是，还是有很多软件不能识别 BOM。我在研究 Firefox 的时候就知道，在 Firefox 早期的版本里，扩展是不能有 BOM 的，不过 Firefox 自从 1.5 以后的版本已经开始支持 BOM 了。如今又发现，PHP 也不支持 BOM。\n\nPHP 在设计时就没有考虑 BOM 的问题，也就是说他不会忽略 UTF-8 编码的文件开头 BOM 的那三个字符。由于必须在 “<?” 或者 “<?php” 标记后面的代码才会被作为 PHP 代码执行，所以这三个字符将会直接输出。如果插件的文件有这个问题，将会导致在后台页面里激活或者不激活插件后显示白屏，如果是模版文件有这个问题，将会导致这三个字符直接输出，造成页面上方有一个小空行。国外的英文插件和模版一般都是用的 ASCⅡ 码的编码方式，不会有 BOM，只有国内的插件和模版会由于作者的不知情造成问题。还有，大家修改模版的时候，由于输出页面使用 UTF-8 编码，那么修改模版的时候如果有加入中文字符的话，必须把文件转成 UTF-8 编码才能正常显示，这个时候如果所使用的编辑器自动加上了 BOM 的话，将会造成在页面上输出这三个字符，显示效果就要看浏览器了，一般是一个空行或是一个乱码。\n\n简单的说，BOM 头就是用来表示文件编码方式几个字符，而在 UTF8 编码的文件中，BOM 头有三个字符，分别是：`0xEF 0xBB 0xBF`。\n\n```php\n<?php\n    // 去掉 BOM 头字符；\n    $result = JSON_decode(trim($response, chr(239).chr(187).chr(191)),true);\n```\n\n至此，终于找到了问题所在。其实我们在调试过程中并不需要这么麻烦，直接通过 `JSON_last_error` 函数即可获得最后一次 `JSON_decode` 函数执行失败的原因。\n\n最后，封装一个完备的 `JSON_decode` 函数：\n\n```php\n<?php\n    public function JSONDecode($content) {\n        // 去空格和占位符(\"\\\\\"换成\"\\\")；\n        $order = array(\"\\\\r\\\\n\", \"\\\\r\", \"\\\\n\");\n        str_replace($order, '', $content);\n        // 去掉 BOM 头；\n        $content = trim($response, chr(239).chr(187).chr(191));\n        // 使用 UTF-8 编码；\n        $content = utf8_encode($response);\n        // 解析并返回生成的数组；\n        return JSON_decode($content, true);\n    }\n```\n\n","slug":"前端那些事儿-三字节-BOM-头","published":1,"updated":"2019-02-05T08:22:52.553Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtaz006dknp2uowtrlv3","content":"<p>今天在修复一个后台 BUG 的时候遇到了很奇怪的问题，从服务器端返回来的数据是 JSON 格式的，并且打印以及 Base64 编码解码之后均为正确的 JSON 字符串格式，但偏偏 PHP 内置的 <code>JSON_decode</code> 函数却无法正常解码，一直返回空的解析结果。遂借此机会研究了一番，发现这其中的一些不为人知的秘密。</p>\n<p>于是，查询了 PHP 官网文档，发现 <code>JSON_decode</code> 函数对解析的 JSON 字符串有着严格的要求：</p>\n<ol>\n<li>JSON 字符串必须是以 UTF8 格式编码的；</li>\n<li>字符串格式必须完整准确，最后的元素不能有逗号存在；</li>\n<li>所有元素必须使用双引号；</li>\n<li>元素中不能含有控制或转义字符；</li>\n</ol>\n<p>接下来对应着文档的标准 JSON 字符串格式要求，我们可以逐条进行测试：</p>\n<pre class=\"line-numbers language-php\"><code class=\"language-php\"><span class=\"token delimiter\">&lt;?php</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 使用 utf8_encode 方法编码 JSON 字符串；</span>\n    <span class=\"token variable\">$result</span> <span class=\"token operator\">=</span> <span class=\"token function\">JSON_decode</span><span class=\"token punctuation\">(</span><span class=\"token function\">utf8_encode</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$response</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>使用 UTF8 编码 JSON 字符串并没有解决问题，发现输出的 UTF8 编码过的 JSON 字符串最前端部分存在乱码。对于 JSON 字符串的格式是否正确和是否使用双引号可以通过 <code>print_r</code> 函数把响应数据打印到页面直接观察来得到。接下来去掉 JSON 字符串中的控制和转义字符。</p>\n<pre class=\"line-numbers language-php\"><code class=\"language-php\"><span class=\"token delimiter\">&lt;?php</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 去掉 JSON 字符串中的换行符(\"\\\\\"换成\"\\\")；</span>\n    <span class=\"token variable\">$order</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">array</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\\\\r\\\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\\\\r\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\\\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">str_replace</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$order</span><span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">,</span> <span class=\"token variable\">$response</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>至此，问题依然没有解决，接下来还是从之前发现的 UTF8 编码后 JSON 字符串存在乱码入手。乱码位于 JSON 字符串的最前端，并且是在经过 UTF8 编码之后产生的。<code>utf8_encode</code> 方法也会将不可见的标识或控制字符进行编码。因此怀疑是存在隐藏的标识字符或者控制字符。</p>\n<p>大家都知道，PHP 对 BOM头 并不能很好的识别，所以很多时候 PHP 在解析含有 BOM 头的页面时，常常会将 BOM 的三个字符输出到页面中，导致解析出现问题。那么 BOM 到底是什么呢？</p>\n<p><strong>以下内容来自百度百科</strong>：</p>\n<p>Unicode 规范中有一个 BOM 的概念。BOM(Byte Order Mark)，翻译过来就是“字节序标记“。在这里找到一段关于 BOM 的说明：</p>\n<p>在 UCS 编码中有一个叫做 “ZERO WIDTH NO-BREAK SPACE” 的字符，它的编码是 FEFF。而 FFFE 在 UCS 中是不存在的字符，所以不应该出现在实际的数据传输过程中。UCS 规范建议我们在传输字节流前，先传输字符 “ZERO WIDTH NO-BREAK SPACE”。这样如果接收者收到 FEFF，就表明这个字节流是 “Big-Endian“ 的；如果收到 FFFE，就表明这个字节流是 “Little-Endian” 的。因此字符 “ZERO WIDTH NO-BREAK SPACE” 又被称作 BOM。</p>\n<p>UTF-8 不需要 BOM 来表明字节顺序，但可以用 BOM 来表明编码方式。字符 “ZERO WIDTH NO-BREAK SPACE” 的 UTF-8 编码是 “EF BB BF”。所以如果接收者收到以 “EF BB BF” 开头的字节流，就知道这是 UTF-8 编码了。</p>\n<p>Windows 记事本就是使用 BOM 来标记文本文件的编码方式的。</p>\n<p>UTF-8 编码的文件中，BOM 占三个字节。如果用记事本把一个文本文件另存为 UTF-8 编码方式的话，再用 UE 打开这个文件，切换到十六进制编辑状态就可以看到开头的 FFFE 了。这是个标识 UTF-8 编码文件的好办法，软件通过 BOM 来识别这个文件是否是 UTF-8 编码，很多软件还要求读入的文件必须带 BOM。可是，还是有很多软件不能识别 BOM。我在研究 Firefox 的时候就知道，在 Firefox 早期的版本里，扩展是不能有 BOM 的，不过 Firefox 自从 1.5 以后的版本已经开始支持 BOM 了。如今又发现，PHP 也不支持 BOM。</p>\n<p>PHP 在设计时就没有考虑 BOM 的问题，也就是说他不会忽略 UTF-8 编码的文件开头 BOM 的那三个字符。由于必须在 “&lt;?” 或者 “&lt;?php” 标记后面的代码才会被作为 PHP 代码执行，所以这三个字符将会直接输出。如果插件的文件有这个问题，将会导致在后台页面里激活或者不激活插件后显示白屏，如果是模版文件有这个问题，将会导致这三个字符直接输出，造成页面上方有一个小空行。国外的英文插件和模版一般都是用的 ASCⅡ 码的编码方式，不会有 BOM，只有国内的插件和模版会由于作者的不知情造成问题。还有，大家修改模版的时候，由于输出页面使用 UTF-8 编码，那么修改模版的时候如果有加入中文字符的话，必须把文件转成 UTF-8 编码才能正常显示，这个时候如果所使用的编辑器自动加上了 BOM 的话，将会造成在页面上输出这三个字符，显示效果就要看浏览器了，一般是一个空行或是一个乱码。</p>\n<p>简单的说，BOM 头就是用来表示文件编码方式几个字符，而在 UTF8 编码的文件中，BOM 头有三个字符，分别是：<code>0xEF 0xBB 0xBF</code>。</p>\n<pre class=\"line-numbers language-php\"><code class=\"language-php\"><span class=\"token delimiter\">&lt;?php</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 去掉 BOM 头字符；</span>\n    <span class=\"token variable\">$result</span> <span class=\"token operator\">=</span> <span class=\"token function\">JSON_decode</span><span class=\"token punctuation\">(</span><span class=\"token function\">trim</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$response</span><span class=\"token punctuation\">,</span> <span class=\"token function\">chr</span><span class=\"token punctuation\">(</span><span class=\"token number\">239</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">chr</span><span class=\"token punctuation\">(</span><span class=\"token number\">187</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">chr</span><span class=\"token punctuation\">(</span><span class=\"token number\">191</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>至此，终于找到了问题所在。其实我们在调试过程中并不需要这么麻烦，直接通过 <code>JSON_last_error</code> 函数即可获得最后一次 <code>JSON_decode</code> 函数执行失败的原因。</p>\n<p>最后，封装一个完备的 <code>JSON_decode</code> 函数：</p>\n<pre class=\"line-numbers language-php\"><code class=\"language-php\"><span class=\"token delimiter\">&lt;?php</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">function</span> <span class=\"token function\">JSONDecode</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$content</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 去空格和占位符(\"\\\\\"换成\"\\\")；</span>\n        <span class=\"token variable\">$order</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">array</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\\\\r\\\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\\\\r\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\\\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">str_replace</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$order</span><span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">,</span> <span class=\"token variable\">$content</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 去掉 BOM 头；</span>\n        <span class=\"token variable\">$content</span> <span class=\"token operator\">=</span> <span class=\"token function\">trim</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$response</span><span class=\"token punctuation\">,</span> <span class=\"token function\">chr</span><span class=\"token punctuation\">(</span><span class=\"token number\">239</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">chr</span><span class=\"token punctuation\">(</span><span class=\"token number\">187</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">chr</span><span class=\"token punctuation\">(</span><span class=\"token number\">191</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 使用 UTF-8 编码；</span>\n        <span class=\"token variable\">$content</span> <span class=\"token operator\">=</span> <span class=\"token function\">utf8_encode</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$response</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 解析并返回生成的数组；</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">JSON_decode</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$content</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"id":"bebfb905100f29f00c582db8d10ee73b","excerpt":"","more":"<p>今天在修复一个后台 BUG 的时候遇到了很奇怪的问题，从服务器端返回来的数据是 JSON 格式的，并且打印以及 Base64 编码解码之后均为正确的 JSON 字符串格式，但偏偏 PHP 内置的 <code>JSON_decode</code> 函数却无法正常解码，一直返回空的解析结果。遂借此机会研究了一番，发现这其中的一些不为人知的秘密。</p>\n<p>于是，查询了 PHP 官网文档，发现 <code>JSON_decode</code> 函数对解析的 JSON 字符串有着严格的要求：</p>\n<ol>\n<li>JSON 字符串必须是以 UTF8 格式编码的；</li>\n<li>字符串格式必须完整准确，最后的元素不能有逗号存在；</li>\n<li>所有元素必须使用双引号；</li>\n<li>元素中不能含有控制或转义字符；</li>\n</ol>\n<p>接下来对应着文档的标准 JSON 字符串格式要求，我们可以逐条进行测试：</p>\n<pre><code class=\"php\">&lt;?php\n    // 使用 utf8_encode 方法编码 JSON 字符串；\n    $result = JSON_decode(utf8_encode($response), true);\n</code></pre>\n<p>使用 UTF8 编码 JSON 字符串并没有解决问题，发现输出的 UTF8 编码过的 JSON 字符串最前端部分存在乱码。对于 JSON 字符串的格式是否正确和是否使用双引号可以通过 <code>print_r</code> 函数把响应数据打印到页面直接观察来得到。接下来去掉 JSON 字符串中的控制和转义字符。</p>\n<pre><code class=\"php\">&lt;?php\n    // 去掉 JSON 字符串中的换行符(&quot;\\\\&quot;换成&quot;\\&quot;)；\n    $order = array(&quot;\\\\r\\\\n&quot;, &quot;\\\\r&quot;, &quot;\\\\n&quot;);\n    str_replace($order, &#39;&#39;, $response);\n</code></pre>\n<p>至此，问题依然没有解决，接下来还是从之前发现的 UTF8 编码后 JSON 字符串存在乱码入手。乱码位于 JSON 字符串的最前端，并且是在经过 UTF8 编码之后产生的。<code>utf8_encode</code> 方法也会将不可见的标识或控制字符进行编码。因此怀疑是存在隐藏的标识字符或者控制字符。</p>\n<p>大家都知道，PHP 对 BOM头 并不能很好的识别，所以很多时候 PHP 在解析含有 BOM 头的页面时，常常会将 BOM 的三个字符输出到页面中，导致解析出现问题。那么 BOM 到底是什么呢？</p>\n<p><strong>以下内容来自百度百科</strong>：</p>\n<p>Unicode 规范中有一个 BOM 的概念。BOM(Byte Order Mark)，翻译过来就是“字节序标记“。在这里找到一段关于 BOM 的说明：</p>\n<p>在 UCS 编码中有一个叫做 “ZERO WIDTH NO-BREAK SPACE” 的字符，它的编码是 FEFF。而 FFFE 在 UCS 中是不存在的字符，所以不应该出现在实际的数据传输过程中。UCS 规范建议我们在传输字节流前，先传输字符 “ZERO WIDTH NO-BREAK SPACE”。这样如果接收者收到 FEFF，就表明这个字节流是 “Big-Endian“ 的；如果收到 FFFE，就表明这个字节流是 “Little-Endian” 的。因此字符 “ZERO WIDTH NO-BREAK SPACE” 又被称作 BOM。</p>\n<p>UTF-8 不需要 BOM 来表明字节顺序，但可以用 BOM 来表明编码方式。字符 “ZERO WIDTH NO-BREAK SPACE” 的 UTF-8 编码是 “EF BB BF”。所以如果接收者收到以 “EF BB BF” 开头的字节流，就知道这是 UTF-8 编码了。</p>\n<p>Windows 记事本就是使用 BOM 来标记文本文件的编码方式的。</p>\n<p>UTF-8 编码的文件中，BOM 占三个字节。如果用记事本把一个文本文件另存为 UTF-8 编码方式的话，再用 UE 打开这个文件，切换到十六进制编辑状态就可以看到开头的 FFFE 了。这是个标识 UTF-8 编码文件的好办法，软件通过 BOM 来识别这个文件是否是 UTF-8 编码，很多软件还要求读入的文件必须带 BOM。可是，还是有很多软件不能识别 BOM。我在研究 Firefox 的时候就知道，在 Firefox 早期的版本里，扩展是不能有 BOM 的，不过 Firefox 自从 1.5 以后的版本已经开始支持 BOM 了。如今又发现，PHP 也不支持 BOM。</p>\n<p>PHP 在设计时就没有考虑 BOM 的问题，也就是说他不会忽略 UTF-8 编码的文件开头 BOM 的那三个字符。由于必须在 “&lt;?” 或者 “&lt;?php” 标记后面的代码才会被作为 PHP 代码执行，所以这三个字符将会直接输出。如果插件的文件有这个问题，将会导致在后台页面里激活或者不激活插件后显示白屏，如果是模版文件有这个问题，将会导致这三个字符直接输出，造成页面上方有一个小空行。国外的英文插件和模版一般都是用的 ASCⅡ 码的编码方式，不会有 BOM，只有国内的插件和模版会由于作者的不知情造成问题。还有，大家修改模版的时候，由于输出页面使用 UTF-8 编码，那么修改模版的时候如果有加入中文字符的话，必须把文件转成 UTF-8 编码才能正常显示，这个时候如果所使用的编辑器自动加上了 BOM 的话，将会造成在页面上输出这三个字符，显示效果就要看浏览器了，一般是一个空行或是一个乱码。</p>\n<p>简单的说，BOM 头就是用来表示文件编码方式几个字符，而在 UTF8 编码的文件中，BOM 头有三个字符，分别是：<code>0xEF 0xBB 0xBF</code>。</p>\n<pre><code class=\"php\">&lt;?php\n    // 去掉 BOM 头字符；\n    $result = JSON_decode(trim($response, chr(239).chr(187).chr(191)),true);\n</code></pre>\n<p>至此，终于找到了问题所在。其实我们在调试过程中并不需要这么麻烦，直接通过 <code>JSON_last_error</code> 函数即可获得最后一次 <code>JSON_decode</code> 函数执行失败的原因。</p>\n<p>最后，封装一个完备的 <code>JSON_decode</code> 函数：</p>\n<pre><code class=\"php\">&lt;?php\n    public function JSONDecode($content) {\n        // 去空格和占位符(&quot;\\\\&quot;换成&quot;\\&quot;)；\n        $order = array(&quot;\\\\r\\\\n&quot;, &quot;\\\\r&quot;, &quot;\\\\n&quot;);\n        str_replace($order, &#39;&#39;, $content);\n        // 去掉 BOM 头；\n        $content = trim($response, chr(239).chr(187).chr(191));\n        // 使用 UTF-8 编码；\n        $content = utf8_encode($response);\n        // 解析并返回生成的数组；\n        return JSON_decode($content, true);\n    }\n</code></pre>\n"},{"title":"前端项目规划与团队管理","intro":"在职业生涯的发展中，我们不仅会涉及到编码. 做技术，也会和团队建设与项目规划打交道。一个项目不是简单的打开编辑器写代码，一个好的项目一定是在开始之前就进行了严格的项目规划与团队内部建设。今天我们要罗列一下前端项目初期阶段所需要进行的工作。","comments":1,"date":"2016-12-14T13:30:30.000Z","_content":"\n在职业生涯的发展中，我们不仅会涉及到编码. 做技术，也会和团队建设与项目规划打交道。一个项目不是简单的打开编辑器写代码，一个好的项目一定是在开始之前就进行了严格的项目规划与团队内部建设。今天我们要罗列一下前端项目初期阶段所需要进行的工作。\n\n#### 1. 团队编码规范：\n\n主要指的是团队成员的编码规范，一般的项目周期少则几个月多则几年，在项目推进的过程中不免有人要离开，又新的人加入到队伍当中。如果团队没有一套统一的编码规范，在项目的后期维护上会消耗巨大的人力和时间等资源。\n\n**注释规范：**\n\n块状注释、单行注释、行内注释。块状注释要统一缩进，并且标注在特定对象的上方；单行注释的文字两端需要留出空格（防止注释编码导致注释关闭符失效），也要标注在特定对象的上方；行内注释的文字两端需要留出空格，并且放在语句的分号后边。\n\n**文件规范：**\n\n文件分类、文件引入、文件本身。文件分类主要指将资源文件按照业务或功能进行文件夹分类；文件引入指 CSS 文件的引入方式，行内样式不推荐，外联引入和内联引入；文件本身包括文件的命名（下划线大小写），文件编码（UTF8）。\n\n**命名规范：**\n\n分类命名、命名格式、语义化命名。分类命名中可以通过分类来对 CSS 类进行命名，比如 “g-” 前缀代表全局类，“m-” 前缀代表模块类；命名格式，建议全部小写，对命名长度进行衡量，要一眼能够看出名字的意义；语义化命名，以内容语义来命名 CSS 类名。\n\n**书写规范：**\n\n单行多行、空格分号、属性顺序、Hack 方式、值格式。单行多行，CSS 的单行多行各有利弊；空格分号，CSS 多行书写必须缩进，单行书写在属性名冒号和结尾分号之后加入空格，每一条规则都要以分号结尾；属性顺序，先写显示顺序，后写盒模型相关属性，文本属性，修饰属性；Hack 方式：统一各种浏览器的 Hack 方式；值格式：比如 `color` 属性的取值使用十六进制格式，`url` 属性的值是否带单引号或双引号。\n\n**其他规范：**\n\nHTML 规范、图片规范。HTML 的文档声明，使用 H5 的标准声明，遵循 XHTML 规范闭合标签，标签属性名用双引号还是单引号；标签缩进，正确的分层；标签和属性均小写；资源文件具有语义性，图片保留源文件。\n\n#### 2. 团队协作流程：\n\n**Web 产品初期的分工方式：**\n\n* 视觉/交互团队；\n* 后端开发；\n\n**Web 产品后期的分工方式：**\n\n* 交互团队；\n* 视觉团队；\n* 前端团队（页面工程师 + 交互工程师）；\n* 后端团队；\n* 产品团队；\n* PMO 团队（负责制定和维护项目进度）；\n\n![](1.jpg)\n","source":"_posts/前端项目规划与团队管理.md","raw":"---\ntitle: 前端项目规划与团队管理\nintro: 在职业生涯的发展中，我们不仅会涉及到编码. 做技术，也会和团队建设与项目规划打交道。一个项目不是简单的打开编辑器写代码，一个好的项目一定是在开始之前就进行了严格的项目规划与团队内部建设。今天我们要罗列一下前端项目初期阶段所需要进行的工作。\ncomments: true\ndate: 2016-12-14 21:30:30\ntags:\n- 团队管理\n---\n\n在职业生涯的发展中，我们不仅会涉及到编码. 做技术，也会和团队建设与项目规划打交道。一个项目不是简单的打开编辑器写代码，一个好的项目一定是在开始之前就进行了严格的项目规划与团队内部建设。今天我们要罗列一下前端项目初期阶段所需要进行的工作。\n\n#### 1. 团队编码规范：\n\n主要指的是团队成员的编码规范，一般的项目周期少则几个月多则几年，在项目推进的过程中不免有人要离开，又新的人加入到队伍当中。如果团队没有一套统一的编码规范，在项目的后期维护上会消耗巨大的人力和时间等资源。\n\n**注释规范：**\n\n块状注释、单行注释、行内注释。块状注释要统一缩进，并且标注在特定对象的上方；单行注释的文字两端需要留出空格（防止注释编码导致注释关闭符失效），也要标注在特定对象的上方；行内注释的文字两端需要留出空格，并且放在语句的分号后边。\n\n**文件规范：**\n\n文件分类、文件引入、文件本身。文件分类主要指将资源文件按照业务或功能进行文件夹分类；文件引入指 CSS 文件的引入方式，行内样式不推荐，外联引入和内联引入；文件本身包括文件的命名（下划线大小写），文件编码（UTF8）。\n\n**命名规范：**\n\n分类命名、命名格式、语义化命名。分类命名中可以通过分类来对 CSS 类进行命名，比如 “g-” 前缀代表全局类，“m-” 前缀代表模块类；命名格式，建议全部小写，对命名长度进行衡量，要一眼能够看出名字的意义；语义化命名，以内容语义来命名 CSS 类名。\n\n**书写规范：**\n\n单行多行、空格分号、属性顺序、Hack 方式、值格式。单行多行，CSS 的单行多行各有利弊；空格分号，CSS 多行书写必须缩进，单行书写在属性名冒号和结尾分号之后加入空格，每一条规则都要以分号结尾；属性顺序，先写显示顺序，后写盒模型相关属性，文本属性，修饰属性；Hack 方式：统一各种浏览器的 Hack 方式；值格式：比如 `color` 属性的取值使用十六进制格式，`url` 属性的值是否带单引号或双引号。\n\n**其他规范：**\n\nHTML 规范、图片规范。HTML 的文档声明，使用 H5 的标准声明，遵循 XHTML 规范闭合标签，标签属性名用双引号还是单引号；标签缩进，正确的分层；标签和属性均小写；资源文件具有语义性，图片保留源文件。\n\n#### 2. 团队协作流程：\n\n**Web 产品初期的分工方式：**\n\n* 视觉/交互团队；\n* 后端开发；\n\n**Web 产品后期的分工方式：**\n\n* 交互团队；\n* 视觉团队；\n* 前端团队（页面工程师 + 交互工程师）；\n* 后端团队；\n* 产品团队；\n* PMO 团队（负责制定和维护项目进度）；\n\n![](1.jpg)\n","slug":"前端项目规划与团队管理","published":1,"updated":"2019-02-11T07:32:37.927Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtb0006gknp2sarpkzee","content":"<p>在职业生涯的发展中，我们不仅会涉及到编码. 做技术，也会和团队建设与项目规划打交道。一个项目不是简单的打开编辑器写代码，一个好的项目一定是在开始之前就进行了严格的项目规划与团队内部建设。今天我们要罗列一下前端项目初期阶段所需要进行的工作。</p>\n<h4 id=\"1-团队编码规范：\"><a href=\"#1-团队编码规范：\" class=\"headerlink\" title=\"1. 团队编码规范：\"></a>1. 团队编码规范：</h4><p>主要指的是团队成员的编码规范，一般的项目周期少则几个月多则几年，在项目推进的过程中不免有人要离开，又新的人加入到队伍当中。如果团队没有一套统一的编码规范，在项目的后期维护上会消耗巨大的人力和时间等资源。</p>\n<p><strong>注释规范：</strong></p>\n<p>块状注释、单行注释、行内注释。块状注释要统一缩进，并且标注在特定对象的上方；单行注释的文字两端需要留出空格（防止注释编码导致注释关闭符失效），也要标注在特定对象的上方；行内注释的文字两端需要留出空格，并且放在语句的分号后边。</p>\n<p><strong>文件规范：</strong></p>\n<p>文件分类、文件引入、文件本身。文件分类主要指将资源文件按照业务或功能进行文件夹分类；文件引入指 CSS 文件的引入方式，行内样式不推荐，外联引入和内联引入；文件本身包括文件的命名（下划线大小写），文件编码（UTF8）。</p>\n<p><strong>命名规范：</strong></p>\n<p>分类命名、命名格式、语义化命名。分类命名中可以通过分类来对 CSS 类进行命名，比如 “g-” 前缀代表全局类，“m-” 前缀代表模块类；命名格式，建议全部小写，对命名长度进行衡量，要一眼能够看出名字的意义；语义化命名，以内容语义来命名 CSS 类名。</p>\n<p><strong>书写规范：</strong></p>\n<p>单行多行、空格分号、属性顺序、Hack 方式、值格式。单行多行，CSS 的单行多行各有利弊；空格分号，CSS 多行书写必须缩进，单行书写在属性名冒号和结尾分号之后加入空格，每一条规则都要以分号结尾；属性顺序，先写显示顺序，后写盒模型相关属性，文本属性，修饰属性；Hack 方式：统一各种浏览器的 Hack 方式；值格式：比如 <code>color</code> 属性的取值使用十六进制格式，<code>url</code> 属性的值是否带单引号或双引号。</p>\n<p><strong>其他规范：</strong></p>\n<p>HTML 规范、图片规范。HTML 的文档声明，使用 H5 的标准声明，遵循 XHTML 规范闭合标签，标签属性名用双引号还是单引号；标签缩进，正确的分层；标签和属性均小写；资源文件具有语义性，图片保留源文件。</p>\n<h4 id=\"2-团队协作流程：\"><a href=\"#2-团队协作流程：\" class=\"headerlink\" title=\"2. 团队协作流程：\"></a>2. 团队协作流程：</h4><p><strong>Web 产品初期的分工方式：</strong></p>\n<ul>\n<li>视觉/交互团队；</li>\n<li>后端开发；</li>\n</ul>\n<p><strong>Web 产品后期的分工方式：</strong></p>\n<ul>\n<li>交互团队；</li>\n<li>视觉团队；</li>\n<li>前端团队（页面工程师 + 交互工程师）；</li>\n<li>后端团队；</li>\n<li>产品团队；</li>\n<li>PMO 团队（负责制定和维护项目进度）；</li>\n</ul>\n<p><img src=\"1.jpg\" alt></p>\n","site":{"data":{}},"id":"f6008bcc679fc8a9158871aafe47f2fc","excerpt":"","more":"<p>在职业生涯的发展中，我们不仅会涉及到编码. 做技术，也会和团队建设与项目规划打交道。一个项目不是简单的打开编辑器写代码，一个好的项目一定是在开始之前就进行了严格的项目规划与团队内部建设。今天我们要罗列一下前端项目初期阶段所需要进行的工作。</p>\n<h4 id=\"1-团队编码规范：\"><a href=\"#1-团队编码规范：\" class=\"headerlink\" title=\"1. 团队编码规范：\"></a>1. 团队编码规范：</h4><p>主要指的是团队成员的编码规范，一般的项目周期少则几个月多则几年，在项目推进的过程中不免有人要离开，又新的人加入到队伍当中。如果团队没有一套统一的编码规范，在项目的后期维护上会消耗巨大的人力和时间等资源。</p>\n<p><strong>注释规范：</strong></p>\n<p>块状注释、单行注释、行内注释。块状注释要统一缩进，并且标注在特定对象的上方；单行注释的文字两端需要留出空格（防止注释编码导致注释关闭符失效），也要标注在特定对象的上方；行内注释的文字两端需要留出空格，并且放在语句的分号后边。</p>\n<p><strong>文件规范：</strong></p>\n<p>文件分类、文件引入、文件本身。文件分类主要指将资源文件按照业务或功能进行文件夹分类；文件引入指 CSS 文件的引入方式，行内样式不推荐，外联引入和内联引入；文件本身包括文件的命名（下划线大小写），文件编码（UTF8）。</p>\n<p><strong>命名规范：</strong></p>\n<p>分类命名、命名格式、语义化命名。分类命名中可以通过分类来对 CSS 类进行命名，比如 “g-” 前缀代表全局类，“m-” 前缀代表模块类；命名格式，建议全部小写，对命名长度进行衡量，要一眼能够看出名字的意义；语义化命名，以内容语义来命名 CSS 类名。</p>\n<p><strong>书写规范：</strong></p>\n<p>单行多行、空格分号、属性顺序、Hack 方式、值格式。单行多行，CSS 的单行多行各有利弊；空格分号，CSS 多行书写必须缩进，单行书写在属性名冒号和结尾分号之后加入空格，每一条规则都要以分号结尾；属性顺序，先写显示顺序，后写盒模型相关属性，文本属性，修饰属性；Hack 方式：统一各种浏览器的 Hack 方式；值格式：比如 <code>color</code> 属性的取值使用十六进制格式，<code>url</code> 属性的值是否带单引号或双引号。</p>\n<p><strong>其他规范：</strong></p>\n<p>HTML 规范、图片规范。HTML 的文档声明，使用 H5 的标准声明，遵循 XHTML 规范闭合标签，标签属性名用双引号还是单引号；标签缩进，正确的分层；标签和属性均小写；资源文件具有语义性，图片保留源文件。</p>\n<h4 id=\"2-团队协作流程：\"><a href=\"#2-团队协作流程：\" class=\"headerlink\" title=\"2. 团队协作流程：\"></a>2. 团队协作流程：</h4><p><strong>Web 产品初期的分工方式：</strong></p>\n<ul>\n<li>视觉/交互团队；</li>\n<li>后端开发；</li>\n</ul>\n<p><strong>Web 产品后期的分工方式：</strong></p>\n<ul>\n<li>交互团队；</li>\n<li>视觉团队；</li>\n<li>前端团队（页面工程师 + 交互工程师）；</li>\n<li>后端团队；</li>\n<li>产品团队；</li>\n<li>PMO 团队（负责制定和维护项目进度）；</li>\n</ul>\n<p><img src=\"1.jpg\" alt></p>\n"},{"title":"博客正式使用“知识共享 CC”国际协议","intro":"博客从今日起将将正式使用“知识共享 CC”国际协议。此协议主要用来维护网站的所有知识版权。为了营造一个和谐的资源及知识共享环境，请所有转载或者使用本站资源的网友自觉遵守此协议所包含的规范。","comments":1,"date":"2015-01-11T08:13:08.000Z","_content":"\n博客从今日起将将正式使用“知识共享 CC”国际协议。此协议主要用来维护网站的所有知识版权。为了营造一个和谐的资源及知识共享环境，请所有转载或者使用本站资源的网友自觉遵守此协议所包含的规范。\n\n#### 四种核心权利\nCreative Commons（知识共享）是一个相对宽松的版权协议。它只保留几种了权利，除此以外的其他权利全部放弃。使用者可以明确知道所有者的权利，不容易侵犯对方的版权，作品可以得到有效传播。\n\n* **署名**（Attribution，简写为 BY）：必须提到原作者；\n* **非商业用途**（Noncommercial，简写为 NC）：不得用于盈利性目的；\n* **禁止演绎**（No Derivative Works，简写为 ND）：不得修改原作品, 不得再创作；\n* **相同方式共享**（Share Alike，简写为 SA）：允许修改原作品，但必须使用相同的许可证发布；\n","source":"_posts/博客正式使用“知识共享-CC”国际协议.md","raw":"---\ntitle: 博客正式使用“知识共享 CC”国际协议\nintro: 博客从今日起将将正式使用“知识共享 CC”国际协议。此协议主要用来维护网站的所有知识版权。为了营造一个和谐的资源及知识共享环境，请所有转载或者使用本站资源的网友自觉遵守此协议所包含的规范。\ncomments: true\ndate: 2015-01-11 16:13:08\ntags:\n- 网站事务\n---\n\n博客从今日起将将正式使用“知识共享 CC”国际协议。此协议主要用来维护网站的所有知识版权。为了营造一个和谐的资源及知识共享环境，请所有转载或者使用本站资源的网友自觉遵守此协议所包含的规范。\n\n#### 四种核心权利\nCreative Commons（知识共享）是一个相对宽松的版权协议。它只保留几种了权利，除此以外的其他权利全部放弃。使用者可以明确知道所有者的权利，不容易侵犯对方的版权，作品可以得到有效传播。\n\n* **署名**（Attribution，简写为 BY）：必须提到原作者；\n* **非商业用途**（Noncommercial，简写为 NC）：不得用于盈利性目的；\n* **禁止演绎**（No Derivative Works，简写为 ND）：不得修改原作品, 不得再创作；\n* **相同方式共享**（Share Alike，简写为 SA）：允许修改原作品，但必须使用相同的许可证发布；\n","slug":"博客正式使用“知识共享-CC”国际协议","published":1,"updated":"2019-02-04T05:16:24.986Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtb2006iknp2o4ibl5os","content":"<p>博客从今日起将将正式使用“知识共享 CC”国际协议。此协议主要用来维护网站的所有知识版权。为了营造一个和谐的资源及知识共享环境，请所有转载或者使用本站资源的网友自觉遵守此协议所包含的规范。</p>\n<h4 id=\"四种核心权利\"><a href=\"#四种核心权利\" class=\"headerlink\" title=\"四种核心权利\"></a>四种核心权利</h4><p>Creative Commons（知识共享）是一个相对宽松的版权协议。它只保留几种了权利，除此以外的其他权利全部放弃。使用者可以明确知道所有者的权利，不容易侵犯对方的版权，作品可以得到有效传播。</p>\n<ul>\n<li><strong>署名</strong>（Attribution，简写为 BY）：必须提到原作者；</li>\n<li><strong>非商业用途</strong>（Noncommercial，简写为 NC）：不得用于盈利性目的；</li>\n<li><strong>禁止演绎</strong>（No Derivative Works，简写为 ND）：不得修改原作品, 不得再创作；</li>\n<li><strong>相同方式共享</strong>（Share Alike，简写为 SA）：允许修改原作品，但必须使用相同的许可证发布；</li>\n</ul>\n","site":{"data":{}},"id":"09f59a342f39b50b5794ef8b20cc2ade","excerpt":"","more":"<p>博客从今日起将将正式使用“知识共享 CC”国际协议。此协议主要用来维护网站的所有知识版权。为了营造一个和谐的资源及知识共享环境，请所有转载或者使用本站资源的网友自觉遵守此协议所包含的规范。</p>\n<h4 id=\"四种核心权利\"><a href=\"#四种核心权利\" class=\"headerlink\" title=\"四种核心权利\"></a>四种核心权利</h4><p>Creative Commons（知识共享）是一个相对宽松的版权协议。它只保留几种了权利，除此以外的其他权利全部放弃。使用者可以明确知道所有者的权利，不容易侵犯对方的版权，作品可以得到有效传播。</p>\n<ul>\n<li><strong>署名</strong>（Attribution，简写为 BY）：必须提到原作者；</li>\n<li><strong>非商业用途</strong>（Noncommercial，简写为 NC）：不得用于盈利性目的；</li>\n<li><strong>禁止演绎</strong>（No Derivative Works，简写为 ND）：不得修改原作品, 不得再创作；</li>\n<li><strong>相同方式共享</strong>（Share Alike，简写为 SA）：允许修改原作品，但必须使用相同的许可证发布；</li>\n</ul>\n"},{"title":"基于 AWS 探索 Shadowsocks","intro":"今天本来想写一篇关于 JQuery 最佳实践的文章，但是写到中途手滑没有保存，遂留到日后再写好了。今天要写的一篇文章是关于 Shadowsocks 在 AWS 上的实践文章。通过本文所述的实践操作，大家可以熟悉 AWS 的常用操作，并逐渐了解 Shadowsocks 的核心原理。同时，这也是一次记录与整理。","comments":1,"date":"2016-08-16T15:24:45.000Z","_content":"\n\n今天本来想写一篇关于 JQuery 最佳实践的文章，但是写到中途手滑没有保存，遂留到日后再写好了。今天要写的一篇文章是关于 Shadowsocks 在 AWS 上的实践文章。通过本文所述的实践操作，大家可以熟悉 AWS 的常用操作，并逐渐了解 Shadowsocks 的核心原理。同时，这也是一次记录与整理。\n\nShadowsocks 是什么这里就不做介绍了，简单的理解就是一个代理服务。我们要做的就是在 AWS 的海外 EC2 服务器上配置 Shadowsocks 服务，这样在本地我们既可以通过连接这台海外的 EC2 服务器作为正向代理服务器来访问外部网络。当然这整个的配置过程并不是十分的“傻瓜式”，还需要对服务器以及 Linux 的基本操作有着基本的了解。\n\n#### 一、注册以及配置 EC2 服务器：\n\n现在的 AWS 新注册用户可以享用一年的免费 “t2.micro“ 型号云主机的使用权，而且 AWS 的所有 EC2 主机都会自带有默认的外网 DNS 解析，所以我们这里只需要申请一台这样的免费主机即可。请注意，在 AWS 上注册用户时需要提供信用卡信息，而且是必需的。我这里申请的是加利福尼亚北部的 EC2 服务器，顺带一句，按照付费方案计算的话，弗吉尼亚北部的 EC2 机群是最便宜的。当全部注册流程结束后会来到下图所示页面来创建和启用 EC2 服务器。具体的步骤这里不多讲，直接按照提示选择并且下一步即可，选择 “AMI“ 和“实例类型“时请注意选择带有“免费“字样标志的实例类型。当实例申请配置进行到最后一步时，AWS 会让用户为该实例选择或创建一个密钥对，这个密钥对的私钥（*.pem）文件会被用户下载下来用来登陆 SSH 终端，这里请妥善保管该私钥，因为只能下载一次。\n\n![](1.png)\n\nEC2 实例启动后我们来到控制面板的“安全组“选项卡，这里可以配置 EC2 服务器的安全策略，比如允许的进网 IP，协议等等。我们这里可以修改已有的安全组协议或者创建新的自定义安全组协议。主要配置项为“入站“的安全设置，如下图所示，将访问设置设置成允许来自所有协议的所有流量。\n\n![](2.png)\n\n#### 二、配置 Shadowsocks 服务端：\n\n接下来便要开始配置服务器端的 Shadowsocks 服务了，使用之前生成的私钥文件通过 SSH 客户端连接到我们的 EC2 服务器，EC2 服务器的外网 DNS 可以通过在“实例“选项卡点选我们的 EC2，在其下方的信息栏中找到。由于我们这里的 EC2 服务器使用的是 Ubuntu 系统，所以可以直接按照 Shadowsocks 在 Github 上的 Wiki 文档进行配置。\n\n> [Shadowsocks Wiki](https://github.com/shadowsocks/shadowsocks/tree/master)\n\n请阅读上文给出的 Wiki 页面，直接按照 “Install” 章节的指南进行安装即可。Shadowsocks 的核心服务由 Python 语言编写，所以直接通过 “pip” 来安装即可使用，省去了编译和链接的过程。下面给出的链接是 Shadowsocks 在 Python Package Management 页面的官方链接。\n\n> [Shadowsocks - Python Package Management](https://pypi.python.org/pypi/shadowsocks/2.8.2)\n\n\n#### 三、开始使用 Shadowsocks 客户端：\n\n![](3.png)\n\n服务端的工作全部结束之后既可开始使用 Shadowsocks 的客户端工具来连接我们的 EC2 代理服务器了。Windows 版本的 Shadowsocks 客户端基于 C# 语言编写，并提供了本地负载均衡、PAC（代理自动配置）等高级功能，自带的流量监控功能也十分好用（如上图所示）。可以通过以下给出的 Github 链接来查看详细的说明。\n\n> [Shadowsocks Windows Client Wiki](https://github.com/shadowsocks/shadowsocks-windows/tree/master)\n\n对于 MacOS 和 IOS 等系统上的客户端，笔者还没有进行尝试，可以通过上述第一个 Wiki 页面来查找相关的信息。\n\n#### 四、Shadowsocks 源码解析：\n\n我们可以直接从 Github 或者上述给出的 Python 包管理页面直接下载 Shadowsocks 的服务端源码进行解读。\n","source":"_posts/基于-AWS-探索-Shadowsocks.md","raw":"---\ntitle: 基于 AWS 探索 Shadowsocks\nintro: 今天本来想写一篇关于 JQuery 最佳实践的文章，但是写到中途手滑没有保存，遂留到日后再写好了。今天要写的一篇文章是关于 Shadowsocks 在 AWS 上的实践文章。通过本文所述的实践操作，大家可以熟悉 AWS 的常用操作，并逐渐了解 Shadowsocks 的核心原理。同时，这也是一次记录与整理。\ncomments: true\ndate: 2016-08-16 23:24:45\ntags:\n- AWS\n- Shadowsocks\n---\n\n\n今天本来想写一篇关于 JQuery 最佳实践的文章，但是写到中途手滑没有保存，遂留到日后再写好了。今天要写的一篇文章是关于 Shadowsocks 在 AWS 上的实践文章。通过本文所述的实践操作，大家可以熟悉 AWS 的常用操作，并逐渐了解 Shadowsocks 的核心原理。同时，这也是一次记录与整理。\n\nShadowsocks 是什么这里就不做介绍了，简单的理解就是一个代理服务。我们要做的就是在 AWS 的海外 EC2 服务器上配置 Shadowsocks 服务，这样在本地我们既可以通过连接这台海外的 EC2 服务器作为正向代理服务器来访问外部网络。当然这整个的配置过程并不是十分的“傻瓜式”，还需要对服务器以及 Linux 的基本操作有着基本的了解。\n\n#### 一、注册以及配置 EC2 服务器：\n\n现在的 AWS 新注册用户可以享用一年的免费 “t2.micro“ 型号云主机的使用权，而且 AWS 的所有 EC2 主机都会自带有默认的外网 DNS 解析，所以我们这里只需要申请一台这样的免费主机即可。请注意，在 AWS 上注册用户时需要提供信用卡信息，而且是必需的。我这里申请的是加利福尼亚北部的 EC2 服务器，顺带一句，按照付费方案计算的话，弗吉尼亚北部的 EC2 机群是最便宜的。当全部注册流程结束后会来到下图所示页面来创建和启用 EC2 服务器。具体的步骤这里不多讲，直接按照提示选择并且下一步即可，选择 “AMI“ 和“实例类型“时请注意选择带有“免费“字样标志的实例类型。当实例申请配置进行到最后一步时，AWS 会让用户为该实例选择或创建一个密钥对，这个密钥对的私钥（*.pem）文件会被用户下载下来用来登陆 SSH 终端，这里请妥善保管该私钥，因为只能下载一次。\n\n![](1.png)\n\nEC2 实例启动后我们来到控制面板的“安全组“选项卡，这里可以配置 EC2 服务器的安全策略，比如允许的进网 IP，协议等等。我们这里可以修改已有的安全组协议或者创建新的自定义安全组协议。主要配置项为“入站“的安全设置，如下图所示，将访问设置设置成允许来自所有协议的所有流量。\n\n![](2.png)\n\n#### 二、配置 Shadowsocks 服务端：\n\n接下来便要开始配置服务器端的 Shadowsocks 服务了，使用之前生成的私钥文件通过 SSH 客户端连接到我们的 EC2 服务器，EC2 服务器的外网 DNS 可以通过在“实例“选项卡点选我们的 EC2，在其下方的信息栏中找到。由于我们这里的 EC2 服务器使用的是 Ubuntu 系统，所以可以直接按照 Shadowsocks 在 Github 上的 Wiki 文档进行配置。\n\n> [Shadowsocks Wiki](https://github.com/shadowsocks/shadowsocks/tree/master)\n\n请阅读上文给出的 Wiki 页面，直接按照 “Install” 章节的指南进行安装即可。Shadowsocks 的核心服务由 Python 语言编写，所以直接通过 “pip” 来安装即可使用，省去了编译和链接的过程。下面给出的链接是 Shadowsocks 在 Python Package Management 页面的官方链接。\n\n> [Shadowsocks - Python Package Management](https://pypi.python.org/pypi/shadowsocks/2.8.2)\n\n\n#### 三、开始使用 Shadowsocks 客户端：\n\n![](3.png)\n\n服务端的工作全部结束之后既可开始使用 Shadowsocks 的客户端工具来连接我们的 EC2 代理服务器了。Windows 版本的 Shadowsocks 客户端基于 C# 语言编写，并提供了本地负载均衡、PAC（代理自动配置）等高级功能，自带的流量监控功能也十分好用（如上图所示）。可以通过以下给出的 Github 链接来查看详细的说明。\n\n> [Shadowsocks Windows Client Wiki](https://github.com/shadowsocks/shadowsocks-windows/tree/master)\n\n对于 MacOS 和 IOS 等系统上的客户端，笔者还没有进行尝试，可以通过上述第一个 Wiki 页面来查找相关的信息。\n\n#### 四、Shadowsocks 源码解析：\n\n我们可以直接从 Github 或者上述给出的 Python 包管理页面直接下载 Shadowsocks 的服务端源码进行解读。\n","slug":"基于-AWS-探索-Shadowsocks","published":1,"updated":"2019-02-10T02:28:38.339Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtb3006lknp2v0ms2kkl","content":"<p>今天本来想写一篇关于 JQuery 最佳实践的文章，但是写到中途手滑没有保存，遂留到日后再写好了。今天要写的一篇文章是关于 Shadowsocks 在 AWS 上的实践文章。通过本文所述的实践操作，大家可以熟悉 AWS 的常用操作，并逐渐了解 Shadowsocks 的核心原理。同时，这也是一次记录与整理。</p>\n<p>Shadowsocks 是什么这里就不做介绍了，简单的理解就是一个代理服务。我们要做的就是在 AWS 的海外 EC2 服务器上配置 Shadowsocks 服务，这样在本地我们既可以通过连接这台海外的 EC2 服务器作为正向代理服务器来访问外部网络。当然这整个的配置过程并不是十分的“傻瓜式”，还需要对服务器以及 Linux 的基本操作有着基本的了解。</p>\n<h4 id=\"一、注册以及配置-EC2-服务器：\"><a href=\"#一、注册以及配置-EC2-服务器：\" class=\"headerlink\" title=\"一、注册以及配置 EC2 服务器：\"></a>一、注册以及配置 EC2 服务器：</h4><p>现在的 AWS 新注册用户可以享用一年的免费 “t2.micro“ 型号云主机的使用权，而且 AWS 的所有 EC2 主机都会自带有默认的外网 DNS 解析，所以我们这里只需要申请一台这样的免费主机即可。请注意，在 AWS 上注册用户时需要提供信用卡信息，而且是必需的。我这里申请的是加利福尼亚北部的 EC2 服务器，顺带一句，按照付费方案计算的话，弗吉尼亚北部的 EC2 机群是最便宜的。当全部注册流程结束后会来到下图所示页面来创建和启用 EC2 服务器。具体的步骤这里不多讲，直接按照提示选择并且下一步即可，选择 “AMI“ 和“实例类型“时请注意选择带有“免费“字样标志的实例类型。当实例申请配置进行到最后一步时，AWS 会让用户为该实例选择或创建一个密钥对，这个密钥对的私钥（*.pem）文件会被用户下载下来用来登陆 SSH 终端，这里请妥善保管该私钥，因为只能下载一次。</p>\n<p><img src=\"1.png\" alt></p>\n<p>EC2 实例启动后我们来到控制面板的“安全组“选项卡，这里可以配置 EC2 服务器的安全策略，比如允许的进网 IP，协议等等。我们这里可以修改已有的安全组协议或者创建新的自定义安全组协议。主要配置项为“入站“的安全设置，如下图所示，将访问设置设置成允许来自所有协议的所有流量。</p>\n<p><img src=\"2.png\" alt></p>\n<h4 id=\"二、配置-Shadowsocks-服务端：\"><a href=\"#二、配置-Shadowsocks-服务端：\" class=\"headerlink\" title=\"二、配置 Shadowsocks 服务端：\"></a>二、配置 Shadowsocks 服务端：</h4><p>接下来便要开始配置服务器端的 Shadowsocks 服务了，使用之前生成的私钥文件通过 SSH 客户端连接到我们的 EC2 服务器，EC2 服务器的外网 DNS 可以通过在“实例“选项卡点选我们的 EC2，在其下方的信息栏中找到。由于我们这里的 EC2 服务器使用的是 Ubuntu 系统，所以可以直接按照 Shadowsocks 在 Github 上的 Wiki 文档进行配置。</p>\n<blockquote>\n<p><a href=\"https://github.com/shadowsocks/shadowsocks/tree/master\" target=\"_blank\" rel=\"noopener\">Shadowsocks Wiki</a></p>\n</blockquote>\n<p>请阅读上文给出的 Wiki 页面，直接按照 “Install” 章节的指南进行安装即可。Shadowsocks 的核心服务由 Python 语言编写，所以直接通过 “pip” 来安装即可使用，省去了编译和链接的过程。下面给出的链接是 Shadowsocks 在 Python Package Management 页面的官方链接。</p>\n<blockquote>\n<p><a href=\"https://pypi.python.org/pypi/shadowsocks/2.8.2\" target=\"_blank\" rel=\"noopener\">Shadowsocks - Python Package Management</a></p>\n</blockquote>\n<h4 id=\"三、开始使用-Shadowsocks-客户端：\"><a href=\"#三、开始使用-Shadowsocks-客户端：\" class=\"headerlink\" title=\"三、开始使用 Shadowsocks 客户端：\"></a>三、开始使用 Shadowsocks 客户端：</h4><p><img src=\"3.png\" alt></p>\n<p>服务端的工作全部结束之后既可开始使用 Shadowsocks 的客户端工具来连接我们的 EC2 代理服务器了。Windows 版本的 Shadowsocks 客户端基于 C# 语言编写，并提供了本地负载均衡、PAC（代理自动配置）等高级功能，自带的流量监控功能也十分好用（如上图所示）。可以通过以下给出的 Github 链接来查看详细的说明。</p>\n<blockquote>\n<p><a href=\"https://github.com/shadowsocks/shadowsocks-windows/tree/master\" target=\"_blank\" rel=\"noopener\">Shadowsocks Windows Client Wiki</a></p>\n</blockquote>\n<p>对于 MacOS 和 IOS 等系统上的客户端，笔者还没有进行尝试，可以通过上述第一个 Wiki 页面来查找相关的信息。</p>\n<h4 id=\"四、Shadowsocks-源码解析：\"><a href=\"#四、Shadowsocks-源码解析：\" class=\"headerlink\" title=\"四、Shadowsocks 源码解析：\"></a>四、Shadowsocks 源码解析：</h4><p>我们可以直接从 Github 或者上述给出的 Python 包管理页面直接下载 Shadowsocks 的服务端源码进行解读。</p>\n","site":{"data":{}},"id":"b4f03bda3b79803270167ed922256d7d","excerpt":"","more":"<p>今天本来想写一篇关于 JQuery 最佳实践的文章，但是写到中途手滑没有保存，遂留到日后再写好了。今天要写的一篇文章是关于 Shadowsocks 在 AWS 上的实践文章。通过本文所述的实践操作，大家可以熟悉 AWS 的常用操作，并逐渐了解 Shadowsocks 的核心原理。同时，这也是一次记录与整理。</p>\n<p>Shadowsocks 是什么这里就不做介绍了，简单的理解就是一个代理服务。我们要做的就是在 AWS 的海外 EC2 服务器上配置 Shadowsocks 服务，这样在本地我们既可以通过连接这台海外的 EC2 服务器作为正向代理服务器来访问外部网络。当然这整个的配置过程并不是十分的“傻瓜式”，还需要对服务器以及 Linux 的基本操作有着基本的了解。</p>\n<h4 id=\"一、注册以及配置-EC2-服务器：\"><a href=\"#一、注册以及配置-EC2-服务器：\" class=\"headerlink\" title=\"一、注册以及配置 EC2 服务器：\"></a>一、注册以及配置 EC2 服务器：</h4><p>现在的 AWS 新注册用户可以享用一年的免费 “t2.micro“ 型号云主机的使用权，而且 AWS 的所有 EC2 主机都会自带有默认的外网 DNS 解析，所以我们这里只需要申请一台这样的免费主机即可。请注意，在 AWS 上注册用户时需要提供信用卡信息，而且是必需的。我这里申请的是加利福尼亚北部的 EC2 服务器，顺带一句，按照付费方案计算的话，弗吉尼亚北部的 EC2 机群是最便宜的。当全部注册流程结束后会来到下图所示页面来创建和启用 EC2 服务器。具体的步骤这里不多讲，直接按照提示选择并且下一步即可，选择 “AMI“ 和“实例类型“时请注意选择带有“免费“字样标志的实例类型。当实例申请配置进行到最后一步时，AWS 会让用户为该实例选择或创建一个密钥对，这个密钥对的私钥（*.pem）文件会被用户下载下来用来登陆 SSH 终端，这里请妥善保管该私钥，因为只能下载一次。</p>\n<p><img src=\"1.png\" alt></p>\n<p>EC2 实例启动后我们来到控制面板的“安全组“选项卡，这里可以配置 EC2 服务器的安全策略，比如允许的进网 IP，协议等等。我们这里可以修改已有的安全组协议或者创建新的自定义安全组协议。主要配置项为“入站“的安全设置，如下图所示，将访问设置设置成允许来自所有协议的所有流量。</p>\n<p><img src=\"2.png\" alt></p>\n<h4 id=\"二、配置-Shadowsocks-服务端：\"><a href=\"#二、配置-Shadowsocks-服务端：\" class=\"headerlink\" title=\"二、配置 Shadowsocks 服务端：\"></a>二、配置 Shadowsocks 服务端：</h4><p>接下来便要开始配置服务器端的 Shadowsocks 服务了，使用之前生成的私钥文件通过 SSH 客户端连接到我们的 EC2 服务器，EC2 服务器的外网 DNS 可以通过在“实例“选项卡点选我们的 EC2，在其下方的信息栏中找到。由于我们这里的 EC2 服务器使用的是 Ubuntu 系统，所以可以直接按照 Shadowsocks 在 Github 上的 Wiki 文档进行配置。</p>\n<blockquote>\n<p><a href=\"https://github.com/shadowsocks/shadowsocks/tree/master\" target=\"_blank\" rel=\"noopener\">Shadowsocks Wiki</a></p>\n</blockquote>\n<p>请阅读上文给出的 Wiki 页面，直接按照 “Install” 章节的指南进行安装即可。Shadowsocks 的核心服务由 Python 语言编写，所以直接通过 “pip” 来安装即可使用，省去了编译和链接的过程。下面给出的链接是 Shadowsocks 在 Python Package Management 页面的官方链接。</p>\n<blockquote>\n<p><a href=\"https://pypi.python.org/pypi/shadowsocks/2.8.2\" target=\"_blank\" rel=\"noopener\">Shadowsocks - Python Package Management</a></p>\n</blockquote>\n<h4 id=\"三、开始使用-Shadowsocks-客户端：\"><a href=\"#三、开始使用-Shadowsocks-客户端：\" class=\"headerlink\" title=\"三、开始使用 Shadowsocks 客户端：\"></a>三、开始使用 Shadowsocks 客户端：</h4><p><img src=\"3.png\" alt></p>\n<p>服务端的工作全部结束之后既可开始使用 Shadowsocks 的客户端工具来连接我们的 EC2 代理服务器了。Windows 版本的 Shadowsocks 客户端基于 C# 语言编写，并提供了本地负载均衡、PAC（代理自动配置）等高级功能，自带的流量监控功能也十分好用（如上图所示）。可以通过以下给出的 Github 链接来查看详细的说明。</p>\n<blockquote>\n<p><a href=\"https://github.com/shadowsocks/shadowsocks-windows/tree/master\" target=\"_blank\" rel=\"noopener\">Shadowsocks Windows Client Wiki</a></p>\n</blockquote>\n<p>对于 MacOS 和 IOS 等系统上的客户端，笔者还没有进行尝试，可以通过上述第一个 Wiki 页面来查找相关的信息。</p>\n<h4 id=\"四、Shadowsocks-源码解析：\"><a href=\"#四、Shadowsocks-源码解析：\" class=\"headerlink\" title=\"四、Shadowsocks 源码解析：\"></a>四、Shadowsocks 源码解析：</h4><p>我们可以直接从 Github 或者上述给出的 Python 包管理页面直接下载 Shadowsocks 的服务端源码进行解读。</p>\n"},{"title":"图像扫描及 OCR 技术开发 SDK - Asprise","intro":"今天在项目中应用到了扫描仪，需要通过扫描仪来扫描并传输一张图片以供程序使用。Java 对于扫描仪硬件的控制没有像 C++ 那样灵活，同时这方面的类似应用也相对较少。但作为一种拥有最多第三方库且体系相当成熟的的开发语言，这并不会成为一个难题。","comments":1,"date":"2015-03-22T10:03:19.000Z","_content":"\n今天在项目中应用到了扫描仪，需要通过扫描仪来扫描并传输一张图片以供程序使用。Java 对于扫描仪硬件的控制没有像 C++ 那样灵活，同时这方面的类似应用也相对较少。但作为一种拥有最多第三方库且体系相当成熟的的开发语言，这并不会成为一个难题。\n\n“**http://asprise.com**” 是一个致力于研究在各种平台实现 OCR 技术及扫描仪传输技术的网站。它成立于1998年，已经有了17年的历史，同样也积累了很多非常优秀的 OCR 及相关技术的开发 SDK 资源。对于在 Java 中使用扫描仪这个功能，我选择了网站提供的 “Asprise Scanning and Image Capture SDK“” 来进行开发。\n\nAsprise 已经将扫描仪的功能接口封装成在了 jar 包中，只需要将 jar 包导入到工程，再添加一行代码，便可以实现从扫描仪扫描一张图片并传输给当前应用程序的功能。示例代码如下所示。\n\n```java\nFile[] fs = ScanManager.getDefaultManager().quickScanUsingUI(new File(\".\"), null);\n```\n\n这行代码会启动一个系统的扫描仪设置界面，在设置完毕后点击扫描即可将扫描得到的图像以 File 数组的形式返回。而对于 File 数组的后期处理过程就可以自由发挥。比如保存成一张图片，或者使用 OCR 技术提取页面的文字内容等等。\n\n除此之外，封装好的 jar 包几乎可以兼容任何常见类型的扫描仪，同时还可以可以在应用程序中获得对应的扫描仪对象，以进行更加深入的参数设置。不仅如此，它也可以应用于 Java Web 程序中，或者网站的 Applet 应用中。\n\n不过唯一有点遗憾的是，它并不是一款免费的第三方库。但好在价格并不贵，相对于其不错的封装性和易用性，这个价格还是很值得关注的。\n","source":"_posts/图像扫描及-OCR-技术开发-SDK-Asprise.md","raw":"---\ntitle: 图像扫描及 OCR 技术开发 SDK - Asprise\nintro: 今天在项目中应用到了扫描仪，需要通过扫描仪来扫描并传输一张图片以供程序使用。Java 对于扫描仪硬件的控制没有像 C++ 那样灵活，同时这方面的类似应用也相对较少。但作为一种拥有最多第三方库且体系相当成熟的的开发语言，这并不会成为一个难题。\ncomments: true\ndate: 2015-03-22 18:03:19\ntags:\n- Java\n---\n\n今天在项目中应用到了扫描仪，需要通过扫描仪来扫描并传输一张图片以供程序使用。Java 对于扫描仪硬件的控制没有像 C++ 那样灵活，同时这方面的类似应用也相对较少。但作为一种拥有最多第三方库且体系相当成熟的的开发语言，这并不会成为一个难题。\n\n“**http://asprise.com**” 是一个致力于研究在各种平台实现 OCR 技术及扫描仪传输技术的网站。它成立于1998年，已经有了17年的历史，同样也积累了很多非常优秀的 OCR 及相关技术的开发 SDK 资源。对于在 Java 中使用扫描仪这个功能，我选择了网站提供的 “Asprise Scanning and Image Capture SDK“” 来进行开发。\n\nAsprise 已经将扫描仪的功能接口封装成在了 jar 包中，只需要将 jar 包导入到工程，再添加一行代码，便可以实现从扫描仪扫描一张图片并传输给当前应用程序的功能。示例代码如下所示。\n\n```java\nFile[] fs = ScanManager.getDefaultManager().quickScanUsingUI(new File(\".\"), null);\n```\n\n这行代码会启动一个系统的扫描仪设置界面，在设置完毕后点击扫描即可将扫描得到的图像以 File 数组的形式返回。而对于 File 数组的后期处理过程就可以自由发挥。比如保存成一张图片，或者使用 OCR 技术提取页面的文字内容等等。\n\n除此之外，封装好的 jar 包几乎可以兼容任何常见类型的扫描仪，同时还可以可以在应用程序中获得对应的扫描仪对象，以进行更加深入的参数设置。不仅如此，它也可以应用于 Java Web 程序中，或者网站的 Applet 应用中。\n\n不过唯一有点遗憾的是，它并不是一款免费的第三方库。但好在价格并不贵，相对于其不错的封装性和易用性，这个价格还是很值得关注的。\n","slug":"图像扫描及-OCR-技术开发-SDK-Asprise","published":1,"updated":"2019-02-04T09:46:22.372Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtb3006nknp253hksycu","content":"<p>今天在项目中应用到了扫描仪，需要通过扫描仪来扫描并传输一张图片以供程序使用。Java 对于扫描仪硬件的控制没有像 C++ 那样灵活，同时这方面的类似应用也相对较少。但作为一种拥有最多第三方库且体系相当成熟的的开发语言，这并不会成为一个难题。</p>\n<p>“<strong><a href=\"http://asprise.com\" target=\"_blank\" rel=\"noopener\">http://asprise.com</a></strong>” 是一个致力于研究在各种平台实现 OCR 技术及扫描仪传输技术的网站。它成立于1998年，已经有了17年的历史，同样也积累了很多非常优秀的 OCR 及相关技术的开发 SDK 资源。对于在 Java 中使用扫描仪这个功能，我选择了网站提供的 “Asprise Scanning and Image Capture SDK“” 来进行开发。</p>\n<p>Asprise 已经将扫描仪的功能接口封装成在了 jar 包中，只需要将 jar 包导入到工程，再添加一行代码，便可以实现从扫描仪扫描一张图片并传输给当前应用程序的功能。示例代码如下所示。</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\">File<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> fs <span class=\"token operator\">=</span> ScanManager<span class=\"token punctuation\">.</span><span class=\"token function\">getDefaultManager</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">quickScanUsingUI</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">File</span><span class=\"token punctuation\">(</span><span class=\"token string\">\".\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>这行代码会启动一个系统的扫描仪设置界面，在设置完毕后点击扫描即可将扫描得到的图像以 File 数组的形式返回。而对于 File 数组的后期处理过程就可以自由发挥。比如保存成一张图片，或者使用 OCR 技术提取页面的文字内容等等。</p>\n<p>除此之外，封装好的 jar 包几乎可以兼容任何常见类型的扫描仪，同时还可以可以在应用程序中获得对应的扫描仪对象，以进行更加深入的参数设置。不仅如此，它也可以应用于 Java Web 程序中，或者网站的 Applet 应用中。</p>\n<p>不过唯一有点遗憾的是，它并不是一款免费的第三方库。但好在价格并不贵，相对于其不错的封装性和易用性，这个价格还是很值得关注的。</p>\n","site":{"data":{}},"id":"bfea20ab1627eac26ccac27b40ca1aec","excerpt":"","more":"<p>今天在项目中应用到了扫描仪，需要通过扫描仪来扫描并传输一张图片以供程序使用。Java 对于扫描仪硬件的控制没有像 C++ 那样灵活，同时这方面的类似应用也相对较少。但作为一种拥有最多第三方库且体系相当成熟的的开发语言，这并不会成为一个难题。</p>\n<p>“<strong><a href=\"http://asprise.com\" target=\"_blank\" rel=\"noopener\">http://asprise.com</a></strong>” 是一个致力于研究在各种平台实现 OCR 技术及扫描仪传输技术的网站。它成立于1998年，已经有了17年的历史，同样也积累了很多非常优秀的 OCR 及相关技术的开发 SDK 资源。对于在 Java 中使用扫描仪这个功能，我选择了网站提供的 “Asprise Scanning and Image Capture SDK“” 来进行开发。</p>\n<p>Asprise 已经将扫描仪的功能接口封装成在了 jar 包中，只需要将 jar 包导入到工程，再添加一行代码，便可以实现从扫描仪扫描一张图片并传输给当前应用程序的功能。示例代码如下所示。</p>\n<pre><code class=\"java\">File[] fs = ScanManager.getDefaultManager().quickScanUsingUI(new File(&quot;.&quot;), null);\n</code></pre>\n<p>这行代码会启动一个系统的扫描仪设置界面，在设置完毕后点击扫描即可将扫描得到的图像以 File 数组的形式返回。而对于 File 数组的后期处理过程就可以自由发挥。比如保存成一张图片，或者使用 OCR 技术提取页面的文字内容等等。</p>\n<p>除此之外，封装好的 jar 包几乎可以兼容任何常见类型的扫描仪，同时还可以可以在应用程序中获得对应的扫描仪对象，以进行更加深入的参数设置。不仅如此，它也可以应用于 Java Web 程序中，或者网站的 Applet 应用中。</p>\n<p>不过唯一有点遗憾的是，它并不是一款免费的第三方库。但好在价格并不贵，相对于其不错的封装性和易用性，这个价格还是很值得关注的。</p>\n"},{"title":"基于 NumPy 和 TensorFlow 的简单 KNN 实现","intro":"最近花了点时间分别用 NumPy 和 TensorFlow 实现了一个简单基础的 KNN 算法。对于两种实现而言，KNN 算法的原理与常见的问题都是一致的。这里主要记录下实现的代码过程，同时讨论下 KNN 算法本身的一些问题。所有实现均基于 Python3，需要的相关 Lib 可以通过 Pip 进行安装。","comments":1,"date":"2017-05-26T14:50:24.000Z","_content":"\n\n最近花了点时间分别用 NumPy 和 TensorFlow 实现了一个简单基础的 KNN 算法。对于两种实现而言，KNN 算法的原理与常见的问题都是一致的。这里主要记录下实现的代码过程，同时讨论下 KNN 算法本身的一些问题。所有实现均基于 Python3，需要的相关 Lib 可以通过 Pip 进行安装。\n\n\n\n#### 1、资源：\n\n1. 仓库地址：[https://github.com/Becavalier/MachineLearning](https://github.com/Becavalier/MachineLearning)；\n2. 实验数据地址：[http://archive.ics.uci.edu/ml/](http://archive.ics.uci.edu/ml/)；\n\n\n\n#### 2、遇到的问题：\n\n1. 为了防止单一特征的数值过大影响欧氏距离的计算，在进行距离计算前统一进行归一化处理；\n2. 训练样本的数量分布不均匀，集中在某几个类型的样本数量过多，若最后采用“K 距离内的多数表决法”，则数量多的样本会对最后结果产生影响。因此最后采用距离权重的方式来进行表决；\n3. 欧式距离并不适合该模型的惰性训练和预测，可能原因是：并不是所有给出的特征都与最后需要进行分类的特征有很强的相关性，最后的分类结果大多会受到这些无用特征的影响，这些特征变成了噪声；\n4. 计算**距离权重**的方式可以采用距离倒数或者高斯函数的方式；\n5. 最优 K 可以通过交叉验证的方式进行测量；\n\n\n\n#### 3、待优化：\n\n1. 高斯函数代替距离权重；\n2. 交叉检验；\n3. TensorFlow 替代；\n\n\n#### 4、源代码：\n\n```python\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n&quot; KNN - Machine Learning &quot;\n\n__author__ = 'YHSPY'\n\nfrom numpy import *\nimport operator\nimport argparse\nimport os\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport tensorflow as tf\n\n&quot; Cloumns setting&quot;\nfeatures = ('Sex', 'Length', 'Diameter', 'Height', 'Whole weight', 'Shucked weight', 'Viscera weight', 'Shell weight', 'Rings')\nclassification_feature = 'Rings'\nclassification_number = 29\n\n\ndef features_normalization (features):\n    row_count = features.shape[0]\n    min = features.min(axis = 0)\n    max = features.max(axis = 0)\n\n    step = max - min\n\n    normalization_matrix = zeros(features.shape)\n    normalization_matrix = features - tile(min, [row_count, 1])\n    normalization_matrix = normalization_matrix / tile(step, [row_count, 1])\n    return normalization_matrix, step, min\n\n\ndef process_input_samples (path):\n    samples_file_handler = open(path, mode='r')\n    formatted_samples_class = []\n    sample_index = 0\n\n    samples_all_lines = samples_file_handler.readlines()\n    samples_all_lines_len = len(samples_all_lines)\n    samples_features_len = len(features)\n\n    &quot; Generate a matrix with zero&quot;\n    samples_all_matrix = zeros([samples_all_lines_len, samples_features_len - 1])\n    for line in samples_all_lines:\n        line = line.strip()\n        sample_features_list = line.split(',')\n        samples_all_matrix[sample_index, :] = sample_features_list[:samples_features_len - 1]\n        formatted_samples_class.append(int(sample_features_list[-1]))\n        sample_index += 1\n    return samples_all_matrix, formatted_samples_class\n\n\n\ndef handle_samples (path):\n    samples_all_matrix, formatted_samples_class = process_input_samples(path)\n    normalization_matrix, step, min = features_normalization(samples_all_matrix)\n    return normalization_matrix, step, min, formatted_samples_class\n\n\ndef handle_testcase_samples(path, step, min):\n    samples_all_matrix, classification_initial_list  = process_input_samples(path)\n    &quot; Normalization according to previous training set &quot;\n    row_count = samples_all_matrix.shape[0]\n    normalization_matrix = zeros(samples_all_matrix.shape)\n    normalization_matrix = samples_all_matrix - tile(min, [row_count, 1])\n    normalization_matrix = normalization_matrix / tile(step, [row_count, 1])\n\n    return normalization_matrix\n\n\ndef handle_samples_with_tensorflow (path):\n    process_input_samples(path)\n\nparser = argparse.ArgumentParser (description='KNN - YHSPY')\nparser.add_argument('--samples', help = 'Input the path of sample file for KNN algorithm')\nparser.add_argument('--test', help = 'Input the path of predict samples file.')\nparser.add_argument('--ts', help = 'Use tensorflow as an analysis tool', action = 'store_true')\n\n&quot; Extract input parameters &quot;\nsamples_path = parser.parse_args().samples\ntestcase_samples_path = parser.parse_args().test\nuse_tensorflow = parser.parse_args().ts\n\nif os.path.exists(samples_path):\n    if use_tensorflow:\n        handle_samples_with_tensorflow(samples_path)\n    else:\n        samples_all_matrix, step, min, formatted_samples_class = handle_samples(samples_path)\n        samples_all_testcase_matrix = handle_testcase_samples(testcase_samples_path, step, min)\n        row_count = samples_all_matrix.shape[0]\n\n        for testcasae in samples_all_testcase_matrix:\n            diffMat = tile(testcasae, [row_count, 1]) - samples_all_matrix\n            &quot; argsort return the index of elements after sorted&quot;\n            distance = ((diffMat ** 2).sum(axis = 1)) ** 0.5\n            distanceSorted = distance.argsort()\n            voteCount = {}\n\n            &quot; General k&quot;\n            for i in range(int(len(samples_all_matrix) ** 0.5)):\n                voteLable = formatted_samples_class[distanceSorted[i]]\n                voteCount[voteLable] = voteCount.get(voteLable, 0) + (1 / distance[distanceSorted[i]])\n            &quot; itermitems return an iterator used for dict &quot;\n            sortedVotes = sorted(voteCount.items(), key = operator.itemgetter(1), reverse = True)\n            print (sortedVotes[0][0])\nelse:\n    raise Exception('[Exception] Invalid path of input samples.')\n\n```\n","source":"_posts/基于-NumPy-和-TensorFlow-的简单-KNN-实现.md","raw":"---\ntitle: 基于 NumPy 和 TensorFlow 的简单 KNN 实现\nintro: 最近花了点时间分别用 NumPy 和 TensorFlow 实现了一个简单基础的 KNN 算法。对于两种实现而言，KNN 算法的原理与常见的问题都是一致的。这里主要记录下实现的代码过程，同时讨论下 KNN 算法本身的一些问题。所有实现均基于 Python3，需要的相关 Lib 可以通过 Pip 进行安装。\ncomments: true\ndate: 2017-05-26 22:50:24\ntags:\n- KNN\n- TensorFlow\n---\n\n\n最近花了点时间分别用 NumPy 和 TensorFlow 实现了一个简单基础的 KNN 算法。对于两种实现而言，KNN 算法的原理与常见的问题都是一致的。这里主要记录下实现的代码过程，同时讨论下 KNN 算法本身的一些问题。所有实现均基于 Python3，需要的相关 Lib 可以通过 Pip 进行安装。\n\n\n\n#### 1、资源：\n\n1. 仓库地址：[https://github.com/Becavalier/MachineLearning](https://github.com/Becavalier/MachineLearning)；\n2. 实验数据地址：[http://archive.ics.uci.edu/ml/](http://archive.ics.uci.edu/ml/)；\n\n\n\n#### 2、遇到的问题：\n\n1. 为了防止单一特征的数值过大影响欧氏距离的计算，在进行距离计算前统一进行归一化处理；\n2. 训练样本的数量分布不均匀，集中在某几个类型的样本数量过多，若最后采用“K 距离内的多数表决法”，则数量多的样本会对最后结果产生影响。因此最后采用距离权重的方式来进行表决；\n3. 欧式距离并不适合该模型的惰性训练和预测，可能原因是：并不是所有给出的特征都与最后需要进行分类的特征有很强的相关性，最后的分类结果大多会受到这些无用特征的影响，这些特征变成了噪声；\n4. 计算**距离权重**的方式可以采用距离倒数或者高斯函数的方式；\n5. 最优 K 可以通过交叉验证的方式进行测量；\n\n\n\n#### 3、待优化：\n\n1. 高斯函数代替距离权重；\n2. 交叉检验；\n3. TensorFlow 替代；\n\n\n#### 4、源代码：\n\n```python\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n&quot; KNN - Machine Learning &quot;\n\n__author__ = 'YHSPY'\n\nfrom numpy import *\nimport operator\nimport argparse\nimport os\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport tensorflow as tf\n\n&quot; Cloumns setting&quot;\nfeatures = ('Sex', 'Length', 'Diameter', 'Height', 'Whole weight', 'Shucked weight', 'Viscera weight', 'Shell weight', 'Rings')\nclassification_feature = 'Rings'\nclassification_number = 29\n\n\ndef features_normalization (features):\n    row_count = features.shape[0]\n    min = features.min(axis = 0)\n    max = features.max(axis = 0)\n\n    step = max - min\n\n    normalization_matrix = zeros(features.shape)\n    normalization_matrix = features - tile(min, [row_count, 1])\n    normalization_matrix = normalization_matrix / tile(step, [row_count, 1])\n    return normalization_matrix, step, min\n\n\ndef process_input_samples (path):\n    samples_file_handler = open(path, mode='r')\n    formatted_samples_class = []\n    sample_index = 0\n\n    samples_all_lines = samples_file_handler.readlines()\n    samples_all_lines_len = len(samples_all_lines)\n    samples_features_len = len(features)\n\n    &quot; Generate a matrix with zero&quot;\n    samples_all_matrix = zeros([samples_all_lines_len, samples_features_len - 1])\n    for line in samples_all_lines:\n        line = line.strip()\n        sample_features_list = line.split(',')\n        samples_all_matrix[sample_index, :] = sample_features_list[:samples_features_len - 1]\n        formatted_samples_class.append(int(sample_features_list[-1]))\n        sample_index += 1\n    return samples_all_matrix, formatted_samples_class\n\n\n\ndef handle_samples (path):\n    samples_all_matrix, formatted_samples_class = process_input_samples(path)\n    normalization_matrix, step, min = features_normalization(samples_all_matrix)\n    return normalization_matrix, step, min, formatted_samples_class\n\n\ndef handle_testcase_samples(path, step, min):\n    samples_all_matrix, classification_initial_list  = process_input_samples(path)\n    &quot; Normalization according to previous training set &quot;\n    row_count = samples_all_matrix.shape[0]\n    normalization_matrix = zeros(samples_all_matrix.shape)\n    normalization_matrix = samples_all_matrix - tile(min, [row_count, 1])\n    normalization_matrix = normalization_matrix / tile(step, [row_count, 1])\n\n    return normalization_matrix\n\n\ndef handle_samples_with_tensorflow (path):\n    process_input_samples(path)\n\nparser = argparse.ArgumentParser (description='KNN - YHSPY')\nparser.add_argument('--samples', help = 'Input the path of sample file for KNN algorithm')\nparser.add_argument('--test', help = 'Input the path of predict samples file.')\nparser.add_argument('--ts', help = 'Use tensorflow as an analysis tool', action = 'store_true')\n\n&quot; Extract input parameters &quot;\nsamples_path = parser.parse_args().samples\ntestcase_samples_path = parser.parse_args().test\nuse_tensorflow = parser.parse_args().ts\n\nif os.path.exists(samples_path):\n    if use_tensorflow:\n        handle_samples_with_tensorflow(samples_path)\n    else:\n        samples_all_matrix, step, min, formatted_samples_class = handle_samples(samples_path)\n        samples_all_testcase_matrix = handle_testcase_samples(testcase_samples_path, step, min)\n        row_count = samples_all_matrix.shape[0]\n\n        for testcasae in samples_all_testcase_matrix:\n            diffMat = tile(testcasae, [row_count, 1]) - samples_all_matrix\n            &quot; argsort return the index of elements after sorted&quot;\n            distance = ((diffMat ** 2).sum(axis = 1)) ** 0.5\n            distanceSorted = distance.argsort()\n            voteCount = {}\n\n            &quot; General k&quot;\n            for i in range(int(len(samples_all_matrix) ** 0.5)):\n                voteLable = formatted_samples_class[distanceSorted[i]]\n                voteCount[voteLable] = voteCount.get(voteLable, 0) + (1 / distance[distanceSorted[i]])\n            &quot; itermitems return an iterator used for dict &quot;\n            sortedVotes = sorted(voteCount.items(), key = operator.itemgetter(1), reverse = True)\n            print (sortedVotes[0][0])\nelse:\n    raise Exception('[Exception] Invalid path of input samples.')\n\n```\n","slug":"基于-NumPy-和-TensorFlow-的简单-KNN-实现","published":1,"updated":"2019-02-18T02:18:46.276Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtb4006qknp2msquzl4w","content":"<p>最近花了点时间分别用 NumPy 和 TensorFlow 实现了一个简单基础的 KNN 算法。对于两种实现而言，KNN 算法的原理与常见的问题都是一致的。这里主要记录下实现的代码过程，同时讨论下 KNN 算法本身的一些问题。所有实现均基于 Python3，需要的相关 Lib 可以通过 Pip 进行安装。</p>\n<h4 id=\"1、资源：\"><a href=\"#1、资源：\" class=\"headerlink\" title=\"1、资源：\"></a>1、资源：</h4><ol>\n<li>仓库地址：<a href=\"https://github.com/Becavalier/MachineLearning\" target=\"_blank\" rel=\"noopener\">https://github.com/Becavalier/MachineLearning</a>；</li>\n<li>实验数据地址：<a href=\"http://archive.ics.uci.edu/ml/\" target=\"_blank\" rel=\"noopener\">http://archive.ics.uci.edu/ml/</a>；</li>\n</ol>\n<h4 id=\"2、遇到的问题：\"><a href=\"#2、遇到的问题：\" class=\"headerlink\" title=\"2、遇到的问题：\"></a>2、遇到的问题：</h4><ol>\n<li>为了防止单一特征的数值过大影响欧氏距离的计算，在进行距离计算前统一进行归一化处理；</li>\n<li>训练样本的数量分布不均匀，集中在某几个类型的样本数量过多，若最后采用“K 距离内的多数表决法”，则数量多的样本会对最后结果产生影响。因此最后采用距离权重的方式来进行表决；</li>\n<li>欧式距离并不适合该模型的惰性训练和预测，可能原因是：并不是所有给出的特征都与最后需要进行分类的特征有很强的相关性，最后的分类结果大多会受到这些无用特征的影响，这些特征变成了噪声；</li>\n<li>计算<strong>距离权重</strong>的方式可以采用距离倒数或者高斯函数的方式；</li>\n<li>最优 K 可以通过交叉验证的方式进行测量；</li>\n</ol>\n<h4 id=\"3、待优化：\"><a href=\"#3、待优化：\" class=\"headerlink\" title=\"3、待优化：\"></a>3、待优化：</h4><ol>\n<li>高斯函数代替距离权重；</li>\n<li>交叉检验；</li>\n<li>TensorFlow 替代；</li>\n</ol>\n<h4 id=\"4、源代码：\"><a href=\"#4、源代码：\" class=\"headerlink\" title=\"4、源代码：\"></a>4、源代码：</h4><pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token comment\" spellcheck=\"true\">#!/usr/bin/env python3</span>\n<span class=\"token comment\" spellcheck=\"true\"># -*- coding: utf-8 -*-</span>\n\n<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span> KNN <span class=\"token operator\">-</span> Machine Learning <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>\n\n__author__ <span class=\"token operator\">=</span> <span class=\"token string\">'YHSPY'</span>\n\n<span class=\"token keyword\">from</span> numpy <span class=\"token keyword\">import</span> <span class=\"token operator\">*</span>\n<span class=\"token keyword\">import</span> operator\n<span class=\"token keyword\">import</span> argparse\n<span class=\"token keyword\">import</span> os\n<span class=\"token keyword\">import</span> matplotlib\n<span class=\"token keyword\">import</span> matplotlib<span class=\"token punctuation\">.</span>pyplot <span class=\"token keyword\">as</span> plt\n<span class=\"token keyword\">import</span> tensorflow <span class=\"token keyword\">as</span> tf\n\n<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span> Cloumns setting<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>\nfeatures <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token string\">'Sex'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Length'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Diameter'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Height'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Whole weight'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Shucked weight'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Viscera weight'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Shell weight'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Rings'</span><span class=\"token punctuation\">)</span>\nclassification_feature <span class=\"token operator\">=</span> <span class=\"token string\">'Rings'</span>\nclassification_number <span class=\"token operator\">=</span> <span class=\"token number\">29</span>\n\n\n<span class=\"token keyword\">def</span> features_normalization <span class=\"token punctuation\">(</span>features<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    row_count <span class=\"token operator\">=</span> features<span class=\"token punctuation\">.</span>shape<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\n    min <span class=\"token operator\">=</span> features<span class=\"token punctuation\">.</span>min<span class=\"token punctuation\">(</span>axis <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    max <span class=\"token operator\">=</span> features<span class=\"token punctuation\">.</span>max<span class=\"token punctuation\">(</span>axis <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n\n    step <span class=\"token operator\">=</span> max <span class=\"token operator\">-</span> min\n\n    normalization_matrix <span class=\"token operator\">=</span> zeros<span class=\"token punctuation\">(</span>features<span class=\"token punctuation\">.</span>shape<span class=\"token punctuation\">)</span>\n    normalization_matrix <span class=\"token operator\">=</span> features <span class=\"token operator\">-</span> tile<span class=\"token punctuation\">(</span>min<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>row_count<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    normalization_matrix <span class=\"token operator\">=</span> normalization_matrix <span class=\"token operator\">/</span> tile<span class=\"token punctuation\">(</span>step<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>row_count<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> normalization_matrix<span class=\"token punctuation\">,</span> step<span class=\"token punctuation\">,</span> min\n\n\n<span class=\"token keyword\">def</span> process_input_samples <span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    samples_file_handler <span class=\"token operator\">=</span> open<span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">,</span> mode<span class=\"token operator\">=</span><span class=\"token string\">'r'</span><span class=\"token punctuation\">)</span>\n    formatted_samples_class <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    sample_index <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n\n    samples_all_lines <span class=\"token operator\">=</span> samples_file_handler<span class=\"token punctuation\">.</span>readlines<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    samples_all_lines_len <span class=\"token operator\">=</span> len<span class=\"token punctuation\">(</span>samples_all_lines<span class=\"token punctuation\">)</span>\n    samples_features_len <span class=\"token operator\">=</span> len<span class=\"token punctuation\">(</span>features<span class=\"token punctuation\">)</span>\n\n    <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span> Generate a matrix <span class=\"token keyword\">with</span> zero<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>\n    samples_all_matrix <span class=\"token operator\">=</span> zeros<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>samples_all_lines_len<span class=\"token punctuation\">,</span> samples_features_len <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">for</span> line <span class=\"token keyword\">in</span> samples_all_lines<span class=\"token punctuation\">:</span>\n        line <span class=\"token operator\">=</span> line<span class=\"token punctuation\">.</span>strip<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        sample_features_list <span class=\"token operator\">=</span> line<span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token string\">','</span><span class=\"token punctuation\">)</span>\n        samples_all_matrix<span class=\"token punctuation\">[</span>sample_index<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> sample_features_list<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span>samples_features_len <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n        formatted_samples_class<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>int<span class=\"token punctuation\">(</span>sample_features_list<span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        sample_index <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n    <span class=\"token keyword\">return</span> samples_all_matrix<span class=\"token punctuation\">,</span> formatted_samples_class\n\n\n\n<span class=\"token keyword\">def</span> handle_samples <span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    samples_all_matrix<span class=\"token punctuation\">,</span> formatted_samples_class <span class=\"token operator\">=</span> process_input_samples<span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">)</span>\n    normalization_matrix<span class=\"token punctuation\">,</span> step<span class=\"token punctuation\">,</span> min <span class=\"token operator\">=</span> features_normalization<span class=\"token punctuation\">(</span>samples_all_matrix<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> normalization_matrix<span class=\"token punctuation\">,</span> step<span class=\"token punctuation\">,</span> min<span class=\"token punctuation\">,</span> formatted_samples_class\n\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">handle_testcase_samples</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">,</span> step<span class=\"token punctuation\">,</span> min<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    samples_all_matrix<span class=\"token punctuation\">,</span> classification_initial_list  <span class=\"token operator\">=</span> process_input_samples<span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">)</span>\n    <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span> Normalization according to previous training set <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>\n    row_count <span class=\"token operator\">=</span> samples_all_matrix<span class=\"token punctuation\">.</span>shape<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\n    normalization_matrix <span class=\"token operator\">=</span> zeros<span class=\"token punctuation\">(</span>samples_all_matrix<span class=\"token punctuation\">.</span>shape<span class=\"token punctuation\">)</span>\n    normalization_matrix <span class=\"token operator\">=</span> samples_all_matrix <span class=\"token operator\">-</span> tile<span class=\"token punctuation\">(</span>min<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>row_count<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    normalization_matrix <span class=\"token operator\">=</span> normalization_matrix <span class=\"token operator\">/</span> tile<span class=\"token punctuation\">(</span>step<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>row_count<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">return</span> normalization_matrix\n\n\n<span class=\"token keyword\">def</span> handle_samples_with_tensorflow <span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    process_input_samples<span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">)</span>\n\nparser <span class=\"token operator\">=</span> argparse<span class=\"token punctuation\">.</span>ArgumentParser <span class=\"token punctuation\">(</span>description<span class=\"token operator\">=</span><span class=\"token string\">'KNN - YHSPY'</span><span class=\"token punctuation\">)</span>\nparser<span class=\"token punctuation\">.</span>add_argument<span class=\"token punctuation\">(</span><span class=\"token string\">'--samples'</span><span class=\"token punctuation\">,</span> help <span class=\"token operator\">=</span> <span class=\"token string\">'Input the path of sample file for KNN algorithm'</span><span class=\"token punctuation\">)</span>\nparser<span class=\"token punctuation\">.</span>add_argument<span class=\"token punctuation\">(</span><span class=\"token string\">'--test'</span><span class=\"token punctuation\">,</span> help <span class=\"token operator\">=</span> <span class=\"token string\">'Input the path of predict samples file.'</span><span class=\"token punctuation\">)</span>\nparser<span class=\"token punctuation\">.</span>add_argument<span class=\"token punctuation\">(</span><span class=\"token string\">'--ts'</span><span class=\"token punctuation\">,</span> help <span class=\"token operator\">=</span> <span class=\"token string\">'Use tensorflow as an analysis tool'</span><span class=\"token punctuation\">,</span> action <span class=\"token operator\">=</span> <span class=\"token string\">'store_true'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span> Extract input parameters <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>\nsamples_path <span class=\"token operator\">=</span> parser<span class=\"token punctuation\">.</span>parse_args<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>samples\ntestcase_samples_path <span class=\"token operator\">=</span> parser<span class=\"token punctuation\">.</span>parse_args<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>test\nuse_tensorflow <span class=\"token operator\">=</span> parser<span class=\"token punctuation\">.</span>parse_args<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>ts\n\n<span class=\"token keyword\">if</span> os<span class=\"token punctuation\">.</span>path<span class=\"token punctuation\">.</span>exists<span class=\"token punctuation\">(</span>samples_path<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">if</span> use_tensorflow<span class=\"token punctuation\">:</span>\n        handle_samples_with_tensorflow<span class=\"token punctuation\">(</span>samples_path<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        samples_all_matrix<span class=\"token punctuation\">,</span> step<span class=\"token punctuation\">,</span> min<span class=\"token punctuation\">,</span> formatted_samples_class <span class=\"token operator\">=</span> handle_samples<span class=\"token punctuation\">(</span>samples_path<span class=\"token punctuation\">)</span>\n        samples_all_testcase_matrix <span class=\"token operator\">=</span> handle_testcase_samples<span class=\"token punctuation\">(</span>testcase_samples_path<span class=\"token punctuation\">,</span> step<span class=\"token punctuation\">,</span> min<span class=\"token punctuation\">)</span>\n        row_count <span class=\"token operator\">=</span> samples_all_matrix<span class=\"token punctuation\">.</span>shape<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\n\n        <span class=\"token keyword\">for</span> testcasae <span class=\"token keyword\">in</span> samples_all_testcase_matrix<span class=\"token punctuation\">:</span>\n            diffMat <span class=\"token operator\">=</span> tile<span class=\"token punctuation\">(</span>testcasae<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>row_count<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> samples_all_matrix\n            <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span> argsort <span class=\"token keyword\">return</span> the index of elements after sorted<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>\n            distance <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>diffMat <span class=\"token operator\">**</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>sum<span class=\"token punctuation\">(</span>axis <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">**</span> <span class=\"token number\">0.5</span>\n            distanceSorted <span class=\"token operator\">=</span> distance<span class=\"token punctuation\">.</span>argsort<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n            voteCount <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n            <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span> General k<span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> range<span class=\"token punctuation\">(</span>int<span class=\"token punctuation\">(</span>len<span class=\"token punctuation\">(</span>samples_all_matrix<span class=\"token punctuation\">)</span> <span class=\"token operator\">**</span> <span class=\"token number\">0.5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n                voteLable <span class=\"token operator\">=</span> formatted_samples_class<span class=\"token punctuation\">[</span>distanceSorted<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span>\n                voteCount<span class=\"token punctuation\">[</span>voteLable<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> voteCount<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span>voteLable<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span> <span class=\"token operator\">/</span> distance<span class=\"token punctuation\">[</span>distanceSorted<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n            <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span> itermitems <span class=\"token keyword\">return</span> an iterator used <span class=\"token keyword\">for</span> dict <span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>\n            sortedVotes <span class=\"token operator\">=</span> sorted<span class=\"token punctuation\">(</span>voteCount<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> key <span class=\"token operator\">=</span> operator<span class=\"token punctuation\">.</span>itemgetter<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> reverse <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">print</span> <span class=\"token punctuation\">(</span>sortedVotes<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">raise</span> Exception<span class=\"token punctuation\">(</span><span class=\"token string\">'[Exception] Invalid path of input samples.'</span><span class=\"token punctuation\">)</span>\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"id":"ef5a36a0d98d86504c4cda4021964bab","excerpt":"","more":"<p>最近花了点时间分别用 NumPy 和 TensorFlow 实现了一个简单基础的 KNN 算法。对于两种实现而言，KNN 算法的原理与常见的问题都是一致的。这里主要记录下实现的代码过程，同时讨论下 KNN 算法本身的一些问题。所有实现均基于 Python3，需要的相关 Lib 可以通过 Pip 进行安装。</p>\n<h4 id=\"1、资源：\"><a href=\"#1、资源：\" class=\"headerlink\" title=\"1、资源：\"></a>1、资源：</h4><ol>\n<li>仓库地址：<a href=\"https://github.com/Becavalier/MachineLearning\" target=\"_blank\" rel=\"noopener\">https://github.com/Becavalier/MachineLearning</a>；</li>\n<li>实验数据地址：<a href=\"http://archive.ics.uci.edu/ml/\" target=\"_blank\" rel=\"noopener\">http://archive.ics.uci.edu/ml/</a>；</li>\n</ol>\n<h4 id=\"2、遇到的问题：\"><a href=\"#2、遇到的问题：\" class=\"headerlink\" title=\"2、遇到的问题：\"></a>2、遇到的问题：</h4><ol>\n<li>为了防止单一特征的数值过大影响欧氏距离的计算，在进行距离计算前统一进行归一化处理；</li>\n<li>训练样本的数量分布不均匀，集中在某几个类型的样本数量过多，若最后采用“K 距离内的多数表决法”，则数量多的样本会对最后结果产生影响。因此最后采用距离权重的方式来进行表决；</li>\n<li>欧式距离并不适合该模型的惰性训练和预测，可能原因是：并不是所有给出的特征都与最后需要进行分类的特征有很强的相关性，最后的分类结果大多会受到这些无用特征的影响，这些特征变成了噪声；</li>\n<li>计算<strong>距离权重</strong>的方式可以采用距离倒数或者高斯函数的方式；</li>\n<li>最优 K 可以通过交叉验证的方式进行测量；</li>\n</ol>\n<h4 id=\"3、待优化：\"><a href=\"#3、待优化：\" class=\"headerlink\" title=\"3、待优化：\"></a>3、待优化：</h4><ol>\n<li>高斯函数代替距离权重；</li>\n<li>交叉检验；</li>\n<li>TensorFlow 替代；</li>\n</ol>\n<h4 id=\"4、源代码：\"><a href=\"#4、源代码：\" class=\"headerlink\" title=\"4、源代码：\"></a>4、源代码：</h4><pre><code class=\"python\">#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n&amp;quot; KNN - Machine Learning &amp;quot;\n\n__author__ = &#39;YHSPY&#39;\n\nfrom numpy import *\nimport operator\nimport argparse\nimport os\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport tensorflow as tf\n\n&amp;quot; Cloumns setting&amp;quot;\nfeatures = (&#39;Sex&#39;, &#39;Length&#39;, &#39;Diameter&#39;, &#39;Height&#39;, &#39;Whole weight&#39;, &#39;Shucked weight&#39;, &#39;Viscera weight&#39;, &#39;Shell weight&#39;, &#39;Rings&#39;)\nclassification_feature = &#39;Rings&#39;\nclassification_number = 29\n\n\ndef features_normalization (features):\n    row_count = features.shape[0]\n    min = features.min(axis = 0)\n    max = features.max(axis = 0)\n\n    step = max - min\n\n    normalization_matrix = zeros(features.shape)\n    normalization_matrix = features - tile(min, [row_count, 1])\n    normalization_matrix = normalization_matrix / tile(step, [row_count, 1])\n    return normalization_matrix, step, min\n\n\ndef process_input_samples (path):\n    samples_file_handler = open(path, mode=&#39;r&#39;)\n    formatted_samples_class = []\n    sample_index = 0\n\n    samples_all_lines = samples_file_handler.readlines()\n    samples_all_lines_len = len(samples_all_lines)\n    samples_features_len = len(features)\n\n    &amp;quot; Generate a matrix with zero&amp;quot;\n    samples_all_matrix = zeros([samples_all_lines_len, samples_features_len - 1])\n    for line in samples_all_lines:\n        line = line.strip()\n        sample_features_list = line.split(&#39;,&#39;)\n        samples_all_matrix[sample_index, :] = sample_features_list[:samples_features_len - 1]\n        formatted_samples_class.append(int(sample_features_list[-1]))\n        sample_index += 1\n    return samples_all_matrix, formatted_samples_class\n\n\n\ndef handle_samples (path):\n    samples_all_matrix, formatted_samples_class = process_input_samples(path)\n    normalization_matrix, step, min = features_normalization(samples_all_matrix)\n    return normalization_matrix, step, min, formatted_samples_class\n\n\ndef handle_testcase_samples(path, step, min):\n    samples_all_matrix, classification_initial_list  = process_input_samples(path)\n    &amp;quot; Normalization according to previous training set &amp;quot;\n    row_count = samples_all_matrix.shape[0]\n    normalization_matrix = zeros(samples_all_matrix.shape)\n    normalization_matrix = samples_all_matrix - tile(min, [row_count, 1])\n    normalization_matrix = normalization_matrix / tile(step, [row_count, 1])\n\n    return normalization_matrix\n\n\ndef handle_samples_with_tensorflow (path):\n    process_input_samples(path)\n\nparser = argparse.ArgumentParser (description=&#39;KNN - YHSPY&#39;)\nparser.add_argument(&#39;--samples&#39;, help = &#39;Input the path of sample file for KNN algorithm&#39;)\nparser.add_argument(&#39;--test&#39;, help = &#39;Input the path of predict samples file.&#39;)\nparser.add_argument(&#39;--ts&#39;, help = &#39;Use tensorflow as an analysis tool&#39;, action = &#39;store_true&#39;)\n\n&amp;quot; Extract input parameters &amp;quot;\nsamples_path = parser.parse_args().samples\ntestcase_samples_path = parser.parse_args().test\nuse_tensorflow = parser.parse_args().ts\n\nif os.path.exists(samples_path):\n    if use_tensorflow:\n        handle_samples_with_tensorflow(samples_path)\n    else:\n        samples_all_matrix, step, min, formatted_samples_class = handle_samples(samples_path)\n        samples_all_testcase_matrix = handle_testcase_samples(testcase_samples_path, step, min)\n        row_count = samples_all_matrix.shape[0]\n\n        for testcasae in samples_all_testcase_matrix:\n            diffMat = tile(testcasae, [row_count, 1]) - samples_all_matrix\n            &amp;quot; argsort return the index of elements after sorted&amp;quot;\n            distance = ((diffMat ** 2).sum(axis = 1)) ** 0.5\n            distanceSorted = distance.argsort()\n            voteCount = {}\n\n            &amp;quot; General k&amp;quot;\n            for i in range(int(len(samples_all_matrix) ** 0.5)):\n                voteLable = formatted_samples_class[distanceSorted[i]]\n                voteCount[voteLable] = voteCount.get(voteLable, 0) + (1 / distance[distanceSorted[i]])\n            &amp;quot; itermitems return an iterator used for dict &amp;quot;\n            sortedVotes = sorted(voteCount.items(), key = operator.itemgetter(1), reverse = True)\n            print (sortedVotes[0][0])\nelse:\n    raise Exception(&#39;[Exception] Invalid path of input samples.&#39;)\n\n</code></pre>\n"},{"title":"基于 PHP 实现的优化盐值加密算法","intro":"通常在开发网站注册登录模块时，我们会在网站的后端数据库中存储用户密码对应的 MD5 值，即用户密码的 Hash 值，而不会直接存储用户的明文密码。这种做法确实可以大大提高网站运行的安全性，即使网站的数据库泄露也不会轻易的将明文密码展示给黑客。但随着时间的推移，这种方式的安全性也在慢慢降低。","comments":1,"date":"2015-03-20T14:36:48.000Z","_content":"\n通常在开发网站注册登录模块时，我们会在网站的后端数据库中存储用户密码对应的 MD5 值，即用户密码的 Hash 值，而不会直接存储用户的明文密码。这种做法确实可以大大提高网站运行的安全性，即使网站的数据库泄露也不会轻易的将明文密码展示给黑客。但随着时间的推移，这种方式的安全性也在慢慢降低。\n\n当黑客获得用户明文密码的散列值后，便可以通过查询散列值字典（例如 MD5 密码破解网站），来得到某用户的明文密码。随着时间推移，这些 MD5 密码破解网站的破解数据库信息越来越多，散列值被破解的几率也会越来越大。因此，很多企业便逐渐开始采用一种名为“盐值加密”的新型加密方法，但其本身还是基于 MD5 的。\n\n“盐值加密”的基本想法是这样的：当用户首次提供密码时，由系统自动向这个密码加入一些“盐值”，即一些随机信息，然后再进行散列存储到数据库中。而当用户登录时，系统为用户提供的代码加入同样的“盐值”信息，然后进行散列，最后通过比较两者的散列值是否相等，来判断密码是否正确。\n\n由于密码和“盐值”混合在一起，随机的“盐值”使得散列值被破解的几率大大降低，并且黑客也无法确定对应明文密码的正确长度及信息是否正确。解密的过程变得更加复杂，因此安全性得以相对提高。现在大多数论坛程序所使用的“盐值加密”算法如下：\n\n```php\nfunction saltPwd($password, $salt) {\n  return md5(md5($salt) . $password);\n  // 或者采用如下方式，但本质原理上是一样的；\n  // return md5($salt . $password);\n}\n```\n\n将密码明文与“盐值”的散列值进行组合，然后再次进行散列来得到最后加入了“盐值”的加密信息。这种方法虽然采用了“盐值加密”，但也并不是最佳的密码安全防范手段。如果这个全局的“盐值”信息被泄露出去，那么黑客还可以继续通过散列字典或者“彩虹表”来推断用户的真实密码信息。所以我们有了如下经过优化的“盐值加密”算法：\n\n```php\nfunction optimizedSaltPwd($password, $salt, $saltGain = 1) {\n  // 过滤参数；\n  if(!is_numeric($saltGain)) exit;\n  if(intval($saltGain) < 0 || intval($saltGain) > 35) exit;\n\t\n  // 对 MD5 后的盐值进行变换，添加信息增益；\n  $tempSaltMd5 = md5($salt);\n  for($i = 0;$i < strlen($tempSaltMd5); $i++){\n    if(ord($tempSaltMd5[$i]) < 91 && ord($tempSaltMd5[$i]) > 32) {\n      // 每一个字符添加同样的增益；\n      $tempSaltMd5[$i] = chr(ord($tempSaltMd5[$i]) + $saltGain);\n    }\n  }\n\n  // 返回整个哈希值；\n  return md5($password . $tempSaltMd5);\n}\n```\n\n这里通过使用 `$saltGain`（盐值增益）和 `$salt`（盐值）来控制最后产生的加密信息。这种优化的“盐值加密”算法其改进点在于：对已经哈希化的数据中又隐藏了自定义的增益信息，这些增益信息的添加方式是由具体的算法决定的。当然，上述算法只是哈希增益改进算法中的一个例子，具体的改进优化方法还有很多。但最基本的思想就是尽可能增加反向哈希解密的复杂度。\n","source":"_posts/基于-PHP-实现的优化盐值加密算法.md","raw":"---\ntitle: 基于 PHP 实现的优化盐值加密算法\nintro: 通常在开发网站注册登录模块时，我们会在网站的后端数据库中存储用户密码对应的 MD5 值，即用户密码的 Hash 值，而不会直接存储用户的明文密码。这种做法确实可以大大提高网站运行的安全性，即使网站的数据库泄露也不会轻易的将明文密码展示给黑客。但随着时间的推移，这种方式的安全性也在慢慢降低。\ncomments: true\ndate: 2015-03-20 22:36:48\ntags:\n- PHP\n---\n\n通常在开发网站注册登录模块时，我们会在网站的后端数据库中存储用户密码对应的 MD5 值，即用户密码的 Hash 值，而不会直接存储用户的明文密码。这种做法确实可以大大提高网站运行的安全性，即使网站的数据库泄露也不会轻易的将明文密码展示给黑客。但随着时间的推移，这种方式的安全性也在慢慢降低。\n\n当黑客获得用户明文密码的散列值后，便可以通过查询散列值字典（例如 MD5 密码破解网站），来得到某用户的明文密码。随着时间推移，这些 MD5 密码破解网站的破解数据库信息越来越多，散列值被破解的几率也会越来越大。因此，很多企业便逐渐开始采用一种名为“盐值加密”的新型加密方法，但其本身还是基于 MD5 的。\n\n“盐值加密”的基本想法是这样的：当用户首次提供密码时，由系统自动向这个密码加入一些“盐值”，即一些随机信息，然后再进行散列存储到数据库中。而当用户登录时，系统为用户提供的代码加入同样的“盐值”信息，然后进行散列，最后通过比较两者的散列值是否相等，来判断密码是否正确。\n\n由于密码和“盐值”混合在一起，随机的“盐值”使得散列值被破解的几率大大降低，并且黑客也无法确定对应明文密码的正确长度及信息是否正确。解密的过程变得更加复杂，因此安全性得以相对提高。现在大多数论坛程序所使用的“盐值加密”算法如下：\n\n```php\nfunction saltPwd($password, $salt) {\n  return md5(md5($salt) . $password);\n  // 或者采用如下方式，但本质原理上是一样的；\n  // return md5($salt . $password);\n}\n```\n\n将密码明文与“盐值”的散列值进行组合，然后再次进行散列来得到最后加入了“盐值”的加密信息。这种方法虽然采用了“盐值加密”，但也并不是最佳的密码安全防范手段。如果这个全局的“盐值”信息被泄露出去，那么黑客还可以继续通过散列字典或者“彩虹表”来推断用户的真实密码信息。所以我们有了如下经过优化的“盐值加密”算法：\n\n```php\nfunction optimizedSaltPwd($password, $salt, $saltGain = 1) {\n  // 过滤参数；\n  if(!is_numeric($saltGain)) exit;\n  if(intval($saltGain) < 0 || intval($saltGain) > 35) exit;\n\t\n  // 对 MD5 后的盐值进行变换，添加信息增益；\n  $tempSaltMd5 = md5($salt);\n  for($i = 0;$i < strlen($tempSaltMd5); $i++){\n    if(ord($tempSaltMd5[$i]) < 91 && ord($tempSaltMd5[$i]) > 32) {\n      // 每一个字符添加同样的增益；\n      $tempSaltMd5[$i] = chr(ord($tempSaltMd5[$i]) + $saltGain);\n    }\n  }\n\n  // 返回整个哈希值；\n  return md5($password . $tempSaltMd5);\n}\n```\n\n这里通过使用 `$saltGain`（盐值增益）和 `$salt`（盐值）来控制最后产生的加密信息。这种优化的“盐值加密”算法其改进点在于：对已经哈希化的数据中又隐藏了自定义的增益信息，这些增益信息的添加方式是由具体的算法决定的。当然，上述算法只是哈希增益改进算法中的一个例子，具体的改进优化方法还有很多。但最基本的思想就是尽可能增加反向哈希解密的复杂度。\n","slug":"基于-PHP-实现的优化盐值加密算法","published":1,"updated":"2019-02-04T07:43:39.759Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtb5006sknp2q6ibs2i9","content":"<p>通常在开发网站注册登录模块时，我们会在网站的后端数据库中存储用户密码对应的 MD5 值，即用户密码的 Hash 值，而不会直接存储用户的明文密码。这种做法确实可以大大提高网站运行的安全性，即使网站的数据库泄露也不会轻易的将明文密码展示给黑客。但随着时间的推移，这种方式的安全性也在慢慢降低。</p>\n<p>当黑客获得用户明文密码的散列值后，便可以通过查询散列值字典（例如 MD5 密码破解网站），来得到某用户的明文密码。随着时间推移，这些 MD5 密码破解网站的破解数据库信息越来越多，散列值被破解的几率也会越来越大。因此，很多企业便逐渐开始采用一种名为“盐值加密”的新型加密方法，但其本身还是基于 MD5 的。</p>\n<p>“盐值加密”的基本想法是这样的：当用户首次提供密码时，由系统自动向这个密码加入一些“盐值”，即一些随机信息，然后再进行散列存储到数据库中。而当用户登录时，系统为用户提供的代码加入同样的“盐值”信息，然后进行散列，最后通过比较两者的散列值是否相等，来判断密码是否正确。</p>\n<p>由于密码和“盐值”混合在一起，随机的“盐值”使得散列值被破解的几率大大降低，并且黑客也无法确定对应明文密码的正确长度及信息是否正确。解密的过程变得更加复杂，因此安全性得以相对提高。现在大多数论坛程序所使用的“盐值加密”算法如下：</p>\n<pre class=\"line-numbers language-php\"><code class=\"language-php\"><span class=\"token keyword\">function</span> <span class=\"token function\">saltPwd</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$password</span><span class=\"token punctuation\">,</span> <span class=\"token variable\">$salt</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">md5</span><span class=\"token punctuation\">(</span><span class=\"token function\">md5</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$salt</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">.</span> <span class=\"token variable\">$password</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 或者采用如下方式，但本质原理上是一样的；</span>\n  <span class=\"token comment\" spellcheck=\"true\">// return md5($salt . $password);</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>将密码明文与“盐值”的散列值进行组合，然后再次进行散列来得到最后加入了“盐值”的加密信息。这种方法虽然采用了“盐值加密”，但也并不是最佳的密码安全防范手段。如果这个全局的“盐值”信息被泄露出去，那么黑客还可以继续通过散列字典或者“彩虹表”来推断用户的真实密码信息。所以我们有了如下经过优化的“盐值加密”算法：</p>\n<pre class=\"line-numbers language-php\"><code class=\"language-php\"><span class=\"token keyword\">function</span> <span class=\"token function\">optimizedSaltPwd</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$password</span><span class=\"token punctuation\">,</span> <span class=\"token variable\">$salt</span><span class=\"token punctuation\">,</span> <span class=\"token variable\">$saltGain</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 过滤参数；</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">is_numeric</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$saltGain</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> exit<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">intval</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$saltGain</span><span class=\"token punctuation\">)</span> <span class=\"token markup\">&lt; 0 || intval($saltGain) ></span> <span class=\"token number\">35</span><span class=\"token punctuation\">)</span> exit<span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// 对 MD5 后的盐值进行变换，添加信息增益；</span>\n  <span class=\"token variable\">$tempSaltMd5</span> <span class=\"token operator\">=</span> <span class=\"token function\">md5</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$salt</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$i</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span><span class=\"token variable\">$i</span> <span class=\"token operator\">&lt;</span> <span class=\"token function\">strlen</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$tempSaltMd5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token variable\">$i</span><span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">ord</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$tempSaltMd5</span><span class=\"token punctuation\">[</span><span class=\"token variable\">$i</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token markup\">&lt; 91 &amp;&amp; ord($tempSaltMd5[$i]) ></span> <span class=\"token number\">32</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 每一个字符添加同样的增益；</span>\n      <span class=\"token variable\">$tempSaltMd5</span><span class=\"token punctuation\">[</span><span class=\"token variable\">$i</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">chr</span><span class=\"token punctuation\">(</span><span class=\"token function\">ord</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$tempSaltMd5</span><span class=\"token punctuation\">[</span><span class=\"token variable\">$i</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token variable\">$saltGain</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// 返回整个哈希值；</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">md5</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$password</span> <span class=\"token punctuation\">.</span> <span class=\"token variable\">$tempSaltMd5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这里通过使用 <code>$saltGain</code>（盐值增益）和 <code>$salt</code>（盐值）来控制最后产生的加密信息。这种优化的“盐值加密”算法其改进点在于：对已经哈希化的数据中又隐藏了自定义的增益信息，这些增益信息的添加方式是由具体的算法决定的。当然，上述算法只是哈希增益改进算法中的一个例子，具体的改进优化方法还有很多。但最基本的思想就是尽可能增加反向哈希解密的复杂度。</p>\n","site":{"data":{}},"id":"23c13826af8c1eac33776f8ec5d00c66","excerpt":"","more":"<p>通常在开发网站注册登录模块时，我们会在网站的后端数据库中存储用户密码对应的 MD5 值，即用户密码的 Hash 值，而不会直接存储用户的明文密码。这种做法确实可以大大提高网站运行的安全性，即使网站的数据库泄露也不会轻易的将明文密码展示给黑客。但随着时间的推移，这种方式的安全性也在慢慢降低。</p>\n<p>当黑客获得用户明文密码的散列值后，便可以通过查询散列值字典（例如 MD5 密码破解网站），来得到某用户的明文密码。随着时间推移，这些 MD5 密码破解网站的破解数据库信息越来越多，散列值被破解的几率也会越来越大。因此，很多企业便逐渐开始采用一种名为“盐值加密”的新型加密方法，但其本身还是基于 MD5 的。</p>\n<p>“盐值加密”的基本想法是这样的：当用户首次提供密码时，由系统自动向这个密码加入一些“盐值”，即一些随机信息，然后再进行散列存储到数据库中。而当用户登录时，系统为用户提供的代码加入同样的“盐值”信息，然后进行散列，最后通过比较两者的散列值是否相等，来判断密码是否正确。</p>\n<p>由于密码和“盐值”混合在一起，随机的“盐值”使得散列值被破解的几率大大降低，并且黑客也无法确定对应明文密码的正确长度及信息是否正确。解密的过程变得更加复杂，因此安全性得以相对提高。现在大多数论坛程序所使用的“盐值加密”算法如下：</p>\n<pre><code class=\"php\">function saltPwd($password, $salt) {\n  return md5(md5($salt) . $password);\n  // 或者采用如下方式，但本质原理上是一样的；\n  // return md5($salt . $password);\n}\n</code></pre>\n<p>将密码明文与“盐值”的散列值进行组合，然后再次进行散列来得到最后加入了“盐值”的加密信息。这种方法虽然采用了“盐值加密”，但也并不是最佳的密码安全防范手段。如果这个全局的“盐值”信息被泄露出去，那么黑客还可以继续通过散列字典或者“彩虹表”来推断用户的真实密码信息。所以我们有了如下经过优化的“盐值加密”算法：</p>\n<pre><code class=\"php\">function optimizedSaltPwd($password, $salt, $saltGain = 1) {\n  // 过滤参数；\n  if(!is_numeric($saltGain)) exit;\n  if(intval($saltGain) &lt; 0 || intval($saltGain) &gt; 35) exit;\n\n  // 对 MD5 后的盐值进行变换，添加信息增益；\n  $tempSaltMd5 = md5($salt);\n  for($i = 0;$i &lt; strlen($tempSaltMd5); $i++){\n    if(ord($tempSaltMd5[$i]) &lt; 91 &amp;&amp; ord($tempSaltMd5[$i]) &gt; 32) {\n      // 每一个字符添加同样的增益；\n      $tempSaltMd5[$i] = chr(ord($tempSaltMd5[$i]) + $saltGain);\n    }\n  }\n\n  // 返回整个哈希值；\n  return md5($password . $tempSaltMd5);\n}\n</code></pre>\n<p>这里通过使用 <code>$saltGain</code>（盐值增益）和 <code>$salt</code>（盐值）来控制最后产生的加密信息。这种优化的“盐值加密”算法其改进点在于：对已经哈希化的数据中又隐藏了自定义的增益信息，这些增益信息的添加方式是由具体的算法决定的。当然，上述算法只是哈希增益改进算法中的一个例子，具体的改进优化方法还有很多。但最基本的思想就是尽可能增加反向哈希解密的复杂度。</p>\n"},{"title":"大数据基础架构概述","intro":"本篇文章用于记录大数据系统基础架构中的一些常用框架和工具介绍。从总体上来了解大数据相关（机器学习、深度学习等）处理的基本系统架构和各个软件框架、数据仓库、计算引擎的使用场景。","comments":1,"date":"2017-09-04T13:57:08.000Z","_content":"\n\n本篇文章用于记录大数据系统基础架构中的一些常用框架和工具介绍。从总体上来了解大数据相关（机器学习、深度学习等）处理的基本系统架构和各个软件框架、数据仓库、计算引擎的使用场景。\n\n#### 1、Hadoop：\n\n最早诞生的大数据处理计算框架，由 Java 语言编写。其结构主要包括三层：**HDFS** - Hadoop 分布式文件系统、**HBase** NoSQL 存储系统和一个基于 **MapReduce** 的分布式计算引擎；由于 Hadoop 会把计算的中间结果也存储到 HDFS，因此它并不适合有大量迭代计算的场景；并且一个 Job 只有 Map 和 Reduce 两个阶段，每个 Job 之间的数据依赖关系需要自己控制。同时其 MapTask 和 ReduceTask 也无法并行，数据处理效率较低。\n\n#### 2、Hadoop Yarn：\n\n是 Hadoop 自 0.23.0 版本后对其内部资源管理系统中的 JobTracker 和 TaskTracker 进行了大幅的的修改和重构以提高其性能。它的基本设计思想是将 MRv1 中的 JobTracker 拆分成了两个独立的服务，一个全局的资源管理器 ResourceManager(RM) 和每个应用程序特有的 ApplicationMaster。其中ResourceManager 负责整个系统的资源管理和分配，而 ApplicationMaster 负责单个应用程序的管理。这个新版本框架被命名为 Yarn。\n\n#### 3、Spark：\n\n是继 Hadoop MapReduce 之后的第二代大数据计算引擎，基于 Scala 开发。Spark 并不基于 MapReduce，它将所有的**数据处理过程**（从磁盘读取到内存）放在了集群的内存中进行，相较于 Hadoop 使用 Map 和 Reduce 直接在磁盘上处理数据，Spark 的速度则更快。因此 Spark 更适合处理类似机器学习、深度学习等计算过程中有大量迭代的中间结果的场景。\n\n#### 4、Hive：\n\n是一个基于 MapReduce 的数据仓库工具。它提供来 HQL 可以以 SQL 的方式来描述 MapReduce，它可以将普通的 Hive QL 转换为 MapReduce 任务来运行。但由于 Hive 直接运行在 Hadoop 上，其数据处理作业但速度并不快，效率并不高。\n\n#### 5、Hive on Spark：\n\nHive on Spark 是从 Hive on MapReduce 演进而来，Hive 的整体解决方案很不错，但是从查询提交到结果返回需要相当长的时间，查询耗时太长，这个主要原因就是由于 Hive 原生是基于 MapReduce 的，那么如果我们不生成 MapReduce Job，而是生成 Spark Job，就可以充分利用 Spark 的快速执行能力来缩短 HiveQL 的响应时间。\n\n#### 6、SparkSQL：\n\nSpark 早先有 Shark 项目用来实现 SQL 层，不过后来推翻重做就变成了 SparkSQL，其本质和 Hive on Spark 类似。\n\n#### 7、Spark Streaming：\n\n是一个基于 Spark 的实时流式计算框架。Spark Streaming 在内部的处理机制是，接收实时流的数据，并根据一定的时间间隔拆分成一批批的数据，然后通过 Spark Engine 处理这些批数据，最终得到处理后的一批批结果数据。在流数据分成一批一批后，通过一个**先进先出**的队列，然后 Spark Engine 从该队列中依次取出一个个批数据，把批数据封装成一个 RDD（弹性分布式数据集），然后进行处理。\n\n总结下来，一个数据仓库的基本架构如此：底层存储系统使用 HDFS，接下来是一层计算引擎使用 MapReduce、Tez 或 Spark，再上面跑基于 SQL 或者脚本的 Wrapper 层 Hive 或者 Pig。或者直接在 HDFS 上跑 Impala、Drill、Presto 等交互式的 SQL 引擎。\n","source":"_posts/大数据基础架构概述.md","raw":"---\ntitle: 大数据基础架构概述\nintro: 本篇文章用于记录大数据系统基础架构中的一些常用框架和工具介绍。从总体上来了解大数据相关（机器学习、深度学习等）处理的基本系统架构和各个软件框架、数据仓库、计算引擎的使用场景。\ncomments: true\ndate: 2017-09-04 21:57:08\ntags:\n- 大数据\n- 架构\n---\n\n\n本篇文章用于记录大数据系统基础架构中的一些常用框架和工具介绍。从总体上来了解大数据相关（机器学习、深度学习等）处理的基本系统架构和各个软件框架、数据仓库、计算引擎的使用场景。\n\n#### 1、Hadoop：\n\n最早诞生的大数据处理计算框架，由 Java 语言编写。其结构主要包括三层：**HDFS** - Hadoop 分布式文件系统、**HBase** NoSQL 存储系统和一个基于 **MapReduce** 的分布式计算引擎；由于 Hadoop 会把计算的中间结果也存储到 HDFS，因此它并不适合有大量迭代计算的场景；并且一个 Job 只有 Map 和 Reduce 两个阶段，每个 Job 之间的数据依赖关系需要自己控制。同时其 MapTask 和 ReduceTask 也无法并行，数据处理效率较低。\n\n#### 2、Hadoop Yarn：\n\n是 Hadoop 自 0.23.0 版本后对其内部资源管理系统中的 JobTracker 和 TaskTracker 进行了大幅的的修改和重构以提高其性能。它的基本设计思想是将 MRv1 中的 JobTracker 拆分成了两个独立的服务，一个全局的资源管理器 ResourceManager(RM) 和每个应用程序特有的 ApplicationMaster。其中ResourceManager 负责整个系统的资源管理和分配，而 ApplicationMaster 负责单个应用程序的管理。这个新版本框架被命名为 Yarn。\n\n#### 3、Spark：\n\n是继 Hadoop MapReduce 之后的第二代大数据计算引擎，基于 Scala 开发。Spark 并不基于 MapReduce，它将所有的**数据处理过程**（从磁盘读取到内存）放在了集群的内存中进行，相较于 Hadoop 使用 Map 和 Reduce 直接在磁盘上处理数据，Spark 的速度则更快。因此 Spark 更适合处理类似机器学习、深度学习等计算过程中有大量迭代的中间结果的场景。\n\n#### 4、Hive：\n\n是一个基于 MapReduce 的数据仓库工具。它提供来 HQL 可以以 SQL 的方式来描述 MapReduce，它可以将普通的 Hive QL 转换为 MapReduce 任务来运行。但由于 Hive 直接运行在 Hadoop 上，其数据处理作业但速度并不快，效率并不高。\n\n#### 5、Hive on Spark：\n\nHive on Spark 是从 Hive on MapReduce 演进而来，Hive 的整体解决方案很不错，但是从查询提交到结果返回需要相当长的时间，查询耗时太长，这个主要原因就是由于 Hive 原生是基于 MapReduce 的，那么如果我们不生成 MapReduce Job，而是生成 Spark Job，就可以充分利用 Spark 的快速执行能力来缩短 HiveQL 的响应时间。\n\n#### 6、SparkSQL：\n\nSpark 早先有 Shark 项目用来实现 SQL 层，不过后来推翻重做就变成了 SparkSQL，其本质和 Hive on Spark 类似。\n\n#### 7、Spark Streaming：\n\n是一个基于 Spark 的实时流式计算框架。Spark Streaming 在内部的处理机制是，接收实时流的数据，并根据一定的时间间隔拆分成一批批的数据，然后通过 Spark Engine 处理这些批数据，最终得到处理后的一批批结果数据。在流数据分成一批一批后，通过一个**先进先出**的队列，然后 Spark Engine 从该队列中依次取出一个个批数据，把批数据封装成一个 RDD（弹性分布式数据集），然后进行处理。\n\n总结下来，一个数据仓库的基本架构如此：底层存储系统使用 HDFS，接下来是一层计算引擎使用 MapReduce、Tez 或 Spark，再上面跑基于 SQL 或者脚本的 Wrapper 层 Hive 或者 Pig。或者直接在 HDFS 上跑 Impala、Drill、Presto 等交互式的 SQL 引擎。\n","slug":"大数据基础架构概述","published":1,"updated":"2019-02-19T10:34:20.888Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtb6006vknp2m4hd0pko","content":"<p>本篇文章用于记录大数据系统基础架构中的一些常用框架和工具介绍。从总体上来了解大数据相关（机器学习、深度学习等）处理的基本系统架构和各个软件框架、数据仓库、计算引擎的使用场景。</p>\n<h4 id=\"1、Hadoop：\"><a href=\"#1、Hadoop：\" class=\"headerlink\" title=\"1、Hadoop：\"></a>1、Hadoop：</h4><p>最早诞生的大数据处理计算框架，由 Java 语言编写。其结构主要包括三层：<strong>HDFS</strong> - Hadoop 分布式文件系统、<strong>HBase</strong> NoSQL 存储系统和一个基于 <strong>MapReduce</strong> 的分布式计算引擎；由于 Hadoop 会把计算的中间结果也存储到 HDFS，因此它并不适合有大量迭代计算的场景；并且一个 Job 只有 Map 和 Reduce 两个阶段，每个 Job 之间的数据依赖关系需要自己控制。同时其 MapTask 和 ReduceTask 也无法并行，数据处理效率较低。</p>\n<h4 id=\"2、Hadoop-Yarn：\"><a href=\"#2、Hadoop-Yarn：\" class=\"headerlink\" title=\"2、Hadoop Yarn：\"></a>2、Hadoop Yarn：</h4><p>是 Hadoop 自 0.23.0 版本后对其内部资源管理系统中的 JobTracker 和 TaskTracker 进行了大幅的的修改和重构以提高其性能。它的基本设计思想是将 MRv1 中的 JobTracker 拆分成了两个独立的服务，一个全局的资源管理器 ResourceManager(RM) 和每个应用程序特有的 ApplicationMaster。其中ResourceManager 负责整个系统的资源管理和分配，而 ApplicationMaster 负责单个应用程序的管理。这个新版本框架被命名为 Yarn。</p>\n<h4 id=\"3、Spark：\"><a href=\"#3、Spark：\" class=\"headerlink\" title=\"3、Spark：\"></a>3、Spark：</h4><p>是继 Hadoop MapReduce 之后的第二代大数据计算引擎，基于 Scala 开发。Spark 并不基于 MapReduce，它将所有的<strong>数据处理过程</strong>（从磁盘读取到内存）放在了集群的内存中进行，相较于 Hadoop 使用 Map 和 Reduce 直接在磁盘上处理数据，Spark 的速度则更快。因此 Spark 更适合处理类似机器学习、深度学习等计算过程中有大量迭代的中间结果的场景。</p>\n<h4 id=\"4、Hive：\"><a href=\"#4、Hive：\" class=\"headerlink\" title=\"4、Hive：\"></a>4、Hive：</h4><p>是一个基于 MapReduce 的数据仓库工具。它提供来 HQL 可以以 SQL 的方式来描述 MapReduce，它可以将普通的 Hive QL 转换为 MapReduce 任务来运行。但由于 Hive 直接运行在 Hadoop 上，其数据处理作业但速度并不快，效率并不高。</p>\n<h4 id=\"5、Hive-on-Spark：\"><a href=\"#5、Hive-on-Spark：\" class=\"headerlink\" title=\"5、Hive on Spark：\"></a>5、Hive on Spark：</h4><p>Hive on Spark 是从 Hive on MapReduce 演进而来，Hive 的整体解决方案很不错，但是从查询提交到结果返回需要相当长的时间，查询耗时太长，这个主要原因就是由于 Hive 原生是基于 MapReduce 的，那么如果我们不生成 MapReduce Job，而是生成 Spark Job，就可以充分利用 Spark 的快速执行能力来缩短 HiveQL 的响应时间。</p>\n<h4 id=\"6、SparkSQL：\"><a href=\"#6、SparkSQL：\" class=\"headerlink\" title=\"6、SparkSQL：\"></a>6、SparkSQL：</h4><p>Spark 早先有 Shark 项目用来实现 SQL 层，不过后来推翻重做就变成了 SparkSQL，其本质和 Hive on Spark 类似。</p>\n<h4 id=\"7、Spark-Streaming：\"><a href=\"#7、Spark-Streaming：\" class=\"headerlink\" title=\"7、Spark Streaming：\"></a>7、Spark Streaming：</h4><p>是一个基于 Spark 的实时流式计算框架。Spark Streaming 在内部的处理机制是，接收实时流的数据，并根据一定的时间间隔拆分成一批批的数据，然后通过 Spark Engine 处理这些批数据，最终得到处理后的一批批结果数据。在流数据分成一批一批后，通过一个<strong>先进先出</strong>的队列，然后 Spark Engine 从该队列中依次取出一个个批数据，把批数据封装成一个 RDD（弹性分布式数据集），然后进行处理。</p>\n<p>总结下来，一个数据仓库的基本架构如此：底层存储系统使用 HDFS，接下来是一层计算引擎使用 MapReduce、Tez 或 Spark，再上面跑基于 SQL 或者脚本的 Wrapper 层 Hive 或者 Pig。或者直接在 HDFS 上跑 Impala、Drill、Presto 等交互式的 SQL 引擎。</p>\n","site":{"data":{}},"id":"063e8ea369def03eceec423fe6e4c3b3","excerpt":"","more":"<p>本篇文章用于记录大数据系统基础架构中的一些常用框架和工具介绍。从总体上来了解大数据相关（机器学习、深度学习等）处理的基本系统架构和各个软件框架、数据仓库、计算引擎的使用场景。</p>\n<h4 id=\"1、Hadoop：\"><a href=\"#1、Hadoop：\" class=\"headerlink\" title=\"1、Hadoop：\"></a>1、Hadoop：</h4><p>最早诞生的大数据处理计算框架，由 Java 语言编写。其结构主要包括三层：<strong>HDFS</strong> - Hadoop 分布式文件系统、<strong>HBase</strong> NoSQL 存储系统和一个基于 <strong>MapReduce</strong> 的分布式计算引擎；由于 Hadoop 会把计算的中间结果也存储到 HDFS，因此它并不适合有大量迭代计算的场景；并且一个 Job 只有 Map 和 Reduce 两个阶段，每个 Job 之间的数据依赖关系需要自己控制。同时其 MapTask 和 ReduceTask 也无法并行，数据处理效率较低。</p>\n<h4 id=\"2、Hadoop-Yarn：\"><a href=\"#2、Hadoop-Yarn：\" class=\"headerlink\" title=\"2、Hadoop Yarn：\"></a>2、Hadoop Yarn：</h4><p>是 Hadoop 自 0.23.0 版本后对其内部资源管理系统中的 JobTracker 和 TaskTracker 进行了大幅的的修改和重构以提高其性能。它的基本设计思想是将 MRv1 中的 JobTracker 拆分成了两个独立的服务，一个全局的资源管理器 ResourceManager(RM) 和每个应用程序特有的 ApplicationMaster。其中ResourceManager 负责整个系统的资源管理和分配，而 ApplicationMaster 负责单个应用程序的管理。这个新版本框架被命名为 Yarn。</p>\n<h4 id=\"3、Spark：\"><a href=\"#3、Spark：\" class=\"headerlink\" title=\"3、Spark：\"></a>3、Spark：</h4><p>是继 Hadoop MapReduce 之后的第二代大数据计算引擎，基于 Scala 开发。Spark 并不基于 MapReduce，它将所有的<strong>数据处理过程</strong>（从磁盘读取到内存）放在了集群的内存中进行，相较于 Hadoop 使用 Map 和 Reduce 直接在磁盘上处理数据，Spark 的速度则更快。因此 Spark 更适合处理类似机器学习、深度学习等计算过程中有大量迭代的中间结果的场景。</p>\n<h4 id=\"4、Hive：\"><a href=\"#4、Hive：\" class=\"headerlink\" title=\"4、Hive：\"></a>4、Hive：</h4><p>是一个基于 MapReduce 的数据仓库工具。它提供来 HQL 可以以 SQL 的方式来描述 MapReduce，它可以将普通的 Hive QL 转换为 MapReduce 任务来运行。但由于 Hive 直接运行在 Hadoop 上，其数据处理作业但速度并不快，效率并不高。</p>\n<h4 id=\"5、Hive-on-Spark：\"><a href=\"#5、Hive-on-Spark：\" class=\"headerlink\" title=\"5、Hive on Spark：\"></a>5、Hive on Spark：</h4><p>Hive on Spark 是从 Hive on MapReduce 演进而来，Hive 的整体解决方案很不错，但是从查询提交到结果返回需要相当长的时间，查询耗时太长，这个主要原因就是由于 Hive 原生是基于 MapReduce 的，那么如果我们不生成 MapReduce Job，而是生成 Spark Job，就可以充分利用 Spark 的快速执行能力来缩短 HiveQL 的响应时间。</p>\n<h4 id=\"6、SparkSQL：\"><a href=\"#6、SparkSQL：\" class=\"headerlink\" title=\"6、SparkSQL：\"></a>6、SparkSQL：</h4><p>Spark 早先有 Shark 项目用来实现 SQL 层，不过后来推翻重做就变成了 SparkSQL，其本质和 Hive on Spark 类似。</p>\n<h4 id=\"7、Spark-Streaming：\"><a href=\"#7、Spark-Streaming：\" class=\"headerlink\" title=\"7、Spark Streaming：\"></a>7、Spark Streaming：</h4><p>是一个基于 Spark 的实时流式计算框架。Spark Streaming 在内部的处理机制是，接收实时流的数据，并根据一定的时间间隔拆分成一批批的数据，然后通过 Spark Engine 处理这些批数据，最终得到处理后的一批批结果数据。在流数据分成一批一批后，通过一个<strong>先进先出</strong>的队列，然后 Spark Engine 从该队列中依次取出一个个批数据，把批数据封装成一个 RDD（弹性分布式数据集），然后进行处理。</p>\n<p>总结下来，一个数据仓库的基本架构如此：底层存储系统使用 HDFS，接下来是一层计算引擎使用 MapReduce、Tez 或 Spark，再上面跑基于 SQL 或者脚本的 Wrapper 层 Hive 或者 Pig。或者直接在 HDFS 上跑 Impala、Drill、Presto 等交互式的 SQL 引擎。</p>\n"},{"title":"常用 Shell 知识点和技巧","intro":"学过的东西不经常用就会忘，往往再次捡起来又会花费不少时间。趁此机会整理下编写 Shell 脚本相关的知识点语法。这里基于的是 Bash Shell，其他 Shell 也大致一样。行文没有什么入门顺序，想到哪儿写到哪儿。请注意，本文不是入门教程，只是单纯记录。","comments":1,"date":"2017-05-16T01:32:35.000Z","_content":"\n\n学过的东西不经常用就会忘，往往再次捡起来又会花费不少时间。趁此机会整理下编写 Shell 脚本相关的知识点语法。这里基于的是 Bash Shell，其他 Shell 也大致一样。行文没有什么入门顺序，想到哪儿写到哪儿。请注意，本文不是入门教程，只是单纯记录。\n\n\n```bash\n# 基本重定向；\nls -al > standardOutput.txt \nls -al 1> standardOutput.txt \nls -al 2> errorOutput.txt \nls -al > /dev/null\nls -al 1> standardOutput.txt  2> errorOutput.txt \nls -al 1> standardOutput.txt 2>&1\n\n# 追加重定向；\nls -al >> standardOutput.txt \n\n# 管道；\nls -al | grep \"fileName\"\nfind / -type f -name \"fileName\" | xargs grep \"fileContent\" > list.txt\nps -aux | grep \"pid\"\nps | sort | more\n\n# 标准自启动注释；\n#!/bin/sh\n\n# 常用环境变量；\n$HOME # 当前登录用户的家目录；\n$PATH # 搜索命令的目录列表；\n$PS1  # 命令提示符（默认是$）；\n$PS2  # 二级提示符（默认是>）；\n$IFS  # 输入域分隔符（默认是空格）；\n$0    # Shell 脚本的名字；\n$#    # 传递给脚本的参数个数；\n$$    # Shell 脚本的进程号；\n$*    # 列出所有参数，用 IFS 的第一个字符分隔；\n$@    # $* 的一种变体，不受 IFS 影响；\n\n# 变量；\necho \"$HOMT\" # 双引号可以解析变量，比较运算最好加上；\necho $HOME\necho /$HOME  # 反斜杠不解析变量，单引号同理；\necho '$HOME'\n\n# 条件命令和语句（test 或 [）；\nif test -f fred.c\nthen\n  echo 0\nelse \n  echo 1\nfi\n\nif [ -f fred.c ]\nthen\n  echo 0\nelif [ -g fred.c ]\nthen \n  echo 1\nfi\n\n# 循环语句（只列了常用的两种）；\nfor item in foo bar\ndo \n  echo $item\ndone\n\nfor file in $(ls -al *.sh)\ndo \n  echo $file\ndone\n\nread str\nwhile [ \"$str\" != \"go\" ]\ndo\n  echo \"retry, please\"\ndone\n\n\n# 选择语句；\nread choice\ncase \"$choice\" in\n  apple) echo \"Apple\";;\n  banana) echo \"Banana\";;\nesac\n\ncase \"$choice\" in\n  apple | banana) echo \"Fruit\";;\n  beef | pork) echo \"Meat\";;\nesac\n\n# 命令列表；\n[] && []  # 形式码；\n[] || []  # 形式码；\n\n# 函数；\nmy_function() {\n  local answer='three'\n  echo -n \"Please enter a number:\"\n  read input\n  if [ \"$answer\" = \"$input\" ]\n  then\n    echo \"Good Job!\"\n  fi\n}\n\n# 其他命令；\nbreak     # 退出循环；\ncontinue  # 退出本次循环；\n:         # 空命令（一般用在死循环中）；\n\nwhile :\ndo \n  echo \"Eternal\"\ndone\n\nx=$(($x+1))        # 算数扩展；\n\n${x}               # 参数扩展（保护变量）；\n${param:-default}  # 带有默认值的参数扩展；\n${#param}          # 给出参数长度；\n${param%word}      # 尾部删除与特定值匹配的最小部分，返回剩下；\n${param%%word}     # 尾部删除与特定值匹配的最大部分，返回剩下；\n${param#word}      # 头部删除与特定值匹配的最小部分，返回剩下；\n${param##word}     # 头部删除与特定值匹配的最大部分，返回剩下；\n\n\n```\n\n下面记录一些常用命令：\n\n\n```bash\nlsof -i:8080                      # 列出使用8080端口的进程；\ndf -h                             # 查看系统磁盘使用情况；\ndu -h --max-depth=1               # 列出第一层目录记文件的使用大小；\nssh [ip] -l [username] -p [port]  # SSH 远程登录；\nnpm view [module] versions        # 查看某一 NPM 模块的所有可用版本  ； \nnpm install [modules]@[version]   # 安装某一版本的 NPM 模块；\nnpm outdated -g                   # 列出全局 NPM 包的过期版本情况；\nnpm outdated                      # 列出当前项目的 NPM 包过期版本情况；\n\nclang -x c -v -E /dev/null        # Clang／Gcc 默认的头文件加载搜索路径；\n\n# 查看 Linux 版本信息；\ncat /etc/issue\nsudo lsb_release -a\n```\n","source":"_posts/常用-Shell-知识点和技巧.md","raw":"---\ntitle: 常用 Shell 知识点和技巧\nintro: 学过的东西不经常用就会忘，往往再次捡起来又会花费不少时间。趁此机会整理下编写 Shell 脚本相关的知识点语法。这里基于的是 Bash Shell，其他 Shell 也大致一样。行文没有什么入门顺序，想到哪儿写到哪儿。请注意，本文不是入门教程，只是单纯记录。\ncomments: true\ndate: 2017-05-16 09:32:35\ntags:\n- Shell\n---\n\n\n学过的东西不经常用就会忘，往往再次捡起来又会花费不少时间。趁此机会整理下编写 Shell 脚本相关的知识点语法。这里基于的是 Bash Shell，其他 Shell 也大致一样。行文没有什么入门顺序，想到哪儿写到哪儿。请注意，本文不是入门教程，只是单纯记录。\n\n\n```bash\n# 基本重定向；\nls -al > standardOutput.txt \nls -al 1> standardOutput.txt \nls -al 2> errorOutput.txt \nls -al > /dev/null\nls -al 1> standardOutput.txt  2> errorOutput.txt \nls -al 1> standardOutput.txt 2>&1\n\n# 追加重定向；\nls -al >> standardOutput.txt \n\n# 管道；\nls -al | grep \"fileName\"\nfind / -type f -name \"fileName\" | xargs grep \"fileContent\" > list.txt\nps -aux | grep \"pid\"\nps | sort | more\n\n# 标准自启动注释；\n#!/bin/sh\n\n# 常用环境变量；\n$HOME # 当前登录用户的家目录；\n$PATH # 搜索命令的目录列表；\n$PS1  # 命令提示符（默认是$）；\n$PS2  # 二级提示符（默认是>）；\n$IFS  # 输入域分隔符（默认是空格）；\n$0    # Shell 脚本的名字；\n$#    # 传递给脚本的参数个数；\n$$    # Shell 脚本的进程号；\n$*    # 列出所有参数，用 IFS 的第一个字符分隔；\n$@    # $* 的一种变体，不受 IFS 影响；\n\n# 变量；\necho \"$HOMT\" # 双引号可以解析变量，比较运算最好加上；\necho $HOME\necho /$HOME  # 反斜杠不解析变量，单引号同理；\necho '$HOME'\n\n# 条件命令和语句（test 或 [）；\nif test -f fred.c\nthen\n  echo 0\nelse \n  echo 1\nfi\n\nif [ -f fred.c ]\nthen\n  echo 0\nelif [ -g fred.c ]\nthen \n  echo 1\nfi\n\n# 循环语句（只列了常用的两种）；\nfor item in foo bar\ndo \n  echo $item\ndone\n\nfor file in $(ls -al *.sh)\ndo \n  echo $file\ndone\n\nread str\nwhile [ \"$str\" != \"go\" ]\ndo\n  echo \"retry, please\"\ndone\n\n\n# 选择语句；\nread choice\ncase \"$choice\" in\n  apple) echo \"Apple\";;\n  banana) echo \"Banana\";;\nesac\n\ncase \"$choice\" in\n  apple | banana) echo \"Fruit\";;\n  beef | pork) echo \"Meat\";;\nesac\n\n# 命令列表；\n[] && []  # 形式码；\n[] || []  # 形式码；\n\n# 函数；\nmy_function() {\n  local answer='three'\n  echo -n \"Please enter a number:\"\n  read input\n  if [ \"$answer\" = \"$input\" ]\n  then\n    echo \"Good Job!\"\n  fi\n}\n\n# 其他命令；\nbreak     # 退出循环；\ncontinue  # 退出本次循环；\n:         # 空命令（一般用在死循环中）；\n\nwhile :\ndo \n  echo \"Eternal\"\ndone\n\nx=$(($x+1))        # 算数扩展；\n\n${x}               # 参数扩展（保护变量）；\n${param:-default}  # 带有默认值的参数扩展；\n${#param}          # 给出参数长度；\n${param%word}      # 尾部删除与特定值匹配的最小部分，返回剩下；\n${param%%word}     # 尾部删除与特定值匹配的最大部分，返回剩下；\n${param#word}      # 头部删除与特定值匹配的最小部分，返回剩下；\n${param##word}     # 头部删除与特定值匹配的最大部分，返回剩下；\n\n\n```\n\n下面记录一些常用命令：\n\n\n```bash\nlsof -i:8080                      # 列出使用8080端口的进程；\ndf -h                             # 查看系统磁盘使用情况；\ndu -h --max-depth=1               # 列出第一层目录记文件的使用大小；\nssh [ip] -l [username] -p [port]  # SSH 远程登录；\nnpm view [module] versions        # 查看某一 NPM 模块的所有可用版本  ； \nnpm install [modules]@[version]   # 安装某一版本的 NPM 模块；\nnpm outdated -g                   # 列出全局 NPM 包的过期版本情况；\nnpm outdated                      # 列出当前项目的 NPM 包过期版本情况；\n\nclang -x c -v -E /dev/null        # Clang／Gcc 默认的头文件加载搜索路径；\n\n# 查看 Linux 版本信息；\ncat /etc/issue\nsudo lsb_release -a\n```\n","slug":"常用-Shell-知识点和技巧","published":1,"updated":"2019-02-18T01:59:34.955Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtb7006xknp25fub8sbs","content":"<p>学过的东西不经常用就会忘，往往再次捡起来又会花费不少时间。趁此机会整理下编写 Shell 脚本相关的知识点语法。这里基于的是 Bash Shell，其他 Shell 也大致一样。行文没有什么入门顺序，想到哪儿写到哪儿。请注意，本文不是入门教程，只是单纯记录。</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token comment\" spellcheck=\"true\"># 基本重定向；</span>\n<span class=\"token function\">ls</span> -al <span class=\"token operator\">></span> standardOutput.txt \n<span class=\"token function\">ls</span> -al 1<span class=\"token operator\">></span> standardOutput.txt \n<span class=\"token function\">ls</span> -al 2<span class=\"token operator\">></span> errorOutput.txt \n<span class=\"token function\">ls</span> -al <span class=\"token operator\">></span> /dev/null\n<span class=\"token function\">ls</span> -al 1<span class=\"token operator\">></span> standardOutput.txt  2<span class=\"token operator\">></span> errorOutput.txt \n<span class=\"token function\">ls</span> -al 1<span class=\"token operator\">></span> standardOutput.txt 2<span class=\"token operator\">></span><span class=\"token operator\">&amp;</span>1\n\n<span class=\"token comment\" spellcheck=\"true\"># 追加重定向；</span>\n<span class=\"token function\">ls</span> -al <span class=\"token operator\">>></span> standardOutput.txt \n\n<span class=\"token comment\" spellcheck=\"true\"># 管道；</span>\n<span class=\"token function\">ls</span> -al <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> <span class=\"token string\">\"fileName\"</span>\n<span class=\"token function\">find</span> / -type f -name <span class=\"token string\">\"fileName\"</span> <span class=\"token operator\">|</span> <span class=\"token function\">xargs</span> <span class=\"token function\">grep</span> <span class=\"token string\">\"fileContent\"</span> <span class=\"token operator\">></span> list.txt\n<span class=\"token function\">ps</span> -aux <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> <span class=\"token string\">\"pid\"</span>\n<span class=\"token function\">ps</span> <span class=\"token operator\">|</span> <span class=\"token function\">sort</span> <span class=\"token operator\">|</span> <span class=\"token function\">more</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 标准自启动注释；</span>\n<span class=\"token comment\" spellcheck=\"true\">#!/bin/sh</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 常用环境变量；</span>\n<span class=\"token variable\">$HOME</span> <span class=\"token comment\" spellcheck=\"true\"># 当前登录用户的家目录；</span>\n<span class=\"token variable\">$PATH</span> <span class=\"token comment\" spellcheck=\"true\"># 搜索命令的目录列表；</span>\n<span class=\"token variable\">$PS1</span>  <span class=\"token comment\" spellcheck=\"true\"># 命令提示符（默认是$）；</span>\n<span class=\"token variable\">$PS2</span>  <span class=\"token comment\" spellcheck=\"true\"># 二级提示符（默认是>）；</span>\n<span class=\"token variable\">$IFS</span>  <span class=\"token comment\" spellcheck=\"true\"># 输入域分隔符（默认是空格）；</span>\n<span class=\"token variable\">$0</span>    <span class=\"token comment\" spellcheck=\"true\"># Shell 脚本的名字；</span>\n$<span class=\"token comment\" spellcheck=\"true\">#    # 传递给脚本的参数个数；</span>\n$$    <span class=\"token comment\" spellcheck=\"true\"># Shell 脚本的进程号；</span>\n<span class=\"token variable\">$*</span>    <span class=\"token comment\" spellcheck=\"true\"># 列出所有参数，用 IFS 的第一个字符分隔；</span>\n<span class=\"token variable\">$@</span>    <span class=\"token comment\" spellcheck=\"true\"># $* 的一种变体，不受 IFS 影响；</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 变量；</span>\n<span class=\"token keyword\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$HOMT</span>\"</span> <span class=\"token comment\" spellcheck=\"true\"># 双引号可以解析变量，比较运算最好加上；</span>\n<span class=\"token keyword\">echo</span> <span class=\"token variable\">$HOME</span>\n<span class=\"token keyword\">echo</span> /<span class=\"token variable\">$HOME</span>  <span class=\"token comment\" spellcheck=\"true\"># 反斜杠不解析变量，单引号同理；</span>\n<span class=\"token keyword\">echo</span> <span class=\"token string\">'<span class=\"token variable\">$HOME</span>'</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 条件命令和语句（test 或 [）；</span>\n<span class=\"token keyword\">if</span> <span class=\"token function\">test</span> -f fred.c\n<span class=\"token keyword\">then</span>\n  <span class=\"token keyword\">echo</span> 0\n<span class=\"token keyword\">else</span> \n  <span class=\"token keyword\">echo</span> 1\n<span class=\"token keyword\">fi</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> -f fred.c <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">then</span>\n  <span class=\"token keyword\">echo</span> 0\n<span class=\"token keyword\">elif</span> <span class=\"token punctuation\">[</span> -g fred.c <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">then</span> \n  <span class=\"token keyword\">echo</span> 1\n<span class=\"token keyword\">fi</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 循环语句（只列了常用的两种）；</span>\n<span class=\"token keyword\">for</span> item <span class=\"token keyword\">in</span> foo bar\n<span class=\"token keyword\">do</span> \n  <span class=\"token keyword\">echo</span> <span class=\"token variable\">$item</span>\n<span class=\"token keyword\">done</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token function\">file</span> <span class=\"token keyword\">in</span> <span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">ls</span> -al *.sh<span class=\"token variable\">)</span></span>\n<span class=\"token keyword\">do</span> \n  <span class=\"token keyword\">echo</span> <span class=\"token variable\">$file</span>\n<span class=\"token keyword\">done</span>\n\n<span class=\"token function\">read</span> str\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">[</span> <span class=\"token string\">\"<span class=\"token variable\">$str</span>\"</span> <span class=\"token operator\">!=</span> <span class=\"token string\">\"go\"</span> <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">do</span>\n  <span class=\"token keyword\">echo</span> <span class=\"token string\">\"retry, please\"</span>\n<span class=\"token keyword\">done</span>\n\n\n<span class=\"token comment\" spellcheck=\"true\"># 选择语句；</span>\n<span class=\"token function\">read</span> choice\n<span class=\"token keyword\">case</span> <span class=\"token string\">\"<span class=\"token variable\">$choice</span>\"</span> <span class=\"token keyword\">in</span>\n  apple<span class=\"token punctuation\">)</span> <span class=\"token keyword\">echo</span> <span class=\"token string\">\"Apple\"</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n  banana<span class=\"token punctuation\">)</span> <span class=\"token keyword\">echo</span> <span class=\"token string\">\"Banana\"</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\nesac\n\n<span class=\"token keyword\">case</span> <span class=\"token string\">\"<span class=\"token variable\">$choice</span>\"</span> <span class=\"token keyword\">in</span>\n  apple <span class=\"token operator\">|</span> banana<span class=\"token punctuation\">)</span> <span class=\"token keyword\">echo</span> <span class=\"token string\">\"Fruit\"</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n  beef <span class=\"token operator\">|</span> pork<span class=\"token punctuation\">)</span> <span class=\"token keyword\">echo</span> <span class=\"token string\">\"Meat\"</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\nesac\n\n<span class=\"token comment\" spellcheck=\"true\"># 命令列表；</span>\n<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>  <span class=\"token comment\" spellcheck=\"true\"># 形式码；</span>\n<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">||</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>  <span class=\"token comment\" spellcheck=\"true\"># 形式码；</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 函数；</span>\nmy_function<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  local answer<span class=\"token operator\">=</span><span class=\"token string\">'three'</span>\n  <span class=\"token keyword\">echo</span> -n <span class=\"token string\">\"Please enter a number:\"</span>\n  <span class=\"token function\">read</span> input\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token string\">\"<span class=\"token variable\">$answer</span>\"</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"<span class=\"token variable\">$input</span>\"</span> <span class=\"token punctuation\">]</span>\n  <span class=\"token keyword\">then</span>\n    <span class=\"token keyword\">echo</span> <span class=\"token string\">\"Good Job!\"</span>\n  <span class=\"token keyword\">fi</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 其他命令；</span>\n<span class=\"token keyword\">break</span>     <span class=\"token comment\" spellcheck=\"true\"># 退出循环；</span>\n<span class=\"token keyword\">continue</span>  <span class=\"token comment\" spellcheck=\"true\"># 退出本次循环；</span>\n<span class=\"token keyword\">:</span>         <span class=\"token comment\" spellcheck=\"true\"># 空命令（一般用在死循环中）；</span>\n\n<span class=\"token keyword\">while</span> <span class=\"token keyword\">:</span>\n<span class=\"token keyword\">do</span> \n  <span class=\"token keyword\">echo</span> <span class=\"token string\">\"Eternal\"</span>\n<span class=\"token keyword\">done</span>\n\nx<span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$((</span>$x<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token variable\">))</span></span>        <span class=\"token comment\" spellcheck=\"true\"># 算数扩展；</span>\n\n<span class=\"token variable\">${x}</span>               <span class=\"token comment\" spellcheck=\"true\"># 参数扩展（保护变量）；</span>\n<span class=\"token variable\">${param:-default}</span>  <span class=\"token comment\" spellcheck=\"true\"># 带有默认值的参数扩展；</span>\n<span class=\"token variable\">${#param}</span>          <span class=\"token comment\" spellcheck=\"true\"># 给出参数长度；</span>\n<span class=\"token variable\">${param%word}</span>      <span class=\"token comment\" spellcheck=\"true\"># 尾部删除与特定值匹配的最小部分，返回剩下；</span>\n<span class=\"token variable\">${param%%word}</span>     <span class=\"token comment\" spellcheck=\"true\"># 尾部删除与特定值匹配的最大部分，返回剩下；</span>\n$<span class=\"token punctuation\">{</span>param<span class=\"token comment\" spellcheck=\"true\">#word}      # 头部删除与特定值匹配的最小部分，返回剩下；</span>\n$<span class=\"token punctuation\">{</span>param<span class=\"token comment\" spellcheck=\"true\">##word}     # 头部删除与特定值匹配的最大部分，返回剩下；</span>\n\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>下面记录一些常用命令：</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token function\">lsof</span> -i:8080                      <span class=\"token comment\" spellcheck=\"true\"># 列出使用8080端口的进程；</span>\n<span class=\"token function\">df</span> -h                             <span class=\"token comment\" spellcheck=\"true\"># 查看系统磁盘使用情况；</span>\n<span class=\"token function\">du</span> -h --max-depth<span class=\"token operator\">=</span>1               <span class=\"token comment\" spellcheck=\"true\"># 列出第一层目录记文件的使用大小；</span>\n<span class=\"token function\">ssh</span> <span class=\"token punctuation\">[</span>ip<span class=\"token punctuation\">]</span> -l <span class=\"token punctuation\">[</span>username<span class=\"token punctuation\">]</span> -p <span class=\"token punctuation\">[</span>port<span class=\"token punctuation\">]</span>  <span class=\"token comment\" spellcheck=\"true\"># SSH 远程登录；</span>\n<span class=\"token function\">npm</span> view <span class=\"token punctuation\">[</span>module<span class=\"token punctuation\">]</span> versions        <span class=\"token comment\" spellcheck=\"true\"># 查看某一 NPM 模块的所有可用版本  ； </span>\n<span class=\"token function\">npm</span> <span class=\"token function\">install</span> <span class=\"token punctuation\">[</span>modules<span class=\"token punctuation\">]</span>@<span class=\"token punctuation\">[</span>version<span class=\"token punctuation\">]</span>   <span class=\"token comment\" spellcheck=\"true\"># 安装某一版本的 NPM 模块；</span>\n<span class=\"token function\">npm</span> outdated -g                   <span class=\"token comment\" spellcheck=\"true\"># 列出全局 NPM 包的过期版本情况；</span>\n<span class=\"token function\">npm</span> outdated                      <span class=\"token comment\" spellcheck=\"true\"># 列出当前项目的 NPM 包过期版本情况；</span>\n\nclang -x c -v -E /dev/null        <span class=\"token comment\" spellcheck=\"true\"># Clang／Gcc 默认的头文件加载搜索路径；</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 查看 Linux 版本信息；</span>\n<span class=\"token function\">cat</span> /etc/issue\n<span class=\"token function\">sudo</span> lsb_release -a\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"id":"03da483cb2f642a745024d16de45da30","excerpt":"","more":"<p>学过的东西不经常用就会忘，往往再次捡起来又会花费不少时间。趁此机会整理下编写 Shell 脚本相关的知识点语法。这里基于的是 Bash Shell，其他 Shell 也大致一样。行文没有什么入门顺序，想到哪儿写到哪儿。请注意，本文不是入门教程，只是单纯记录。</p>\n<pre><code class=\"bash\"># 基本重定向；\nls -al &gt; standardOutput.txt \nls -al 1&gt; standardOutput.txt \nls -al 2&gt; errorOutput.txt \nls -al &gt; /dev/null\nls -al 1&gt; standardOutput.txt  2&gt; errorOutput.txt \nls -al 1&gt; standardOutput.txt 2&gt;&amp;1\n\n# 追加重定向；\nls -al &gt;&gt; standardOutput.txt \n\n# 管道；\nls -al | grep &quot;fileName&quot;\nfind / -type f -name &quot;fileName&quot; | xargs grep &quot;fileContent&quot; &gt; list.txt\nps -aux | grep &quot;pid&quot;\nps | sort | more\n\n# 标准自启动注释；\n#!/bin/sh\n\n# 常用环境变量；\n$HOME # 当前登录用户的家目录；\n$PATH # 搜索命令的目录列表；\n$PS1  # 命令提示符（默认是$）；\n$PS2  # 二级提示符（默认是&gt;）；\n$IFS  # 输入域分隔符（默认是空格）；\n$0    # Shell 脚本的名字；\n$#    # 传递给脚本的参数个数；\n$$    # Shell 脚本的进程号；\n$*    # 列出所有参数，用 IFS 的第一个字符分隔；\n$@    # $* 的一种变体，不受 IFS 影响；\n\n# 变量；\necho &quot;$HOMT&quot; # 双引号可以解析变量，比较运算最好加上；\necho $HOME\necho /$HOME  # 反斜杠不解析变量，单引号同理；\necho &#39;$HOME&#39;\n\n# 条件命令和语句（test 或 [）；\nif test -f fred.c\nthen\n  echo 0\nelse \n  echo 1\nfi\n\nif [ -f fred.c ]\nthen\n  echo 0\nelif [ -g fred.c ]\nthen \n  echo 1\nfi\n\n# 循环语句（只列了常用的两种）；\nfor item in foo bar\ndo \n  echo $item\ndone\n\nfor file in $(ls -al *.sh)\ndo \n  echo $file\ndone\n\nread str\nwhile [ &quot;$str&quot; != &quot;go&quot; ]\ndo\n  echo &quot;retry, please&quot;\ndone\n\n\n# 选择语句；\nread choice\ncase &quot;$choice&quot; in\n  apple) echo &quot;Apple&quot;;;\n  banana) echo &quot;Banana&quot;;;\nesac\n\ncase &quot;$choice&quot; in\n  apple | banana) echo &quot;Fruit&quot;;;\n  beef | pork) echo &quot;Meat&quot;;;\nesac\n\n# 命令列表；\n[] &amp;&amp; []  # 形式码；\n[] || []  # 形式码；\n\n# 函数；\nmy_function() {\n  local answer=&#39;three&#39;\n  echo -n &quot;Please enter a number:&quot;\n  read input\n  if [ &quot;$answer&quot; = &quot;$input&quot; ]\n  then\n    echo &quot;Good Job!&quot;\n  fi\n}\n\n# 其他命令；\nbreak     # 退出循环；\ncontinue  # 退出本次循环；\n:         # 空命令（一般用在死循环中）；\n\nwhile :\ndo \n  echo &quot;Eternal&quot;\ndone\n\nx=$(($x+1))        # 算数扩展；\n\n${x}               # 参数扩展（保护变量）；\n${param:-default}  # 带有默认值的参数扩展；\n${#param}          # 给出参数长度；\n${param%word}      # 尾部删除与特定值匹配的最小部分，返回剩下；\n${param%%word}     # 尾部删除与特定值匹配的最大部分，返回剩下；\n${param#word}      # 头部删除与特定值匹配的最小部分，返回剩下；\n${param##word}     # 头部删除与特定值匹配的最大部分，返回剩下；\n\n\n</code></pre>\n<p>下面记录一些常用命令：</p>\n<pre><code class=\"bash\">lsof -i:8080                      # 列出使用8080端口的进程；\ndf -h                             # 查看系统磁盘使用情况；\ndu -h --max-depth=1               # 列出第一层目录记文件的使用大小；\nssh [ip] -l [username] -p [port]  # SSH 远程登录；\nnpm view [module] versions        # 查看某一 NPM 模块的所有可用版本  ； \nnpm install [modules]@[version]   # 安装某一版本的 NPM 模块；\nnpm outdated -g                   # 列出全局 NPM 包的过期版本情况；\nnpm outdated                      # 列出当前项目的 NPM 包过期版本情况；\n\nclang -x c -v -E /dev/null        # Clang／Gcc 默认的头文件加载搜索路径；\n\n# 查看 Linux 版本信息；\ncat /etc/issue\nsudo lsb_release -a\n</code></pre>\n"},{"title":"我的新书 “深入浅出 WebAssembly” 出版啦 (｡･ω･｡)ﾉ","intro":"好吧，首先承认，这本书的出版确实延期了。作为国内第一本介绍 WebAssembly 技术的相关书籍，确实还是花了很长的时间来组织内容。整个初稿从写作到最后交稿花了足足 8 个月的时间，最终成书的内容有 530 多页，已经涵盖了 Wasm 技术相关的大部分内容。2018年这一整年几乎没怎么更新博客，把 90%+ 的闲暇时间都放到了写书的过程中，希望大家能够喜欢这部最后呈现出来的作品。","comments":1,"date":"2018-10-31T16:00:00.000Z","_content":"\n好吧，首先承认，这本书的出版确实延期了。作为国内第一本介绍 WebAssembly 技术的相关书籍，确实还是花了很长的时间来组织内容。整个初稿从写作到最后交稿花了足足 8 个月的时间，最终成书的内容有 530 多页，已经涵盖了 Wasm 技术相关的大部分内容。2018年这一整年几乎没怎么更新博客，把 90%+ 的闲暇时间都放到了写书的过程中，希望大家能够喜欢这部最后呈现出来的作品。\n\n点此跳至：**[知乎原文](https://zhuanlan.zhihu.com/p/47577104)**。\n","source":"_posts/我的新书《深入浅出-WebAssembly》出版啦-｡･ω･｡-ﾉ.md","raw":"---\ntitle: 我的新书 “深入浅出 WebAssembly” 出版啦 (｡･ω･｡)ﾉ\nintro: 好吧，首先承认，这本书的出版确实延期了。作为国内第一本介绍 WebAssembly 技术的相关书籍，确实还是花了很长的时间来组织内容。整个初稿从写作到最后交稿花了足足 8 个月的时间，最终成书的内容有 530 多页，已经涵盖了 Wasm 技术相关的大部分内容。2018年这一整年几乎没怎么更新博客，把 90%+ 的闲暇时间都放到了写书的过程中，希望大家能够喜欢这部最后呈现出来的作品。\ncomments: true\ndate: 2018-11-01 00:00:00\ntags:\n- 出版\n---\n\n好吧，首先承认，这本书的出版确实延期了。作为国内第一本介绍 WebAssembly 技术的相关书籍，确实还是花了很长的时间来组织内容。整个初稿从写作到最后交稿花了足足 8 个月的时间，最终成书的内容有 530 多页，已经涵盖了 Wasm 技术相关的大部分内容。2018年这一整年几乎没怎么更新博客，把 90%+ 的闲暇时间都放到了写书的过程中，希望大家能够喜欢这部最后呈现出来的作品。\n\n点此跳至：**[知乎原文](https://zhuanlan.zhihu.com/p/47577104)**。\n","slug":"我的新书《深入浅出-WebAssembly》出版啦-｡･ω･｡-ﾉ","published":1,"updated":"2019-02-20T06:51:07.664Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtb80070knp24vir3mxn","content":"<p>好吧，首先承认，这本书的出版确实延期了。作为国内第一本介绍 WebAssembly 技术的相关书籍，确实还是花了很长的时间来组织内容。整个初稿从写作到最后交稿花了足足 8 个月的时间，最终成书的内容有 530 多页，已经涵盖了 Wasm 技术相关的大部分内容。2018年这一整年几乎没怎么更新博客，把 90%+ 的闲暇时间都放到了写书的过程中，希望大家能够喜欢这部最后呈现出来的作品。</p>\n<p>点此跳至：<strong><a href=\"https://zhuanlan.zhihu.com/p/47577104\" target=\"_blank\" rel=\"noopener\">知乎原文</a></strong>。</p>\n","site":{"data":{}},"id":"ebc2a9748d4ce5ad212a19f9d56db5ab","excerpt":"","more":"<p>好吧，首先承认，这本书的出版确实延期了。作为国内第一本介绍 WebAssembly 技术的相关书籍，确实还是花了很长的时间来组织内容。整个初稿从写作到最后交稿花了足足 8 个月的时间，最终成书的内容有 530 多页，已经涵盖了 Wasm 技术相关的大部分内容。2018年这一整年几乎没怎么更新博客，把 90%+ 的闲暇时间都放到了写书的过程中，希望大家能够喜欢这部最后呈现出来的作品。</p>\n<p>点此跳至：<strong><a href=\"https://zhuanlan.zhihu.com/p/47577104\" target=\"_blank\" rel=\"noopener\">知乎原文</a></strong>。</p>\n"},{"title":"技术是成功的“绊脚石”","intro":"记得第一次接触编程技术是在初中二年级，舅舅买的一本《VB 编程入门》引领着了我逐渐走进了计算机和互联网世界的大门，这么多年来一直在追逐技术的路上不断前行，有时也会不断反思和总结，技术与现实生活之间的关系。","comments":1,"date":"2016-02-12T14:45:08.000Z","_content":"\n记得第一次接触编程技术是在初中二年级，舅舅买的一本《VB 编程入门》引领着了我逐渐走进了计算机和互联网世界的大门，这么多年来一直在追逐技术的路上不断前行，有时也会不断反思和总结，技术与现实生活之间的关系。\n\n开发 APP，开发 Web 网站，开发桌面程序。每一个领域我都曾想去尝试，而且也都曾经或多或少的去尝试过，但一直都无法满足。当然这种对技术的热爱与执着是好的，人一生难得花大量时间去执着于一件事情，况且这件事情还是自己喜爱的事情，无论花多长时间在上面我都不会觉得累。\n\n在此之前一直认为只要能够不断提高自己的技术水平，薪水和金钱就会不断向自己“袭来”，但事实却不是这样。\n\n技术终究只是技术，只是一种生产力工具，最终赚钱的还是**产品本身**的价值。同样，公司也不会因为你的技术高就给你增加薪水，毕竟老板们给员工涨薪水看的是你给公司带来的利益价值有多少。哪怕你什么都不会做，但是能够“夸夸其谈”的给公司带来了几百万的收入，老板还是会开心的给你提高薪水。\n\n技术本身就像是建造大楼的用的材料，材料不管好坏只要能够造楼，能够卖给消费者赚到钱这就是老板本身的目的。只不过好的材料要贵一些，差一点的材料要便宜一些，但最终都能达成目的，老板会选用哪一个呢？\n\n我们作为开发人员，总是会看到那些卖点很足的产品背后的技术体系有多强大，但却不知道其实卖给消费者赚到钱的是产品给用户带来的服务本身而非技术体系。技术是产品强而有力的支撑，但并不是卖点。\n\n希望在走在 IT 路上的你不要被技术迷失了方向（并不是鼓励不要深入钻研技术，而是要看清技术只是**工具**的本质），不要让他成为你的“绊脚石”。而要看清技术的本质，并加以利用，相信你很快会有所收获。\n\n写在最后，如果你没有信心能够**颠覆现有的技术**，那么请不要在技术的路上陷得太深，请在适当的时候用适当的技术去做想做的事情吧。\n\n（以上仅为个人观点）\n","source":"_posts/技术是成功的“绊脚石”.md","raw":"---\ntitle: 技术是成功的“绊脚石”\nintro: 记得第一次接触编程技术是在初中二年级，舅舅买的一本《VB 编程入门》引领着了我逐渐走进了计算机和互联网世界的大门，这么多年来一直在追逐技术的路上不断前行，有时也会不断反思和总结，技术与现实生活之间的关系。\ncomments: true\ndate: 2016-02-12 22:45:08\ntags:\n- 日记\n---\n\n记得第一次接触编程技术是在初中二年级，舅舅买的一本《VB 编程入门》引领着了我逐渐走进了计算机和互联网世界的大门，这么多年来一直在追逐技术的路上不断前行，有时也会不断反思和总结，技术与现实生活之间的关系。\n\n开发 APP，开发 Web 网站，开发桌面程序。每一个领域我都曾想去尝试，而且也都曾经或多或少的去尝试过，但一直都无法满足。当然这种对技术的热爱与执着是好的，人一生难得花大量时间去执着于一件事情，况且这件事情还是自己喜爱的事情，无论花多长时间在上面我都不会觉得累。\n\n在此之前一直认为只要能够不断提高自己的技术水平，薪水和金钱就会不断向自己“袭来”，但事实却不是这样。\n\n技术终究只是技术，只是一种生产力工具，最终赚钱的还是**产品本身**的价值。同样，公司也不会因为你的技术高就给你增加薪水，毕竟老板们给员工涨薪水看的是你给公司带来的利益价值有多少。哪怕你什么都不会做，但是能够“夸夸其谈”的给公司带来了几百万的收入，老板还是会开心的给你提高薪水。\n\n技术本身就像是建造大楼的用的材料，材料不管好坏只要能够造楼，能够卖给消费者赚到钱这就是老板本身的目的。只不过好的材料要贵一些，差一点的材料要便宜一些，但最终都能达成目的，老板会选用哪一个呢？\n\n我们作为开发人员，总是会看到那些卖点很足的产品背后的技术体系有多强大，但却不知道其实卖给消费者赚到钱的是产品给用户带来的服务本身而非技术体系。技术是产品强而有力的支撑，但并不是卖点。\n\n希望在走在 IT 路上的你不要被技术迷失了方向（并不是鼓励不要深入钻研技术，而是要看清技术只是**工具**的本质），不要让他成为你的“绊脚石”。而要看清技术的本质，并加以利用，相信你很快会有所收获。\n\n写在最后，如果你没有信心能够**颠覆现有的技术**，那么请不要在技术的路上陷得太深，请在适当的时候用适当的技术去做想做的事情吧。\n\n（以上仅为个人观点）\n","slug":"技术是成功的“绊脚石”","published":1,"updated":"2019-02-05T09:01:02.009Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtb90072knp2x62m5uda","content":"<p>记得第一次接触编程技术是在初中二年级，舅舅买的一本《VB 编程入门》引领着了我逐渐走进了计算机和互联网世界的大门，这么多年来一直在追逐技术的路上不断前行，有时也会不断反思和总结，技术与现实生活之间的关系。</p>\n<p>开发 APP，开发 Web 网站，开发桌面程序。每一个领域我都曾想去尝试，而且也都曾经或多或少的去尝试过，但一直都无法满足。当然这种对技术的热爱与执着是好的，人一生难得花大量时间去执着于一件事情，况且这件事情还是自己喜爱的事情，无论花多长时间在上面我都不会觉得累。</p>\n<p>在此之前一直认为只要能够不断提高自己的技术水平，薪水和金钱就会不断向自己“袭来”，但事实却不是这样。</p>\n<p>技术终究只是技术，只是一种生产力工具，最终赚钱的还是<strong>产品本身</strong>的价值。同样，公司也不会因为你的技术高就给你增加薪水，毕竟老板们给员工涨薪水看的是你给公司带来的利益价值有多少。哪怕你什么都不会做，但是能够“夸夸其谈”的给公司带来了几百万的收入，老板还是会开心的给你提高薪水。</p>\n<p>技术本身就像是建造大楼的用的材料，材料不管好坏只要能够造楼，能够卖给消费者赚到钱这就是老板本身的目的。只不过好的材料要贵一些，差一点的材料要便宜一些，但最终都能达成目的，老板会选用哪一个呢？</p>\n<p>我们作为开发人员，总是会看到那些卖点很足的产品背后的技术体系有多强大，但却不知道其实卖给消费者赚到钱的是产品给用户带来的服务本身而非技术体系。技术是产品强而有力的支撑，但并不是卖点。</p>\n<p>希望在走在 IT 路上的你不要被技术迷失了方向（并不是鼓励不要深入钻研技术，而是要看清技术只是<strong>工具</strong>的本质），不要让他成为你的“绊脚石”。而要看清技术的本质，并加以利用，相信你很快会有所收获。</p>\n<p>写在最后，如果你没有信心能够<strong>颠覆现有的技术</strong>，那么请不要在技术的路上陷得太深，请在适当的时候用适当的技术去做想做的事情吧。</p>\n<p>（以上仅为个人观点）</p>\n","site":{"data":{}},"id":"13741c3f87762ea825175077dda2bc1b","excerpt":"","more":"<p>记得第一次接触编程技术是在初中二年级，舅舅买的一本《VB 编程入门》引领着了我逐渐走进了计算机和互联网世界的大门，这么多年来一直在追逐技术的路上不断前行，有时也会不断反思和总结，技术与现实生活之间的关系。</p>\n<p>开发 APP，开发 Web 网站，开发桌面程序。每一个领域我都曾想去尝试，而且也都曾经或多或少的去尝试过，但一直都无法满足。当然这种对技术的热爱与执着是好的，人一生难得花大量时间去执着于一件事情，况且这件事情还是自己喜爱的事情，无论花多长时间在上面我都不会觉得累。</p>\n<p>在此之前一直认为只要能够不断提高自己的技术水平，薪水和金钱就会不断向自己“袭来”，但事实却不是这样。</p>\n<p>技术终究只是技术，只是一种生产力工具，最终赚钱的还是<strong>产品本身</strong>的价值。同样，公司也不会因为你的技术高就给你增加薪水，毕竟老板们给员工涨薪水看的是你给公司带来的利益价值有多少。哪怕你什么都不会做，但是能够“夸夸其谈”的给公司带来了几百万的收入，老板还是会开心的给你提高薪水。</p>\n<p>技术本身就像是建造大楼的用的材料，材料不管好坏只要能够造楼，能够卖给消费者赚到钱这就是老板本身的目的。只不过好的材料要贵一些，差一点的材料要便宜一些，但最终都能达成目的，老板会选用哪一个呢？</p>\n<p>我们作为开发人员，总是会看到那些卖点很足的产品背后的技术体系有多强大，但却不知道其实卖给消费者赚到钱的是产品给用户带来的服务本身而非技术体系。技术是产品强而有力的支撑，但并不是卖点。</p>\n<p>希望在走在 IT 路上的你不要被技术迷失了方向（并不是鼓励不要深入钻研技术，而是要看清技术只是<strong>工具</strong>的本质），不要让他成为你的“绊脚石”。而要看清技术的本质，并加以利用，相信你很快会有所收获。</p>\n<p>写在最后，如果你没有信心能够<strong>颠覆现有的技术</strong>，那么请不要在技术的路上陷得太深，请在适当的时候用适当的技术去做想做的事情吧。</p>\n<p>（以上仅为个人观点）</p>\n"},{"title":"数据结构 - 线性顺序表","intro":"顺序表是所以常用数据结构中最基础的一种数据结构，它的整体存储模式跟编程语言中的数组类型十分相似。所以可以很简单的用数组来模拟顺序表中的存储过程。好久没有碰数据结构的东西了，今天就让我们来慢慢回忆，从数据结构到算法的第一步 - 顺序表。","comments":1,"date":"2014-12-23T06:23:02.000Z","_content":"\n顺序表就是指用一组连续的物理存储单元来存储表内的每个元素，使得表中相邻的元素在物理地址上也是相邻的。简单的讲，假如第一个元素在地址0X00000000，且第一个元素占用了2个内存单元，而这时的第二个元素开头则处于地址0X00000002，以此类推。假如线性表中有n个元素，每个元素占用k个单元，第一个元素的地址为loc(a1)，则第n个元素的地址为：loc(an) = loc(a1) + (n - 1) *&nbsp;k。\n\n顺序表的存储结构可以用如下C语言代码来表示：\n\n```c\n#define MAXSIZE\ntypedef struct {\n    ElemType elem[MAXSIZE];\n    int last;\n} SeqList;\n```\n其中ElemType为顺序表内元素的类型。last变量记录顺序表中最后一个元素在数组elem[]中的位置，空表为-1。\n#### 顺序表常用操作 - 查找操作：\n\n按序号查找很简单，只需要按照给出的所有返回对应的数组内容即可，这里我们给出的是按内容查找。即查找出与给定元素内容相同的元素在顺序表中的位置，L为待查找顺序表，e为待查找内容。\n\n```c\nint Locate(SeqList L, ElemType e) {\n    i = 0;\n    while((i <= L.last) && (L.elem[i] != e)) i ++;\n    if(i <= L.last) {\n        return(i + 1);\n    } else {\n        return -1;\n    } \n}\n```\n\n#### 顺序表常用操作 - 插入操作：\n由于顺序表元素的在物理上的存储位置需要与逻辑顺序一致，所以当插入元素时需要将此元素所在位置的后续所有元素依次向后移动，才能保持物理和逻辑上的位置一致。而此时的顺序表长度也由原来的n变为n+1。\n\n```c\n#define OK 1\n#define ERROR 0\nint InsList(SeqList *L, int i, ElemType e) {\n    int k;\n    if((i < 1) || (i > L -> last + 2)) {\n        printf(\"插入位置i不合法！\");\n        return(ERROR);\n    }\n    if(L -> last >= MAXSIZE - 1) {\n        printf(\"表已满无法插入！\");\n        return(ERROR);\n    }\n    for(k = L -> last;k <= i - 1;k --) L -> elem[k + 1] = L -> elem[k];\n    L -> elem[i - 1] = e;\n    L -> last++;\n    return(OK);\n}\n```\n\n#### 顺序表常用操作 - 删除操作：\n顺序的删除操作同样需要移动元素，且表长度也由原来的n变为n-1，删除后返回删除元素的值。\n\n```c\n#define ERROR 0\nint DelList(SeqList *L, int i, ElemType *e) {\n    int k;\n    if((i < 1) || (i > L -> last + 1)) {\n        printf(\"删除位置i不合法！\");\n        return(ERROR);\n    }\n    *e = L -> elem[i - 1];\n    for(k = i;k <= L -> last;k ++) L -> elem[k - 1] = L -> elem[k];\n    L -> last--;\n    return(OK);\n}\n```\n","source":"_posts/数据结构-线性顺序表.md","raw":"---\ntitle: 数据结构 - 线性顺序表\nintro: 顺序表是所以常用数据结构中最基础的一种数据结构，它的整体存储模式跟编程语言中的数组类型十分相似。所以可以很简单的用数组来模拟顺序表中的存储过程。好久没有碰数据结构的东西了，今天就让我们来慢慢回忆，从数据结构到算法的第一步 - 顺序表。\ncomments: true\ndate: 2014-12-23 14:23:02\ntags: \n- 算法\n---\n\n顺序表就是指用一组连续的物理存储单元来存储表内的每个元素，使得表中相邻的元素在物理地址上也是相邻的。简单的讲，假如第一个元素在地址0X00000000，且第一个元素占用了2个内存单元，而这时的第二个元素开头则处于地址0X00000002，以此类推。假如线性表中有n个元素，每个元素占用k个单元，第一个元素的地址为loc(a1)，则第n个元素的地址为：loc(an) = loc(a1) + (n - 1) *&nbsp;k。\n\n顺序表的存储结构可以用如下C语言代码来表示：\n\n```c\n#define MAXSIZE\ntypedef struct {\n    ElemType elem[MAXSIZE];\n    int last;\n} SeqList;\n```\n其中ElemType为顺序表内元素的类型。last变量记录顺序表中最后一个元素在数组elem[]中的位置，空表为-1。\n#### 顺序表常用操作 - 查找操作：\n\n按序号查找很简单，只需要按照给出的所有返回对应的数组内容即可，这里我们给出的是按内容查找。即查找出与给定元素内容相同的元素在顺序表中的位置，L为待查找顺序表，e为待查找内容。\n\n```c\nint Locate(SeqList L, ElemType e) {\n    i = 0;\n    while((i <= L.last) && (L.elem[i] != e)) i ++;\n    if(i <= L.last) {\n        return(i + 1);\n    } else {\n        return -1;\n    } \n}\n```\n\n#### 顺序表常用操作 - 插入操作：\n由于顺序表元素的在物理上的存储位置需要与逻辑顺序一致，所以当插入元素时需要将此元素所在位置的后续所有元素依次向后移动，才能保持物理和逻辑上的位置一致。而此时的顺序表长度也由原来的n变为n+1。\n\n```c\n#define OK 1\n#define ERROR 0\nint InsList(SeqList *L, int i, ElemType e) {\n    int k;\n    if((i < 1) || (i > L -> last + 2)) {\n        printf(\"插入位置i不合法！\");\n        return(ERROR);\n    }\n    if(L -> last >= MAXSIZE - 1) {\n        printf(\"表已满无法插入！\");\n        return(ERROR);\n    }\n    for(k = L -> last;k <= i - 1;k --) L -> elem[k + 1] = L -> elem[k];\n    L -> elem[i - 1] = e;\n    L -> last++;\n    return(OK);\n}\n```\n\n#### 顺序表常用操作 - 删除操作：\n顺序的删除操作同样需要移动元素，且表长度也由原来的n变为n-1，删除后返回删除元素的值。\n\n```c\n#define ERROR 0\nint DelList(SeqList *L, int i, ElemType *e) {\n    int k;\n    if((i < 1) || (i > L -> last + 1)) {\n        printf(\"删除位置i不合法！\");\n        return(ERROR);\n    }\n    *e = L -> elem[i - 1];\n    for(k = i;k <= L -> last;k ++) L -> elem[k - 1] = L -> elem[k];\n    L -> last--;\n    return(OK);\n}\n```\n","slug":"数据结构-线性顺序表","published":1,"updated":"2019-02-05T14:35:30.280Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtba0075knp2l7mojp66","content":"<p>顺序表就是指用一组连续的物理存储单元来存储表内的每个元素，使得表中相邻的元素在物理地址上也是相邻的。简单的讲，假如第一个元素在地址0X00000000，且第一个元素占用了2个内存单元，而这时的第二个元素开头则处于地址0X00000002，以此类推。假如线性表中有n个元素，每个元素占用k个单元，第一个元素的地址为loc(a1)，则第n个元素的地址为：loc(an) = loc(a1) + (n - 1) *&nbsp;k。</p>\n<p>顺序表的存储结构可以用如下C语言代码来表示：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> MAXSIZE</span>\n<span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    ElemType elem<span class=\"token punctuation\">[</span>MAXSIZE<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> last<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> SeqList<span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>其中ElemType为顺序表内元素的类型。last变量记录顺序表中最后一个元素在数组elem[]中的位置，空表为-1。</p>\n<h4 id=\"顺序表常用操作-查找操作：\"><a href=\"#顺序表常用操作-查找操作：\" class=\"headerlink\" title=\"顺序表常用操作 - 查找操作：\"></a>顺序表常用操作 - 查找操作：</h4><p>按序号查找很简单，只需要按照给出的所有返回对应的数组内容即可，这里我们给出的是按内容查找。即查找出与给定元素内容相同的元素在顺序表中的位置，L为待查找顺序表，e为待查找内容。</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">Locate</span><span class=\"token punctuation\">(</span>SeqList L<span class=\"token punctuation\">,</span> ElemType e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;=</span> L<span class=\"token punctuation\">.</span>last<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>L<span class=\"token punctuation\">.</span>elem<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> i <span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;=</span> L<span class=\"token punctuation\">.</span>last<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> \n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"顺序表常用操作-插入操作：\"><a href=\"#顺序表常用操作-插入操作：\" class=\"headerlink\" title=\"顺序表常用操作 - 插入操作：\"></a>顺序表常用操作 - 插入操作：</h4><p>由于顺序表元素的在物理上的存储位置需要与逻辑顺序一致，所以当插入元素时需要将此元素所在位置的后续所有元素依次向后移动，才能保持物理和逻辑上的位置一致。而此时的顺序表长度也由原来的n变为n+1。</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> OK 1</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> ERROR 0</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">InsList</span><span class=\"token punctuation\">(</span>SeqList <span class=\"token operator\">*</span>L<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">,</span> ElemType e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> k<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">></span> L <span class=\"token operator\">-></span> last <span class=\"token operator\">+</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"插入位置i不合法！\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">(</span>ERROR<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>L <span class=\"token operator\">-></span> last <span class=\"token operator\">>=</span> MAXSIZE <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"表已满无法插入！\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">(</span>ERROR<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>k <span class=\"token operator\">=</span> L <span class=\"token operator\">-></span> last<span class=\"token punctuation\">;</span>k <span class=\"token operator\">&lt;=</span> i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>k <span class=\"token operator\">--</span><span class=\"token punctuation\">)</span> L <span class=\"token operator\">-></span> elem<span class=\"token punctuation\">[</span>k <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> L <span class=\"token operator\">-></span> elem<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    L <span class=\"token operator\">-></span> elem<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> e<span class=\"token punctuation\">;</span>\n    L <span class=\"token operator\">-></span> last<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span><span class=\"token punctuation\">(</span>OK<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"顺序表常用操作-删除操作：\"><a href=\"#顺序表常用操作-删除操作：\" class=\"headerlink\" title=\"顺序表常用操作 - 删除操作：\"></a>顺序表常用操作 - 删除操作：</h4><p>顺序的删除操作同样需要移动元素，且表长度也由原来的n变为n-1，删除后返回删除元素的值。</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> ERROR 0</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">DelList</span><span class=\"token punctuation\">(</span>SeqList <span class=\"token operator\">*</span>L<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">,</span> ElemType <span class=\"token operator\">*</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> k<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">></span> L <span class=\"token operator\">-></span> last <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"删除位置i不合法！\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">(</span>ERROR<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">*</span>e <span class=\"token operator\">=</span> L <span class=\"token operator\">-></span> elem<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>k <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>k <span class=\"token operator\">&lt;=</span> L <span class=\"token operator\">-></span> last<span class=\"token punctuation\">;</span>k <span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> L <span class=\"token operator\">-></span> elem<span class=\"token punctuation\">[</span>k <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> L <span class=\"token operator\">-></span> elem<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    L <span class=\"token operator\">-></span> last<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span><span class=\"token punctuation\">(</span>OK<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"id":"e2158126d3975832601f3cb45b925023","excerpt":"","more":"<p>顺序表就是指用一组连续的物理存储单元来存储表内的每个元素，使得表中相邻的元素在物理地址上也是相邻的。简单的讲，假如第一个元素在地址0X00000000，且第一个元素占用了2个内存单元，而这时的第二个元素开头则处于地址0X00000002，以此类推。假如线性表中有n个元素，每个元素占用k个单元，第一个元素的地址为loc(a1)，则第n个元素的地址为：loc(an) = loc(a1) + (n - 1) *&nbsp;k。</p>\n<p>顺序表的存储结构可以用如下C语言代码来表示：</p>\n<pre><code class=\"c\">#define MAXSIZE\ntypedef struct {\n    ElemType elem[MAXSIZE];\n    int last;\n} SeqList;\n</code></pre>\n<p>其中ElemType为顺序表内元素的类型。last变量记录顺序表中最后一个元素在数组elem[]中的位置，空表为-1。</p>\n<h4 id=\"顺序表常用操作-查找操作：\"><a href=\"#顺序表常用操作-查找操作：\" class=\"headerlink\" title=\"顺序表常用操作 - 查找操作：\"></a>顺序表常用操作 - 查找操作：</h4><p>按序号查找很简单，只需要按照给出的所有返回对应的数组内容即可，这里我们给出的是按内容查找。即查找出与给定元素内容相同的元素在顺序表中的位置，L为待查找顺序表，e为待查找内容。</p>\n<pre><code class=\"c\">int Locate(SeqList L, ElemType e) {\n    i = 0;\n    while((i &lt;= L.last) &amp;&amp; (L.elem[i] != e)) i ++;\n    if(i &lt;= L.last) {\n        return(i + 1);\n    } else {\n        return -1;\n    } \n}\n</code></pre>\n<h4 id=\"顺序表常用操作-插入操作：\"><a href=\"#顺序表常用操作-插入操作：\" class=\"headerlink\" title=\"顺序表常用操作 - 插入操作：\"></a>顺序表常用操作 - 插入操作：</h4><p>由于顺序表元素的在物理上的存储位置需要与逻辑顺序一致，所以当插入元素时需要将此元素所在位置的后续所有元素依次向后移动，才能保持物理和逻辑上的位置一致。而此时的顺序表长度也由原来的n变为n+1。</p>\n<pre><code class=\"c\">#define OK 1\n#define ERROR 0\nint InsList(SeqList *L, int i, ElemType e) {\n    int k;\n    if((i &lt; 1) || (i &gt; L -&gt; last + 2)) {\n        printf(&quot;插入位置i不合法！&quot;);\n        return(ERROR);\n    }\n    if(L -&gt; last &gt;= MAXSIZE - 1) {\n        printf(&quot;表已满无法插入！&quot;);\n        return(ERROR);\n    }\n    for(k = L -&gt; last;k &lt;= i - 1;k --) L -&gt; elem[k + 1] = L -&gt; elem[k];\n    L -&gt; elem[i - 1] = e;\n    L -&gt; last++;\n    return(OK);\n}\n</code></pre>\n<h4 id=\"顺序表常用操作-删除操作：\"><a href=\"#顺序表常用操作-删除操作：\" class=\"headerlink\" title=\"顺序表常用操作 - 删除操作：\"></a>顺序表常用操作 - 删除操作：</h4><p>顺序的删除操作同样需要移动元素，且表长度也由原来的n变为n-1，删除后返回删除元素的值。</p>\n<pre><code class=\"c\">#define ERROR 0\nint DelList(SeqList *L, int i, ElemType *e) {\n    int k;\n    if((i &lt; 1) || (i &gt; L -&gt; last + 1)) {\n        printf(&quot;删除位置i不合法！&quot;);\n        return(ERROR);\n    }\n    *e = L -&gt; elem[i - 1];\n    for(k = i;k &lt;= L -&gt; last;k ++) L -&gt; elem[k - 1] = L -&gt; elem[k];\n    L -&gt; last--;\n    return(OK);\n}\n</code></pre>\n"},{"title":"机器学习记录 - 简介","intro":"为了迎合新时代的新技术发展，最近便开始了自学机器学习的艰难道路。从日常我们能够接触到的“垃圾邮件过滤”，“人脸识别”，“笔迹识别”和 “Google PageRank” 等，其实在互联网上到处都有机器学习的影子，这些也都是机器学习在日常应用中的体现。","comments":1,"date":"2017-04-22T03:12:16.000Z","_content":"\n为了迎合新时代的新技术发展，最近便开始了自学机器学习的艰难道路。从日常我们能够接触到的“垃圾邮件过滤”，“人脸识别”，“笔迹识别”和 “Google PageRank” 等，其实在互联网上到处都有机器学习的影子，这些也都是机器学习在日常应用中的体现。\n\n#### 一、什么是机器学习：\n\n对于这个问题，我不想引用所谓“教程”里的古板术语。从字面意义上来看，“机器学习”就是让机器去学习。学习什么呢？当然是去学习人类的行为方式。比如人类可以在一群人中识别出哪些是自己的朋友，哪些是陌生人。我们同样也可以识别哪些图案是方形的，哪些是圆形的。其实这些简单的小事就是我们想要让机器去学习的东西。\n\n人类在学习事物的过程中，也是通过不断的积累经验然后得到一个统一的规律，然后这些规律逐渐变成了定理，从而可以达到“一眼识别”的效果。其实对于机器来说也是一样的道理。通过给机器提供大量的“样本”案例，让机器在这些案例中自动的寻找规律，最后得到一连串的“特征”，而这些“特征”就是最后用来判断事务的“利器”。\n\n#### 二、机器学习分类：\n\n在我们实际的机器学习应用中，其实可以分为两大类。第一类叫做“有监督学习的机器学习”，另一类叫做“无监督学习的机器学习”。怎么理解呢？所谓的“监督学习”，其实就是指在训练一个机器学习算法的时候，这个算法的学习过程有没有一个正确的指标作为“对照组”。如果机器是按照预先给定的一组我们事先**已经确定其属性（比如已经确定这一组都是方形/圆形）**的“对照组”来进行学习的，那么这个机器学习的过程就叫做“有监督学习”，机器会在这一组“对照组”中寻找特定的关系，比如“这一组圆形的物体都包含什么样的特征？”，通过大量的这种学习后，最后得出一个对应的机器学习算法，并在其他没有确定属性的“对照组”中进行检验。而“无监督学习的机器学习”正好相反，这种机器学习算法会自动在给定的、未知属性的“对照组”中自动的寻找特征并加以区分，最后得出一个相应的算法。\n\n对于“监督学习”，我们又可以分为“分类学习”和“回归学习”。而对于“无监督学习”只对应于“聚类学习”。“分类学习”顾名思义，机器通过大量我们给定的已分类的样本集来进行学习，进而得出一个分类算法，最后将该算法在其他未知的测试样本集中进行检验测试该算法分类的准确性。“回归学习”一般用来进行预测，比如通过已给定的大量房屋售价与房屋面积和房屋使用时间的关系，机器可以通过这些给定的数据进行训练，进而得出一个算法，最后我们可以通过该算法来预测其他未给定房屋的房屋面积和使用时间来预测该房屋的可能出售价格。“聚类学习”不要与“分类学习”混淆，举个例子，我们给定一个测试样本集包含了大量的三角形、圆形和方形分别散落在不同区域，如果在该样本集上应用聚类算法，则该算法会自动将所有的三角形、圆形和方形分为三类（比如用三种颜色来表示）。而分类算法不仅会将所有的三角形、圆形和方形用三种不同颜色表示，而且还会标记出这三类分别是什么形状（因为分类算法是通过我们给定的样本集学习的）。这就是分类和聚类的不同。\n\n#### 三、其他机器学习算法：\n\n强化学习、遗传算法。","source":"_posts/机器学习记录-简介.md","raw":"---\ntitle: 机器学习记录 - 简介\nintro: 为了迎合新时代的新技术发展，最近便开始了自学机器学习的艰难道路。从日常我们能够接触到的“垃圾邮件过滤”，“人脸识别”，“笔迹识别”和 “Google PageRank” 等，其实在互联网上到处都有机器学习的影子，这些也都是机器学习在日常应用中的体现。\ncomments: true\ndate: 2017-04-22 11:12:16\ntags:\n- 机器学习\n---\n\n为了迎合新时代的新技术发展，最近便开始了自学机器学习的艰难道路。从日常我们能够接触到的“垃圾邮件过滤”，“人脸识别”，“笔迹识别”和 “Google PageRank” 等，其实在互联网上到处都有机器学习的影子，这些也都是机器学习在日常应用中的体现。\n\n#### 一、什么是机器学习：\n\n对于这个问题，我不想引用所谓“教程”里的古板术语。从字面意义上来看，“机器学习”就是让机器去学习。学习什么呢？当然是去学习人类的行为方式。比如人类可以在一群人中识别出哪些是自己的朋友，哪些是陌生人。我们同样也可以识别哪些图案是方形的，哪些是圆形的。其实这些简单的小事就是我们想要让机器去学习的东西。\n\n人类在学习事物的过程中，也是通过不断的积累经验然后得到一个统一的规律，然后这些规律逐渐变成了定理，从而可以达到“一眼识别”的效果。其实对于机器来说也是一样的道理。通过给机器提供大量的“样本”案例，让机器在这些案例中自动的寻找规律，最后得到一连串的“特征”，而这些“特征”就是最后用来判断事务的“利器”。\n\n#### 二、机器学习分类：\n\n在我们实际的机器学习应用中，其实可以分为两大类。第一类叫做“有监督学习的机器学习”，另一类叫做“无监督学习的机器学习”。怎么理解呢？所谓的“监督学习”，其实就是指在训练一个机器学习算法的时候，这个算法的学习过程有没有一个正确的指标作为“对照组”。如果机器是按照预先给定的一组我们事先**已经确定其属性（比如已经确定这一组都是方形/圆形）**的“对照组”来进行学习的，那么这个机器学习的过程就叫做“有监督学习”，机器会在这一组“对照组”中寻找特定的关系，比如“这一组圆形的物体都包含什么样的特征？”，通过大量的这种学习后，最后得出一个对应的机器学习算法，并在其他没有确定属性的“对照组”中进行检验。而“无监督学习的机器学习”正好相反，这种机器学习算法会自动在给定的、未知属性的“对照组”中自动的寻找特征并加以区分，最后得出一个相应的算法。\n\n对于“监督学习”，我们又可以分为“分类学习”和“回归学习”。而对于“无监督学习”只对应于“聚类学习”。“分类学习”顾名思义，机器通过大量我们给定的已分类的样本集来进行学习，进而得出一个分类算法，最后将该算法在其他未知的测试样本集中进行检验测试该算法分类的准确性。“回归学习”一般用来进行预测，比如通过已给定的大量房屋售价与房屋面积和房屋使用时间的关系，机器可以通过这些给定的数据进行训练，进而得出一个算法，最后我们可以通过该算法来预测其他未给定房屋的房屋面积和使用时间来预测该房屋的可能出售价格。“聚类学习”不要与“分类学习”混淆，举个例子，我们给定一个测试样本集包含了大量的三角形、圆形和方形分别散落在不同区域，如果在该样本集上应用聚类算法，则该算法会自动将所有的三角形、圆形和方形分为三类（比如用三种颜色来表示）。而分类算法不仅会将所有的三角形、圆形和方形用三种不同颜色表示，而且还会标记出这三类分别是什么形状（因为分类算法是通过我们给定的样本集学习的）。这就是分类和聚类的不同。\n\n#### 三、其他机器学习算法：\n\n强化学习、遗传算法。","slug":"机器学习记录-简介","published":1,"updated":"2019-02-12T06:24:58.691Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtbb0077knp2r1sca5x3","content":"<p>为了迎合新时代的新技术发展，最近便开始了自学机器学习的艰难道路。从日常我们能够接触到的“垃圾邮件过滤”，“人脸识别”，“笔迹识别”和 “Google PageRank” 等，其实在互联网上到处都有机器学习的影子，这些也都是机器学习在日常应用中的体现。</p>\n<h4 id=\"一、什么是机器学习：\"><a href=\"#一、什么是机器学习：\" class=\"headerlink\" title=\"一、什么是机器学习：\"></a>一、什么是机器学习：</h4><p>对于这个问题，我不想引用所谓“教程”里的古板术语。从字面意义上来看，“机器学习”就是让机器去学习。学习什么呢？当然是去学习人类的行为方式。比如人类可以在一群人中识别出哪些是自己的朋友，哪些是陌生人。我们同样也可以识别哪些图案是方形的，哪些是圆形的。其实这些简单的小事就是我们想要让机器去学习的东西。</p>\n<p>人类在学习事物的过程中，也是通过不断的积累经验然后得到一个统一的规律，然后这些规律逐渐变成了定理，从而可以达到“一眼识别”的效果。其实对于机器来说也是一样的道理。通过给机器提供大量的“样本”案例，让机器在这些案例中自动的寻找规律，最后得到一连串的“特征”，而这些“特征”就是最后用来判断事务的“利器”。</p>\n<h4 id=\"二、机器学习分类：\"><a href=\"#二、机器学习分类：\" class=\"headerlink\" title=\"二、机器学习分类：\"></a>二、机器学习分类：</h4><p>在我们实际的机器学习应用中，其实可以分为两大类。第一类叫做“有监督学习的机器学习”，另一类叫做“无监督学习的机器学习”。怎么理解呢？所谓的“监督学习”，其实就是指在训练一个机器学习算法的时候，这个算法的学习过程有没有一个正确的指标作为“对照组”。如果机器是按照预先给定的一组我们事先<strong>已经确定其属性（比如已经确定这一组都是方形/圆形）</strong>的“对照组”来进行学习的，那么这个机器学习的过程就叫做“有监督学习”，机器会在这一组“对照组”中寻找特定的关系，比如“这一组圆形的物体都包含什么样的特征？”，通过大量的这种学习后，最后得出一个对应的机器学习算法，并在其他没有确定属性的“对照组”中进行检验。而“无监督学习的机器学习”正好相反，这种机器学习算法会自动在给定的、未知属性的“对照组”中自动的寻找特征并加以区分，最后得出一个相应的算法。</p>\n<p>对于“监督学习”，我们又可以分为“分类学习”和“回归学习”。而对于“无监督学习”只对应于“聚类学习”。“分类学习”顾名思义，机器通过大量我们给定的已分类的样本集来进行学习，进而得出一个分类算法，最后将该算法在其他未知的测试样本集中进行检验测试该算法分类的准确性。“回归学习”一般用来进行预测，比如通过已给定的大量房屋售价与房屋面积和房屋使用时间的关系，机器可以通过这些给定的数据进行训练，进而得出一个算法，最后我们可以通过该算法来预测其他未给定房屋的房屋面积和使用时间来预测该房屋的可能出售价格。“聚类学习”不要与“分类学习”混淆，举个例子，我们给定一个测试样本集包含了大量的三角形、圆形和方形分别散落在不同区域，如果在该样本集上应用聚类算法，则该算法会自动将所有的三角形、圆形和方形分为三类（比如用三种颜色来表示）。而分类算法不仅会将所有的三角形、圆形和方形用三种不同颜色表示，而且还会标记出这三类分别是什么形状（因为分类算法是通过我们给定的样本集学习的）。这就是分类和聚类的不同。</p>\n<h4 id=\"三、其他机器学习算法：\"><a href=\"#三、其他机器学习算法：\" class=\"headerlink\" title=\"三、其他机器学习算法：\"></a>三、其他机器学习算法：</h4><p>强化学习、遗传算法。</p>\n","site":{"data":{}},"id":"b2d1567cc5b9d8d42a3ce1e287dbe028","excerpt":"","more":"<p>为了迎合新时代的新技术发展，最近便开始了自学机器学习的艰难道路。从日常我们能够接触到的“垃圾邮件过滤”，“人脸识别”，“笔迹识别”和 “Google PageRank” 等，其实在互联网上到处都有机器学习的影子，这些也都是机器学习在日常应用中的体现。</p>\n<h4 id=\"一、什么是机器学习：\"><a href=\"#一、什么是机器学习：\" class=\"headerlink\" title=\"一、什么是机器学习：\"></a>一、什么是机器学习：</h4><p>对于这个问题，我不想引用所谓“教程”里的古板术语。从字面意义上来看，“机器学习”就是让机器去学习。学习什么呢？当然是去学习人类的行为方式。比如人类可以在一群人中识别出哪些是自己的朋友，哪些是陌生人。我们同样也可以识别哪些图案是方形的，哪些是圆形的。其实这些简单的小事就是我们想要让机器去学习的东西。</p>\n<p>人类在学习事物的过程中，也是通过不断的积累经验然后得到一个统一的规律，然后这些规律逐渐变成了定理，从而可以达到“一眼识别”的效果。其实对于机器来说也是一样的道理。通过给机器提供大量的“样本”案例，让机器在这些案例中自动的寻找规律，最后得到一连串的“特征”，而这些“特征”就是最后用来判断事务的“利器”。</p>\n<h4 id=\"二、机器学习分类：\"><a href=\"#二、机器学习分类：\" class=\"headerlink\" title=\"二、机器学习分类：\"></a>二、机器学习分类：</h4><p>在我们实际的机器学习应用中，其实可以分为两大类。第一类叫做“有监督学习的机器学习”，另一类叫做“无监督学习的机器学习”。怎么理解呢？所谓的“监督学习”，其实就是指在训练一个机器学习算法的时候，这个算法的学习过程有没有一个正确的指标作为“对照组”。如果机器是按照预先给定的一组我们事先<strong>已经确定其属性（比如已经确定这一组都是方形/圆形）</strong>的“对照组”来进行学习的，那么这个机器学习的过程就叫做“有监督学习”，机器会在这一组“对照组”中寻找特定的关系，比如“这一组圆形的物体都包含什么样的特征？”，通过大量的这种学习后，最后得出一个对应的机器学习算法，并在其他没有确定属性的“对照组”中进行检验。而“无监督学习的机器学习”正好相反，这种机器学习算法会自动在给定的、未知属性的“对照组”中自动的寻找特征并加以区分，最后得出一个相应的算法。</p>\n<p>对于“监督学习”，我们又可以分为“分类学习”和“回归学习”。而对于“无监督学习”只对应于“聚类学习”。“分类学习”顾名思义，机器通过大量我们给定的已分类的样本集来进行学习，进而得出一个分类算法，最后将该算法在其他未知的测试样本集中进行检验测试该算法分类的准确性。“回归学习”一般用来进行预测，比如通过已给定的大量房屋售价与房屋面积和房屋使用时间的关系，机器可以通过这些给定的数据进行训练，进而得出一个算法，最后我们可以通过该算法来预测其他未给定房屋的房屋面积和使用时间来预测该房屋的可能出售价格。“聚类学习”不要与“分类学习”混淆，举个例子，我们给定一个测试样本集包含了大量的三角形、圆形和方形分别散落在不同区域，如果在该样本集上应用聚类算法，则该算法会自动将所有的三角形、圆形和方形分为三类（比如用三种颜色来表示）。而分类算法不仅会将所有的三角形、圆形和方形用三种不同颜色表示，而且还会标记出这三类分别是什么形状（因为分类算法是通过我们给定的样本集学习的）。这就是分类和聚类的不同。</p>\n<h4 id=\"三、其他机器学习算法：\"><a href=\"#三、其他机器学习算法：\" class=\"headerlink\" title=\"三、其他机器学习算法：\"></a>三、其他机器学习算法：</h4><p>强化学习、遗传算法。</p>\n"},{"title":"日本樱花季游攻略","intro":"计划今年3月下旬待天气稍微转暖，把18年剩余的几天年假用掉，碰巧此时也正好赶上了日本3-5月份的“樱花季”，遂决定去趟日本🇯🇵。按照往年的规律，东京的樱花期是从每年的3月22日开始，持续连续一周左右时间，而我们的出行航班正好是于花季的第二天到达东京，没准能够感上“最新鲜”的樱花视觉盛宴。整个旅程计划6天5晚，大致路线为：东京-镰仓-箱根。","comments":1,"date":"2019-02-14T15:34:42.000Z","_content":"\n\n计划今年3月下旬待天气稍微转暖，把18年剩余的几天年假用掉，碰巧此时也正好赶上了日本3-5月份的“樱花季”，遂决定去趟日本🇯🇵。按照往年的规律，东京的樱花期是从每年的3月22日开始，持续连续一周左右时间，而我们的出行航班正好是于花季的第二天到达东京，没准能够感上“最新鲜”的樱花视觉盛宴。整个旅程计划6天5晚，大致路线为：**东京-镰仓-箱根**。\n\n![](1.jpg)\n\n### 快速导航：\n\n* <a href=\"#1\">3/23 第一天（羽田机场、皇居、千鸟湖、银座、东京塔、六本木）；</a>\n* <a href=\"#2\">3/24 第二天（新宿御苑、目黑川、涩谷、明治神宫、原宿、表参道）；</a>\n* <a href=\"#3\">3/25 第三天（池袋、上野公园、浅草寺、隅田公园、东京天空树）；</a>\n* <a href=\"#4\">3/26 第四天（江之岛、湘南海岸、镰仓高校前站、高德院、长谷寺、鹤冈八幡宫）；</a>\n* <a href=\"#5\">3/27 第五天（箱根汤本站、早云山站、大涌谷站、桃园台站、元箱根港、箱根神社）；</a>\n* <a href=\"#6\">3/28 第六天（箱根美术馆、POLA 美术馆、箱根小王子博物馆、箱根玻璃之森美术馆）；</a>\n\n### 附录资料：\n\n* 周游券/车票购买地点：[小田急旅游服务中心、自动售票机](https://www.odakyu.jp/sc/transport/riding/howto/#purchase)；\n* [小田急“浪漫”特快预约购票（提前一月预订、建议选择 70000 GSE/50000 VSE 车型眺望席）](https://www.web-odakyu.com/e-romancecar/vacantSeatInquiry/input?STICKY=11074)；\n* <a href=\"#7\">箱根地图；</a>\n* <a href=\"#8\">江之岛/镰仓地图；</a>\n* <a href=\"#9\">小田急线路线图；</a>\n\n\n\n### 日本签证材料参考：\n\n1. 护照（至少剩余6月有效期）；\n2. 2张2寸白底彩照（一张贴在申请表上，一张写上名字，3个月内拍摄）；\n3. 身份证（正反清晰复印件）；\n4. 户口本（户主页和本人首页复印件）；\n5. 日本签证申请表；\n6. 个人信息处理同意书；\n7. 旅签材料受理表；\n8. 在职证明原件（本人带公章，带有薪资字样，年收入10万以上）；\n9. 电子税单（近一年缴税金额须每月达到230元以上，同一公司缴纳）；\n10. 全程的机酒预订单（带有出入境日期、第一晚入住城市、及全程入住的酒店和机票）；\n11. 居住证（外地户籍，需符合上海领区的地区要求）；\n\n\n### <a name=\"1\">行程 Day1 (3/23)</a>\n\n#### - 路线：\n\n1. **羽田国际机场**（*[位置](https://goo.gl/maps/E8rL54MhkUs)*）：\n\n![](2.jpg)\n \n> 交通：直飞航班，从上海到东京，当日清晨 05:30 分抵达机场；\n\n2. **皇居**（*[位置](https://goo.gl/maps/9vcodQirdVP2) / [百科](https://zh.wikipedia.org/zh-cn/%E7%9A%87%E5%B1%85)*）：\n\n![](3.jpg)\n\n> 交通：[东京单轨电车 - 京滨东北线 - 有乐町线 / 63min](https://goo.gl/maps/3QUTgYN2gz92)\n\n\n\n传统上，日本没有定都的概念，习惯以在位天皇（大王）的所在地为国都（古代称为“京”），并以在位天皇居住之宫殿为皇居（古代称为“宫”）。现在的皇居位于东京都千代田区，即原江户幕府历代将军所居住的江户城，但范围较原始的江户城为小。\n\n皇居除皇室起居部分不对公众开放外，其他部分可经由宫内厅进行预约参观，东面的皇居东御苑（原江户城本丸所在地）则在固定时间开放自由参观。皇居内部每年开放两次，分别在天皇诞生日及新年的次日（1月2日）。皇居的土地为国有财产，皇居的管理则连同皇室的事务由宫内厅全权负责。虽然皇居的位置邻近东京交通枢纽之一的东京站，而东京又有极为绵密的地下铁路网和高速公路系统，但并没有任何一条铁道或公路穿过皇居的地底下，全由周边绕开。\n\n\n3. **千鸟渊**（*[位置](https://goo.gl/maps/CZ1PYFBpXmk) / [百科](https://zh.wikipedia.org/zh-cn/%E5%8D%83%E9%B3%A5%E6%B7%B5)*）：\n\n![](4.jpg)\n\n> 交通：[步行 / 1.5KM / 18min](https://goo.gl/maps/3XpDobWx71R2)\n\n千鸟渊是江户开府后江户城扩张之际，在局泽川筑上两座土桥半藏门与田安门而形成的护城河。以代官町通相隔的半藏濠在过去与千鸟渊相通，但1900年（明治33年）因道路建设进行填地后成为独立的两条护城河。\n\n千鸟渊附近以赏樱名所而知名，吸引大批名众来此赏樱。开花期间中、千鸟渊沿旁的千鸟渊绿道在花期夜晚会点灯照明。此外，千鸟渊绿道设有搭船处，可在千鸟渊内划船。\n\n千鸟渊绿道旁有日本政府设置的千鸟渊战殁者墓苑，安置第二次世界大战中在海外丧生的身份不明日本人遗骨。\n\n\n4. **银座**（*[位置](https://goo.gl/maps/Gqyycidp84P2) / [百科](https://zh.wikipedia.org/zh-cn/%E9%8A%80%E5%BA%A7)*）：\n\n![](5.jpg)\n\n> 交通：[步行 / 3.5KM / 42min](https://goo.gl/maps/KAGP9wQDMgH2)\n\n是日本东京中央区的一个主要商业区，以高级购物商店闻名，是东京其中一个代表性地区。\n\n银座位于日本中央区西部，分为银座一丁目至银座八丁目。银座四丁目与银座五丁目之间被晴海通所分隔，全部8个丁目由中央通贯通。银座是高级商店街的象征，因此日本各地商店街常可见冠以银座之名的“某某银座”。\n\n\n5. **东京塔**（*[位置](https://goo.gl/maps/EqMAqDuUKz82) / [百科](https://zh.wikipedia.org/zh-cn/%E4%B8%9C%E4%BA%AC%E9%93%81%E5%A1%94)*）：\n\n![](6.jpg)\n\n> 交通：[浅草线 / 23min](https://goo.gl/maps/XyyRRfwi6kQ2)\n\n是位于日本东京都港区芝公园的电波塔。其以巴黎埃菲尔铁塔为范本而建造，高333米，比前者高13米，完工以来即成为东京著名地标与观光景点。正式名称为日本电波塔（日本電波塔／にっぽんでんぱとう），这同时也是其营运机构的名称。\n\n东京铁塔由建筑师内藤多仲与日建设计株式会社共同设计。高332.6米，较艾菲尔铁塔的324米高出8.6米，较东京天空树矮301.4米，比广州塔矮267.4米，是世界第三高的自立式铁塔，重4,000吨，与重7,300吨的埃菲尔铁塔相比重量大幅减轻，开工于1957年6月29日，1958年10月14日竣工，12月7日正式公开，12月23日举行竣工仪式，开始了正式营业。三分之一用于建塔的钢铁，来自韩战时美军的坦克废铁。\n\n\n6. **六本木**（*[位置](https://goo.gl/maps/Wz9dasFuacB2) / [百科](https://zh.wikipedia.org/zh-cn/%E5%85%AD%E6%9C%AC%E6%9C%A8)*）：\n\n![](7.jpg)\n\n> 交通：[大江户线 / 14min](https://goo.gl/maps/dUkXekDDjTP2)\n\n是位于日本东京都港区的街区，坐落于港区的北侧，北邻南青山，东接赤坂，东南临虎之门，南接麻布台、麻布永坂町、麻布十番，西南临元麻布，西接西麻布。现行行政地名为六本木一丁目至六本木七丁目。2013年7月1日的人口为11,929人。邮递区号106-0032。\n\n六本木是驻日大使馆的主要聚集地，以聚集外国人与夜生活而闻名。虽然有闹区的强烈印象，但是并没有百货公司设于此地。时至今日，商办设施、高级公寓，以及方舟之丘、泉花园大厦、六本木新城、东京中城等都市再开发计划，让六本木呈现多样的面貌。\n\n\n#### - 美食：\n\n拉面、天妇罗、牛丼、大仮烧、和牛；\n\n#### - 住宿：\n\n> 交通：[大江户线 / 24min](https://goo.gl/maps/TZRW1CfYdTm)\n\n新宿区：E Hotel Higashi Shinjuku （东新宿E酒店）双人间 / ￥1001\n\n### <a name=\"2\">行程 Day2 (3/24)</a>\n\n#### - 路线： \n\n\n1. **新宿御苑**（*[位置](https://goo.gl/maps/ogBrfC2pYhp) / [百科](https://zh.wikipedia.org/zh-cn/%E6%96%B0%E5%AE%BF%E5%BE%A1%E8%8B%91)*）：\n\n![](13.jpg)\n\n> 交通：[副都心线 / 13min](https://goo.gl/maps/hJPcr2YhjfJ2)\n\n新宿御苑是日本东京都横跨新宿区与涩谷区的庭园，面积58.3公顷。该处在江户时代为内藤家的宅地；其后成为宫内厅管理的庭园，现在则属环境省管辖的国民公园。\n\n\n2. **明治神宫**（*[位置](https://goo.gl/maps/4jkzF2FMpct) / [百科](https://zh.wikipedia.org/zh-cn/%E6%98%8E%E6%B2%BB%E7%A5%9E%E5%AE%AB)*）：\n\n![](10.jpg)\n\n\n> 交通：[步行 / 2KM / 24min](https://goo.gl/maps/j5ZyYnAQGsn)\n\n是位于日本东京都涩谷区的神社，供奉明治天皇，昭宪皇太后的灵位。1920年启用，占地70公顷，紧挨着原宿、新宿等东京两大商圈，占据了从代代木到原宿站之间的整片地带，与相邻的代代木公园构成东京市中心除了皇居之外最大的一块绿地。正式书记中，“宫”的写法采取日本古代常见写法，下方“吕”中间没有一撇“ノ”，为“明治神宫”。\n\n3. **原宿**（*[位置](https://goo.gl/maps/URr6YNikPuz) / [百科](https://zh.wikipedia.org/zh-cn/%E5%8E%9F%E5%AE%BF)*）：\n\n![](11.jpg)\n\n\n> 交通：[步行 / 1KM / 11min](https://goo.gl/maps/D7i5pMeiDrr)\n\n原宿是东京都涩谷区的一个地区，范围约为明治神宫、代代木公园、竹下通、表参道、国立代代木竞技场一带，是日本著名的“年轻人之街”。\n\n4. **表参道**（*[位置](https://goo.gl/maps/qzUtiPbR7LT2) / [百科](https://zh.wikipedia.org/zh-cn/%E8%A1%A8%E5%8F%83%E9%81%93)*）：\n\n![](12.jpg)\n\n> 交通：[步行 / 1KM / 12min](https://goo.gl/maps/NR5xs4BLb7x)\n\n表参道是1920年明治神宫创建时，在正面侧的参道与兴建道路的通称。位于东京都涩谷区与港区，都道413号线，及原宿站前附近，至青山通交差的表参道交差点区域。但多数用以称呼东京地下铁表参道站附近，为明确区别，道路以表参道通称呼。\n\n表参道与明治通的交差点，即神宫前交差点以东，为日本著名外国品牌时装店林立之地。过去有1927年建设的同润会青山公寓，但因建筑变得古旧，在2003年被拆卸，原址在2006年2月建成表参道之丘，内设有一些有个性的店铺，附近则为潮流区域里原宿的入口。神宫前交差点以西有时装商场 Laforet 原宿，及不少饮食店与杂货店。\n\n在表参道交差点至根津美术馆方向，阔15米的道路通称为“从快通”。\n\n5. **涩谷**（*[位置](https://goo.gl/maps/ruGGgZ82b3C2) / [百科](https://zh.wikipedia.org/zh-cn/%E6%BE%80%E8%B0%B7)*）：\n\n![](9.gif)\n\n> 交通：[步行 / 0.8KM / 9min](https://goo.gl/maps/7a8Dvtp7QUB2)\n\n涩谷与新宿、池袋并列为东京三大副都心，是东京最具代表性的商圈之一，乃日本流行与时尚的重要发信地，又以“音乐之街”、“年轻人之街”著称；同时是东京通往首都圈东南郊区的重要转运点，拥有多家连锁百货公司及综合商场，为东急集团的大本营。涩谷站前的八公铜像是涩谷的地标；涩谷站前交叉口的行人保护时相，则是东京知名的城市地景之一。\n\n6. **目黑川**（*[位置](https://goo.gl/maps/5GVfiQSQYJP2) / [百科](https://zh.wikipedia.org/zh-cn/%E7%9B%AE%E9%BB%91%E5%B7%9D)*）：\n\n![](8.jpg)\n\n> 交通：[东急东横线 / 14min](https://goo.gl/maps/idRtv3YAWrq)\n\n是东京都流经世田谷区、目黑区与品川区，最后注入东京湾的河川。为二级水系的主流。\n\n河口附近自古以来称为“品川”（しながわ）。在湾岸开发以前，河口附近河道弯曲，流速合缓，因此成为港口，是物品来来往往的河川因而称为“品川”。\n\n另外，从江户时代的绘图，其上游下目黑附近称作“こりとり川”。“こりとり”意为“垢离取り”，源自于在此川洁净自身的目黑不动尊。\n\n#### - 美食：\n\n-\n\n#### - 住宿：\n\n> 交通：[东急东横线 / 18min](https://goo.gl/maps/mJvFS2wBdJy)\n\n新宿区：E Hotel Higashi Shinjuku （东新宿E酒店）双人间 / ￥1001\n\n\n### <a name=\"3\">行程 Day3 (3/25)</a>\n\n> 【酒店寄存行李】 交通：[大江戶線 / 23min](https://goo.gl/maps/wuCpP12dBUG2)\n\n#### - 路线： \n\n\n1. **池袋**（*[位置](https://goo.gl/maps/JKp7zsH8Zyn) / [百科](https://zh.wikipedia.org/zh-cn/%E6%B1%A0%E8%A2%8B)*）：\n\n![](15.jpg)\n\n> 交通：[大江户线 -> 丸之内线 / 25min](https://goo.gl/maps/NcNaYDa9ES62)\n\n是日本东京都丰岛区的一个区域，也是东京市区中一个主要的商业及娱乐地区。池袋有多家大型百货公司据点及东京主要车站之一的池袋站，亦是丰岛区役所（区政府）所在地。\n\n2. **上野公园**（*[位置](https://goo.gl/maps/NPhsms11D9A2) / [百科](https://zh.wikipedia.org/zh-cn/%E4%B8%8A%E9%87%8E%E5%85%AC%E5%9C%92)*）：\n\n![](16.jpg)\n\n> 交通：[山手线 / 35min](https://goo.gl/maps/uSE6TmaAaY22)\n\n全名上野恩赐公园，是日本东京都台东区上野的一座公园，也是日本第一座公园，占地约53万平方米。全园在1873年指定为公园、1876年正式开园。此地原属于日本皇室，至1924年始由大正天皇下赐与东京市管理，故名“恩赐”。\n\n上野公园是东京国立博物馆、国立西洋美术馆、国立科学博物馆、上野动物园的所在地。同时也有雕刻家高村光云所作的西乡隆盛铜像[1]，以及野口英世的铜像。\n\n称作忍冈的高地是近代的赏樱名所，入选为日本樱名所100选，吸引大量赏花游客前往。此外，忍冈南方的不忍池（しのばずのいけ），夏天池上大量桃色莲花盛开。冬季有鸭等多种水鸟飞至此地栖息。\n\n\n3. **浅草寺**（*[位置](https://goo.gl/maps/9oFcWmwrNcL2) / [百科](https://zh.wikipedia.org/zh-cn/%E6%B7%BA%E8%8D%89%E5%AF%BA)*）：\n\n![](17.jpg)\n\n> 交通：[步行 / 2.5KM / 30min](https://goo.gl/maps/sLP9Tkrhapz)\n\n又名金龙山浅草寺，位于日本东京都台东区浅草二丁目，是东京都内历史最悠久的寺院。山号为金龙山。供奉的本尊是圣观音。原属天台宗，于第二次世界大战后独立，成为圣观音宗的总本山。观音菩萨本尊通称为“浅草观音”。\n\n4. **隅田公园**（*[位置](https://goo.gl/maps/fM1zpAjgrPx) / [百科](https://zh.wikipedia.org/zh-cn/%E9%9A%85%E7%94%B0%E5%85%AC%E5%9C%92)*）：\n\n![](18.jpg)\n\n\n> 交通：[步行 / 1KM / 12min](https://goo.gl/maps/bpoLyJR2A8p)\n\n是东京都隅田川岸的公园，分为右岸的台东区浅草、花川户、今户（35°42′55″N 139°48′10.5″E）与左岸的墨田区向岛（35°42′45″N 139°48′15″E）两侧。春季以满开樱花闻名，夏季则是隅田川花火大会会场。\n\n每年举行樱花季的隅田公园内约有约700多棵樱花树，是日本樱名所100选之一。约1公里左右的隅田川两岸樱花木是在八代将军德川吉宗安排下所种植。江户时代起便是知名赏樱景点。\n\n5. **东京天空树**（*[位置](https://goo.gl/maps/g9785FpgnvT2) / [百科](https://zh.wikipedia.org/zh-cn/%E6%9D%B1%E4%BA%AC%E6%99%B4%E7%A9%BA%E5%A1%94)*）：\n\n![](19.jpg)\n\n\n> 交通：[步行 / 0.8KM / 10min](https://goo.gl/maps/taDVPzjQsB22)\n\n是位于日本东京都墨田区的电波塔，由东武铁道及其子公司东武塔晴空塔共同筹建，于2008年7月14日动工，2012年2月29日完工、同年5月22日正式启用。其高度为634米，于2011年11月17日获得吉尼斯世界纪录认证为“世界第一高塔”，成为全世界最高的自立式塔形建筑；目前亦为世界第二高的人工构造物，仅次于哈里发塔。\n\n#### - 美食：\n\n-\n\n#### - 住宿：\n\n> 交通：[浅草线 / 11min](https://goo.gl/maps/XQ6HHAzqpNx)\n\n台东区：Asakusa Kuramae Hotel Yume Iroha （浅草藏前梦伊吕波经济型酒店）双人间 / ￥616.5\n\n\n\n\n### <a name=\"4\">行程 Day4 (3/26)</a>\n\n> 【酒店寄存行李】 交通：[大江户线 / 29min](https://goo.gl/maps/HcA7s5Rp1RF2)\n\n> [交通指南](https://www.odakyu.jp/sc/getting-around/enoshima_kamakura/)；[箱根镰仓周游券（3天）](https://www.odakyu.jp/sc/passes/hakone_kamakura/)；\n\n当天早起先去新宿的新酒店寄存行李，然后直接前往镰仓。晚上返程住新宿。\n\n#### - 路线：\n\n1. **江之岛**（*[位置](https://goo.gl/maps/KqvLRhN4WU62) / [百科](https://zh.wikipedia.org/zh-cn/%E6%B1%9F%E4%B9%8B%E5%B3%B6)*）：\n\n![](25.jpg)\n\n> 交通：[小田急线 - 小田急江之岛线 / 98min](https://goo.gl/maps/NjFkgFwMGAu)\n\n\n江之岛是湘南的代表景点，也是神奈川县指定史迹名胜（1960年开始）及日本百景（1927年）之一。交通机关的站名等多记为江ノ島，住居表示、公文等多使用“江の島”。有时也以古老的江岛神社（日本三大辩天之一）的“江岛”代表。本条目叙述的是陆连岛与地名的江之岛，但一般认知的观光地还包含对岸的片濑、鹄沼地区南部一带。\n\n\n2. **湘南海岸**（*[位置](https://goo.gl/maps/i7T8oXJgM212)*）：\n\n![](26.jpg)\n\n> 交通：[步行 / 1.5KM / 19min](https://goo.gl/maps/NjFkgFwMGAu)\n\n湘南海岸（湘南海岸）是，神奈川县的湘南出区域，该区域被称为的茅崎从镰仓沿海地区和在沿海区域。\n\n长期开设日本海滩代表，是全国着名的冲浪点。它还显示在四季中熙熙攘攘的日期点。顺便说一句，134号公路沿着湘南海岸。\n\n\n3. **镰仓高校前站**（*[位置](https://goo.gl/maps/iJfoHGhSAGk) / [百科](https://zh.wikipedia.org/zh-cn/%E9%8E%8C%E5%80%89%E9%AB%98%E6%A0%A1%E5%89%8D%E8%BB%8A%E7%AB%99)*）：\n\n![](20.jpg)\n\n> 交通：[步行 / 2.7KM / 34min](https://goo.gl/maps/NjFkgFwMGAu)\n\n是一由江之岛电铁（江之电）所经营的铁路车站，位于日本神奈川县镰仓市境内，是江之岛电铁线沿线的一个无人车站。由于车站仅与七里滨（七里ヶ浜）的海岸线隔着国道134号相望，因此站在月台上即能眺望海边的风光。\n\n本站在1903年初设站时，原名日坂，并在1953年时根据紧邻的神奈川县立镰仓高等学校，改名为镰仓高校前。1997年时，因为车站所在地可以见到海景的优美风情，而成为首批入选“关东车站百选”的其中一个车站。\n\n车站周边有多部动漫、电视剧及广告等作品取景，特别是东侧的一处平交道，因为是同名漫画改编的电视动画《灌篮高手》（スラムダンク）主题曲以及《Tari Tari》动画场景之一，吸引不少该作品的爱好者到此探访拍照[1]，但有部分人士擅自闯入未开放的镰仓高校校园内拍照游玩，造成该校的困扰。\n\n\n4. **高德院**（*[位置](https://goo.gl/maps/LHEo1G69rVw) / [百科](https://zh.wikipedia.org/zh-cn/%E9%AB%98%E5%BE%B7%E9%99%A2)*）：\n\n![](24.jpg)\n\n> 交通：[江之岛电铁线 / 23min](https://goo.gl/maps/UXGX7uBkDBJ2)\n\n高德院位于日本神奈川县镰仓市的长谷，是一间佛教净土宗的寺院。供奉的本尊阿弥陀佛一般人称为“镰仓大佛”，坐落于大异山。开基（创立者）与开山（初代住持）均不明。\n\n这座寺院拥有日本最著名的佛像之一—大佛—一座高达11.3米，重约121吨的露天阿弥陀佛青铜塑像，它的尺寸在全日本仅次于位于奈良市东大寺的另一尊佛像。\n\n根据寺院有关青铜像建造的相关记载，这座塑像的历史可以追溯到1252年的镰仓时代。然而，并不清楚寺院记录中那座当时正在建造的塑像是否就是今天这座大佛像。这座佛像曾经位于一座寺庙建筑中，而原本容纳大佛的木质寺庙建筑毁于15世纪末室町时代的一场海啸，但佛像却保留了下来。\n\n5. **长谷寺**（*[位置](https://goo.gl/maps/cnrhLHDu5h92)*）：\n\n![](23.jpg)\n\n> 交通：[步行 / 0.7KM / 9min](https://goo.gl/maps/VKDzUDtJTWo)\n\n是位在日本奈良县樱井市的寺院，真言宗丰山派总本山。山号“丰山”（ぶざん）。本尊十一面观音、开基（创立者）为道明。别称“花之御寺”。\n\n6. **鹤冈八幡宫**（*[位置](https://goo.gl/maps/trhdMFyGi562)*）：\n\n![](22.jpg)\n\n> 交通：[江之岛电铁线 / 26min](https://goo.gl/maps/VaYkVGmUsfK2)\n\n是位于日本神奈川县镰仓市的神社。旧社格为国币中社（现神社本厅的别表神社）。武家源氏、镰仓武士之守护神。也称作镰仓八幡宫。公元1063年由源赖义由京都的石清水八幡宫劝请至由比之滨。此后，于公元1180年进入镰仓的幕府将军源赖朝将其移请至现址，并加以扩建，才成为日后镰仓幕府时期中心。\n\n#### - 美食：\n\n-\n\n#### - 住宿：\n\n> 交通：[镰仓站 - 藤泽站 / 江之岛电铁线 / 36min](https://goo.gl/maps/cNgfndNJhzA2) -> [藤泽站 - 新宿 / 小田急线 / 70min](https://goo.gl/maps/H7ZosDWmSg22)\n\n新宿区：Citadines Central Shinjuku Tokyo（馨乐庭中央东京新宿区酒店）双人间 / ￥1052\n\n\n\n\n\n### <a name=\"5\">行程 Day5 (3/27)</a>\n\n![](27.png)\n\n> [交通指南](https://www.odakyu.jp/sc/getting-around/hakone/)；[箱根镰仓周游券（3天）](https://www.odakyu.jp/sc/passes/hakone_kamakura/)；\n\n#### - 路线：\n\n1. **箱根汤本站**（*[位置](https://goo.gl/maps/g4L4YaPX7yj)*）：\n\n![](21.jpg)\n\n> 交通：[小田急浪漫特快 / 95min](https://goo.gl/maps/SAZfg2J1fd82)\n\n自古已是温泉町，在江户时代设置箱根关。近代由于西武铁道集团与小田急电铁致力于观光开发而得到急速发展。箱根温泉是汤本、塔之泽、大平台、宫之下、小涌谷等地温泉的总称。\n\n\n2. **Emblem Flow Hakone 酒店寄存**（*[位置](https://goo.gl/maps/wAWgwPSWAF92)*）：\n\n> 交通：[箱根登山线 / 37min](https://goo.gl/maps/axQ5wKEUgFk)\n\n\n3. **早云山站**（*[位置](https://goo.gl/maps/s7tFrFPZzZC2)*）：\n\n> 交通：[箱根登山线 / 10min](https://goo.gl/maps/rGtpgcYC1xr)\n\n\n4. **大涌谷站**（*[位置](https://goo.gl/maps/A2vHp7KUkxL2)*）：\n\n> 交通：[箱根空中缆车 / 8min](https://goo.gl/maps/S3FEyt4Vxx52)\n\n5. **桃园台站**（*[位置](https://goo.gl/maps/CkyELagfu4R2)*）：\n\n> 交通：[箱根空中缆车 / 16min](https://goo.gl/maps/JZaM8QTy19u)\n\n\n6. **元箱根港**（*[位置](https://goo.gl/maps/ZnkiVduN4gu)*）：\n\n> 交通：箱根海盗船\n\n7. **箱根神社**（*[位置](https://goo.gl/maps/dHzUHdS1buF2)*）：\n\n![](28.jpg)\n\n> 交通：[步行 / 1KM / 14min](https://goo.gl/maps/3hcHkHfLmzP2)\n\n\n#### - 美食：\n\n-\n\n#### - 住宿：\n\n> 交通：[箱根町線：箱根口経由 -> 箱根登山線 / 42分钟](https://goo.gl/maps/bzH8jKf7jXT2)\n\n箱根：Emblem Flow Hakone / 双人间￥1092\n\n\n\n### <a name=\"6\">行程 Day6 (3/28)</a>\n\n\n1. **箱根美术馆**（*[位置](https://goo.gl/maps/3Z4FjVQGBKD2)*）：\n\n\n> 交通：[步行 / 0.65KM / 13min](https://goo.gl/maps/AVEvzajWhBm)\n\n箱根美术馆是箱根地区最早建立的美术馆。昭和27年6月，由创始人岡田茂吉先生建立。主要展品为岡田茂吉先生收藏的中日古代陶瓷器。其中最古老的藏品历史可追溯到古坟时代。\n\n箱根美术馆的苔藓庭院是一绝，茶室楼阁山石花草，看似无心布置，却处处透露着日式的禅意。秋季枫叶变红，与绿苔形成鲜明的对比，能吸引大批游客。\n\n2. **POLA 美术馆**（*[位置](https://goo.gl/maps/SVsUGKz8jEx)*）：\n\n\n> 交通：[天悠～強羅小塚～湿生花園前 / 12min](https://goo.gl/maps/qJX5qB2vZkM2)\n\nPola Museum of Art 位于日本神奈川县箱根。它于2002年9月在富士箱根伊豆国立公园内开放。它收藏了 Pola 化妆品集团前负责人收购的超过9,500件作品，其中包括法国印象派和巴黎 École 的许多作品。引人注目的建筑是 Nikken Sekkei。\n\n\n3. **箱根小王子博物馆**（*[位置](https://goo.gl/maps/zxSsZ8e9bcy)*）：\n\n\n> 交通：[天悠～強羅小塚～湿生花園前 / 4min](https://goo.gl/maps/yD9PWYThE1L2)\n\n箱根小王子博物馆（日语：箱根★サン＝テグジュペリ 星の王子さまミュージアム）是位于日本神奈川县箱根町仙石原的博物馆[1]，专门展出与《小王子》及其作者安东尼·迪·圣-修伯里有关的展品。该馆开幕于1999年6月29日，即圣修伯里诞生100周年之际。\n\n博物馆呈现了《小王子》书中的情节与人物，其中设有小王子及其B612星球的雕塑、“小王子庭院”、模仿1930年代时期的咖啡馆、模仿圣修伯里童年时期的教会、圣修伯里生平展示空间等等。馆内的礼品店出售《小王子》的相关商品。\n\n4. **箱根玻璃之森美术馆**（*[位置](https://goo.gl/maps/YNPhEHvaoZJ2)*）：\n\n\n> 交通：[步行 / 0.85KM / 11min](https://goo.gl/maps/EWZZELi6TCR2)\n\n神奈川县的玻璃之森美术馆，坐落在箱根绵延的群山之中，主体建筑酷似欧洲中世纪贵族别墅，仿若童话世界。在这广阔的庭园里分布着美术馆、商店和咖啡厅。 美术馆里陈列着15世纪至19世纪期间威尼斯和现代威尼斯的作品约100件，它们是曾经让欧洲贵族为之疯狂的威尼斯玻璃艺术。此外，还公开展示了很多罗斯柴尔德家族传承下来的钴蓝高脚杯等贵重作品。最令人惊叹的是礼花树 Fontana 喷泉，阳光下熠熠生辉的礼花树，亮晶晶的树木、泉水、瀑布都是一粒一粒的玻璃球制成，整个美术馆都显得十分精致美好。 露天咖啡厅可观赏以中世纪威尼斯为形象的庭院，那里有正宗的坎佐纳器乐作品实况演奏。另外还有能体验玻璃工艺制作的体验工房。\n\n\n5. **Emblem Flow Hakone 酒店取行李**：\n\n> 交通：[アウトレット～宮城野～天悠 / 13min](https://goo.gl/maps/Sf1ptiTDHLw)\n\n\n6. **箱根汤本站**：\n\n当日 15:30 前必须上车。\n\n> 交通：[箱根登山线 / 45min](https://goo.gl/maps/oz9sP91Y4CU2)\n\n7. **新宿站**：\n\n> 交通：[小田急浪漫特快 / 99min](https://goo.gl/maps/9Pp7BVaNvFM2)\n\n\n8. **羽田国际机场**（*[位置](https://goo.gl/maps/E8rL54MhkUs)*）：\n\n> 交通：[大江戶線 -> 東京單軌電車 / 55min](https://goo.gl/maps/Rq6qk8dDPKm)\n\n\n### 附录资料\n\n#### <a name=\"7\">箱根地图：</a>\n\n![](29.png)\n\n#### <a name=\"8\">江之岛/镰仓地图：</a>\n\n![](31.png)\n\n#### <a name=\"9\">小田急线路线图：</a>\n\n![](30.png)","source":"_posts/日本樱花季游攻略.md","raw":"---\ntitle: 日本樱花季游攻略\nintro: 计划今年3月下旬待天气稍微转暖，把18年剩余的几天年假用掉，碰巧此时也正好赶上了日本3-5月份的“樱花季”，遂决定去趟日本🇯🇵。按照往年的规律，东京的樱花期是从每年的3月22日开始，持续连续一周左右时间，而我们的出行航班正好是于花季的第二天到达东京，没准能够感上“最新鲜”的樱花视觉盛宴。整个旅程计划6天5晚，大致路线为：东京-镰仓-箱根。\ncomments: true\ndate: 2019-02-14 23:34:42\ntags:\n- 日记\n- 旅游\n---\n\n\n计划今年3月下旬待天气稍微转暖，把18年剩余的几天年假用掉，碰巧此时也正好赶上了日本3-5月份的“樱花季”，遂决定去趟日本🇯🇵。按照往年的规律，东京的樱花期是从每年的3月22日开始，持续连续一周左右时间，而我们的出行航班正好是于花季的第二天到达东京，没准能够感上“最新鲜”的樱花视觉盛宴。整个旅程计划6天5晚，大致路线为：**东京-镰仓-箱根**。\n\n![](1.jpg)\n\n### 快速导航：\n\n* <a href=\"#1\">3/23 第一天（羽田机场、皇居、千鸟湖、银座、东京塔、六本木）；</a>\n* <a href=\"#2\">3/24 第二天（新宿御苑、目黑川、涩谷、明治神宫、原宿、表参道）；</a>\n* <a href=\"#3\">3/25 第三天（池袋、上野公园、浅草寺、隅田公园、东京天空树）；</a>\n* <a href=\"#4\">3/26 第四天（江之岛、湘南海岸、镰仓高校前站、高德院、长谷寺、鹤冈八幡宫）；</a>\n* <a href=\"#5\">3/27 第五天（箱根汤本站、早云山站、大涌谷站、桃园台站、元箱根港、箱根神社）；</a>\n* <a href=\"#6\">3/28 第六天（箱根美术馆、POLA 美术馆、箱根小王子博物馆、箱根玻璃之森美术馆）；</a>\n\n### 附录资料：\n\n* 周游券/车票购买地点：[小田急旅游服务中心、自动售票机](https://www.odakyu.jp/sc/transport/riding/howto/#purchase)；\n* [小田急“浪漫”特快预约购票（提前一月预订、建议选择 70000 GSE/50000 VSE 车型眺望席）](https://www.web-odakyu.com/e-romancecar/vacantSeatInquiry/input?STICKY=11074)；\n* <a href=\"#7\">箱根地图；</a>\n* <a href=\"#8\">江之岛/镰仓地图；</a>\n* <a href=\"#9\">小田急线路线图；</a>\n\n\n\n### 日本签证材料参考：\n\n1. 护照（至少剩余6月有效期）；\n2. 2张2寸白底彩照（一张贴在申请表上，一张写上名字，3个月内拍摄）；\n3. 身份证（正反清晰复印件）；\n4. 户口本（户主页和本人首页复印件）；\n5. 日本签证申请表；\n6. 个人信息处理同意书；\n7. 旅签材料受理表；\n8. 在职证明原件（本人带公章，带有薪资字样，年收入10万以上）；\n9. 电子税单（近一年缴税金额须每月达到230元以上，同一公司缴纳）；\n10. 全程的机酒预订单（带有出入境日期、第一晚入住城市、及全程入住的酒店和机票）；\n11. 居住证（外地户籍，需符合上海领区的地区要求）；\n\n\n### <a name=\"1\">行程 Day1 (3/23)</a>\n\n#### - 路线：\n\n1. **羽田国际机场**（*[位置](https://goo.gl/maps/E8rL54MhkUs)*）：\n\n![](2.jpg)\n \n> 交通：直飞航班，从上海到东京，当日清晨 05:30 分抵达机场；\n\n2. **皇居**（*[位置](https://goo.gl/maps/9vcodQirdVP2) / [百科](https://zh.wikipedia.org/zh-cn/%E7%9A%87%E5%B1%85)*）：\n\n![](3.jpg)\n\n> 交通：[东京单轨电车 - 京滨东北线 - 有乐町线 / 63min](https://goo.gl/maps/3QUTgYN2gz92)\n\n\n\n传统上，日本没有定都的概念，习惯以在位天皇（大王）的所在地为国都（古代称为“京”），并以在位天皇居住之宫殿为皇居（古代称为“宫”）。现在的皇居位于东京都千代田区，即原江户幕府历代将军所居住的江户城，但范围较原始的江户城为小。\n\n皇居除皇室起居部分不对公众开放外，其他部分可经由宫内厅进行预约参观，东面的皇居东御苑（原江户城本丸所在地）则在固定时间开放自由参观。皇居内部每年开放两次，分别在天皇诞生日及新年的次日（1月2日）。皇居的土地为国有财产，皇居的管理则连同皇室的事务由宫内厅全权负责。虽然皇居的位置邻近东京交通枢纽之一的东京站，而东京又有极为绵密的地下铁路网和高速公路系统，但并没有任何一条铁道或公路穿过皇居的地底下，全由周边绕开。\n\n\n3. **千鸟渊**（*[位置](https://goo.gl/maps/CZ1PYFBpXmk) / [百科](https://zh.wikipedia.org/zh-cn/%E5%8D%83%E9%B3%A5%E6%B7%B5)*）：\n\n![](4.jpg)\n\n> 交通：[步行 / 1.5KM / 18min](https://goo.gl/maps/3XpDobWx71R2)\n\n千鸟渊是江户开府后江户城扩张之际，在局泽川筑上两座土桥半藏门与田安门而形成的护城河。以代官町通相隔的半藏濠在过去与千鸟渊相通，但1900年（明治33年）因道路建设进行填地后成为独立的两条护城河。\n\n千鸟渊附近以赏樱名所而知名，吸引大批名众来此赏樱。开花期间中、千鸟渊沿旁的千鸟渊绿道在花期夜晚会点灯照明。此外，千鸟渊绿道设有搭船处，可在千鸟渊内划船。\n\n千鸟渊绿道旁有日本政府设置的千鸟渊战殁者墓苑，安置第二次世界大战中在海外丧生的身份不明日本人遗骨。\n\n\n4. **银座**（*[位置](https://goo.gl/maps/Gqyycidp84P2) / [百科](https://zh.wikipedia.org/zh-cn/%E9%8A%80%E5%BA%A7)*）：\n\n![](5.jpg)\n\n> 交通：[步行 / 3.5KM / 42min](https://goo.gl/maps/KAGP9wQDMgH2)\n\n是日本东京中央区的一个主要商业区，以高级购物商店闻名，是东京其中一个代表性地区。\n\n银座位于日本中央区西部，分为银座一丁目至银座八丁目。银座四丁目与银座五丁目之间被晴海通所分隔，全部8个丁目由中央通贯通。银座是高级商店街的象征，因此日本各地商店街常可见冠以银座之名的“某某银座”。\n\n\n5. **东京塔**（*[位置](https://goo.gl/maps/EqMAqDuUKz82) / [百科](https://zh.wikipedia.org/zh-cn/%E4%B8%9C%E4%BA%AC%E9%93%81%E5%A1%94)*）：\n\n![](6.jpg)\n\n> 交通：[浅草线 / 23min](https://goo.gl/maps/XyyRRfwi6kQ2)\n\n是位于日本东京都港区芝公园的电波塔。其以巴黎埃菲尔铁塔为范本而建造，高333米，比前者高13米，完工以来即成为东京著名地标与观光景点。正式名称为日本电波塔（日本電波塔／にっぽんでんぱとう），这同时也是其营运机构的名称。\n\n东京铁塔由建筑师内藤多仲与日建设计株式会社共同设计。高332.6米，较艾菲尔铁塔的324米高出8.6米，较东京天空树矮301.4米，比广州塔矮267.4米，是世界第三高的自立式铁塔，重4,000吨，与重7,300吨的埃菲尔铁塔相比重量大幅减轻，开工于1957年6月29日，1958年10月14日竣工，12月7日正式公开，12月23日举行竣工仪式，开始了正式营业。三分之一用于建塔的钢铁，来自韩战时美军的坦克废铁。\n\n\n6. **六本木**（*[位置](https://goo.gl/maps/Wz9dasFuacB2) / [百科](https://zh.wikipedia.org/zh-cn/%E5%85%AD%E6%9C%AC%E6%9C%A8)*）：\n\n![](7.jpg)\n\n> 交通：[大江户线 / 14min](https://goo.gl/maps/dUkXekDDjTP2)\n\n是位于日本东京都港区的街区，坐落于港区的北侧，北邻南青山，东接赤坂，东南临虎之门，南接麻布台、麻布永坂町、麻布十番，西南临元麻布，西接西麻布。现行行政地名为六本木一丁目至六本木七丁目。2013年7月1日的人口为11,929人。邮递区号106-0032。\n\n六本木是驻日大使馆的主要聚集地，以聚集外国人与夜生活而闻名。虽然有闹区的强烈印象，但是并没有百货公司设于此地。时至今日，商办设施、高级公寓，以及方舟之丘、泉花园大厦、六本木新城、东京中城等都市再开发计划，让六本木呈现多样的面貌。\n\n\n#### - 美食：\n\n拉面、天妇罗、牛丼、大仮烧、和牛；\n\n#### - 住宿：\n\n> 交通：[大江户线 / 24min](https://goo.gl/maps/TZRW1CfYdTm)\n\n新宿区：E Hotel Higashi Shinjuku （东新宿E酒店）双人间 / ￥1001\n\n### <a name=\"2\">行程 Day2 (3/24)</a>\n\n#### - 路线： \n\n\n1. **新宿御苑**（*[位置](https://goo.gl/maps/ogBrfC2pYhp) / [百科](https://zh.wikipedia.org/zh-cn/%E6%96%B0%E5%AE%BF%E5%BE%A1%E8%8B%91)*）：\n\n![](13.jpg)\n\n> 交通：[副都心线 / 13min](https://goo.gl/maps/hJPcr2YhjfJ2)\n\n新宿御苑是日本东京都横跨新宿区与涩谷区的庭园，面积58.3公顷。该处在江户时代为内藤家的宅地；其后成为宫内厅管理的庭园，现在则属环境省管辖的国民公园。\n\n\n2. **明治神宫**（*[位置](https://goo.gl/maps/4jkzF2FMpct) / [百科](https://zh.wikipedia.org/zh-cn/%E6%98%8E%E6%B2%BB%E7%A5%9E%E5%AE%AB)*）：\n\n![](10.jpg)\n\n\n> 交通：[步行 / 2KM / 24min](https://goo.gl/maps/j5ZyYnAQGsn)\n\n是位于日本东京都涩谷区的神社，供奉明治天皇，昭宪皇太后的灵位。1920年启用，占地70公顷，紧挨着原宿、新宿等东京两大商圈，占据了从代代木到原宿站之间的整片地带，与相邻的代代木公园构成东京市中心除了皇居之外最大的一块绿地。正式书记中，“宫”的写法采取日本古代常见写法，下方“吕”中间没有一撇“ノ”，为“明治神宫”。\n\n3. **原宿**（*[位置](https://goo.gl/maps/URr6YNikPuz) / [百科](https://zh.wikipedia.org/zh-cn/%E5%8E%9F%E5%AE%BF)*）：\n\n![](11.jpg)\n\n\n> 交通：[步行 / 1KM / 11min](https://goo.gl/maps/D7i5pMeiDrr)\n\n原宿是东京都涩谷区的一个地区，范围约为明治神宫、代代木公园、竹下通、表参道、国立代代木竞技场一带，是日本著名的“年轻人之街”。\n\n4. **表参道**（*[位置](https://goo.gl/maps/qzUtiPbR7LT2) / [百科](https://zh.wikipedia.org/zh-cn/%E8%A1%A8%E5%8F%83%E9%81%93)*）：\n\n![](12.jpg)\n\n> 交通：[步行 / 1KM / 12min](https://goo.gl/maps/NR5xs4BLb7x)\n\n表参道是1920年明治神宫创建时，在正面侧的参道与兴建道路的通称。位于东京都涩谷区与港区，都道413号线，及原宿站前附近，至青山通交差的表参道交差点区域。但多数用以称呼东京地下铁表参道站附近，为明确区别，道路以表参道通称呼。\n\n表参道与明治通的交差点，即神宫前交差点以东，为日本著名外国品牌时装店林立之地。过去有1927年建设的同润会青山公寓，但因建筑变得古旧，在2003年被拆卸，原址在2006年2月建成表参道之丘，内设有一些有个性的店铺，附近则为潮流区域里原宿的入口。神宫前交差点以西有时装商场 Laforet 原宿，及不少饮食店与杂货店。\n\n在表参道交差点至根津美术馆方向，阔15米的道路通称为“从快通”。\n\n5. **涩谷**（*[位置](https://goo.gl/maps/ruGGgZ82b3C2) / [百科](https://zh.wikipedia.org/zh-cn/%E6%BE%80%E8%B0%B7)*）：\n\n![](9.gif)\n\n> 交通：[步行 / 0.8KM / 9min](https://goo.gl/maps/7a8Dvtp7QUB2)\n\n涩谷与新宿、池袋并列为东京三大副都心，是东京最具代表性的商圈之一，乃日本流行与时尚的重要发信地，又以“音乐之街”、“年轻人之街”著称；同时是东京通往首都圈东南郊区的重要转运点，拥有多家连锁百货公司及综合商场，为东急集团的大本营。涩谷站前的八公铜像是涩谷的地标；涩谷站前交叉口的行人保护时相，则是东京知名的城市地景之一。\n\n6. **目黑川**（*[位置](https://goo.gl/maps/5GVfiQSQYJP2) / [百科](https://zh.wikipedia.org/zh-cn/%E7%9B%AE%E9%BB%91%E5%B7%9D)*）：\n\n![](8.jpg)\n\n> 交通：[东急东横线 / 14min](https://goo.gl/maps/idRtv3YAWrq)\n\n是东京都流经世田谷区、目黑区与品川区，最后注入东京湾的河川。为二级水系的主流。\n\n河口附近自古以来称为“品川”（しながわ）。在湾岸开发以前，河口附近河道弯曲，流速合缓，因此成为港口，是物品来来往往的河川因而称为“品川”。\n\n另外，从江户时代的绘图，其上游下目黑附近称作“こりとり川”。“こりとり”意为“垢离取り”，源自于在此川洁净自身的目黑不动尊。\n\n#### - 美食：\n\n-\n\n#### - 住宿：\n\n> 交通：[东急东横线 / 18min](https://goo.gl/maps/mJvFS2wBdJy)\n\n新宿区：E Hotel Higashi Shinjuku （东新宿E酒店）双人间 / ￥1001\n\n\n### <a name=\"3\">行程 Day3 (3/25)</a>\n\n> 【酒店寄存行李】 交通：[大江戶線 / 23min](https://goo.gl/maps/wuCpP12dBUG2)\n\n#### - 路线： \n\n\n1. **池袋**（*[位置](https://goo.gl/maps/JKp7zsH8Zyn) / [百科](https://zh.wikipedia.org/zh-cn/%E6%B1%A0%E8%A2%8B)*）：\n\n![](15.jpg)\n\n> 交通：[大江户线 -> 丸之内线 / 25min](https://goo.gl/maps/NcNaYDa9ES62)\n\n是日本东京都丰岛区的一个区域，也是东京市区中一个主要的商业及娱乐地区。池袋有多家大型百货公司据点及东京主要车站之一的池袋站，亦是丰岛区役所（区政府）所在地。\n\n2. **上野公园**（*[位置](https://goo.gl/maps/NPhsms11D9A2) / [百科](https://zh.wikipedia.org/zh-cn/%E4%B8%8A%E9%87%8E%E5%85%AC%E5%9C%92)*）：\n\n![](16.jpg)\n\n> 交通：[山手线 / 35min](https://goo.gl/maps/uSE6TmaAaY22)\n\n全名上野恩赐公园，是日本东京都台东区上野的一座公园，也是日本第一座公园，占地约53万平方米。全园在1873年指定为公园、1876年正式开园。此地原属于日本皇室，至1924年始由大正天皇下赐与东京市管理，故名“恩赐”。\n\n上野公园是东京国立博物馆、国立西洋美术馆、国立科学博物馆、上野动物园的所在地。同时也有雕刻家高村光云所作的西乡隆盛铜像[1]，以及野口英世的铜像。\n\n称作忍冈的高地是近代的赏樱名所，入选为日本樱名所100选，吸引大量赏花游客前往。此外，忍冈南方的不忍池（しのばずのいけ），夏天池上大量桃色莲花盛开。冬季有鸭等多种水鸟飞至此地栖息。\n\n\n3. **浅草寺**（*[位置](https://goo.gl/maps/9oFcWmwrNcL2) / [百科](https://zh.wikipedia.org/zh-cn/%E6%B7%BA%E8%8D%89%E5%AF%BA)*）：\n\n![](17.jpg)\n\n> 交通：[步行 / 2.5KM / 30min](https://goo.gl/maps/sLP9Tkrhapz)\n\n又名金龙山浅草寺，位于日本东京都台东区浅草二丁目，是东京都内历史最悠久的寺院。山号为金龙山。供奉的本尊是圣观音。原属天台宗，于第二次世界大战后独立，成为圣观音宗的总本山。观音菩萨本尊通称为“浅草观音”。\n\n4. **隅田公园**（*[位置](https://goo.gl/maps/fM1zpAjgrPx) / [百科](https://zh.wikipedia.org/zh-cn/%E9%9A%85%E7%94%B0%E5%85%AC%E5%9C%92)*）：\n\n![](18.jpg)\n\n\n> 交通：[步行 / 1KM / 12min](https://goo.gl/maps/bpoLyJR2A8p)\n\n是东京都隅田川岸的公园，分为右岸的台东区浅草、花川户、今户（35°42′55″N 139°48′10.5″E）与左岸的墨田区向岛（35°42′45″N 139°48′15″E）两侧。春季以满开樱花闻名，夏季则是隅田川花火大会会场。\n\n每年举行樱花季的隅田公园内约有约700多棵樱花树，是日本樱名所100选之一。约1公里左右的隅田川两岸樱花木是在八代将军德川吉宗安排下所种植。江户时代起便是知名赏樱景点。\n\n5. **东京天空树**（*[位置](https://goo.gl/maps/g9785FpgnvT2) / [百科](https://zh.wikipedia.org/zh-cn/%E6%9D%B1%E4%BA%AC%E6%99%B4%E7%A9%BA%E5%A1%94)*）：\n\n![](19.jpg)\n\n\n> 交通：[步行 / 0.8KM / 10min](https://goo.gl/maps/taDVPzjQsB22)\n\n是位于日本东京都墨田区的电波塔，由东武铁道及其子公司东武塔晴空塔共同筹建，于2008年7月14日动工，2012年2月29日完工、同年5月22日正式启用。其高度为634米，于2011年11月17日获得吉尼斯世界纪录认证为“世界第一高塔”，成为全世界最高的自立式塔形建筑；目前亦为世界第二高的人工构造物，仅次于哈里发塔。\n\n#### - 美食：\n\n-\n\n#### - 住宿：\n\n> 交通：[浅草线 / 11min](https://goo.gl/maps/XQ6HHAzqpNx)\n\n台东区：Asakusa Kuramae Hotel Yume Iroha （浅草藏前梦伊吕波经济型酒店）双人间 / ￥616.5\n\n\n\n\n### <a name=\"4\">行程 Day4 (3/26)</a>\n\n> 【酒店寄存行李】 交通：[大江户线 / 29min](https://goo.gl/maps/HcA7s5Rp1RF2)\n\n> [交通指南](https://www.odakyu.jp/sc/getting-around/enoshima_kamakura/)；[箱根镰仓周游券（3天）](https://www.odakyu.jp/sc/passes/hakone_kamakura/)；\n\n当天早起先去新宿的新酒店寄存行李，然后直接前往镰仓。晚上返程住新宿。\n\n#### - 路线：\n\n1. **江之岛**（*[位置](https://goo.gl/maps/KqvLRhN4WU62) / [百科](https://zh.wikipedia.org/zh-cn/%E6%B1%9F%E4%B9%8B%E5%B3%B6)*）：\n\n![](25.jpg)\n\n> 交通：[小田急线 - 小田急江之岛线 / 98min](https://goo.gl/maps/NjFkgFwMGAu)\n\n\n江之岛是湘南的代表景点，也是神奈川县指定史迹名胜（1960年开始）及日本百景（1927年）之一。交通机关的站名等多记为江ノ島，住居表示、公文等多使用“江の島”。有时也以古老的江岛神社（日本三大辩天之一）的“江岛”代表。本条目叙述的是陆连岛与地名的江之岛，但一般认知的观光地还包含对岸的片濑、鹄沼地区南部一带。\n\n\n2. **湘南海岸**（*[位置](https://goo.gl/maps/i7T8oXJgM212)*）：\n\n![](26.jpg)\n\n> 交通：[步行 / 1.5KM / 19min](https://goo.gl/maps/NjFkgFwMGAu)\n\n湘南海岸（湘南海岸）是，神奈川县的湘南出区域，该区域被称为的茅崎从镰仓沿海地区和在沿海区域。\n\n长期开设日本海滩代表，是全国着名的冲浪点。它还显示在四季中熙熙攘攘的日期点。顺便说一句，134号公路沿着湘南海岸。\n\n\n3. **镰仓高校前站**（*[位置](https://goo.gl/maps/iJfoHGhSAGk) / [百科](https://zh.wikipedia.org/zh-cn/%E9%8E%8C%E5%80%89%E9%AB%98%E6%A0%A1%E5%89%8D%E8%BB%8A%E7%AB%99)*）：\n\n![](20.jpg)\n\n> 交通：[步行 / 2.7KM / 34min](https://goo.gl/maps/NjFkgFwMGAu)\n\n是一由江之岛电铁（江之电）所经营的铁路车站，位于日本神奈川县镰仓市境内，是江之岛电铁线沿线的一个无人车站。由于车站仅与七里滨（七里ヶ浜）的海岸线隔着国道134号相望，因此站在月台上即能眺望海边的风光。\n\n本站在1903年初设站时，原名日坂，并在1953年时根据紧邻的神奈川县立镰仓高等学校，改名为镰仓高校前。1997年时，因为车站所在地可以见到海景的优美风情，而成为首批入选“关东车站百选”的其中一个车站。\n\n车站周边有多部动漫、电视剧及广告等作品取景，特别是东侧的一处平交道，因为是同名漫画改编的电视动画《灌篮高手》（スラムダンク）主题曲以及《Tari Tari》动画场景之一，吸引不少该作品的爱好者到此探访拍照[1]，但有部分人士擅自闯入未开放的镰仓高校校园内拍照游玩，造成该校的困扰。\n\n\n4. **高德院**（*[位置](https://goo.gl/maps/LHEo1G69rVw) / [百科](https://zh.wikipedia.org/zh-cn/%E9%AB%98%E5%BE%B7%E9%99%A2)*）：\n\n![](24.jpg)\n\n> 交通：[江之岛电铁线 / 23min](https://goo.gl/maps/UXGX7uBkDBJ2)\n\n高德院位于日本神奈川县镰仓市的长谷，是一间佛教净土宗的寺院。供奉的本尊阿弥陀佛一般人称为“镰仓大佛”，坐落于大异山。开基（创立者）与开山（初代住持）均不明。\n\n这座寺院拥有日本最著名的佛像之一—大佛—一座高达11.3米，重约121吨的露天阿弥陀佛青铜塑像，它的尺寸在全日本仅次于位于奈良市东大寺的另一尊佛像。\n\n根据寺院有关青铜像建造的相关记载，这座塑像的历史可以追溯到1252年的镰仓时代。然而，并不清楚寺院记录中那座当时正在建造的塑像是否就是今天这座大佛像。这座佛像曾经位于一座寺庙建筑中，而原本容纳大佛的木质寺庙建筑毁于15世纪末室町时代的一场海啸，但佛像却保留了下来。\n\n5. **长谷寺**（*[位置](https://goo.gl/maps/cnrhLHDu5h92)*）：\n\n![](23.jpg)\n\n> 交通：[步行 / 0.7KM / 9min](https://goo.gl/maps/VKDzUDtJTWo)\n\n是位在日本奈良县樱井市的寺院，真言宗丰山派总本山。山号“丰山”（ぶざん）。本尊十一面观音、开基（创立者）为道明。别称“花之御寺”。\n\n6. **鹤冈八幡宫**（*[位置](https://goo.gl/maps/trhdMFyGi562)*）：\n\n![](22.jpg)\n\n> 交通：[江之岛电铁线 / 26min](https://goo.gl/maps/VaYkVGmUsfK2)\n\n是位于日本神奈川县镰仓市的神社。旧社格为国币中社（现神社本厅的别表神社）。武家源氏、镰仓武士之守护神。也称作镰仓八幡宫。公元1063年由源赖义由京都的石清水八幡宫劝请至由比之滨。此后，于公元1180年进入镰仓的幕府将军源赖朝将其移请至现址，并加以扩建，才成为日后镰仓幕府时期中心。\n\n#### - 美食：\n\n-\n\n#### - 住宿：\n\n> 交通：[镰仓站 - 藤泽站 / 江之岛电铁线 / 36min](https://goo.gl/maps/cNgfndNJhzA2) -> [藤泽站 - 新宿 / 小田急线 / 70min](https://goo.gl/maps/H7ZosDWmSg22)\n\n新宿区：Citadines Central Shinjuku Tokyo（馨乐庭中央东京新宿区酒店）双人间 / ￥1052\n\n\n\n\n\n### <a name=\"5\">行程 Day5 (3/27)</a>\n\n![](27.png)\n\n> [交通指南](https://www.odakyu.jp/sc/getting-around/hakone/)；[箱根镰仓周游券（3天）](https://www.odakyu.jp/sc/passes/hakone_kamakura/)；\n\n#### - 路线：\n\n1. **箱根汤本站**（*[位置](https://goo.gl/maps/g4L4YaPX7yj)*）：\n\n![](21.jpg)\n\n> 交通：[小田急浪漫特快 / 95min](https://goo.gl/maps/SAZfg2J1fd82)\n\n自古已是温泉町，在江户时代设置箱根关。近代由于西武铁道集团与小田急电铁致力于观光开发而得到急速发展。箱根温泉是汤本、塔之泽、大平台、宫之下、小涌谷等地温泉的总称。\n\n\n2. **Emblem Flow Hakone 酒店寄存**（*[位置](https://goo.gl/maps/wAWgwPSWAF92)*）：\n\n> 交通：[箱根登山线 / 37min](https://goo.gl/maps/axQ5wKEUgFk)\n\n\n3. **早云山站**（*[位置](https://goo.gl/maps/s7tFrFPZzZC2)*）：\n\n> 交通：[箱根登山线 / 10min](https://goo.gl/maps/rGtpgcYC1xr)\n\n\n4. **大涌谷站**（*[位置](https://goo.gl/maps/A2vHp7KUkxL2)*）：\n\n> 交通：[箱根空中缆车 / 8min](https://goo.gl/maps/S3FEyt4Vxx52)\n\n5. **桃园台站**（*[位置](https://goo.gl/maps/CkyELagfu4R2)*）：\n\n> 交通：[箱根空中缆车 / 16min](https://goo.gl/maps/JZaM8QTy19u)\n\n\n6. **元箱根港**（*[位置](https://goo.gl/maps/ZnkiVduN4gu)*）：\n\n> 交通：箱根海盗船\n\n7. **箱根神社**（*[位置](https://goo.gl/maps/dHzUHdS1buF2)*）：\n\n![](28.jpg)\n\n> 交通：[步行 / 1KM / 14min](https://goo.gl/maps/3hcHkHfLmzP2)\n\n\n#### - 美食：\n\n-\n\n#### - 住宿：\n\n> 交通：[箱根町線：箱根口経由 -> 箱根登山線 / 42分钟](https://goo.gl/maps/bzH8jKf7jXT2)\n\n箱根：Emblem Flow Hakone / 双人间￥1092\n\n\n\n### <a name=\"6\">行程 Day6 (3/28)</a>\n\n\n1. **箱根美术馆**（*[位置](https://goo.gl/maps/3Z4FjVQGBKD2)*）：\n\n\n> 交通：[步行 / 0.65KM / 13min](https://goo.gl/maps/AVEvzajWhBm)\n\n箱根美术馆是箱根地区最早建立的美术馆。昭和27年6月，由创始人岡田茂吉先生建立。主要展品为岡田茂吉先生收藏的中日古代陶瓷器。其中最古老的藏品历史可追溯到古坟时代。\n\n箱根美术馆的苔藓庭院是一绝，茶室楼阁山石花草，看似无心布置，却处处透露着日式的禅意。秋季枫叶变红，与绿苔形成鲜明的对比，能吸引大批游客。\n\n2. **POLA 美术馆**（*[位置](https://goo.gl/maps/SVsUGKz8jEx)*）：\n\n\n> 交通：[天悠～強羅小塚～湿生花園前 / 12min](https://goo.gl/maps/qJX5qB2vZkM2)\n\nPola Museum of Art 位于日本神奈川县箱根。它于2002年9月在富士箱根伊豆国立公园内开放。它收藏了 Pola 化妆品集团前负责人收购的超过9,500件作品，其中包括法国印象派和巴黎 École 的许多作品。引人注目的建筑是 Nikken Sekkei。\n\n\n3. **箱根小王子博物馆**（*[位置](https://goo.gl/maps/zxSsZ8e9bcy)*）：\n\n\n> 交通：[天悠～強羅小塚～湿生花園前 / 4min](https://goo.gl/maps/yD9PWYThE1L2)\n\n箱根小王子博物馆（日语：箱根★サン＝テグジュペリ 星の王子さまミュージアム）是位于日本神奈川县箱根町仙石原的博物馆[1]，专门展出与《小王子》及其作者安东尼·迪·圣-修伯里有关的展品。该馆开幕于1999年6月29日，即圣修伯里诞生100周年之际。\n\n博物馆呈现了《小王子》书中的情节与人物，其中设有小王子及其B612星球的雕塑、“小王子庭院”、模仿1930年代时期的咖啡馆、模仿圣修伯里童年时期的教会、圣修伯里生平展示空间等等。馆内的礼品店出售《小王子》的相关商品。\n\n4. **箱根玻璃之森美术馆**（*[位置](https://goo.gl/maps/YNPhEHvaoZJ2)*）：\n\n\n> 交通：[步行 / 0.85KM / 11min](https://goo.gl/maps/EWZZELi6TCR2)\n\n神奈川县的玻璃之森美术馆，坐落在箱根绵延的群山之中，主体建筑酷似欧洲中世纪贵族别墅，仿若童话世界。在这广阔的庭园里分布着美术馆、商店和咖啡厅。 美术馆里陈列着15世纪至19世纪期间威尼斯和现代威尼斯的作品约100件，它们是曾经让欧洲贵族为之疯狂的威尼斯玻璃艺术。此外，还公开展示了很多罗斯柴尔德家族传承下来的钴蓝高脚杯等贵重作品。最令人惊叹的是礼花树 Fontana 喷泉，阳光下熠熠生辉的礼花树，亮晶晶的树木、泉水、瀑布都是一粒一粒的玻璃球制成，整个美术馆都显得十分精致美好。 露天咖啡厅可观赏以中世纪威尼斯为形象的庭院，那里有正宗的坎佐纳器乐作品实况演奏。另外还有能体验玻璃工艺制作的体验工房。\n\n\n5. **Emblem Flow Hakone 酒店取行李**：\n\n> 交通：[アウトレット～宮城野～天悠 / 13min](https://goo.gl/maps/Sf1ptiTDHLw)\n\n\n6. **箱根汤本站**：\n\n当日 15:30 前必须上车。\n\n> 交通：[箱根登山线 / 45min](https://goo.gl/maps/oz9sP91Y4CU2)\n\n7. **新宿站**：\n\n> 交通：[小田急浪漫特快 / 99min](https://goo.gl/maps/9Pp7BVaNvFM2)\n\n\n8. **羽田国际机场**（*[位置](https://goo.gl/maps/E8rL54MhkUs)*）：\n\n> 交通：[大江戶線 -> 東京單軌電車 / 55min](https://goo.gl/maps/Rq6qk8dDPKm)\n\n\n### 附录资料\n\n#### <a name=\"7\">箱根地图：</a>\n\n![](29.png)\n\n#### <a name=\"8\">江之岛/镰仓地图：</a>\n\n![](31.png)\n\n#### <a name=\"9\">小田急线路线图：</a>\n\n![](30.png)","slug":"日本樱花季游攻略","published":1,"updated":"2019-02-26T08:23:21.310Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtbb007aknp24xkhpxkv","content":"<p>计划今年3月下旬待天气稍微转暖，把18年剩余的几天年假用掉，碰巧此时也正好赶上了日本3-5月份的“樱花季”，遂决定去趟日本🇯🇵。按照往年的规律，东京的樱花期是从每年的3月22日开始，持续连续一周左右时间，而我们的出行航班正好是于花季的第二天到达东京，没准能够感上“最新鲜”的樱花视觉盛宴。整个旅程计划6天5晚，大致路线为：<strong>东京-镰仓-箱根</strong>。</p>\n<p><img src=\"1.jpg\" alt></p>\n<h3 id=\"快速导航：\"><a href=\"#快速导航：\" class=\"headerlink\" title=\"快速导航：\"></a>快速导航：</h3><ul>\n<li><a href=\"#1\">3/23 第一天（羽田机场、皇居、千鸟湖、银座、东京塔、六本木）；</a></li>\n<li><a href=\"#2\">3/24 第二天（新宿御苑、目黑川、涩谷、明治神宫、原宿、表参道）；</a></li>\n<li><a href=\"#3\">3/25 第三天（池袋、上野公园、浅草寺、隅田公园、东京天空树）；</a></li>\n<li><a href=\"#4\">3/26 第四天（江之岛、湘南海岸、镰仓高校前站、高德院、长谷寺、鹤冈八幡宫）；</a></li>\n<li><a href=\"#5\">3/27 第五天（箱根汤本站、早云山站、大涌谷站、桃园台站、元箱根港、箱根神社）；</a></li>\n<li><a href=\"#6\">3/28 第六天（箱根美术馆、POLA 美术馆、箱根小王子博物馆、箱根玻璃之森美术馆）；</a></li>\n</ul>\n<h3 id=\"附录资料：\"><a href=\"#附录资料：\" class=\"headerlink\" title=\"附录资料：\"></a>附录资料：</h3><ul>\n<li>周游券/车票购买地点：<a href=\"https://www.odakyu.jp/sc/transport/riding/howto/#purchase\" target=\"_blank\" rel=\"noopener\">小田急旅游服务中心、自动售票机</a>；</li>\n<li><a href=\"https://www.web-odakyu.com/e-romancecar/vacantSeatInquiry/input?STICKY=11074\" target=\"_blank\" rel=\"noopener\">小田急“浪漫”特快预约购票（提前一月预订、建议选择 70000 GSE/50000 VSE 车型眺望席）</a>；</li>\n<li><a href=\"#7\">箱根地图；</a></li>\n<li><a href=\"#8\">江之岛/镰仓地图；</a></li>\n<li><a href=\"#9\">小田急线路线图；</a></li>\n</ul>\n<h3 id=\"日本签证材料参考：\"><a href=\"#日本签证材料参考：\" class=\"headerlink\" title=\"日本签证材料参考：\"></a>日本签证材料参考：</h3><ol>\n<li>护照（至少剩余6月有效期）；</li>\n<li>2张2寸白底彩照（一张贴在申请表上，一张写上名字，3个月内拍摄）；</li>\n<li>身份证（正反清晰复印件）；</li>\n<li>户口本（户主页和本人首页复印件）；</li>\n<li>日本签证申请表；</li>\n<li>个人信息处理同意书；</li>\n<li>旅签材料受理表；</li>\n<li>在职证明原件（本人带公章，带有薪资字样，年收入10万以上）；</li>\n<li>电子税单（近一年缴税金额须每月达到230元以上，同一公司缴纳）；</li>\n<li>全程的机酒预订单（带有出入境日期、第一晚入住城市、及全程入住的酒店和机票）；</li>\n<li>居住证（外地户籍，需符合上海领区的地区要求）；</li>\n</ol>\n<h3 id=\"行程-Day1-3-23\"><a href=\"#行程-Day1-3-23\" class=\"headerlink\" title=\"行程 Day1 (3/23)\"></a><a name=\"1\">行程 Day1 (3/23)</a></h3><h4 id=\"路线：\"><a href=\"#路线：\" class=\"headerlink\" title=\"- 路线：\"></a>- 路线：</h4><ol>\n<li><strong>羽田国际机场</strong>（<em><a href=\"https://goo.gl/maps/E8rL54MhkUs\" target=\"_blank\" rel=\"noopener\">位置</a></em>）：</li>\n</ol>\n<p><img src=\"2.jpg\" alt></p>\n<blockquote>\n<p>交通：直飞航班，从上海到东京，当日清晨 05:30 分抵达机场；</p>\n</blockquote>\n<ol start=\"2\">\n<li><strong>皇居</strong>（<em><a href=\"https://goo.gl/maps/9vcodQirdVP2\" target=\"_blank\" rel=\"noopener\">位置</a> / <a href=\"https://zh.wikipedia.org/zh-cn/%E7%9A%87%E5%B1%85\" target=\"_blank\" rel=\"noopener\">百科</a></em>）：</li>\n</ol>\n<p><img src=\"3.jpg\" alt></p>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/3QUTgYN2gz92\" target=\"_blank\" rel=\"noopener\">东京单轨电车 - 京滨东北线 - 有乐町线 / 63min</a></p>\n</blockquote>\n<p>传统上，日本没有定都的概念，习惯以在位天皇（大王）的所在地为国都（古代称为“京”），并以在位天皇居住之宫殿为皇居（古代称为“宫”）。现在的皇居位于东京都千代田区，即原江户幕府历代将军所居住的江户城，但范围较原始的江户城为小。</p>\n<p>皇居除皇室起居部分不对公众开放外，其他部分可经由宫内厅进行预约参观，东面的皇居东御苑（原江户城本丸所在地）则在固定时间开放自由参观。皇居内部每年开放两次，分别在天皇诞生日及新年的次日（1月2日）。皇居的土地为国有财产，皇居的管理则连同皇室的事务由宫内厅全权负责。虽然皇居的位置邻近东京交通枢纽之一的东京站，而东京又有极为绵密的地下铁路网和高速公路系统，但并没有任何一条铁道或公路穿过皇居的地底下，全由周边绕开。</p>\n<ol start=\"3\">\n<li><strong>千鸟渊</strong>（<em><a href=\"https://goo.gl/maps/CZ1PYFBpXmk\" target=\"_blank\" rel=\"noopener\">位置</a> / <a href=\"https://zh.wikipedia.org/zh-cn/%E5%8D%83%E9%B3%A5%E6%B7%B5\" target=\"_blank\" rel=\"noopener\">百科</a></em>）：</li>\n</ol>\n<p><img src=\"4.jpg\" alt></p>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/3XpDobWx71R2\" target=\"_blank\" rel=\"noopener\">步行 / 1.5KM / 18min</a></p>\n</blockquote>\n<p>千鸟渊是江户开府后江户城扩张之际，在局泽川筑上两座土桥半藏门与田安门而形成的护城河。以代官町通相隔的半藏濠在过去与千鸟渊相通，但1900年（明治33年）因道路建设进行填地后成为独立的两条护城河。</p>\n<p>千鸟渊附近以赏樱名所而知名，吸引大批名众来此赏樱。开花期间中、千鸟渊沿旁的千鸟渊绿道在花期夜晚会点灯照明。此外，千鸟渊绿道设有搭船处，可在千鸟渊内划船。</p>\n<p>千鸟渊绿道旁有日本政府设置的千鸟渊战殁者墓苑，安置第二次世界大战中在海外丧生的身份不明日本人遗骨。</p>\n<ol start=\"4\">\n<li><strong>银座</strong>（<em><a href=\"https://goo.gl/maps/Gqyycidp84P2\" target=\"_blank\" rel=\"noopener\">位置</a> / <a href=\"https://zh.wikipedia.org/zh-cn/%E9%8A%80%E5%BA%A7\" target=\"_blank\" rel=\"noopener\">百科</a></em>）：</li>\n</ol>\n<p><img src=\"5.jpg\" alt></p>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/KAGP9wQDMgH2\" target=\"_blank\" rel=\"noopener\">步行 / 3.5KM / 42min</a></p>\n</blockquote>\n<p>是日本东京中央区的一个主要商业区，以高级购物商店闻名，是东京其中一个代表性地区。</p>\n<p>银座位于日本中央区西部，分为银座一丁目至银座八丁目。银座四丁目与银座五丁目之间被晴海通所分隔，全部8个丁目由中央通贯通。银座是高级商店街的象征，因此日本各地商店街常可见冠以银座之名的“某某银座”。</p>\n<ol start=\"5\">\n<li><strong>东京塔</strong>（<em><a href=\"https://goo.gl/maps/EqMAqDuUKz82\" target=\"_blank\" rel=\"noopener\">位置</a> / <a href=\"https://zh.wikipedia.org/zh-cn/%E4%B8%9C%E4%BA%AC%E9%93%81%E5%A1%94\" target=\"_blank\" rel=\"noopener\">百科</a></em>）：</li>\n</ol>\n<p><img src=\"6.jpg\" alt></p>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/XyyRRfwi6kQ2\" target=\"_blank\" rel=\"noopener\">浅草线 / 23min</a></p>\n</blockquote>\n<p>是位于日本东京都港区芝公园的电波塔。其以巴黎埃菲尔铁塔为范本而建造，高333米，比前者高13米，完工以来即成为东京著名地标与观光景点。正式名称为日本电波塔（日本電波塔／にっぽんでんぱとう），这同时也是其营运机构的名称。</p>\n<p>东京铁塔由建筑师内藤多仲与日建设计株式会社共同设计。高332.6米，较艾菲尔铁塔的324米高出8.6米，较东京天空树矮301.4米，比广州塔矮267.4米，是世界第三高的自立式铁塔，重4,000吨，与重7,300吨的埃菲尔铁塔相比重量大幅减轻，开工于1957年6月29日，1958年10月14日竣工，12月7日正式公开，12月23日举行竣工仪式，开始了正式营业。三分之一用于建塔的钢铁，来自韩战时美军的坦克废铁。</p>\n<ol start=\"6\">\n<li><strong>六本木</strong>（<em><a href=\"https://goo.gl/maps/Wz9dasFuacB2\" target=\"_blank\" rel=\"noopener\">位置</a> / <a href=\"https://zh.wikipedia.org/zh-cn/%E5%85%AD%E6%9C%AC%E6%9C%A8\" target=\"_blank\" rel=\"noopener\">百科</a></em>）：</li>\n</ol>\n<p><img src=\"7.jpg\" alt></p>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/dUkXekDDjTP2\" target=\"_blank\" rel=\"noopener\">大江户线 / 14min</a></p>\n</blockquote>\n<p>是位于日本东京都港区的街区，坐落于港区的北侧，北邻南青山，东接赤坂，东南临虎之门，南接麻布台、麻布永坂町、麻布十番，西南临元麻布，西接西麻布。现行行政地名为六本木一丁目至六本木七丁目。2013年7月1日的人口为11,929人。邮递区号106-0032。</p>\n<p>六本木是驻日大使馆的主要聚集地，以聚集外国人与夜生活而闻名。虽然有闹区的强烈印象，但是并没有百货公司设于此地。时至今日，商办设施、高级公寓，以及方舟之丘、泉花园大厦、六本木新城、东京中城等都市再开发计划，让六本木呈现多样的面貌。</p>\n<h4 id=\"美食：\"><a href=\"#美食：\" class=\"headerlink\" title=\"- 美食：\"></a>- 美食：</h4><p>拉面、天妇罗、牛丼、大仮烧、和牛；</p>\n<h4 id=\"住宿：\"><a href=\"#住宿：\" class=\"headerlink\" title=\"- 住宿：\"></a>- 住宿：</h4><blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/TZRW1CfYdTm\" target=\"_blank\" rel=\"noopener\">大江户线 / 24min</a></p>\n</blockquote>\n<p>新宿区：E Hotel Higashi Shinjuku （东新宿E酒店）双人间 / ￥1001</p>\n<h3 id=\"行程-Day2-3-24\"><a href=\"#行程-Day2-3-24\" class=\"headerlink\" title=\"行程 Day2 (3/24)\"></a><a name=\"2\">行程 Day2 (3/24)</a></h3><h4 id=\"路线：-1\"><a href=\"#路线：-1\" class=\"headerlink\" title=\"- 路线：\"></a>- 路线：</h4><ol>\n<li><strong>新宿御苑</strong>（<em><a href=\"https://goo.gl/maps/ogBrfC2pYhp\" target=\"_blank\" rel=\"noopener\">位置</a> / <a href=\"https://zh.wikipedia.org/zh-cn/%E6%96%B0%E5%AE%BF%E5%BE%A1%E8%8B%91\" target=\"_blank\" rel=\"noopener\">百科</a></em>）：</li>\n</ol>\n<p><img src=\"13.jpg\" alt></p>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/hJPcr2YhjfJ2\" target=\"_blank\" rel=\"noopener\">副都心线 / 13min</a></p>\n</blockquote>\n<p>新宿御苑是日本东京都横跨新宿区与涩谷区的庭园，面积58.3公顷。该处在江户时代为内藤家的宅地；其后成为宫内厅管理的庭园，现在则属环境省管辖的国民公园。</p>\n<ol start=\"2\">\n<li><strong>明治神宫</strong>（<em><a href=\"https://goo.gl/maps/4jkzF2FMpct\" target=\"_blank\" rel=\"noopener\">位置</a> / <a href=\"https://zh.wikipedia.org/zh-cn/%E6%98%8E%E6%B2%BB%E7%A5%9E%E5%AE%AB\" target=\"_blank\" rel=\"noopener\">百科</a></em>）：</li>\n</ol>\n<p><img src=\"10.jpg\" alt></p>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/j5ZyYnAQGsn\" target=\"_blank\" rel=\"noopener\">步行 / 2KM / 24min</a></p>\n</blockquote>\n<p>是位于日本东京都涩谷区的神社，供奉明治天皇，昭宪皇太后的灵位。1920年启用，占地70公顷，紧挨着原宿、新宿等东京两大商圈，占据了从代代木到原宿站之间的整片地带，与相邻的代代木公园构成东京市中心除了皇居之外最大的一块绿地。正式书记中，“宫”的写法采取日本古代常见写法，下方“吕”中间没有一撇“ノ”，为“明治神宫”。</p>\n<ol start=\"3\">\n<li><strong>原宿</strong>（<em><a href=\"https://goo.gl/maps/URr6YNikPuz\" target=\"_blank\" rel=\"noopener\">位置</a> / <a href=\"https://zh.wikipedia.org/zh-cn/%E5%8E%9F%E5%AE%BF\" target=\"_blank\" rel=\"noopener\">百科</a></em>）：</li>\n</ol>\n<p><img src=\"11.jpg\" alt></p>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/D7i5pMeiDrr\" target=\"_blank\" rel=\"noopener\">步行 / 1KM / 11min</a></p>\n</blockquote>\n<p>原宿是东京都涩谷区的一个地区，范围约为明治神宫、代代木公园、竹下通、表参道、国立代代木竞技场一带，是日本著名的“年轻人之街”。</p>\n<ol start=\"4\">\n<li><strong>表参道</strong>（<em><a href=\"https://goo.gl/maps/qzUtiPbR7LT2\" target=\"_blank\" rel=\"noopener\">位置</a> / <a href=\"https://zh.wikipedia.org/zh-cn/%E8%A1%A8%E5%8F%83%E9%81%93\" target=\"_blank\" rel=\"noopener\">百科</a></em>）：</li>\n</ol>\n<p><img src=\"12.jpg\" alt></p>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/NR5xs4BLb7x\" target=\"_blank\" rel=\"noopener\">步行 / 1KM / 12min</a></p>\n</blockquote>\n<p>表参道是1920年明治神宫创建时，在正面侧的参道与兴建道路的通称。位于东京都涩谷区与港区，都道413号线，及原宿站前附近，至青山通交差的表参道交差点区域。但多数用以称呼东京地下铁表参道站附近，为明确区别，道路以表参道通称呼。</p>\n<p>表参道与明治通的交差点，即神宫前交差点以东，为日本著名外国品牌时装店林立之地。过去有1927年建设的同润会青山公寓，但因建筑变得古旧，在2003年被拆卸，原址在2006年2月建成表参道之丘，内设有一些有个性的店铺，附近则为潮流区域里原宿的入口。神宫前交差点以西有时装商场 Laforet 原宿，及不少饮食店与杂货店。</p>\n<p>在表参道交差点至根津美术馆方向，阔15米的道路通称为“从快通”。</p>\n<ol start=\"5\">\n<li><strong>涩谷</strong>（<em><a href=\"https://goo.gl/maps/ruGGgZ82b3C2\" target=\"_blank\" rel=\"noopener\">位置</a> / <a href=\"https://zh.wikipedia.org/zh-cn/%E6%BE%80%E8%B0%B7\" target=\"_blank\" rel=\"noopener\">百科</a></em>）：</li>\n</ol>\n<p><img src=\"9.gif\" alt></p>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/7a8Dvtp7QUB2\" target=\"_blank\" rel=\"noopener\">步行 / 0.8KM / 9min</a></p>\n</blockquote>\n<p>涩谷与新宿、池袋并列为东京三大副都心，是东京最具代表性的商圈之一，乃日本流行与时尚的重要发信地，又以“音乐之街”、“年轻人之街”著称；同时是东京通往首都圈东南郊区的重要转运点，拥有多家连锁百货公司及综合商场，为东急集团的大本营。涩谷站前的八公铜像是涩谷的地标；涩谷站前交叉口的行人保护时相，则是东京知名的城市地景之一。</p>\n<ol start=\"6\">\n<li><strong>目黑川</strong>（<em><a href=\"https://goo.gl/maps/5GVfiQSQYJP2\" target=\"_blank\" rel=\"noopener\">位置</a> / <a href=\"https://zh.wikipedia.org/zh-cn/%E7%9B%AE%E9%BB%91%E5%B7%9D\" target=\"_blank\" rel=\"noopener\">百科</a></em>）：</li>\n</ol>\n<p><img src=\"8.jpg\" alt></p>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/idRtv3YAWrq\" target=\"_blank\" rel=\"noopener\">东急东横线 / 14min</a></p>\n</blockquote>\n<p>是东京都流经世田谷区、目黑区与品川区，最后注入东京湾的河川。为二级水系的主流。</p>\n<p>河口附近自古以来称为“品川”（しながわ）。在湾岸开发以前，河口附近河道弯曲，流速合缓，因此成为港口，是物品来来往往的河川因而称为“品川”。</p>\n<p>另外，从江户时代的绘图，其上游下目黑附近称作“こりとり川”。“こりとり”意为“垢离取り”，源自于在此川洁净自身的目黑不动尊。</p>\n<h4 id=\"美食：-1\"><a href=\"#美食：-1\" class=\"headerlink\" title=\"- 美食：\"></a>- 美食：</h4><p>-</p>\n<h4 id=\"住宿：-1\"><a href=\"#住宿：-1\" class=\"headerlink\" title=\"- 住宿：\"></a>- 住宿：</h4><blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/mJvFS2wBdJy\" target=\"_blank\" rel=\"noopener\">东急东横线 / 18min</a></p>\n</blockquote>\n<p>新宿区：E Hotel Higashi Shinjuku （东新宿E酒店）双人间 / ￥1001</p>\n<h3 id=\"行程-Day3-3-25\"><a href=\"#行程-Day3-3-25\" class=\"headerlink\" title=\"行程 Day3 (3/25)\"></a><a name=\"3\">行程 Day3 (3/25)</a></h3><blockquote>\n<p>【酒店寄存行李】 交通：<a href=\"https://goo.gl/maps/wuCpP12dBUG2\" target=\"_blank\" rel=\"noopener\">大江戶線 / 23min</a></p>\n</blockquote>\n<h4 id=\"路线：-2\"><a href=\"#路线：-2\" class=\"headerlink\" title=\"- 路线：\"></a>- 路线：</h4><ol>\n<li><strong>池袋</strong>（<em><a href=\"https://goo.gl/maps/JKp7zsH8Zyn\" target=\"_blank\" rel=\"noopener\">位置</a> / <a href=\"https://zh.wikipedia.org/zh-cn/%E6%B1%A0%E8%A2%8B\" target=\"_blank\" rel=\"noopener\">百科</a></em>）：</li>\n</ol>\n<p><img src=\"15.jpg\" alt></p>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/NcNaYDa9ES62\" target=\"_blank\" rel=\"noopener\">大江户线 -&gt; 丸之内线 / 25min</a></p>\n</blockquote>\n<p>是日本东京都丰岛区的一个区域，也是东京市区中一个主要的商业及娱乐地区。池袋有多家大型百货公司据点及东京主要车站之一的池袋站，亦是丰岛区役所（区政府）所在地。</p>\n<ol start=\"2\">\n<li><strong>上野公园</strong>（<em><a href=\"https://goo.gl/maps/NPhsms11D9A2\" target=\"_blank\" rel=\"noopener\">位置</a> / <a href=\"https://zh.wikipedia.org/zh-cn/%E4%B8%8A%E9%87%8E%E5%85%AC%E5%9C%92\" target=\"_blank\" rel=\"noopener\">百科</a></em>）：</li>\n</ol>\n<p><img src=\"16.jpg\" alt></p>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/uSE6TmaAaY22\" target=\"_blank\" rel=\"noopener\">山手线 / 35min</a></p>\n</blockquote>\n<p>全名上野恩赐公园，是日本东京都台东区上野的一座公园，也是日本第一座公园，占地约53万平方米。全园在1873年指定为公园、1876年正式开园。此地原属于日本皇室，至1924年始由大正天皇下赐与东京市管理，故名“恩赐”。</p>\n<p>上野公园是东京国立博物馆、国立西洋美术馆、国立科学博物馆、上野动物园的所在地。同时也有雕刻家高村光云所作的西乡隆盛铜像[1]，以及野口英世的铜像。</p>\n<p>称作忍冈的高地是近代的赏樱名所，入选为日本樱名所100选，吸引大量赏花游客前往。此外，忍冈南方的不忍池（しのばずのいけ），夏天池上大量桃色莲花盛开。冬季有鸭等多种水鸟飞至此地栖息。</p>\n<ol start=\"3\">\n<li><strong>浅草寺</strong>（<em><a href=\"https://goo.gl/maps/9oFcWmwrNcL2\" target=\"_blank\" rel=\"noopener\">位置</a> / <a href=\"https://zh.wikipedia.org/zh-cn/%E6%B7%BA%E8%8D%89%E5%AF%BA\" target=\"_blank\" rel=\"noopener\">百科</a></em>）：</li>\n</ol>\n<p><img src=\"17.jpg\" alt></p>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/sLP9Tkrhapz\" target=\"_blank\" rel=\"noopener\">步行 / 2.5KM / 30min</a></p>\n</blockquote>\n<p>又名金龙山浅草寺，位于日本东京都台东区浅草二丁目，是东京都内历史最悠久的寺院。山号为金龙山。供奉的本尊是圣观音。原属天台宗，于第二次世界大战后独立，成为圣观音宗的总本山。观音菩萨本尊通称为“浅草观音”。</p>\n<ol start=\"4\">\n<li><strong>隅田公园</strong>（<em><a href=\"https://goo.gl/maps/fM1zpAjgrPx\" target=\"_blank\" rel=\"noopener\">位置</a> / <a href=\"https://zh.wikipedia.org/zh-cn/%E9%9A%85%E7%94%B0%E5%85%AC%E5%9C%92\" target=\"_blank\" rel=\"noopener\">百科</a></em>）：</li>\n</ol>\n<p><img src=\"18.jpg\" alt></p>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/bpoLyJR2A8p\" target=\"_blank\" rel=\"noopener\">步行 / 1KM / 12min</a></p>\n</blockquote>\n<p>是东京都隅田川岸的公园，分为右岸的台东区浅草、花川户、今户（35°42′55″N 139°48′10.5″E）与左岸的墨田区向岛（35°42′45″N 139°48′15″E）两侧。春季以满开樱花闻名，夏季则是隅田川花火大会会场。</p>\n<p>每年举行樱花季的隅田公园内约有约700多棵樱花树，是日本樱名所100选之一。约1公里左右的隅田川两岸樱花木是在八代将军德川吉宗安排下所种植。江户时代起便是知名赏樱景点。</p>\n<ol start=\"5\">\n<li><strong>东京天空树</strong>（<em><a href=\"https://goo.gl/maps/g9785FpgnvT2\" target=\"_blank\" rel=\"noopener\">位置</a> / <a href=\"https://zh.wikipedia.org/zh-cn/%E6%9D%B1%E4%BA%AC%E6%99%B4%E7%A9%BA%E5%A1%94\" target=\"_blank\" rel=\"noopener\">百科</a></em>）：</li>\n</ol>\n<p><img src=\"19.jpg\" alt></p>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/taDVPzjQsB22\" target=\"_blank\" rel=\"noopener\">步行 / 0.8KM / 10min</a></p>\n</blockquote>\n<p>是位于日本东京都墨田区的电波塔，由东武铁道及其子公司东武塔晴空塔共同筹建，于2008年7月14日动工，2012年2月29日完工、同年5月22日正式启用。其高度为634米，于2011年11月17日获得吉尼斯世界纪录认证为“世界第一高塔”，成为全世界最高的自立式塔形建筑；目前亦为世界第二高的人工构造物，仅次于哈里发塔。</p>\n<h4 id=\"美食：-2\"><a href=\"#美食：-2\" class=\"headerlink\" title=\"- 美食：\"></a>- 美食：</h4><p>-</p>\n<h4 id=\"住宿：-2\"><a href=\"#住宿：-2\" class=\"headerlink\" title=\"- 住宿：\"></a>- 住宿：</h4><blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/XQ6HHAzqpNx\" target=\"_blank\" rel=\"noopener\">浅草线 / 11min</a></p>\n</blockquote>\n<p>台东区：Asakusa Kuramae Hotel Yume Iroha （浅草藏前梦伊吕波经济型酒店）双人间 / ￥616.5</p>\n<h3 id=\"行程-Day4-3-26\"><a href=\"#行程-Day4-3-26\" class=\"headerlink\" title=\"行程 Day4 (3/26)\"></a><a name=\"4\">行程 Day4 (3/26)</a></h3><blockquote>\n<p>【酒店寄存行李】 交通：<a href=\"https://goo.gl/maps/HcA7s5Rp1RF2\" target=\"_blank\" rel=\"noopener\">大江户线 / 29min</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.odakyu.jp/sc/getting-around/enoshima_kamakura/\" target=\"_blank\" rel=\"noopener\">交通指南</a>；<a href=\"https://www.odakyu.jp/sc/passes/hakone_kamakura/\" target=\"_blank\" rel=\"noopener\">箱根镰仓周游券（3天）</a>；</p>\n</blockquote>\n<p>当天早起先去新宿的新酒店寄存行李，然后直接前往镰仓。晚上返程住新宿。</p>\n<h4 id=\"路线：-3\"><a href=\"#路线：-3\" class=\"headerlink\" title=\"- 路线：\"></a>- 路线：</h4><ol>\n<li><strong>江之岛</strong>（<em><a href=\"https://goo.gl/maps/KqvLRhN4WU62\" target=\"_blank\" rel=\"noopener\">位置</a> / <a href=\"https://zh.wikipedia.org/zh-cn/%E6%B1%9F%E4%B9%8B%E5%B3%B6\" target=\"_blank\" rel=\"noopener\">百科</a></em>）：</li>\n</ol>\n<p><img src=\"25.jpg\" alt></p>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/NjFkgFwMGAu\" target=\"_blank\" rel=\"noopener\">小田急线 - 小田急江之岛线 / 98min</a></p>\n</blockquote>\n<p>江之岛是湘南的代表景点，也是神奈川县指定史迹名胜（1960年开始）及日本百景（1927年）之一。交通机关的站名等多记为江ノ島，住居表示、公文等多使用“江の島”。有时也以古老的江岛神社（日本三大辩天之一）的“江岛”代表。本条目叙述的是陆连岛与地名的江之岛，但一般认知的观光地还包含对岸的片濑、鹄沼地区南部一带。</p>\n<ol start=\"2\">\n<li><strong>湘南海岸</strong>（<em><a href=\"https://goo.gl/maps/i7T8oXJgM212\" target=\"_blank\" rel=\"noopener\">位置</a></em>）：</li>\n</ol>\n<p><img src=\"26.jpg\" alt></p>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/NjFkgFwMGAu\" target=\"_blank\" rel=\"noopener\">步行 / 1.5KM / 19min</a></p>\n</blockquote>\n<p>湘南海岸（湘南海岸）是，神奈川县的湘南出区域，该区域被称为的茅崎从镰仓沿海地区和在沿海区域。</p>\n<p>长期开设日本海滩代表，是全国着名的冲浪点。它还显示在四季中熙熙攘攘的日期点。顺便说一句，134号公路沿着湘南海岸。</p>\n<ol start=\"3\">\n<li><strong>镰仓高校前站</strong>（<em><a href=\"https://goo.gl/maps/iJfoHGhSAGk\" target=\"_blank\" rel=\"noopener\">位置</a> / <a href=\"https://zh.wikipedia.org/zh-cn/%E9%8E%8C%E5%80%89%E9%AB%98%E6%A0%A1%E5%89%8D%E8%BB%8A%E7%AB%99\" target=\"_blank\" rel=\"noopener\">百科</a></em>）：</li>\n</ol>\n<p><img src=\"20.jpg\" alt></p>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/NjFkgFwMGAu\" target=\"_blank\" rel=\"noopener\">步行 / 2.7KM / 34min</a></p>\n</blockquote>\n<p>是一由江之岛电铁（江之电）所经营的铁路车站，位于日本神奈川县镰仓市境内，是江之岛电铁线沿线的一个无人车站。由于车站仅与七里滨（七里ヶ浜）的海岸线隔着国道134号相望，因此站在月台上即能眺望海边的风光。</p>\n<p>本站在1903年初设站时，原名日坂，并在1953年时根据紧邻的神奈川县立镰仓高等学校，改名为镰仓高校前。1997年时，因为车站所在地可以见到海景的优美风情，而成为首批入选“关东车站百选”的其中一个车站。</p>\n<p>车站周边有多部动漫、电视剧及广告等作品取景，特别是东侧的一处平交道，因为是同名漫画改编的电视动画《灌篮高手》（スラムダンク）主题曲以及《Tari Tari》动画场景之一，吸引不少该作品的爱好者到此探访拍照[1]，但有部分人士擅自闯入未开放的镰仓高校校园内拍照游玩，造成该校的困扰。</p>\n<ol start=\"4\">\n<li><strong>高德院</strong>（<em><a href=\"https://goo.gl/maps/LHEo1G69rVw\" target=\"_blank\" rel=\"noopener\">位置</a> / <a href=\"https://zh.wikipedia.org/zh-cn/%E9%AB%98%E5%BE%B7%E9%99%A2\" target=\"_blank\" rel=\"noopener\">百科</a></em>）：</li>\n</ol>\n<p><img src=\"24.jpg\" alt></p>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/UXGX7uBkDBJ2\" target=\"_blank\" rel=\"noopener\">江之岛电铁线 / 23min</a></p>\n</blockquote>\n<p>高德院位于日本神奈川县镰仓市的长谷，是一间佛教净土宗的寺院。供奉的本尊阿弥陀佛一般人称为“镰仓大佛”，坐落于大异山。开基（创立者）与开山（初代住持）均不明。</p>\n<p>这座寺院拥有日本最著名的佛像之一—大佛—一座高达11.3米，重约121吨的露天阿弥陀佛青铜塑像，它的尺寸在全日本仅次于位于奈良市东大寺的另一尊佛像。</p>\n<p>根据寺院有关青铜像建造的相关记载，这座塑像的历史可以追溯到1252年的镰仓时代。然而，并不清楚寺院记录中那座当时正在建造的塑像是否就是今天这座大佛像。这座佛像曾经位于一座寺庙建筑中，而原本容纳大佛的木质寺庙建筑毁于15世纪末室町时代的一场海啸，但佛像却保留了下来。</p>\n<ol start=\"5\">\n<li><strong>长谷寺</strong>（<em><a href=\"https://goo.gl/maps/cnrhLHDu5h92\" target=\"_blank\" rel=\"noopener\">位置</a></em>）：</li>\n</ol>\n<p><img src=\"23.jpg\" alt></p>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/VKDzUDtJTWo\" target=\"_blank\" rel=\"noopener\">步行 / 0.7KM / 9min</a></p>\n</blockquote>\n<p>是位在日本奈良县樱井市的寺院，真言宗丰山派总本山。山号“丰山”（ぶざん）。本尊十一面观音、开基（创立者）为道明。别称“花之御寺”。</p>\n<ol start=\"6\">\n<li><strong>鹤冈八幡宫</strong>（<em><a href=\"https://goo.gl/maps/trhdMFyGi562\" target=\"_blank\" rel=\"noopener\">位置</a></em>）：</li>\n</ol>\n<p><img src=\"22.jpg\" alt></p>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/VaYkVGmUsfK2\" target=\"_blank\" rel=\"noopener\">江之岛电铁线 / 26min</a></p>\n</blockquote>\n<p>是位于日本神奈川县镰仓市的神社。旧社格为国币中社（现神社本厅的别表神社）。武家源氏、镰仓武士之守护神。也称作镰仓八幡宫。公元1063年由源赖义由京都的石清水八幡宫劝请至由比之滨。此后，于公元1180年进入镰仓的幕府将军源赖朝将其移请至现址，并加以扩建，才成为日后镰仓幕府时期中心。</p>\n<h4 id=\"美食：-3\"><a href=\"#美食：-3\" class=\"headerlink\" title=\"- 美食：\"></a>- 美食：</h4><p>-</p>\n<h4 id=\"住宿：-3\"><a href=\"#住宿：-3\" class=\"headerlink\" title=\"- 住宿：\"></a>- 住宿：</h4><blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/cNgfndNJhzA2\" target=\"_blank\" rel=\"noopener\">镰仓站 - 藤泽站 / 江之岛电铁线 / 36min</a> -&gt; <a href=\"https://goo.gl/maps/H7ZosDWmSg22\" target=\"_blank\" rel=\"noopener\">藤泽站 - 新宿 / 小田急线 / 70min</a></p>\n</blockquote>\n<p>新宿区：Citadines Central Shinjuku Tokyo（馨乐庭中央东京新宿区酒店）双人间 / ￥1052</p>\n<h3 id=\"行程-Day5-3-27\"><a href=\"#行程-Day5-3-27\" class=\"headerlink\" title=\"行程 Day5 (3/27)\"></a><a name=\"5\">行程 Day5 (3/27)</a></h3><p><img src=\"27.png\" alt></p>\n<blockquote>\n<p><a href=\"https://www.odakyu.jp/sc/getting-around/hakone/\" target=\"_blank\" rel=\"noopener\">交通指南</a>；<a href=\"https://www.odakyu.jp/sc/passes/hakone_kamakura/\" target=\"_blank\" rel=\"noopener\">箱根镰仓周游券（3天）</a>；</p>\n</blockquote>\n<h4 id=\"路线：-4\"><a href=\"#路线：-4\" class=\"headerlink\" title=\"- 路线：\"></a>- 路线：</h4><ol>\n<li><strong>箱根汤本站</strong>（<em><a href=\"https://goo.gl/maps/g4L4YaPX7yj\" target=\"_blank\" rel=\"noopener\">位置</a></em>）：</li>\n</ol>\n<p><img src=\"21.jpg\" alt></p>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/SAZfg2J1fd82\" target=\"_blank\" rel=\"noopener\">小田急浪漫特快 / 95min</a></p>\n</blockquote>\n<p>自古已是温泉町，在江户时代设置箱根关。近代由于西武铁道集团与小田急电铁致力于观光开发而得到急速发展。箱根温泉是汤本、塔之泽、大平台、宫之下、小涌谷等地温泉的总称。</p>\n<ol start=\"2\">\n<li><strong>Emblem Flow Hakone 酒店寄存</strong>（<em><a href=\"https://goo.gl/maps/wAWgwPSWAF92\" target=\"_blank\" rel=\"noopener\">位置</a></em>）：</li>\n</ol>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/axQ5wKEUgFk\" target=\"_blank\" rel=\"noopener\">箱根登山线 / 37min</a></p>\n</blockquote>\n<ol start=\"3\">\n<li><strong>早云山站</strong>（<em><a href=\"https://goo.gl/maps/s7tFrFPZzZC2\" target=\"_blank\" rel=\"noopener\">位置</a></em>）：</li>\n</ol>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/rGtpgcYC1xr\" target=\"_blank\" rel=\"noopener\">箱根登山线 / 10min</a></p>\n</blockquote>\n<ol start=\"4\">\n<li><strong>大涌谷站</strong>（<em><a href=\"https://goo.gl/maps/A2vHp7KUkxL2\" target=\"_blank\" rel=\"noopener\">位置</a></em>）：</li>\n</ol>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/S3FEyt4Vxx52\" target=\"_blank\" rel=\"noopener\">箱根空中缆车 / 8min</a></p>\n</blockquote>\n<ol start=\"5\">\n<li><strong>桃园台站</strong>（<em><a href=\"https://goo.gl/maps/CkyELagfu4R2\" target=\"_blank\" rel=\"noopener\">位置</a></em>）：</li>\n</ol>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/JZaM8QTy19u\" target=\"_blank\" rel=\"noopener\">箱根空中缆车 / 16min</a></p>\n</blockquote>\n<ol start=\"6\">\n<li><strong>元箱根港</strong>（<em><a href=\"https://goo.gl/maps/ZnkiVduN4gu\" target=\"_blank\" rel=\"noopener\">位置</a></em>）：</li>\n</ol>\n<blockquote>\n<p>交通：箱根海盗船</p>\n</blockquote>\n<ol start=\"7\">\n<li><strong>箱根神社</strong>（<em><a href=\"https://goo.gl/maps/dHzUHdS1buF2\" target=\"_blank\" rel=\"noopener\">位置</a></em>）：</li>\n</ol>\n<p><img src=\"28.jpg\" alt></p>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/3hcHkHfLmzP2\" target=\"_blank\" rel=\"noopener\">步行 / 1KM / 14min</a></p>\n</blockquote>\n<h4 id=\"美食：-4\"><a href=\"#美食：-4\" class=\"headerlink\" title=\"- 美食：\"></a>- 美食：</h4><p>-</p>\n<h4 id=\"住宿：-4\"><a href=\"#住宿：-4\" class=\"headerlink\" title=\"- 住宿：\"></a>- 住宿：</h4><blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/bzH8jKf7jXT2\" target=\"_blank\" rel=\"noopener\">箱根町線：箱根口経由 -&gt; 箱根登山線 / 42分钟</a></p>\n</blockquote>\n<p>箱根：Emblem Flow Hakone / 双人间￥1092</p>\n<h3 id=\"行程-Day6-3-28\"><a href=\"#行程-Day6-3-28\" class=\"headerlink\" title=\"行程 Day6 (3/28)\"></a><a name=\"6\">行程 Day6 (3/28)</a></h3><ol>\n<li><strong>箱根美术馆</strong>（<em><a href=\"https://goo.gl/maps/3Z4FjVQGBKD2\" target=\"_blank\" rel=\"noopener\">位置</a></em>）：</li>\n</ol>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/AVEvzajWhBm\" target=\"_blank\" rel=\"noopener\">步行 / 0.65KM / 13min</a></p>\n</blockquote>\n<p>箱根美术馆是箱根地区最早建立的美术馆。昭和27年6月，由创始人岡田茂吉先生建立。主要展品为岡田茂吉先生收藏的中日古代陶瓷器。其中最古老的藏品历史可追溯到古坟时代。</p>\n<p>箱根美术馆的苔藓庭院是一绝，茶室楼阁山石花草，看似无心布置，却处处透露着日式的禅意。秋季枫叶变红，与绿苔形成鲜明的对比，能吸引大批游客。</p>\n<ol start=\"2\">\n<li><strong>POLA 美术馆</strong>（<em><a href=\"https://goo.gl/maps/SVsUGKz8jEx\" target=\"_blank\" rel=\"noopener\">位置</a></em>）：</li>\n</ol>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/qJX5qB2vZkM2\" target=\"_blank\" rel=\"noopener\">天悠～強羅小塚～湿生花園前 / 12min</a></p>\n</blockquote>\n<p>Pola Museum of Art 位于日本神奈川县箱根。它于2002年9月在富士箱根伊豆国立公园内开放。它收藏了 Pola 化妆品集团前负责人收购的超过9,500件作品，其中包括法国印象派和巴黎 École 的许多作品。引人注目的建筑是 Nikken Sekkei。</p>\n<ol start=\"3\">\n<li><strong>箱根小王子博物馆</strong>（<em><a href=\"https://goo.gl/maps/zxSsZ8e9bcy\" target=\"_blank\" rel=\"noopener\">位置</a></em>）：</li>\n</ol>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/yD9PWYThE1L2\" target=\"_blank\" rel=\"noopener\">天悠～強羅小塚～湿生花園前 / 4min</a></p>\n</blockquote>\n<p>箱根小王子博物馆（日语：箱根★サン＝テグジュペリ 星の王子さまミュージアム）是位于日本神奈川县箱根町仙石原的博物馆[1]，专门展出与《小王子》及其作者安东尼·迪·圣-修伯里有关的展品。该馆开幕于1999年6月29日，即圣修伯里诞生100周年之际。</p>\n<p>博物馆呈现了《小王子》书中的情节与人物，其中设有小王子及其B612星球的雕塑、“小王子庭院”、模仿1930年代时期的咖啡馆、模仿圣修伯里童年时期的教会、圣修伯里生平展示空间等等。馆内的礼品店出售《小王子》的相关商品。</p>\n<ol start=\"4\">\n<li><strong>箱根玻璃之森美术馆</strong>（<em><a href=\"https://goo.gl/maps/YNPhEHvaoZJ2\" target=\"_blank\" rel=\"noopener\">位置</a></em>）：</li>\n</ol>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/EWZZELi6TCR2\" target=\"_blank\" rel=\"noopener\">步行 / 0.85KM / 11min</a></p>\n</blockquote>\n<p>神奈川县的玻璃之森美术馆，坐落在箱根绵延的群山之中，主体建筑酷似欧洲中世纪贵族别墅，仿若童话世界。在这广阔的庭园里分布着美术馆、商店和咖啡厅。 美术馆里陈列着15世纪至19世纪期间威尼斯和现代威尼斯的作品约100件，它们是曾经让欧洲贵族为之疯狂的威尼斯玻璃艺术。此外，还公开展示了很多罗斯柴尔德家族传承下来的钴蓝高脚杯等贵重作品。最令人惊叹的是礼花树 Fontana 喷泉，阳光下熠熠生辉的礼花树，亮晶晶的树木、泉水、瀑布都是一粒一粒的玻璃球制成，整个美术馆都显得十分精致美好。 露天咖啡厅可观赏以中世纪威尼斯为形象的庭院，那里有正宗的坎佐纳器乐作品实况演奏。另外还有能体验玻璃工艺制作的体验工房。</p>\n<ol start=\"5\">\n<li><strong>Emblem Flow Hakone 酒店取行李</strong>：</li>\n</ol>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/Sf1ptiTDHLw\" target=\"_blank\" rel=\"noopener\">アウトレット～宮城野～天悠 / 13min</a></p>\n</blockquote>\n<ol start=\"6\">\n<li><strong>箱根汤本站</strong>：</li>\n</ol>\n<p>当日 15:30 前必须上车。</p>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/oz9sP91Y4CU2\" target=\"_blank\" rel=\"noopener\">箱根登山线 / 45min</a></p>\n</blockquote>\n<ol start=\"7\">\n<li><strong>新宿站</strong>：</li>\n</ol>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/9Pp7BVaNvFM2\" target=\"_blank\" rel=\"noopener\">小田急浪漫特快 / 99min</a></p>\n</blockquote>\n<ol start=\"8\">\n<li><strong>羽田国际机场</strong>（<em><a href=\"https://goo.gl/maps/E8rL54MhkUs\" target=\"_blank\" rel=\"noopener\">位置</a></em>）：</li>\n</ol>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/Rq6qk8dDPKm\" target=\"_blank\" rel=\"noopener\">大江戶線 -&gt; 東京單軌電車 / 55min</a></p>\n</blockquote>\n<h3 id=\"附录资料\"><a href=\"#附录资料\" class=\"headerlink\" title=\"附录资料\"></a>附录资料</h3><h4 id=\"箱根地图：\"><a href=\"#箱根地图：\" class=\"headerlink\" title=\"箱根地图：\"></a><a name=\"7\">箱根地图：</a></h4><p><img src=\"29.png\" alt></p>\n<h4 id=\"江之岛-镰仓地图：\"><a href=\"#江之岛-镰仓地图：\" class=\"headerlink\" title=\"江之岛/镰仓地图：\"></a><a name=\"8\">江之岛/镰仓地图：</a></h4><p><img src=\"31.png\" alt></p>\n<h4 id=\"小田急线路线图：\"><a href=\"#小田急线路线图：\" class=\"headerlink\" title=\"小田急线路线图：\"></a><a name=\"9\">小田急线路线图：</a></h4><p><img src=\"30.png\" alt></p>\n","site":{"data":{}},"id":"e16d85cfc8eaeff9fa5516276251ae65","excerpt":"","more":"<p>计划今年3月下旬待天气稍微转暖，把18年剩余的几天年假用掉，碰巧此时也正好赶上了日本3-5月份的“樱花季”，遂决定去趟日本🇯🇵。按照往年的规律，东京的樱花期是从每年的3月22日开始，持续连续一周左右时间，而我们的出行航班正好是于花季的第二天到达东京，没准能够感上“最新鲜”的樱花视觉盛宴。整个旅程计划6天5晚，大致路线为：<strong>东京-镰仓-箱根</strong>。</p>\n<p><img src=\"1.jpg\" alt></p>\n<h3 id=\"快速导航：\"><a href=\"#快速导航：\" class=\"headerlink\" title=\"快速导航：\"></a>快速导航：</h3><ul>\n<li><a href=\"#1\">3/23 第一天（羽田机场、皇居、千鸟湖、银座、东京塔、六本木）；</a></li>\n<li><a href=\"#2\">3/24 第二天（新宿御苑、目黑川、涩谷、明治神宫、原宿、表参道）；</a></li>\n<li><a href=\"#3\">3/25 第三天（池袋、上野公园、浅草寺、隅田公园、东京天空树）；</a></li>\n<li><a href=\"#4\">3/26 第四天（江之岛、湘南海岸、镰仓高校前站、高德院、长谷寺、鹤冈八幡宫）；</a></li>\n<li><a href=\"#5\">3/27 第五天（箱根汤本站、早云山站、大涌谷站、桃园台站、元箱根港、箱根神社）；</a></li>\n<li><a href=\"#6\">3/28 第六天（箱根美术馆、POLA 美术馆、箱根小王子博物馆、箱根玻璃之森美术馆）；</a></li>\n</ul>\n<h3 id=\"附录资料：\"><a href=\"#附录资料：\" class=\"headerlink\" title=\"附录资料：\"></a>附录资料：</h3><ul>\n<li>周游券/车票购买地点：<a href=\"https://www.odakyu.jp/sc/transport/riding/howto/#purchase\" target=\"_blank\" rel=\"noopener\">小田急旅游服务中心、自动售票机</a>；</li>\n<li><a href=\"https://www.web-odakyu.com/e-romancecar/vacantSeatInquiry/input?STICKY=11074\" target=\"_blank\" rel=\"noopener\">小田急“浪漫”特快预约购票（提前一月预订、建议选择 70000 GSE/50000 VSE 车型眺望席）</a>；</li>\n<li><a href=\"#7\">箱根地图；</a></li>\n<li><a href=\"#8\">江之岛/镰仓地图；</a></li>\n<li><a href=\"#9\">小田急线路线图；</a></li>\n</ul>\n<h3 id=\"日本签证材料参考：\"><a href=\"#日本签证材料参考：\" class=\"headerlink\" title=\"日本签证材料参考：\"></a>日本签证材料参考：</h3><ol>\n<li>护照（至少剩余6月有效期）；</li>\n<li>2张2寸白底彩照（一张贴在申请表上，一张写上名字，3个月内拍摄）；</li>\n<li>身份证（正反清晰复印件）；</li>\n<li>户口本（户主页和本人首页复印件）；</li>\n<li>日本签证申请表；</li>\n<li>个人信息处理同意书；</li>\n<li>旅签材料受理表；</li>\n<li>在职证明原件（本人带公章，带有薪资字样，年收入10万以上）；</li>\n<li>电子税单（近一年缴税金额须每月达到230元以上，同一公司缴纳）；</li>\n<li>全程的机酒预订单（带有出入境日期、第一晚入住城市、及全程入住的酒店和机票）；</li>\n<li>居住证（外地户籍，需符合上海领区的地区要求）；</li>\n</ol>\n<h3 id=\"行程-Day1-3-23\"><a href=\"#行程-Day1-3-23\" class=\"headerlink\" title=\"行程 Day1 (3/23)\"></a><a name=\"1\">行程 Day1 (3/23)</a></h3><h4 id=\"路线：\"><a href=\"#路线：\" class=\"headerlink\" title=\"- 路线：\"></a>- 路线：</h4><ol>\n<li><strong>羽田国际机场</strong>（<em><a href=\"https://goo.gl/maps/E8rL54MhkUs\" target=\"_blank\" rel=\"noopener\">位置</a></em>）：</li>\n</ol>\n<p><img src=\"2.jpg\" alt></p>\n<blockquote>\n<p>交通：直飞航班，从上海到东京，当日清晨 05:30 分抵达机场；</p>\n</blockquote>\n<ol start=\"2\">\n<li><strong>皇居</strong>（<em><a href=\"https://goo.gl/maps/9vcodQirdVP2\" target=\"_blank\" rel=\"noopener\">位置</a> / <a href=\"https://zh.wikipedia.org/zh-cn/%E7%9A%87%E5%B1%85\" target=\"_blank\" rel=\"noopener\">百科</a></em>）：</li>\n</ol>\n<p><img src=\"3.jpg\" alt></p>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/3QUTgYN2gz92\" target=\"_blank\" rel=\"noopener\">东京单轨电车 - 京滨东北线 - 有乐町线 / 63min</a></p>\n</blockquote>\n<p>传统上，日本没有定都的概念，习惯以在位天皇（大王）的所在地为国都（古代称为“京”），并以在位天皇居住之宫殿为皇居（古代称为“宫”）。现在的皇居位于东京都千代田区，即原江户幕府历代将军所居住的江户城，但范围较原始的江户城为小。</p>\n<p>皇居除皇室起居部分不对公众开放外，其他部分可经由宫内厅进行预约参观，东面的皇居东御苑（原江户城本丸所在地）则在固定时间开放自由参观。皇居内部每年开放两次，分别在天皇诞生日及新年的次日（1月2日）。皇居的土地为国有财产，皇居的管理则连同皇室的事务由宫内厅全权负责。虽然皇居的位置邻近东京交通枢纽之一的东京站，而东京又有极为绵密的地下铁路网和高速公路系统，但并没有任何一条铁道或公路穿过皇居的地底下，全由周边绕开。</p>\n<ol start=\"3\">\n<li><strong>千鸟渊</strong>（<em><a href=\"https://goo.gl/maps/CZ1PYFBpXmk\" target=\"_blank\" rel=\"noopener\">位置</a> / <a href=\"https://zh.wikipedia.org/zh-cn/%E5%8D%83%E9%B3%A5%E6%B7%B5\" target=\"_blank\" rel=\"noopener\">百科</a></em>）：</li>\n</ol>\n<p><img src=\"4.jpg\" alt></p>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/3XpDobWx71R2\" target=\"_blank\" rel=\"noopener\">步行 / 1.5KM / 18min</a></p>\n</blockquote>\n<p>千鸟渊是江户开府后江户城扩张之际，在局泽川筑上两座土桥半藏门与田安门而形成的护城河。以代官町通相隔的半藏濠在过去与千鸟渊相通，但1900年（明治33年）因道路建设进行填地后成为独立的两条护城河。</p>\n<p>千鸟渊附近以赏樱名所而知名，吸引大批名众来此赏樱。开花期间中、千鸟渊沿旁的千鸟渊绿道在花期夜晚会点灯照明。此外，千鸟渊绿道设有搭船处，可在千鸟渊内划船。</p>\n<p>千鸟渊绿道旁有日本政府设置的千鸟渊战殁者墓苑，安置第二次世界大战中在海外丧生的身份不明日本人遗骨。</p>\n<ol start=\"4\">\n<li><strong>银座</strong>（<em><a href=\"https://goo.gl/maps/Gqyycidp84P2\" target=\"_blank\" rel=\"noopener\">位置</a> / <a href=\"https://zh.wikipedia.org/zh-cn/%E9%8A%80%E5%BA%A7\" target=\"_blank\" rel=\"noopener\">百科</a></em>）：</li>\n</ol>\n<p><img src=\"5.jpg\" alt></p>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/KAGP9wQDMgH2\" target=\"_blank\" rel=\"noopener\">步行 / 3.5KM / 42min</a></p>\n</blockquote>\n<p>是日本东京中央区的一个主要商业区，以高级购物商店闻名，是东京其中一个代表性地区。</p>\n<p>银座位于日本中央区西部，分为银座一丁目至银座八丁目。银座四丁目与银座五丁目之间被晴海通所分隔，全部8个丁目由中央通贯通。银座是高级商店街的象征，因此日本各地商店街常可见冠以银座之名的“某某银座”。</p>\n<ol start=\"5\">\n<li><strong>东京塔</strong>（<em><a href=\"https://goo.gl/maps/EqMAqDuUKz82\" target=\"_blank\" rel=\"noopener\">位置</a> / <a href=\"https://zh.wikipedia.org/zh-cn/%E4%B8%9C%E4%BA%AC%E9%93%81%E5%A1%94\" target=\"_blank\" rel=\"noopener\">百科</a></em>）：</li>\n</ol>\n<p><img src=\"6.jpg\" alt></p>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/XyyRRfwi6kQ2\" target=\"_blank\" rel=\"noopener\">浅草线 / 23min</a></p>\n</blockquote>\n<p>是位于日本东京都港区芝公园的电波塔。其以巴黎埃菲尔铁塔为范本而建造，高333米，比前者高13米，完工以来即成为东京著名地标与观光景点。正式名称为日本电波塔（日本電波塔／にっぽんでんぱとう），这同时也是其营运机构的名称。</p>\n<p>东京铁塔由建筑师内藤多仲与日建设计株式会社共同设计。高332.6米，较艾菲尔铁塔的324米高出8.6米，较东京天空树矮301.4米，比广州塔矮267.4米，是世界第三高的自立式铁塔，重4,000吨，与重7,300吨的埃菲尔铁塔相比重量大幅减轻，开工于1957年6月29日，1958年10月14日竣工，12月7日正式公开，12月23日举行竣工仪式，开始了正式营业。三分之一用于建塔的钢铁，来自韩战时美军的坦克废铁。</p>\n<ol start=\"6\">\n<li><strong>六本木</strong>（<em><a href=\"https://goo.gl/maps/Wz9dasFuacB2\" target=\"_blank\" rel=\"noopener\">位置</a> / <a href=\"https://zh.wikipedia.org/zh-cn/%E5%85%AD%E6%9C%AC%E6%9C%A8\" target=\"_blank\" rel=\"noopener\">百科</a></em>）：</li>\n</ol>\n<p><img src=\"7.jpg\" alt></p>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/dUkXekDDjTP2\" target=\"_blank\" rel=\"noopener\">大江户线 / 14min</a></p>\n</blockquote>\n<p>是位于日本东京都港区的街区，坐落于港区的北侧，北邻南青山，东接赤坂，东南临虎之门，南接麻布台、麻布永坂町、麻布十番，西南临元麻布，西接西麻布。现行行政地名为六本木一丁目至六本木七丁目。2013年7月1日的人口为11,929人。邮递区号106-0032。</p>\n<p>六本木是驻日大使馆的主要聚集地，以聚集外国人与夜生活而闻名。虽然有闹区的强烈印象，但是并没有百货公司设于此地。时至今日，商办设施、高级公寓，以及方舟之丘、泉花园大厦、六本木新城、东京中城等都市再开发计划，让六本木呈现多样的面貌。</p>\n<h4 id=\"美食：\"><a href=\"#美食：\" class=\"headerlink\" title=\"- 美食：\"></a>- 美食：</h4><p>拉面、天妇罗、牛丼、大仮烧、和牛；</p>\n<h4 id=\"住宿：\"><a href=\"#住宿：\" class=\"headerlink\" title=\"- 住宿：\"></a>- 住宿：</h4><blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/TZRW1CfYdTm\" target=\"_blank\" rel=\"noopener\">大江户线 / 24min</a></p>\n</blockquote>\n<p>新宿区：E Hotel Higashi Shinjuku （东新宿E酒店）双人间 / ￥1001</p>\n<h3 id=\"行程-Day2-3-24\"><a href=\"#行程-Day2-3-24\" class=\"headerlink\" title=\"行程 Day2 (3/24)\"></a><a name=\"2\">行程 Day2 (3/24)</a></h3><h4 id=\"路线：-1\"><a href=\"#路线：-1\" class=\"headerlink\" title=\"- 路线：\"></a>- 路线：</h4><ol>\n<li><strong>新宿御苑</strong>（<em><a href=\"https://goo.gl/maps/ogBrfC2pYhp\" target=\"_blank\" rel=\"noopener\">位置</a> / <a href=\"https://zh.wikipedia.org/zh-cn/%E6%96%B0%E5%AE%BF%E5%BE%A1%E8%8B%91\" target=\"_blank\" rel=\"noopener\">百科</a></em>）：</li>\n</ol>\n<p><img src=\"13.jpg\" alt></p>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/hJPcr2YhjfJ2\" target=\"_blank\" rel=\"noopener\">副都心线 / 13min</a></p>\n</blockquote>\n<p>新宿御苑是日本东京都横跨新宿区与涩谷区的庭园，面积58.3公顷。该处在江户时代为内藤家的宅地；其后成为宫内厅管理的庭园，现在则属环境省管辖的国民公园。</p>\n<ol start=\"2\">\n<li><strong>明治神宫</strong>（<em><a href=\"https://goo.gl/maps/4jkzF2FMpct\" target=\"_blank\" rel=\"noopener\">位置</a> / <a href=\"https://zh.wikipedia.org/zh-cn/%E6%98%8E%E6%B2%BB%E7%A5%9E%E5%AE%AB\" target=\"_blank\" rel=\"noopener\">百科</a></em>）：</li>\n</ol>\n<p><img src=\"10.jpg\" alt></p>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/j5ZyYnAQGsn\" target=\"_blank\" rel=\"noopener\">步行 / 2KM / 24min</a></p>\n</blockquote>\n<p>是位于日本东京都涩谷区的神社，供奉明治天皇，昭宪皇太后的灵位。1920年启用，占地70公顷，紧挨着原宿、新宿等东京两大商圈，占据了从代代木到原宿站之间的整片地带，与相邻的代代木公园构成东京市中心除了皇居之外最大的一块绿地。正式书记中，“宫”的写法采取日本古代常见写法，下方“吕”中间没有一撇“ノ”，为“明治神宫”。</p>\n<ol start=\"3\">\n<li><strong>原宿</strong>（<em><a href=\"https://goo.gl/maps/URr6YNikPuz\" target=\"_blank\" rel=\"noopener\">位置</a> / <a href=\"https://zh.wikipedia.org/zh-cn/%E5%8E%9F%E5%AE%BF\" target=\"_blank\" rel=\"noopener\">百科</a></em>）：</li>\n</ol>\n<p><img src=\"11.jpg\" alt></p>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/D7i5pMeiDrr\" target=\"_blank\" rel=\"noopener\">步行 / 1KM / 11min</a></p>\n</blockquote>\n<p>原宿是东京都涩谷区的一个地区，范围约为明治神宫、代代木公园、竹下通、表参道、国立代代木竞技场一带，是日本著名的“年轻人之街”。</p>\n<ol start=\"4\">\n<li><strong>表参道</strong>（<em><a href=\"https://goo.gl/maps/qzUtiPbR7LT2\" target=\"_blank\" rel=\"noopener\">位置</a> / <a href=\"https://zh.wikipedia.org/zh-cn/%E8%A1%A8%E5%8F%83%E9%81%93\" target=\"_blank\" rel=\"noopener\">百科</a></em>）：</li>\n</ol>\n<p><img src=\"12.jpg\" alt></p>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/NR5xs4BLb7x\" target=\"_blank\" rel=\"noopener\">步行 / 1KM / 12min</a></p>\n</blockquote>\n<p>表参道是1920年明治神宫创建时，在正面侧的参道与兴建道路的通称。位于东京都涩谷区与港区，都道413号线，及原宿站前附近，至青山通交差的表参道交差点区域。但多数用以称呼东京地下铁表参道站附近，为明确区别，道路以表参道通称呼。</p>\n<p>表参道与明治通的交差点，即神宫前交差点以东，为日本著名外国品牌时装店林立之地。过去有1927年建设的同润会青山公寓，但因建筑变得古旧，在2003年被拆卸，原址在2006年2月建成表参道之丘，内设有一些有个性的店铺，附近则为潮流区域里原宿的入口。神宫前交差点以西有时装商场 Laforet 原宿，及不少饮食店与杂货店。</p>\n<p>在表参道交差点至根津美术馆方向，阔15米的道路通称为“从快通”。</p>\n<ol start=\"5\">\n<li><strong>涩谷</strong>（<em><a href=\"https://goo.gl/maps/ruGGgZ82b3C2\" target=\"_blank\" rel=\"noopener\">位置</a> / <a href=\"https://zh.wikipedia.org/zh-cn/%E6%BE%80%E8%B0%B7\" target=\"_blank\" rel=\"noopener\">百科</a></em>）：</li>\n</ol>\n<p><img src=\"9.gif\" alt></p>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/7a8Dvtp7QUB2\" target=\"_blank\" rel=\"noopener\">步行 / 0.8KM / 9min</a></p>\n</blockquote>\n<p>涩谷与新宿、池袋并列为东京三大副都心，是东京最具代表性的商圈之一，乃日本流行与时尚的重要发信地，又以“音乐之街”、“年轻人之街”著称；同时是东京通往首都圈东南郊区的重要转运点，拥有多家连锁百货公司及综合商场，为东急集团的大本营。涩谷站前的八公铜像是涩谷的地标；涩谷站前交叉口的行人保护时相，则是东京知名的城市地景之一。</p>\n<ol start=\"6\">\n<li><strong>目黑川</strong>（<em><a href=\"https://goo.gl/maps/5GVfiQSQYJP2\" target=\"_blank\" rel=\"noopener\">位置</a> / <a href=\"https://zh.wikipedia.org/zh-cn/%E7%9B%AE%E9%BB%91%E5%B7%9D\" target=\"_blank\" rel=\"noopener\">百科</a></em>）：</li>\n</ol>\n<p><img src=\"8.jpg\" alt></p>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/idRtv3YAWrq\" target=\"_blank\" rel=\"noopener\">东急东横线 / 14min</a></p>\n</blockquote>\n<p>是东京都流经世田谷区、目黑区与品川区，最后注入东京湾的河川。为二级水系的主流。</p>\n<p>河口附近自古以来称为“品川”（しながわ）。在湾岸开发以前，河口附近河道弯曲，流速合缓，因此成为港口，是物品来来往往的河川因而称为“品川”。</p>\n<p>另外，从江户时代的绘图，其上游下目黑附近称作“こりとり川”。“こりとり”意为“垢离取り”，源自于在此川洁净自身的目黑不动尊。</p>\n<h4 id=\"美食：-1\"><a href=\"#美食：-1\" class=\"headerlink\" title=\"- 美食：\"></a>- 美食：</h4><p>-</p>\n<h4 id=\"住宿：-1\"><a href=\"#住宿：-1\" class=\"headerlink\" title=\"- 住宿：\"></a>- 住宿：</h4><blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/mJvFS2wBdJy\" target=\"_blank\" rel=\"noopener\">东急东横线 / 18min</a></p>\n</blockquote>\n<p>新宿区：E Hotel Higashi Shinjuku （东新宿E酒店）双人间 / ￥1001</p>\n<h3 id=\"行程-Day3-3-25\"><a href=\"#行程-Day3-3-25\" class=\"headerlink\" title=\"行程 Day3 (3/25)\"></a><a name=\"3\">行程 Day3 (3/25)</a></h3><blockquote>\n<p>【酒店寄存行李】 交通：<a href=\"https://goo.gl/maps/wuCpP12dBUG2\" target=\"_blank\" rel=\"noopener\">大江戶線 / 23min</a></p>\n</blockquote>\n<h4 id=\"路线：-2\"><a href=\"#路线：-2\" class=\"headerlink\" title=\"- 路线：\"></a>- 路线：</h4><ol>\n<li><strong>池袋</strong>（<em><a href=\"https://goo.gl/maps/JKp7zsH8Zyn\" target=\"_blank\" rel=\"noopener\">位置</a> / <a href=\"https://zh.wikipedia.org/zh-cn/%E6%B1%A0%E8%A2%8B\" target=\"_blank\" rel=\"noopener\">百科</a></em>）：</li>\n</ol>\n<p><img src=\"15.jpg\" alt></p>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/NcNaYDa9ES62\" target=\"_blank\" rel=\"noopener\">大江户线 -&gt; 丸之内线 / 25min</a></p>\n</blockquote>\n<p>是日本东京都丰岛区的一个区域，也是东京市区中一个主要的商业及娱乐地区。池袋有多家大型百货公司据点及东京主要车站之一的池袋站，亦是丰岛区役所（区政府）所在地。</p>\n<ol start=\"2\">\n<li><strong>上野公园</strong>（<em><a href=\"https://goo.gl/maps/NPhsms11D9A2\" target=\"_blank\" rel=\"noopener\">位置</a> / <a href=\"https://zh.wikipedia.org/zh-cn/%E4%B8%8A%E9%87%8E%E5%85%AC%E5%9C%92\" target=\"_blank\" rel=\"noopener\">百科</a></em>）：</li>\n</ol>\n<p><img src=\"16.jpg\" alt></p>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/uSE6TmaAaY22\" target=\"_blank\" rel=\"noopener\">山手线 / 35min</a></p>\n</blockquote>\n<p>全名上野恩赐公园，是日本东京都台东区上野的一座公园，也是日本第一座公园，占地约53万平方米。全园在1873年指定为公园、1876年正式开园。此地原属于日本皇室，至1924年始由大正天皇下赐与东京市管理，故名“恩赐”。</p>\n<p>上野公园是东京国立博物馆、国立西洋美术馆、国立科学博物馆、上野动物园的所在地。同时也有雕刻家高村光云所作的西乡隆盛铜像[1]，以及野口英世的铜像。</p>\n<p>称作忍冈的高地是近代的赏樱名所，入选为日本樱名所100选，吸引大量赏花游客前往。此外，忍冈南方的不忍池（しのばずのいけ），夏天池上大量桃色莲花盛开。冬季有鸭等多种水鸟飞至此地栖息。</p>\n<ol start=\"3\">\n<li><strong>浅草寺</strong>（<em><a href=\"https://goo.gl/maps/9oFcWmwrNcL2\" target=\"_blank\" rel=\"noopener\">位置</a> / <a href=\"https://zh.wikipedia.org/zh-cn/%E6%B7%BA%E8%8D%89%E5%AF%BA\" target=\"_blank\" rel=\"noopener\">百科</a></em>）：</li>\n</ol>\n<p><img src=\"17.jpg\" alt></p>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/sLP9Tkrhapz\" target=\"_blank\" rel=\"noopener\">步行 / 2.5KM / 30min</a></p>\n</blockquote>\n<p>又名金龙山浅草寺，位于日本东京都台东区浅草二丁目，是东京都内历史最悠久的寺院。山号为金龙山。供奉的本尊是圣观音。原属天台宗，于第二次世界大战后独立，成为圣观音宗的总本山。观音菩萨本尊通称为“浅草观音”。</p>\n<ol start=\"4\">\n<li><strong>隅田公园</strong>（<em><a href=\"https://goo.gl/maps/fM1zpAjgrPx\" target=\"_blank\" rel=\"noopener\">位置</a> / <a href=\"https://zh.wikipedia.org/zh-cn/%E9%9A%85%E7%94%B0%E5%85%AC%E5%9C%92\" target=\"_blank\" rel=\"noopener\">百科</a></em>）：</li>\n</ol>\n<p><img src=\"18.jpg\" alt></p>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/bpoLyJR2A8p\" target=\"_blank\" rel=\"noopener\">步行 / 1KM / 12min</a></p>\n</blockquote>\n<p>是东京都隅田川岸的公园，分为右岸的台东区浅草、花川户、今户（35°42′55″N 139°48′10.5″E）与左岸的墨田区向岛（35°42′45″N 139°48′15″E）两侧。春季以满开樱花闻名，夏季则是隅田川花火大会会场。</p>\n<p>每年举行樱花季的隅田公园内约有约700多棵樱花树，是日本樱名所100选之一。约1公里左右的隅田川两岸樱花木是在八代将军德川吉宗安排下所种植。江户时代起便是知名赏樱景点。</p>\n<ol start=\"5\">\n<li><strong>东京天空树</strong>（<em><a href=\"https://goo.gl/maps/g9785FpgnvT2\" target=\"_blank\" rel=\"noopener\">位置</a> / <a href=\"https://zh.wikipedia.org/zh-cn/%E6%9D%B1%E4%BA%AC%E6%99%B4%E7%A9%BA%E5%A1%94\" target=\"_blank\" rel=\"noopener\">百科</a></em>）：</li>\n</ol>\n<p><img src=\"19.jpg\" alt></p>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/taDVPzjQsB22\" target=\"_blank\" rel=\"noopener\">步行 / 0.8KM / 10min</a></p>\n</blockquote>\n<p>是位于日本东京都墨田区的电波塔，由东武铁道及其子公司东武塔晴空塔共同筹建，于2008年7月14日动工，2012年2月29日完工、同年5月22日正式启用。其高度为634米，于2011年11月17日获得吉尼斯世界纪录认证为“世界第一高塔”，成为全世界最高的自立式塔形建筑；目前亦为世界第二高的人工构造物，仅次于哈里发塔。</p>\n<h4 id=\"美食：-2\"><a href=\"#美食：-2\" class=\"headerlink\" title=\"- 美食：\"></a>- 美食：</h4><p>-</p>\n<h4 id=\"住宿：-2\"><a href=\"#住宿：-2\" class=\"headerlink\" title=\"- 住宿：\"></a>- 住宿：</h4><blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/XQ6HHAzqpNx\" target=\"_blank\" rel=\"noopener\">浅草线 / 11min</a></p>\n</blockquote>\n<p>台东区：Asakusa Kuramae Hotel Yume Iroha （浅草藏前梦伊吕波经济型酒店）双人间 / ￥616.5</p>\n<h3 id=\"行程-Day4-3-26\"><a href=\"#行程-Day4-3-26\" class=\"headerlink\" title=\"行程 Day4 (3/26)\"></a><a name=\"4\">行程 Day4 (3/26)</a></h3><blockquote>\n<p>【酒店寄存行李】 交通：<a href=\"https://goo.gl/maps/HcA7s5Rp1RF2\" target=\"_blank\" rel=\"noopener\">大江户线 / 29min</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.odakyu.jp/sc/getting-around/enoshima_kamakura/\" target=\"_blank\" rel=\"noopener\">交通指南</a>；<a href=\"https://www.odakyu.jp/sc/passes/hakone_kamakura/\" target=\"_blank\" rel=\"noopener\">箱根镰仓周游券（3天）</a>；</p>\n</blockquote>\n<p>当天早起先去新宿的新酒店寄存行李，然后直接前往镰仓。晚上返程住新宿。</p>\n<h4 id=\"路线：-3\"><a href=\"#路线：-3\" class=\"headerlink\" title=\"- 路线：\"></a>- 路线：</h4><ol>\n<li><strong>江之岛</strong>（<em><a href=\"https://goo.gl/maps/KqvLRhN4WU62\" target=\"_blank\" rel=\"noopener\">位置</a> / <a href=\"https://zh.wikipedia.org/zh-cn/%E6%B1%9F%E4%B9%8B%E5%B3%B6\" target=\"_blank\" rel=\"noopener\">百科</a></em>）：</li>\n</ol>\n<p><img src=\"25.jpg\" alt></p>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/NjFkgFwMGAu\" target=\"_blank\" rel=\"noopener\">小田急线 - 小田急江之岛线 / 98min</a></p>\n</blockquote>\n<p>江之岛是湘南的代表景点，也是神奈川县指定史迹名胜（1960年开始）及日本百景（1927年）之一。交通机关的站名等多记为江ノ島，住居表示、公文等多使用“江の島”。有时也以古老的江岛神社（日本三大辩天之一）的“江岛”代表。本条目叙述的是陆连岛与地名的江之岛，但一般认知的观光地还包含对岸的片濑、鹄沼地区南部一带。</p>\n<ol start=\"2\">\n<li><strong>湘南海岸</strong>（<em><a href=\"https://goo.gl/maps/i7T8oXJgM212\" target=\"_blank\" rel=\"noopener\">位置</a></em>）：</li>\n</ol>\n<p><img src=\"26.jpg\" alt></p>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/NjFkgFwMGAu\" target=\"_blank\" rel=\"noopener\">步行 / 1.5KM / 19min</a></p>\n</blockquote>\n<p>湘南海岸（湘南海岸）是，神奈川县的湘南出区域，该区域被称为的茅崎从镰仓沿海地区和在沿海区域。</p>\n<p>长期开设日本海滩代表，是全国着名的冲浪点。它还显示在四季中熙熙攘攘的日期点。顺便说一句，134号公路沿着湘南海岸。</p>\n<ol start=\"3\">\n<li><strong>镰仓高校前站</strong>（<em><a href=\"https://goo.gl/maps/iJfoHGhSAGk\" target=\"_blank\" rel=\"noopener\">位置</a> / <a href=\"https://zh.wikipedia.org/zh-cn/%E9%8E%8C%E5%80%89%E9%AB%98%E6%A0%A1%E5%89%8D%E8%BB%8A%E7%AB%99\" target=\"_blank\" rel=\"noopener\">百科</a></em>）：</li>\n</ol>\n<p><img src=\"20.jpg\" alt></p>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/NjFkgFwMGAu\" target=\"_blank\" rel=\"noopener\">步行 / 2.7KM / 34min</a></p>\n</blockquote>\n<p>是一由江之岛电铁（江之电）所经营的铁路车站，位于日本神奈川县镰仓市境内，是江之岛电铁线沿线的一个无人车站。由于车站仅与七里滨（七里ヶ浜）的海岸线隔着国道134号相望，因此站在月台上即能眺望海边的风光。</p>\n<p>本站在1903年初设站时，原名日坂，并在1953年时根据紧邻的神奈川县立镰仓高等学校，改名为镰仓高校前。1997年时，因为车站所在地可以见到海景的优美风情，而成为首批入选“关东车站百选”的其中一个车站。</p>\n<p>车站周边有多部动漫、电视剧及广告等作品取景，特别是东侧的一处平交道，因为是同名漫画改编的电视动画《灌篮高手》（スラムダンク）主题曲以及《Tari Tari》动画场景之一，吸引不少该作品的爱好者到此探访拍照[1]，但有部分人士擅自闯入未开放的镰仓高校校园内拍照游玩，造成该校的困扰。</p>\n<ol start=\"4\">\n<li><strong>高德院</strong>（<em><a href=\"https://goo.gl/maps/LHEo1G69rVw\" target=\"_blank\" rel=\"noopener\">位置</a> / <a href=\"https://zh.wikipedia.org/zh-cn/%E9%AB%98%E5%BE%B7%E9%99%A2\" target=\"_blank\" rel=\"noopener\">百科</a></em>）：</li>\n</ol>\n<p><img src=\"24.jpg\" alt></p>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/UXGX7uBkDBJ2\" target=\"_blank\" rel=\"noopener\">江之岛电铁线 / 23min</a></p>\n</blockquote>\n<p>高德院位于日本神奈川县镰仓市的长谷，是一间佛教净土宗的寺院。供奉的本尊阿弥陀佛一般人称为“镰仓大佛”，坐落于大异山。开基（创立者）与开山（初代住持）均不明。</p>\n<p>这座寺院拥有日本最著名的佛像之一—大佛—一座高达11.3米，重约121吨的露天阿弥陀佛青铜塑像，它的尺寸在全日本仅次于位于奈良市东大寺的另一尊佛像。</p>\n<p>根据寺院有关青铜像建造的相关记载，这座塑像的历史可以追溯到1252年的镰仓时代。然而，并不清楚寺院记录中那座当时正在建造的塑像是否就是今天这座大佛像。这座佛像曾经位于一座寺庙建筑中，而原本容纳大佛的木质寺庙建筑毁于15世纪末室町时代的一场海啸，但佛像却保留了下来。</p>\n<ol start=\"5\">\n<li><strong>长谷寺</strong>（<em><a href=\"https://goo.gl/maps/cnrhLHDu5h92\" target=\"_blank\" rel=\"noopener\">位置</a></em>）：</li>\n</ol>\n<p><img src=\"23.jpg\" alt></p>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/VKDzUDtJTWo\" target=\"_blank\" rel=\"noopener\">步行 / 0.7KM / 9min</a></p>\n</blockquote>\n<p>是位在日本奈良县樱井市的寺院，真言宗丰山派总本山。山号“丰山”（ぶざん）。本尊十一面观音、开基（创立者）为道明。别称“花之御寺”。</p>\n<ol start=\"6\">\n<li><strong>鹤冈八幡宫</strong>（<em><a href=\"https://goo.gl/maps/trhdMFyGi562\" target=\"_blank\" rel=\"noopener\">位置</a></em>）：</li>\n</ol>\n<p><img src=\"22.jpg\" alt></p>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/VaYkVGmUsfK2\" target=\"_blank\" rel=\"noopener\">江之岛电铁线 / 26min</a></p>\n</blockquote>\n<p>是位于日本神奈川县镰仓市的神社。旧社格为国币中社（现神社本厅的别表神社）。武家源氏、镰仓武士之守护神。也称作镰仓八幡宫。公元1063年由源赖义由京都的石清水八幡宫劝请至由比之滨。此后，于公元1180年进入镰仓的幕府将军源赖朝将其移请至现址，并加以扩建，才成为日后镰仓幕府时期中心。</p>\n<h4 id=\"美食：-3\"><a href=\"#美食：-3\" class=\"headerlink\" title=\"- 美食：\"></a>- 美食：</h4><p>-</p>\n<h4 id=\"住宿：-3\"><a href=\"#住宿：-3\" class=\"headerlink\" title=\"- 住宿：\"></a>- 住宿：</h4><blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/cNgfndNJhzA2\" target=\"_blank\" rel=\"noopener\">镰仓站 - 藤泽站 / 江之岛电铁线 / 36min</a> -&gt; <a href=\"https://goo.gl/maps/H7ZosDWmSg22\" target=\"_blank\" rel=\"noopener\">藤泽站 - 新宿 / 小田急线 / 70min</a></p>\n</blockquote>\n<p>新宿区：Citadines Central Shinjuku Tokyo（馨乐庭中央东京新宿区酒店）双人间 / ￥1052</p>\n<h3 id=\"行程-Day5-3-27\"><a href=\"#行程-Day5-3-27\" class=\"headerlink\" title=\"行程 Day5 (3/27)\"></a><a name=\"5\">行程 Day5 (3/27)</a></h3><p><img src=\"27.png\" alt></p>\n<blockquote>\n<p><a href=\"https://www.odakyu.jp/sc/getting-around/hakone/\" target=\"_blank\" rel=\"noopener\">交通指南</a>；<a href=\"https://www.odakyu.jp/sc/passes/hakone_kamakura/\" target=\"_blank\" rel=\"noopener\">箱根镰仓周游券（3天）</a>；</p>\n</blockquote>\n<h4 id=\"路线：-4\"><a href=\"#路线：-4\" class=\"headerlink\" title=\"- 路线：\"></a>- 路线：</h4><ol>\n<li><strong>箱根汤本站</strong>（<em><a href=\"https://goo.gl/maps/g4L4YaPX7yj\" target=\"_blank\" rel=\"noopener\">位置</a></em>）：</li>\n</ol>\n<p><img src=\"21.jpg\" alt></p>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/SAZfg2J1fd82\" target=\"_blank\" rel=\"noopener\">小田急浪漫特快 / 95min</a></p>\n</blockquote>\n<p>自古已是温泉町，在江户时代设置箱根关。近代由于西武铁道集团与小田急电铁致力于观光开发而得到急速发展。箱根温泉是汤本、塔之泽、大平台、宫之下、小涌谷等地温泉的总称。</p>\n<ol start=\"2\">\n<li><strong>Emblem Flow Hakone 酒店寄存</strong>（<em><a href=\"https://goo.gl/maps/wAWgwPSWAF92\" target=\"_blank\" rel=\"noopener\">位置</a></em>）：</li>\n</ol>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/axQ5wKEUgFk\" target=\"_blank\" rel=\"noopener\">箱根登山线 / 37min</a></p>\n</blockquote>\n<ol start=\"3\">\n<li><strong>早云山站</strong>（<em><a href=\"https://goo.gl/maps/s7tFrFPZzZC2\" target=\"_blank\" rel=\"noopener\">位置</a></em>）：</li>\n</ol>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/rGtpgcYC1xr\" target=\"_blank\" rel=\"noopener\">箱根登山线 / 10min</a></p>\n</blockquote>\n<ol start=\"4\">\n<li><strong>大涌谷站</strong>（<em><a href=\"https://goo.gl/maps/A2vHp7KUkxL2\" target=\"_blank\" rel=\"noopener\">位置</a></em>）：</li>\n</ol>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/S3FEyt4Vxx52\" target=\"_blank\" rel=\"noopener\">箱根空中缆车 / 8min</a></p>\n</blockquote>\n<ol start=\"5\">\n<li><strong>桃园台站</strong>（<em><a href=\"https://goo.gl/maps/CkyELagfu4R2\" target=\"_blank\" rel=\"noopener\">位置</a></em>）：</li>\n</ol>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/JZaM8QTy19u\" target=\"_blank\" rel=\"noopener\">箱根空中缆车 / 16min</a></p>\n</blockquote>\n<ol start=\"6\">\n<li><strong>元箱根港</strong>（<em><a href=\"https://goo.gl/maps/ZnkiVduN4gu\" target=\"_blank\" rel=\"noopener\">位置</a></em>）：</li>\n</ol>\n<blockquote>\n<p>交通：箱根海盗船</p>\n</blockquote>\n<ol start=\"7\">\n<li><strong>箱根神社</strong>（<em><a href=\"https://goo.gl/maps/dHzUHdS1buF2\" target=\"_blank\" rel=\"noopener\">位置</a></em>）：</li>\n</ol>\n<p><img src=\"28.jpg\" alt></p>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/3hcHkHfLmzP2\" target=\"_blank\" rel=\"noopener\">步行 / 1KM / 14min</a></p>\n</blockquote>\n<h4 id=\"美食：-4\"><a href=\"#美食：-4\" class=\"headerlink\" title=\"- 美食：\"></a>- 美食：</h4><p>-</p>\n<h4 id=\"住宿：-4\"><a href=\"#住宿：-4\" class=\"headerlink\" title=\"- 住宿：\"></a>- 住宿：</h4><blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/bzH8jKf7jXT2\" target=\"_blank\" rel=\"noopener\">箱根町線：箱根口経由 -&gt; 箱根登山線 / 42分钟</a></p>\n</blockquote>\n<p>箱根：Emblem Flow Hakone / 双人间￥1092</p>\n<h3 id=\"行程-Day6-3-28\"><a href=\"#行程-Day6-3-28\" class=\"headerlink\" title=\"行程 Day6 (3/28)\"></a><a name=\"6\">行程 Day6 (3/28)</a></h3><ol>\n<li><strong>箱根美术馆</strong>（<em><a href=\"https://goo.gl/maps/3Z4FjVQGBKD2\" target=\"_blank\" rel=\"noopener\">位置</a></em>）：</li>\n</ol>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/AVEvzajWhBm\" target=\"_blank\" rel=\"noopener\">步行 / 0.65KM / 13min</a></p>\n</blockquote>\n<p>箱根美术馆是箱根地区最早建立的美术馆。昭和27年6月，由创始人岡田茂吉先生建立。主要展品为岡田茂吉先生收藏的中日古代陶瓷器。其中最古老的藏品历史可追溯到古坟时代。</p>\n<p>箱根美术馆的苔藓庭院是一绝，茶室楼阁山石花草，看似无心布置，却处处透露着日式的禅意。秋季枫叶变红，与绿苔形成鲜明的对比，能吸引大批游客。</p>\n<ol start=\"2\">\n<li><strong>POLA 美术馆</strong>（<em><a href=\"https://goo.gl/maps/SVsUGKz8jEx\" target=\"_blank\" rel=\"noopener\">位置</a></em>）：</li>\n</ol>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/qJX5qB2vZkM2\" target=\"_blank\" rel=\"noopener\">天悠～強羅小塚～湿生花園前 / 12min</a></p>\n</blockquote>\n<p>Pola Museum of Art 位于日本神奈川县箱根。它于2002年9月在富士箱根伊豆国立公园内开放。它收藏了 Pola 化妆品集团前负责人收购的超过9,500件作品，其中包括法国印象派和巴黎 École 的许多作品。引人注目的建筑是 Nikken Sekkei。</p>\n<ol start=\"3\">\n<li><strong>箱根小王子博物馆</strong>（<em><a href=\"https://goo.gl/maps/zxSsZ8e9bcy\" target=\"_blank\" rel=\"noopener\">位置</a></em>）：</li>\n</ol>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/yD9PWYThE1L2\" target=\"_blank\" rel=\"noopener\">天悠～強羅小塚～湿生花園前 / 4min</a></p>\n</blockquote>\n<p>箱根小王子博物馆（日语：箱根★サン＝テグジュペリ 星の王子さまミュージアム）是位于日本神奈川县箱根町仙石原的博物馆[1]，专门展出与《小王子》及其作者安东尼·迪·圣-修伯里有关的展品。该馆开幕于1999年6月29日，即圣修伯里诞生100周年之际。</p>\n<p>博物馆呈现了《小王子》书中的情节与人物，其中设有小王子及其B612星球的雕塑、“小王子庭院”、模仿1930年代时期的咖啡馆、模仿圣修伯里童年时期的教会、圣修伯里生平展示空间等等。馆内的礼品店出售《小王子》的相关商品。</p>\n<ol start=\"4\">\n<li><strong>箱根玻璃之森美术馆</strong>（<em><a href=\"https://goo.gl/maps/YNPhEHvaoZJ2\" target=\"_blank\" rel=\"noopener\">位置</a></em>）：</li>\n</ol>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/EWZZELi6TCR2\" target=\"_blank\" rel=\"noopener\">步行 / 0.85KM / 11min</a></p>\n</blockquote>\n<p>神奈川县的玻璃之森美术馆，坐落在箱根绵延的群山之中，主体建筑酷似欧洲中世纪贵族别墅，仿若童话世界。在这广阔的庭园里分布着美术馆、商店和咖啡厅。 美术馆里陈列着15世纪至19世纪期间威尼斯和现代威尼斯的作品约100件，它们是曾经让欧洲贵族为之疯狂的威尼斯玻璃艺术。此外，还公开展示了很多罗斯柴尔德家族传承下来的钴蓝高脚杯等贵重作品。最令人惊叹的是礼花树 Fontana 喷泉，阳光下熠熠生辉的礼花树，亮晶晶的树木、泉水、瀑布都是一粒一粒的玻璃球制成，整个美术馆都显得十分精致美好。 露天咖啡厅可观赏以中世纪威尼斯为形象的庭院，那里有正宗的坎佐纳器乐作品实况演奏。另外还有能体验玻璃工艺制作的体验工房。</p>\n<ol start=\"5\">\n<li><strong>Emblem Flow Hakone 酒店取行李</strong>：</li>\n</ol>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/Sf1ptiTDHLw\" target=\"_blank\" rel=\"noopener\">アウトレット～宮城野～天悠 / 13min</a></p>\n</blockquote>\n<ol start=\"6\">\n<li><strong>箱根汤本站</strong>：</li>\n</ol>\n<p>当日 15:30 前必须上车。</p>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/oz9sP91Y4CU2\" target=\"_blank\" rel=\"noopener\">箱根登山线 / 45min</a></p>\n</blockquote>\n<ol start=\"7\">\n<li><strong>新宿站</strong>：</li>\n</ol>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/9Pp7BVaNvFM2\" target=\"_blank\" rel=\"noopener\">小田急浪漫特快 / 99min</a></p>\n</blockquote>\n<ol start=\"8\">\n<li><strong>羽田国际机场</strong>（<em><a href=\"https://goo.gl/maps/E8rL54MhkUs\" target=\"_blank\" rel=\"noopener\">位置</a></em>）：</li>\n</ol>\n<blockquote>\n<p>交通：<a href=\"https://goo.gl/maps/Rq6qk8dDPKm\" target=\"_blank\" rel=\"noopener\">大江戶線 -&gt; 東京單軌電車 / 55min</a></p>\n</blockquote>\n<h3 id=\"附录资料\"><a href=\"#附录资料\" class=\"headerlink\" title=\"附录资料\"></a>附录资料</h3><h4 id=\"箱根地图：\"><a href=\"#箱根地图：\" class=\"headerlink\" title=\"箱根地图：\"></a><a name=\"7\">箱根地图：</a></h4><p><img src=\"29.png\" alt></p>\n<h4 id=\"江之岛-镰仓地图：\"><a href=\"#江之岛-镰仓地图：\" class=\"headerlink\" title=\"江之岛/镰仓地图：\"></a><a name=\"8\">江之岛/镰仓地图：</a></h4><p><img src=\"31.png\" alt></p>\n<h4 id=\"小田急线路线图：\"><a href=\"#小田急线路线图：\" class=\"headerlink\" title=\"小田急线路线图：\"></a><a name=\"9\">小田急线路线图：</a></h4><p><img src=\"30.png\" alt></p>\n"},{"title":"浅谈 SEO","intro":"最近一直在准备网站上线的相关事宜，发现除了网站本身内容之外，急需解决的一个问题就是网站的 SEO 问题。SEO 的中文全称叫做“搜索引擎优化”，其实简单来讲就是优化你的网站，让你的网站更容易在搜索引擎里被搜索到。这样的做的好处真是太多了，SEO 不仅会带来流量的提高，而且还会让网站变得越来越友好。","comments":1,"date":"2014-12-26T07:37:10.000Z","_content":"\n最近一直在准备网站上线的相关事宜，发现除了网站本身内容之外，急需解决的一个问题就是网站的 SEO 问题。SEO 的中文全称叫做“** 搜索引擎优化 **”，其实简单来讲就是优化你的网站，让你的网站更容易在搜索引擎里被搜索到。这样的做的好处真是太多了，SEO 不仅会带来流量的提高，而且还会让网站变得越来越友好。\n\n不过想要看到 SEO 的成效，还是要付出很大代价的，其中最大的代价就是时间了。相对于 SEO 还有一种方法能够迅速地让自己的网站排名在搜索引擎结果的最前面，那就是花费巨大金钱代价的“竞价排名”，也即“竞价推广”。其实“竞价排名”的过程很简单，就是站长付给搜索引擎提供商一定的金钱，然后搜索引擎会对你的网站进行搜索优化，使搜索排名靠前。这种方式真是“立竿见影”，只要给钱，立马见效。\n\n不过对于个人网站来说，“竞价排名”就显得没有必要了。SEO 是一门学问，并不是用金钱就可以解决的。而对于一个公司网站的长期发展来说，竞价排名只能成为一种紧急情况时的解决办法，而 SEO 才是其发展的根本。而一个专业的 SEO 工程师所需要的基础知识也是相当的多。从基本的 WEB 前端编程语言，到搜索引擎的原理，再到服务器的配置都能够看到可以进行 SEO 的影子。\n\n今天网站刚刚进行了 SEO 优化中的“URL 伪静态”，具体的成效还需要时间来检验。搜索引擎蜘蛛抓取网站页面是有一定时间的，有的网站一天抓取几万次，而有的网站几天才抓取一次。现在的搜索引擎更看重原创的内容，所以原创也是保持网站搜索排名的一个重要因素。\n\n我认为个人网站进行 SEO 是站长的一种负责任的态度。在 SEO 这个“漫漫长路”上，需要持续投入一个人的精力和毅力，才能走的更远。\n","source":"_posts/浅谈-SEO.md","raw":"---\ntitle: 浅谈 SEO\nintro: 最近一直在准备网站上线的相关事宜，发现除了网站本身内容之外，急需解决的一个问题就是网站的 SEO 问题。SEO 的中文全称叫做“搜索引擎优化”，其实简单来讲就是优化你的网站，让你的网站更容易在搜索引擎里被搜索到。这样的做的好处真是太多了，SEO 不仅会带来流量的提高，而且还会让网站变得越来越友好。\ncomments: true\ndate: 2014-12-26 15:37:10\ntags:\n- Web\n---\n\n最近一直在准备网站上线的相关事宜，发现除了网站本身内容之外，急需解决的一个问题就是网站的 SEO 问题。SEO 的中文全称叫做“** 搜索引擎优化 **”，其实简单来讲就是优化你的网站，让你的网站更容易在搜索引擎里被搜索到。这样的做的好处真是太多了，SEO 不仅会带来流量的提高，而且还会让网站变得越来越友好。\n\n不过想要看到 SEO 的成效，还是要付出很大代价的，其中最大的代价就是时间了。相对于 SEO 还有一种方法能够迅速地让自己的网站排名在搜索引擎结果的最前面，那就是花费巨大金钱代价的“竞价排名”，也即“竞价推广”。其实“竞价排名”的过程很简单，就是站长付给搜索引擎提供商一定的金钱，然后搜索引擎会对你的网站进行搜索优化，使搜索排名靠前。这种方式真是“立竿见影”，只要给钱，立马见效。\n\n不过对于个人网站来说，“竞价排名”就显得没有必要了。SEO 是一门学问，并不是用金钱就可以解决的。而对于一个公司网站的长期发展来说，竞价排名只能成为一种紧急情况时的解决办法，而 SEO 才是其发展的根本。而一个专业的 SEO 工程师所需要的基础知识也是相当的多。从基本的 WEB 前端编程语言，到搜索引擎的原理，再到服务器的配置都能够看到可以进行 SEO 的影子。\n\n今天网站刚刚进行了 SEO 优化中的“URL 伪静态”，具体的成效还需要时间来检验。搜索引擎蜘蛛抓取网站页面是有一定时间的，有的网站一天抓取几万次，而有的网站几天才抓取一次。现在的搜索引擎更看重原创的内容，所以原创也是保持网站搜索排名的一个重要因素。\n\n我认为个人网站进行 SEO 是站长的一种负责任的态度。在 SEO 这个“漫漫长路”上，需要持续投入一个人的精力和毅力，才能走的更远。\n","slug":"浅谈-SEO","published":1,"updated":"2019-02-03T15:02:24.769Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtbc007cknp2r0vflne0","content":"<p>最近一直在准备网站上线的相关事宜，发现除了网站本身内容之外，急需解决的一个问题就是网站的 SEO 问题。SEO 的中文全称叫做“<strong> 搜索引擎优化 </strong>”，其实简单来讲就是优化你的网站，让你的网站更容易在搜索引擎里被搜索到。这样的做的好处真是太多了，SEO 不仅会带来流量的提高，而且还会让网站变得越来越友好。</p>\n<p>不过想要看到 SEO 的成效，还是要付出很大代价的，其中最大的代价就是时间了。相对于 SEO 还有一种方法能够迅速地让自己的网站排名在搜索引擎结果的最前面，那就是花费巨大金钱代价的“竞价排名”，也即“竞价推广”。其实“竞价排名”的过程很简单，就是站长付给搜索引擎提供商一定的金钱，然后搜索引擎会对你的网站进行搜索优化，使搜索排名靠前。这种方式真是“立竿见影”，只要给钱，立马见效。</p>\n<p>不过对于个人网站来说，“竞价排名”就显得没有必要了。SEO 是一门学问，并不是用金钱就可以解决的。而对于一个公司网站的长期发展来说，竞价排名只能成为一种紧急情况时的解决办法，而 SEO 才是其发展的根本。而一个专业的 SEO 工程师所需要的基础知识也是相当的多。从基本的 WEB 前端编程语言，到搜索引擎的原理，再到服务器的配置都能够看到可以进行 SEO 的影子。</p>\n<p>今天网站刚刚进行了 SEO 优化中的“URL 伪静态”，具体的成效还需要时间来检验。搜索引擎蜘蛛抓取网站页面是有一定时间的，有的网站一天抓取几万次，而有的网站几天才抓取一次。现在的搜索引擎更看重原创的内容，所以原创也是保持网站搜索排名的一个重要因素。</p>\n<p>我认为个人网站进行 SEO 是站长的一种负责任的态度。在 SEO 这个“漫漫长路”上，需要持续投入一个人的精力和毅力，才能走的更远。</p>\n","site":{"data":{}},"id":"c0444b7bf5c8de5eac8ce4cc64145c7a","excerpt":"","more":"<p>最近一直在准备网站上线的相关事宜，发现除了网站本身内容之外，急需解决的一个问题就是网站的 SEO 问题。SEO 的中文全称叫做“<strong> 搜索引擎优化 </strong>”，其实简单来讲就是优化你的网站，让你的网站更容易在搜索引擎里被搜索到。这样的做的好处真是太多了，SEO 不仅会带来流量的提高，而且还会让网站变得越来越友好。</p>\n<p>不过想要看到 SEO 的成效，还是要付出很大代价的，其中最大的代价就是时间了。相对于 SEO 还有一种方法能够迅速地让自己的网站排名在搜索引擎结果的最前面，那就是花费巨大金钱代价的“竞价排名”，也即“竞价推广”。其实“竞价排名”的过程很简单，就是站长付给搜索引擎提供商一定的金钱，然后搜索引擎会对你的网站进行搜索优化，使搜索排名靠前。这种方式真是“立竿见影”，只要给钱，立马见效。</p>\n<p>不过对于个人网站来说，“竞价排名”就显得没有必要了。SEO 是一门学问，并不是用金钱就可以解决的。而对于一个公司网站的长期发展来说，竞价排名只能成为一种紧急情况时的解决办法，而 SEO 才是其发展的根本。而一个专业的 SEO 工程师所需要的基础知识也是相当的多。从基本的 WEB 前端编程语言，到搜索引擎的原理，再到服务器的配置都能够看到可以进行 SEO 的影子。</p>\n<p>今天网站刚刚进行了 SEO 优化中的“URL 伪静态”，具体的成效还需要时间来检验。搜索引擎蜘蛛抓取网站页面是有一定时间的，有的网站一天抓取几万次，而有的网站几天才抓取一次。现在的搜索引擎更看重原创的内容，所以原创也是保持网站搜索排名的一个重要因素。</p>\n<p>我认为个人网站进行 SEO 是站长的一种负责任的态度。在 SEO 这个“漫漫长路”上，需要持续投入一个人的精力和毅力，才能走的更远。</p>\n"},{"title":"浅谈 CORS：跨域资源共享","intro":"今天在公司做项目时遇到了这样一个问题：公司所有后端的数据接口都位于相同一二级域名不同三级域名的域名服务器上，例如业务处理位于域名“a.abc.com”的服务器上，而数据接口位于域名“b.abc.com”的服务器上，两者的域名有着相同的一二级域名和不同的三级域名，即两者不同源。而这时在业务处理层有一个需要用 AJAX 请求来调用数据接口的方法，那么现在问题来了。","comments":1,"date":"2015-08-11T15:06:19.000Z","_content":"\n今天在公司做项目时遇到了这样一个问题：公司所有后端的数据接口都位于相同一二级域名不同三级域名的域名服务器上，例如业务处理位于域名“a.abc.com”的服务器上，而数据接口位于域名“b.abc.com”的服务器上，两者的域名有着相同的一二级域名和不同的三级域名，即两者不同源。而这时在业务处理层有一个需要用 AJAX 请求来调用数据接口的方法，那么现在问题来了。\n\n由于业务处理和数据接口分别位于两个有着不同二级域名的服务器上，所以这时由“a.abc.com”发起的对“b.abc.com”的 AJAX 请求便会被“b.abc.com”拒绝，并且浏览器的 Console 控制台也会抛出相应的错误提示“No 'Access-Control-Allow-Origin' header is present on the requested resource.”。众所周知，这是由于浏览器的“同源策略”导致的。“同源策略”是指两个位于不同源的站点之间无法互相访问各自的 JS 脚本或者 Cookie 信息。而同源是指：域名，协议，以及端口相同。\n\n“同源策略”的出现是为了保障 Web 的安全考虑，也是浏览器最核心的基本特性。虽然“同源策略”带来了 Web 安全性上的提升，但同时也导致了 AJAX 无法同时向不同源的服务器请求数据，因此开发人员也想出了一些技术来解决“同源策略”带来的“问题”，比如 Jsonp、XHR2 等技术。但毕竟不是专为“跨域”提供的解决方案，所以从各个方面来讲这些技术并不能作为解决该问题的最好标准。\n\n无独有偶，W3C 在最近的草案中发布了专门为解决“同源问题”的技术 — “**CORS**”，CORS(Cross Origin Resource Sharing) 全名为“跨域资源共享”。CORS 使用起来非常简单，只需要服务器端向来自非同源的 AJAX 请求返回一个特定的响应标头即可通过跨域进行正常的访问。比如在含有数据接口的 PHP 页面中包含以下语句即可实现 AJAX 的跨域资源请求。\n\n```php\n    header(\"Access-Control-Allow-Origin：*\");\n```\n\n这里代码中的“\\*”号表示接受来自所有域名的请求，但这样做会存在安全性问题，所以并不推荐。只需将“*”改为需要发送请求的它特定域名，例如上文中提到的“a.abc.com”即可实现较为安全的跨域资源请求。现在的大部分浏览器已经支持 CORS，所以可以放心大胆的使用了。\n","source":"_posts/浅谈-CORS：跨域资源共享.md","raw":"---\ntitle: 浅谈 CORS：跨域资源共享\nintro: 今天在公司做项目时遇到了这样一个问题：公司所有后端的数据接口都位于相同一二级域名不同三级域名的域名服务器上，例如业务处理位于域名“a.abc.com”的服务器上，而数据接口位于域名“b.abc.com”的服务器上，两者的域名有着相同的一二级域名和不同的三级域名，即两者不同源。而这时在业务处理层有一个需要用 AJAX 请求来调用数据接口的方法，那么现在问题来了。\ncomments: true\ndate: 2015-08-11 23:06:19\ntags:\n- HTTP\n---\n\n今天在公司做项目时遇到了这样一个问题：公司所有后端的数据接口都位于相同一二级域名不同三级域名的域名服务器上，例如业务处理位于域名“a.abc.com”的服务器上，而数据接口位于域名“b.abc.com”的服务器上，两者的域名有着相同的一二级域名和不同的三级域名，即两者不同源。而这时在业务处理层有一个需要用 AJAX 请求来调用数据接口的方法，那么现在问题来了。\n\n由于业务处理和数据接口分别位于两个有着不同二级域名的服务器上，所以这时由“a.abc.com”发起的对“b.abc.com”的 AJAX 请求便会被“b.abc.com”拒绝，并且浏览器的 Console 控制台也会抛出相应的错误提示“No 'Access-Control-Allow-Origin' header is present on the requested resource.”。众所周知，这是由于浏览器的“同源策略”导致的。“同源策略”是指两个位于不同源的站点之间无法互相访问各自的 JS 脚本或者 Cookie 信息。而同源是指：域名，协议，以及端口相同。\n\n“同源策略”的出现是为了保障 Web 的安全考虑，也是浏览器最核心的基本特性。虽然“同源策略”带来了 Web 安全性上的提升，但同时也导致了 AJAX 无法同时向不同源的服务器请求数据，因此开发人员也想出了一些技术来解决“同源策略”带来的“问题”，比如 Jsonp、XHR2 等技术。但毕竟不是专为“跨域”提供的解决方案，所以从各个方面来讲这些技术并不能作为解决该问题的最好标准。\n\n无独有偶，W3C 在最近的草案中发布了专门为解决“同源问题”的技术 — “**CORS**”，CORS(Cross Origin Resource Sharing) 全名为“跨域资源共享”。CORS 使用起来非常简单，只需要服务器端向来自非同源的 AJAX 请求返回一个特定的响应标头即可通过跨域进行正常的访问。比如在含有数据接口的 PHP 页面中包含以下语句即可实现 AJAX 的跨域资源请求。\n\n```php\n    header(\"Access-Control-Allow-Origin：*\");\n```\n\n这里代码中的“\\*”号表示接受来自所有域名的请求，但这样做会存在安全性问题，所以并不推荐。只需将“*”改为需要发送请求的它特定域名，例如上文中提到的“a.abc.com”即可实现较为安全的跨域资源请求。现在的大部分浏览器已经支持 CORS，所以可以放心大胆的使用了。\n","slug":"浅谈-CORS：跨域资源共享","published":1,"updated":"2019-02-04T16:25:36.021Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtbd007fknp2qkhg5u1y","content":"<p>今天在公司做项目时遇到了这样一个问题：公司所有后端的数据接口都位于相同一二级域名不同三级域名的域名服务器上，例如业务处理位于域名“a.abc.com”的服务器上，而数据接口位于域名“b.abc.com”的服务器上，两者的域名有着相同的一二级域名和不同的三级域名，即两者不同源。而这时在业务处理层有一个需要用 AJAX 请求来调用数据接口的方法，那么现在问题来了。</p>\n<p>由于业务处理和数据接口分别位于两个有着不同二级域名的服务器上，所以这时由“a.abc.com”发起的对“b.abc.com”的 AJAX 请求便会被“b.abc.com”拒绝，并且浏览器的 Console 控制台也会抛出相应的错误提示“No ‘Access-Control-Allow-Origin’ header is present on the requested resource.”。众所周知，这是由于浏览器的“同源策略”导致的。“同源策略”是指两个位于不同源的站点之间无法互相访问各自的 JS 脚本或者 Cookie 信息。而同源是指：域名，协议，以及端口相同。</p>\n<p>“同源策略”的出现是为了保障 Web 的安全考虑，也是浏览器最核心的基本特性。虽然“同源策略”带来了 Web 安全性上的提升，但同时也导致了 AJAX 无法同时向不同源的服务器请求数据，因此开发人员也想出了一些技术来解决“同源策略”带来的“问题”，比如 Jsonp、XHR2 等技术。但毕竟不是专为“跨域”提供的解决方案，所以从各个方面来讲这些技术并不能作为解决该问题的最好标准。</p>\n<p>无独有偶，W3C 在最近的草案中发布了专门为解决“同源问题”的技术 — “<strong>CORS</strong>”，CORS(Cross Origin Resource Sharing) 全名为“跨域资源共享”。CORS 使用起来非常简单，只需要服务器端向来自非同源的 AJAX 请求返回一个特定的响应标头即可通过跨域进行正常的访问。比如在含有数据接口的 PHP 页面中包含以下语句即可实现 AJAX 的跨域资源请求。</p>\n<pre class=\"line-numbers language-php\"><code class=\"language-php\">    <span class=\"token function\">header</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Access-Control-Allow-Origin：*\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>这里代码中的“*”号表示接受来自所有域名的请求，但这样做会存在安全性问题，所以并不推荐。只需将“*”改为需要发送请求的它特定域名，例如上文中提到的“a.abc.com”即可实现较为安全的跨域资源请求。现在的大部分浏览器已经支持 CORS，所以可以放心大胆的使用了。</p>\n","site":{"data":{}},"id":"6b5cb6e20823a1103d035554f99959bb","excerpt":"","more":"<p>今天在公司做项目时遇到了这样一个问题：公司所有后端的数据接口都位于相同一二级域名不同三级域名的域名服务器上，例如业务处理位于域名“a.abc.com”的服务器上，而数据接口位于域名“b.abc.com”的服务器上，两者的域名有着相同的一二级域名和不同的三级域名，即两者不同源。而这时在业务处理层有一个需要用 AJAX 请求来调用数据接口的方法，那么现在问题来了。</p>\n<p>由于业务处理和数据接口分别位于两个有着不同二级域名的服务器上，所以这时由“a.abc.com”发起的对“b.abc.com”的 AJAX 请求便会被“b.abc.com”拒绝，并且浏览器的 Console 控制台也会抛出相应的错误提示“No ‘Access-Control-Allow-Origin’ header is present on the requested resource.”。众所周知，这是由于浏览器的“同源策略”导致的。“同源策略”是指两个位于不同源的站点之间无法互相访问各自的 JS 脚本或者 Cookie 信息。而同源是指：域名，协议，以及端口相同。</p>\n<p>“同源策略”的出现是为了保障 Web 的安全考虑，也是浏览器最核心的基本特性。虽然“同源策略”带来了 Web 安全性上的提升，但同时也导致了 AJAX 无法同时向不同源的服务器请求数据，因此开发人员也想出了一些技术来解决“同源策略”带来的“问题”，比如 Jsonp、XHR2 等技术。但毕竟不是专为“跨域”提供的解决方案，所以从各个方面来讲这些技术并不能作为解决该问题的最好标准。</p>\n<p>无独有偶，W3C 在最近的草案中发布了专门为解决“同源问题”的技术 — “<strong>CORS</strong>”，CORS(Cross Origin Resource Sharing) 全名为“跨域资源共享”。CORS 使用起来非常简单，只需要服务器端向来自非同源的 AJAX 请求返回一个特定的响应标头即可通过跨域进行正常的访问。比如在含有数据接口的 PHP 页面中包含以下语句即可实现 AJAX 的跨域资源请求。</p>\n<pre><code class=\"php\">    header(&quot;Access-Control-Allow-Origin：*&quot;);\n</code></pre>\n<p>这里代码中的“*”号表示接受来自所有域名的请求，但这样做会存在安全性问题，所以并不推荐。只需将“*”改为需要发送请求的它特定域名，例如上文中提到的“a.abc.com”即可实现较为安全的跨域资源请求。现在的大部分浏览器已经支持 CORS，所以可以放心大胆的使用了。</p>\n"},{"title":"淘宝网的 BigRender","intro":"在上一篇博客里我们讲到了来自 Facebook 的 BigPipe 技术是怎样通过减少请求数量，同时使浏览器和服务器可以并行处理来达到最大程度提升首屏加载效率的目的的。而相对的，淘宝网的 BigRender 技术则是一次性从服务器将资源全部输出，那么他是如何效仿 BigPipe 技术的呢？","comments":1,"date":"2017-04-26T01:24:55.000Z","_content":"\n在上一篇博客里我们讲到了来自 Facebook 的 BigPipe 技术是怎样通过减少请求数量，同时使浏览器和服务器可以并行处理来达到最大程度提升首屏加载效率的目的的。而相对的，淘宝网的 BigRender 技术则是一次性从服务器将资源全部输出，那么他是如何效仿 BigPipe 技术的呢？\n\nBigPipe 技术的整体思路是先输出页面整体布局，然后逐步输出脚本块，一边输出一边执行，将内容渲染回页面布局中。这样可以让服务端的运算、网络传输和浏览器端的渲染变成并行。BigPipe 最主要解决的问题是服务端的运算时间，当服务端的运算时间大于 300~500ms 时才能体现出优势。当服务端响应非常快（小于100ms），BigPipe 则退化为下面要讲的 BigRender。\n\nBigRender 的思路是将首屏需要渲染的 DOM 数量降为最少，把那些区块的细节内容放到首屏加载之后再逐步渲染出来。而这些需要延迟渲染的内容会全部以 HTML 的形式放到页面中的一个隐藏的 **textarea** 中作为值保存起来。\n\n那么为什么要使用 textarea 作为非首屏加载的 HTML 代码的存放容器呢？因为 textarea 是一种 RCDATA 类型的 HTML 元素。RCDATA 的解析规则可以使我们避免遇到在处理字符转义上的问题。并且获取一个 textarea 元素里的内容也十分简单方便。\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <title></title>\n    <style type=\"text/css\">\n        [lazy-render] {\n            display: none;\n        }\n    </style>\n</head>\n<body>\n<div id=\"sidebar\"></div>\n<div id=\"main\"></div>\n<textarea id=\"render-main\" lazy-render>\n    <p>Main Content</p>\n    <ul>\n      <li>Coffee</li>\n      <li>Tea</li>\n      <li>Milk</li>\n    </ul>\n</textarea>\n<textarea id=\"render-sidebar\" lazy-render>\n    <p>Sidebar Content</p>\n    <ul>\n      <li>Apple</li>\n      <li>Banana</li>\n      <li>Orange</li>\n    </ul>\n</textarea>\n\n<script>\n    // DOM 加载完毕后开始渲染；\n    document.addEventListener(\"DOMContentLoaded\", function() {\n      // 控制渲染的间隔，防止重绘与回流引起页面的卡顿；\n      var renderList = [\"main\", \"sidebar\"];\n\n      renderList.forEach(function(i, index) {\n        setTimeout(function() {\n          document.getElementById(i).innerHTML = document.getElementById(\"render-\" + i).value;\n        }, 1000 + index * 1000);\n      });\n    });\n</script>\n</body>\n</html>\n```\n\n","source":"_posts/淘宝网的-BigRender.md","raw":"---\ntitle: 淘宝网的 BigRender\nintro: 在上一篇博客里我们讲到了来自 Facebook 的 BigPipe 技术是怎样通过减少请求数量，同时使浏览器和服务器可以并行处理来达到最大程度提升首屏加载效率的目的的。而相对的，淘宝网的 BigRender 技术则是一次性从服务器将资源全部输出，那么他是如何效仿 BigPipe 技术的呢？\ncomments: true\ndate: 2017-04-26 09:24:55\ntags:\n- JavaScript\n- BigRender\n---\n\n在上一篇博客里我们讲到了来自 Facebook 的 BigPipe 技术是怎样通过减少请求数量，同时使浏览器和服务器可以并行处理来达到最大程度提升首屏加载效率的目的的。而相对的，淘宝网的 BigRender 技术则是一次性从服务器将资源全部输出，那么他是如何效仿 BigPipe 技术的呢？\n\nBigPipe 技术的整体思路是先输出页面整体布局，然后逐步输出脚本块，一边输出一边执行，将内容渲染回页面布局中。这样可以让服务端的运算、网络传输和浏览器端的渲染变成并行。BigPipe 最主要解决的问题是服务端的运算时间，当服务端的运算时间大于 300~500ms 时才能体现出优势。当服务端响应非常快（小于100ms），BigPipe 则退化为下面要讲的 BigRender。\n\nBigRender 的思路是将首屏需要渲染的 DOM 数量降为最少，把那些区块的细节内容放到首屏加载之后再逐步渲染出来。而这些需要延迟渲染的内容会全部以 HTML 的形式放到页面中的一个隐藏的 **textarea** 中作为值保存起来。\n\n那么为什么要使用 textarea 作为非首屏加载的 HTML 代码的存放容器呢？因为 textarea 是一种 RCDATA 类型的 HTML 元素。RCDATA 的解析规则可以使我们避免遇到在处理字符转义上的问题。并且获取一个 textarea 元素里的内容也十分简单方便。\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <title></title>\n    <style type=\"text/css\">\n        [lazy-render] {\n            display: none;\n        }\n    </style>\n</head>\n<body>\n<div id=\"sidebar\"></div>\n<div id=\"main\"></div>\n<textarea id=\"render-main\" lazy-render>\n    <p>Main Content</p>\n    <ul>\n      <li>Coffee</li>\n      <li>Tea</li>\n      <li>Milk</li>\n    </ul>\n</textarea>\n<textarea id=\"render-sidebar\" lazy-render>\n    <p>Sidebar Content</p>\n    <ul>\n      <li>Apple</li>\n      <li>Banana</li>\n      <li>Orange</li>\n    </ul>\n</textarea>\n\n<script>\n    // DOM 加载完毕后开始渲染；\n    document.addEventListener(\"DOMContentLoaded\", function() {\n      // 控制渲染的间隔，防止重绘与回流引起页面的卡顿；\n      var renderList = [\"main\", \"sidebar\"];\n\n      renderList.forEach(function(i, index) {\n        setTimeout(function() {\n          document.getElementById(i).innerHTML = document.getElementById(\"render-\" + i).value;\n        }, 1000 + index * 1000);\n      });\n    });\n</script>\n</body>\n</html>\n```\n\n","slug":"淘宝网的-BigRender","published":1,"updated":"2019-02-17T14:49:16.102Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtbe007hknp25xwvom0b","content":"<p>在上一篇博客里我们讲到了来自 Facebook 的 BigPipe 技术是怎样通过减少请求数量，同时使浏览器和服务器可以并行处理来达到最大程度提升首屏加载效率的目的的。而相对的，淘宝网的 BigRender 技术则是一次性从服务器将资源全部输出，那么他是如何效仿 BigPipe 技术的呢？</p>\n<p>BigPipe 技术的整体思路是先输出页面整体布局，然后逐步输出脚本块，一边输出一边执行，将内容渲染回页面布局中。这样可以让服务端的运算、网络传输和浏览器端的渲染变成并行。BigPipe 最主要解决的问题是服务端的运算时间，当服务端的运算时间大于 300~500ms 时才能体现出优势。当服务端响应非常快（小于100ms），BigPipe 则退化为下面要讲的 BigRender。</p>\n<p>BigRender 的思路是将首屏需要渲染的 DOM 数量降为最少，把那些区块的细节内容放到首屏加载之后再逐步渲染出来。而这些需要延迟渲染的内容会全部以 HTML 的形式放到页面中的一个隐藏的 <strong>textarea</strong> 中作为值保存起来。</p>\n<p>那么为什么要使用 textarea 作为非首屏加载的 HTML 代码的存放容器呢？因为 textarea 是一种 RCDATA 类型的 HTML 元素。RCDATA 的解析规则可以使我们避免遇到在处理字符转义上的问题。并且获取一个 textarea 元素里的内容也十分简单方便。</p>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token doctype\">&lt;!DOCTYPE html></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>html</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>head</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>title</span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>title</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>style</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>text/css<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token style language-css\">\n        <span class=\"token selector\"><span class=\"token attribute\">[lazy-render]</span> </span><span class=\"token punctuation\">{</span>\n            <span class=\"token property\">display</span><span class=\"token punctuation\">:</span> none<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>style</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>head</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>body</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>sidebar<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>main<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>textarea</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>render-main<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">lazy-render</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span>Main Content<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>ul</span><span class=\"token punctuation\">></span></span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>li</span><span class=\"token punctuation\">></span></span>Coffee<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>li</span><span class=\"token punctuation\">></span></span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>li</span><span class=\"token punctuation\">></span></span>Tea<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>li</span><span class=\"token punctuation\">></span></span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>li</span><span class=\"token punctuation\">></span></span>Milk<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>li</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>ul</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>textarea</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>textarea</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>render-sidebar<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">lazy-render</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span>Sidebar Content<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>ul</span><span class=\"token punctuation\">></span></span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>li</span><span class=\"token punctuation\">></span></span>Apple<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>li</span><span class=\"token punctuation\">></span></span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>li</span><span class=\"token punctuation\">></span></span>Banana<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>li</span><span class=\"token punctuation\">></span></span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>li</span><span class=\"token punctuation\">></span></span>Orange<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>li</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>ul</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>textarea</span><span class=\"token punctuation\">></span></span>\n\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span><span class=\"token punctuation\">></span></span><span class=\"token script language-javascript\">\n    <span class=\"token comment\" spellcheck=\"true\">// DOM 加载完毕后开始渲染；</span>\n    document<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"DOMContentLoaded\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 控制渲染的间隔，防止重绘与回流引起页面的卡顿；</span>\n      <span class=\"token keyword\">var</span> renderList <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"main\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"sidebar\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n      renderList<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>innerHTML <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"render-\"</span> <span class=\"token operator\">+</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span> <span class=\"token operator\">+</span> index <span class=\"token operator\">*</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>body</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>html</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"id":"e67b2ec50e8ff1741b7c3630e49b2f2f","excerpt":"","more":"<p>在上一篇博客里我们讲到了来自 Facebook 的 BigPipe 技术是怎样通过减少请求数量，同时使浏览器和服务器可以并行处理来达到最大程度提升首屏加载效率的目的的。而相对的，淘宝网的 BigRender 技术则是一次性从服务器将资源全部输出，那么他是如何效仿 BigPipe 技术的呢？</p>\n<p>BigPipe 技术的整体思路是先输出页面整体布局，然后逐步输出脚本块，一边输出一边执行，将内容渲染回页面布局中。这样可以让服务端的运算、网络传输和浏览器端的渲染变成并行。BigPipe 最主要解决的问题是服务端的运算时间，当服务端的运算时间大于 300~500ms 时才能体现出优势。当服务端响应非常快（小于100ms），BigPipe 则退化为下面要讲的 BigRender。</p>\n<p>BigRender 的思路是将首屏需要渲染的 DOM 数量降为最少，把那些区块的细节内容放到首屏加载之后再逐步渲染出来。而这些需要延迟渲染的内容会全部以 HTML 的形式放到页面中的一个隐藏的 <strong>textarea</strong> 中作为值保存起来。</p>\n<p>那么为什么要使用 textarea 作为非首屏加载的 HTML 代码的存放容器呢？因为 textarea 是一种 RCDATA 类型的 HTML 元素。RCDATA 的解析规则可以使我们避免遇到在处理字符转义上的问题。并且获取一个 textarea 元素里的内容也十分简单方便。</p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;&lt;/title&gt;\n    &lt;style type=&quot;text/css&quot;&gt;\n        [lazy-render] {\n            display: none;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div id=&quot;sidebar&quot;&gt;&lt;/div&gt;\n&lt;div id=&quot;main&quot;&gt;&lt;/div&gt;\n&lt;textarea id=&quot;render-main&quot; lazy-render&gt;\n    &lt;p&gt;Main Content&lt;/p&gt;\n    &lt;ul&gt;\n      &lt;li&gt;Coffee&lt;/li&gt;\n      &lt;li&gt;Tea&lt;/li&gt;\n      &lt;li&gt;Milk&lt;/li&gt;\n    &lt;/ul&gt;\n&lt;/textarea&gt;\n&lt;textarea id=&quot;render-sidebar&quot; lazy-render&gt;\n    &lt;p&gt;Sidebar Content&lt;/p&gt;\n    &lt;ul&gt;\n      &lt;li&gt;Apple&lt;/li&gt;\n      &lt;li&gt;Banana&lt;/li&gt;\n      &lt;li&gt;Orange&lt;/li&gt;\n    &lt;/ul&gt;\n&lt;/textarea&gt;\n\n&lt;script&gt;\n    // DOM 加载完毕后开始渲染；\n    document.addEventListener(&quot;DOMContentLoaded&quot;, function() {\n      // 控制渲染的间隔，防止重绘与回流引起页面的卡顿；\n      var renderList = [&quot;main&quot;, &quot;sidebar&quot;];\n\n      renderList.forEach(function(i, index) {\n        setTimeout(function() {\n          document.getElementById(i).innerHTML = document.getElementById(&quot;render-&quot; + i).value;\n        }, 1000 + index * 1000);\n      });\n    });\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n"},{"title":"深夜吐槽 - 笔试与企业文化","intro":"2015年的7月1日，航哥就要从大学校园生活走入社会了，时间很快，一转眼要毕业了。从去年的十二月初开始，我就开始一直在找工作了。虽然申请的公司并不是很多，但是大大小小也经历了四五次笔试和面试。从这些不同企业的笔试题目中，我也感受到了不同企业面试文化之间的区别。","comments":1,"date":"2015-01-06T14:37:20.000Z","_content":"\n2015年的7月1日，航哥就要从大学校园生活走入社会了，时间很快，一转眼要毕业了。从去年的十二月初开始，我就开始一直在找工作了。虽然申请的公司并不是很多，但是大大小小也经历了四五次笔试和面试。从这些不同企业的笔试题目中，我也感受到了不同企业面试文化之间的区别。\n\n其实当初也投了不少公司的技术岗位，但是并没有全部都收到接下来的面试或者笔试邀请。只能说是因为自己的技术能力还不够，无法达到企业的用人要求。不过在这些收到笔试的企业中，既有国外的全球20强名企，也有国内刚刚成立的不到500人的小企业。同样是笔试环节，他们所考验一个人的能力层面是不一样的。\n\n小型企业大多刚刚成立，时间一般不超过3年。整个企业正处于一个快速发展扩张的时间段。他们更需要能够直接上手进行项目开发，不需要或者很少需要培训的人。哪怕这些人的能力并没有那些已经工作了五六年的“老手”能力强。因为企业相信，随着时间积累，他们的能力在“老手”的带领下会很快的跟上来，而前提是他们已经有了一定的开发基础。即小型企业更期望得到“编程技能”强的人。换句话说，“**编程技巧**”指的就是“单纯懂得或能够熟练的应用开发规范来开发应用程序并实现其基本功能的能力”。\n\n而大型企业，一般成立时间超过十年。整个企业的企业文化已经有了很浓的积淀。业务运行稳定，部门的分配也很明确，他们已经从“扩张”阶段转向了“积淀”阶段，所谓“积淀”就是指开发自己独有的产品。“你们企业有的，我也有了。你们企业没有的，我也有。”因此，大型企业的技术岗位招聘，更喜欢“程序设计能力”强的人，简单来讲就是“算法设计能力强”的人。“算法是程序的灵魂”，“编程技巧”编写的是程序的外壳，而算法才是程序的核心。\n\n其实航哥也想去大企业，但是只因算法能力太薄弱，估计暂时与大企业无缘。希望以后还能够有机会去大企业见见世面。应用编程和算法设计是计算机领域里的两个方面，但是也只有这两个方面同时结合在一起才能发挥两者的最大作用。PS：想要学习算法的推荐经典书籍《算法导论》\n","source":"_posts/深夜吐槽-笔试与企业文化.md","raw":"---\ntitle: 深夜吐槽 - 笔试与企业文化\nintro: 2015年的7月1日，航哥就要从大学校园生活走入社会了，时间很快，一转眼要毕业了。从去年的十二月初开始，我就开始一直在找工作了。虽然申请的公司并不是很多，但是大大小小也经历了四五次笔试和面试。从这些不同企业的笔试题目中，我也感受到了不同企业面试文化之间的区别。\ncomments: true\ndate: 2015-01-06 22:37:20\ntags:\n- 互联网\n---\n\n2015年的7月1日，航哥就要从大学校园生活走入社会了，时间很快，一转眼要毕业了。从去年的十二月初开始，我就开始一直在找工作了。虽然申请的公司并不是很多，但是大大小小也经历了四五次笔试和面试。从这些不同企业的笔试题目中，我也感受到了不同企业面试文化之间的区别。\n\n其实当初也投了不少公司的技术岗位，但是并没有全部都收到接下来的面试或者笔试邀请。只能说是因为自己的技术能力还不够，无法达到企业的用人要求。不过在这些收到笔试的企业中，既有国外的全球20强名企，也有国内刚刚成立的不到500人的小企业。同样是笔试环节，他们所考验一个人的能力层面是不一样的。\n\n小型企业大多刚刚成立，时间一般不超过3年。整个企业正处于一个快速发展扩张的时间段。他们更需要能够直接上手进行项目开发，不需要或者很少需要培训的人。哪怕这些人的能力并没有那些已经工作了五六年的“老手”能力强。因为企业相信，随着时间积累，他们的能力在“老手”的带领下会很快的跟上来，而前提是他们已经有了一定的开发基础。即小型企业更期望得到“编程技能”强的人。换句话说，“**编程技巧**”指的就是“单纯懂得或能够熟练的应用开发规范来开发应用程序并实现其基本功能的能力”。\n\n而大型企业，一般成立时间超过十年。整个企业的企业文化已经有了很浓的积淀。业务运行稳定，部门的分配也很明确，他们已经从“扩张”阶段转向了“积淀”阶段，所谓“积淀”就是指开发自己独有的产品。“你们企业有的，我也有了。你们企业没有的，我也有。”因此，大型企业的技术岗位招聘，更喜欢“程序设计能力”强的人，简单来讲就是“算法设计能力强”的人。“算法是程序的灵魂”，“编程技巧”编写的是程序的外壳，而算法才是程序的核心。\n\n其实航哥也想去大企业，但是只因算法能力太薄弱，估计暂时与大企业无缘。希望以后还能够有机会去大企业见见世面。应用编程和算法设计是计算机领域里的两个方面，但是也只有这两个方面同时结合在一起才能发挥两者的最大作用。PS：想要学习算法的推荐经典书籍《算法导论》\n","slug":"深夜吐槽-笔试与企业文化","published":1,"updated":"2019-02-04T05:10:49.162Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtbf007kknp244qz1bb5","content":"<p>2015年的7月1日，航哥就要从大学校园生活走入社会了，时间很快，一转眼要毕业了。从去年的十二月初开始，我就开始一直在找工作了。虽然申请的公司并不是很多，但是大大小小也经历了四五次笔试和面试。从这些不同企业的笔试题目中，我也感受到了不同企业面试文化之间的区别。</p>\n<p>其实当初也投了不少公司的技术岗位，但是并没有全部都收到接下来的面试或者笔试邀请。只能说是因为自己的技术能力还不够，无法达到企业的用人要求。不过在这些收到笔试的企业中，既有国外的全球20强名企，也有国内刚刚成立的不到500人的小企业。同样是笔试环节，他们所考验一个人的能力层面是不一样的。</p>\n<p>小型企业大多刚刚成立，时间一般不超过3年。整个企业正处于一个快速发展扩张的时间段。他们更需要能够直接上手进行项目开发，不需要或者很少需要培训的人。哪怕这些人的能力并没有那些已经工作了五六年的“老手”能力强。因为企业相信，随着时间积累，他们的能力在“老手”的带领下会很快的跟上来，而前提是他们已经有了一定的开发基础。即小型企业更期望得到“编程技能”强的人。换句话说，“<strong>编程技巧</strong>”指的就是“单纯懂得或能够熟练的应用开发规范来开发应用程序并实现其基本功能的能力”。</p>\n<p>而大型企业，一般成立时间超过十年。整个企业的企业文化已经有了很浓的积淀。业务运行稳定，部门的分配也很明确，他们已经从“扩张”阶段转向了“积淀”阶段，所谓“积淀”就是指开发自己独有的产品。“你们企业有的，我也有了。你们企业没有的，我也有。”因此，大型企业的技术岗位招聘，更喜欢“程序设计能力”强的人，简单来讲就是“算法设计能力强”的人。“算法是程序的灵魂”，“编程技巧”编写的是程序的外壳，而算法才是程序的核心。</p>\n<p>其实航哥也想去大企业，但是只因算法能力太薄弱，估计暂时与大企业无缘。希望以后还能够有机会去大企业见见世面。应用编程和算法设计是计算机领域里的两个方面，但是也只有这两个方面同时结合在一起才能发挥两者的最大作用。PS：想要学习算法的推荐经典书籍《算法导论》</p>\n","site":{"data":{}},"id":"f18cc377c5590f86b8a8e31915590936","excerpt":"","more":"<p>2015年的7月1日，航哥就要从大学校园生活走入社会了，时间很快，一转眼要毕业了。从去年的十二月初开始，我就开始一直在找工作了。虽然申请的公司并不是很多，但是大大小小也经历了四五次笔试和面试。从这些不同企业的笔试题目中，我也感受到了不同企业面试文化之间的区别。</p>\n<p>其实当初也投了不少公司的技术岗位，但是并没有全部都收到接下来的面试或者笔试邀请。只能说是因为自己的技术能力还不够，无法达到企业的用人要求。不过在这些收到笔试的企业中，既有国外的全球20强名企，也有国内刚刚成立的不到500人的小企业。同样是笔试环节，他们所考验一个人的能力层面是不一样的。</p>\n<p>小型企业大多刚刚成立，时间一般不超过3年。整个企业正处于一个快速发展扩张的时间段。他们更需要能够直接上手进行项目开发，不需要或者很少需要培训的人。哪怕这些人的能力并没有那些已经工作了五六年的“老手”能力强。因为企业相信，随着时间积累，他们的能力在“老手”的带领下会很快的跟上来，而前提是他们已经有了一定的开发基础。即小型企业更期望得到“编程技能”强的人。换句话说，“<strong>编程技巧</strong>”指的就是“单纯懂得或能够熟练的应用开发规范来开发应用程序并实现其基本功能的能力”。</p>\n<p>而大型企业，一般成立时间超过十年。整个企业的企业文化已经有了很浓的积淀。业务运行稳定，部门的分配也很明确，他们已经从“扩张”阶段转向了“积淀”阶段，所谓“积淀”就是指开发自己独有的产品。“你们企业有的，我也有了。你们企业没有的，我也有。”因此，大型企业的技术岗位招聘，更喜欢“程序设计能力”强的人，简单来讲就是“算法设计能力强”的人。“算法是程序的灵魂”，“编程技巧”编写的是程序的外壳，而算法才是程序的核心。</p>\n<p>其实航哥也想去大企业，但是只因算法能力太薄弱，估计暂时与大企业无缘。希望以后还能够有机会去大企业见见世面。应用编程和算法设计是计算机领域里的两个方面，但是也只有这两个方面同时结合在一起才能发挥两者的最大作用。PS：想要学习算法的推荐经典书籍《算法导论》</p>\n"},{"title":"简谈 JavaScript 中的数据类型","intro":"为什么要突然说起 JavaScript（后面简称 “JS”） 的数据类型呢？因为最近在看书的时候发现，JS 的数据类型相比其他语言，比如 Java，C++ 等面向对象的高级语言来说，显得十分简洁，却又十分灵活。JS 是一种轻量级的“解释型”语言，它虽然不支持类，但却提供了比类更加强大的和灵活的语言结构和语言体系。","comments":1,"date":"2014-12-27T08:24:58.000Z","_content":"\n为什么要突然说起 JavaScript（后面简称 “JS”） 的数据类型呢？因为最近在看书的时候发现，JS 的数据类型相比其他语言，比如 Java，C++ 等面向对象的高级语言来说，显得十分简洁，却又十分灵活。JS 是一种轻量级的“解释型”语言，它虽然不支持类，但却提供了比类更加强大的和灵活的语言结构和语言体系。\n\nJS 的数据类型十分简洁，简单数据类型只有 `undefined`、`null`、`boolean`、`number` 和 `string` 五种。而复杂数据类型只有一种，即 `object`。在 JS 中，代码只体现为一种形式，即 `function`。\n\n为了进一步的简化编程，JS 还在这些简单数据之上，又规定了一些特殊含义。比如：`undefined`、`null`、`“”`、`0` 这四个值转换为逻辑值是就是 `false`，除此之外的其他类型均为 `true`。而在这五个类型中，除了 `undefined == null` 成立之外，其他的又互不相等。\n\n在 JS 中，“==” 表示不全等，即虽然类型不同，但只要值能够相互转换即可，比如 `“123” == 123`，而 “===” 则表示全等的概念。即数据类型及数据的值均要相等，所以 `undefined == null` 返回 `true`，而 `undefined === null` 则返回 `false`。\n\n因此，这里如果用 `typeof` 运算符来表示 “!==”，即不全等，则可以表示为： \n\n```javascript\nA != B || typeof(A) != typeof(B);\n```\n\n同理，如果要表示全不等，可表示为：\n\n```javascript\nA != B && typeof(A) != typeof(B);\n```","source":"_posts/简谈-JavaScript-中的数据类型.md","raw":"---\ntitle: 简谈 JavaScript 中的数据类型\nintro: 为什么要突然说起 JavaScript（后面简称 “JS”） 的数据类型呢？因为最近在看书的时候发现，JS 的数据类型相比其他语言，比如 Java，C++ 等面向对象的高级语言来说，显得十分简洁，却又十分灵活。JS 是一种轻量级的“解释型”语言，它虽然不支持类，但却提供了比类更加强大的和灵活的语言结构和语言体系。\ncomments: true\ndate: 2014-12-27 16:24:58\ntags:\n- JavaScript\n---\n\n为什么要突然说起 JavaScript（后面简称 “JS”） 的数据类型呢？因为最近在看书的时候发现，JS 的数据类型相比其他语言，比如 Java，C++ 等面向对象的高级语言来说，显得十分简洁，却又十分灵活。JS 是一种轻量级的“解释型”语言，它虽然不支持类，但却提供了比类更加强大的和灵活的语言结构和语言体系。\n\nJS 的数据类型十分简洁，简单数据类型只有 `undefined`、`null`、`boolean`、`number` 和 `string` 五种。而复杂数据类型只有一种，即 `object`。在 JS 中，代码只体现为一种形式，即 `function`。\n\n为了进一步的简化编程，JS 还在这些简单数据之上，又规定了一些特殊含义。比如：`undefined`、`null`、`“”`、`0` 这四个值转换为逻辑值是就是 `false`，除此之外的其他类型均为 `true`。而在这五个类型中，除了 `undefined == null` 成立之外，其他的又互不相等。\n\n在 JS 中，“==” 表示不全等，即虽然类型不同，但只要值能够相互转换即可，比如 `“123” == 123`，而 “===” 则表示全等的概念。即数据类型及数据的值均要相等，所以 `undefined == null` 返回 `true`，而 `undefined === null` 则返回 `false`。\n\n因此，这里如果用 `typeof` 运算符来表示 “!==”，即不全等，则可以表示为： \n\n```javascript\nA != B || typeof(A) != typeof(B);\n```\n\n同理，如果要表示全不等，可表示为：\n\n```javascript\nA != B && typeof(A) != typeof(B);\n```","slug":"简谈-JavaScript-中的数据类型","published":1,"updated":"2019-02-03T15:10:55.296Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtbh007mknp2kytfl7ws","content":"<p>为什么要突然说起 JavaScript（后面简称 “JS”） 的数据类型呢？因为最近在看书的时候发现，JS 的数据类型相比其他语言，比如 Java，C++ 等面向对象的高级语言来说，显得十分简洁，却又十分灵活。JS 是一种轻量级的“解释型”语言，它虽然不支持类，但却提供了比类更加强大的和灵活的语言结构和语言体系。</p>\n<p>JS 的数据类型十分简洁，简单数据类型只有 <code>undefined</code>、<code>null</code>、<code>boolean</code>、<code>number</code> 和 <code>string</code> 五种。而复杂数据类型只有一种，即 <code>object</code>。在 JS 中，代码只体现为一种形式，即 <code>function</code>。</p>\n<p>为了进一步的简化编程，JS 还在这些简单数据之上，又规定了一些特殊含义。比如：<code>undefined</code>、<code>null</code>、<code>“”</code>、<code>0</code> 这四个值转换为逻辑值是就是 <code>false</code>，除此之外的其他类型均为 <code>true</code>。而在这五个类型中，除了 <code>undefined == null</code> 成立之外，其他的又互不相等。</p>\n<p>在 JS 中，“==” 表示不全等，即虽然类型不同，但只要值能够相互转换即可，比如 <code>“123” == 123</code>，而 “===” 则表示全等的概念。即数据类型及数据的值均要相等，所以 <code>undefined == null</code> 返回 <code>true</code>，而 <code>undefined === null</code> 则返回 <code>false</code>。</p>\n<p>因此，这里如果用 <code>typeof</code> 运算符来表示 “!==”，即不全等，则可以表示为： </p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\">A <span class=\"token operator\">!=</span> B <span class=\"token operator\">||</span> <span class=\"token keyword\">typeof</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token keyword\">typeof</span><span class=\"token punctuation\">(</span>B<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>同理，如果要表示全不等，可表示为：</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\">A <span class=\"token operator\">!=</span> B <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">typeof</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token keyword\">typeof</span><span class=\"token punctuation\">(</span>B<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n","site":{"data":{}},"id":"c81a5af9ae5f07445d99bd99daba7920","excerpt":"","more":"<p>为什么要突然说起 JavaScript（后面简称 “JS”） 的数据类型呢？因为最近在看书的时候发现，JS 的数据类型相比其他语言，比如 Java，C++ 等面向对象的高级语言来说，显得十分简洁，却又十分灵活。JS 是一种轻量级的“解释型”语言，它虽然不支持类，但却提供了比类更加强大的和灵活的语言结构和语言体系。</p>\n<p>JS 的数据类型十分简洁，简单数据类型只有 <code>undefined</code>、<code>null</code>、<code>boolean</code>、<code>number</code> 和 <code>string</code> 五种。而复杂数据类型只有一种，即 <code>object</code>。在 JS 中，代码只体现为一种形式，即 <code>function</code>。</p>\n<p>为了进一步的简化编程，JS 还在这些简单数据之上，又规定了一些特殊含义。比如：<code>undefined</code>、<code>null</code>、<code>“”</code>、<code>0</code> 这四个值转换为逻辑值是就是 <code>false</code>，除此之外的其他类型均为 <code>true</code>。而在这五个类型中，除了 <code>undefined == null</code> 成立之外，其他的又互不相等。</p>\n<p>在 JS 中，“==” 表示不全等，即虽然类型不同，但只要值能够相互转换即可，比如 <code>“123” == 123</code>，而 “===” 则表示全等的概念。即数据类型及数据的值均要相等，所以 <code>undefined == null</code> 返回 <code>true</code>，而 <code>undefined === null</code> 则返回 <code>false</code>。</p>\n<p>因此，这里如果用 <code>typeof</code> 运算符来表示 “!==”，即不全等，则可以表示为： </p>\n<pre><code class=\"javascript\">A != B || typeof(A) != typeof(B);\n</code></pre>\n<p>同理，如果要表示全不等，可表示为：</p>\n<pre><code class=\"javascript\">A != B &amp;&amp; typeof(A) != typeof(B);\n</code></pre>\n"},{"title":"简单理解 HTTP 协议","intro":"昨天写了一篇在移动安卓端如何向服务器发送 HTTP 请求的文章，代码很少，操作起来也很简单。但是在安卓开发中，具体的 HTTP 连接和响应的细节都被封装在底层的函数中，我们并不能看到 HTTP 协议的真正面貌。所以今天我就来简单的讲讲我对 HTTP 协议的理解，当然今天只是说说 HTTP 协议比较浅显的部分，更深入的细节研究将在后续进行。","comments":1,"date":"2014-12-25T10:49:22.000Z","_content":"\n昨天写了一篇在移动安卓端如何向服务器发送 HTTP 请求的文章，代码很少，操作起来也很简单。但是在安卓开发中，具体的 HTTP 连接和响应的细节都被封装在底层的函数中，我们并不能看到 HTTP 协议的真正面貌。所以今天我就来简单的讲讲我对 HTTP 协议的理解，当然今天只是说说 HTTP 协议比较浅显的部分，更深入的细节研究将在后续进行。\n\nHTTP 协议主要是用来在服务器与浏览器直接传递信息，也就是常用的 B/S 模式，其实 B/S 模式本身就是一种 C/S 模式。每一次用户在点击一个超链接后浏览器作为客户端都会向服务器发出“请求”，而这个“请求”就是 HTTP 请求。HTTP 协议在协议栈中是在 TCP 层之上的，也就是说 HTTP 协议的传输是基于 TCP/IP 连接的，所以每一次发送 HTTP 请求之前都会在客户端与服务器之间进行 TCP 的三次握手连接。\n\nHTTP 协议的默认端口号是80端口。HTTP 协议是单向的、无状态的协议，即只能单一的从客户端向服务器发送请求，而当客户端没有发送请求时，服务器是无法向客户端返回信息的（HTTP 1.1）。而 HTTP 的无状态是指，同一个浏览器的两次 HTTP 请求之间是没有关系的，对于服务器来说每一次请求都是独立的，没有任何关系。\n\n\n![示例的 HTTP 请求头信息](0.png)\n\n当服务器与客户端建立了 TCP 连接之后即可进行 HTTP 的请求与响应，首先浏览器客户端会向服务器发送一个 HTTP 请求，请求中包含一个 HTTP 请求头部，和可能携带的信息。如图，比如当我们访问“百度”网站的时候，浏览器向百度的服务器发的一个 HTTP 请求头部包含以下内容：\n\n* ** Accept：** 表示浏览器支持的 MIME 类型；（HTML，图片等类型）\n* ** Accept-Encoding：** 表示浏览器支持的压缩编码格式；（gzip, deflate, sdch）\n* ** Accept-Language：** 表示浏览器支持的语言；（zh-CN 表示中文）\n* ** Cache-Control：** 表示浏览器的缓冲控制时间；（max-age=0 即缓存时间为0）\n* ** Connection：** 表示客户端与服务连接类型；（Keep-Alive 表示持久连接）\n* ** Cookie：** 表示浏览器本地存储的 Cookie 内容；\n* ** Host：** 表示请求的服务器域名；（https://www.baidu.com/）\n* ** User-Agent：** 表示本地浏览器客户端的信息；(包括浏览器版本、类型、CPU 信息等）\n\n\n![请求响应的状态码](1.png)\n\n当服务器成功受理了 HTTP 请求时，将会返回一个状态码，如果状态码为200则表示此次交易成功。服务器将返回响应信息。响应信息中也包括一系列字段如下图，一部分与 HTTP 请求头部的内容一致。当然，除了响应头部该有的信息外还有服务器自己传来的特殊字段，一般用于其他作用。\n\n![HTTP 请求的响应头](2.png)\n\n上述响应头的部分字段意义如下：\n\n* ** Bdpagetype / Bdqid / Cxy_all：** 百度服务器传来的特殊字段；\n* ** Server：** 表示服务器的类型；（BWS：Baidu Web Server）\n* ** Set-Cookie：** 服务器想要设置的本地 Cookie 内容；\n\n至此，一次简单的 HTTP 请求与响应就完成了。\n","source":"_posts/简单理解-HTTP-协议.md","raw":"---\ntitle: 简单理解 HTTP 协议\nintro: 昨天写了一篇在移动安卓端如何向服务器发送 HTTP 请求的文章，代码很少，操作起来也很简单。但是在安卓开发中，具体的 HTTP 连接和响应的细节都被封装在底层的函数中，我们并不能看到 HTTP 协议的真正面貌。所以今天我就来简单的讲讲我对 HTTP 协议的理解，当然今天只是说说 HTTP 协议比较浅显的部分，更深入的细节研究将在后续进行。\ncomments: true\ndate: 2014-12-25 18:49:22\ntags:\n- Web\n---\n\n昨天写了一篇在移动安卓端如何向服务器发送 HTTP 请求的文章，代码很少，操作起来也很简单。但是在安卓开发中，具体的 HTTP 连接和响应的细节都被封装在底层的函数中，我们并不能看到 HTTP 协议的真正面貌。所以今天我就来简单的讲讲我对 HTTP 协议的理解，当然今天只是说说 HTTP 协议比较浅显的部分，更深入的细节研究将在后续进行。\n\nHTTP 协议主要是用来在服务器与浏览器直接传递信息，也就是常用的 B/S 模式，其实 B/S 模式本身就是一种 C/S 模式。每一次用户在点击一个超链接后浏览器作为客户端都会向服务器发出“请求”，而这个“请求”就是 HTTP 请求。HTTP 协议在协议栈中是在 TCP 层之上的，也就是说 HTTP 协议的传输是基于 TCP/IP 连接的，所以每一次发送 HTTP 请求之前都会在客户端与服务器之间进行 TCP 的三次握手连接。\n\nHTTP 协议的默认端口号是80端口。HTTP 协议是单向的、无状态的协议，即只能单一的从客户端向服务器发送请求，而当客户端没有发送请求时，服务器是无法向客户端返回信息的（HTTP 1.1）。而 HTTP 的无状态是指，同一个浏览器的两次 HTTP 请求之间是没有关系的，对于服务器来说每一次请求都是独立的，没有任何关系。\n\n\n![示例的 HTTP 请求头信息](0.png)\n\n当服务器与客户端建立了 TCP 连接之后即可进行 HTTP 的请求与响应，首先浏览器客户端会向服务器发送一个 HTTP 请求，请求中包含一个 HTTP 请求头部，和可能携带的信息。如图，比如当我们访问“百度”网站的时候，浏览器向百度的服务器发的一个 HTTP 请求头部包含以下内容：\n\n* ** Accept：** 表示浏览器支持的 MIME 类型；（HTML，图片等类型）\n* ** Accept-Encoding：** 表示浏览器支持的压缩编码格式；（gzip, deflate, sdch）\n* ** Accept-Language：** 表示浏览器支持的语言；（zh-CN 表示中文）\n* ** Cache-Control：** 表示浏览器的缓冲控制时间；（max-age=0 即缓存时间为0）\n* ** Connection：** 表示客户端与服务连接类型；（Keep-Alive 表示持久连接）\n* ** Cookie：** 表示浏览器本地存储的 Cookie 内容；\n* ** Host：** 表示请求的服务器域名；（https://www.baidu.com/）\n* ** User-Agent：** 表示本地浏览器客户端的信息；(包括浏览器版本、类型、CPU 信息等）\n\n\n![请求响应的状态码](1.png)\n\n当服务器成功受理了 HTTP 请求时，将会返回一个状态码，如果状态码为200则表示此次交易成功。服务器将返回响应信息。响应信息中也包括一系列字段如下图，一部分与 HTTP 请求头部的内容一致。当然，除了响应头部该有的信息外还有服务器自己传来的特殊字段，一般用于其他作用。\n\n![HTTP 请求的响应头](2.png)\n\n上述响应头的部分字段意义如下：\n\n* ** Bdpagetype / Bdqid / Cxy_all：** 百度服务器传来的特殊字段；\n* ** Server：** 表示服务器的类型；（BWS：Baidu Web Server）\n* ** Set-Cookie：** 服务器想要设置的本地 Cookie 内容；\n\n至此，一次简单的 HTTP 请求与响应就完成了。\n","slug":"简单理解-HTTP-协议","published":1,"updated":"2019-02-03T14:59:00.642Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtbi007pknp2s29xohpd","content":"<p>昨天写了一篇在移动安卓端如何向服务器发送 HTTP 请求的文章，代码很少，操作起来也很简单。但是在安卓开发中，具体的 HTTP 连接和响应的细节都被封装在底层的函数中，我们并不能看到 HTTP 协议的真正面貌。所以今天我就来简单的讲讲我对 HTTP 协议的理解，当然今天只是说说 HTTP 协议比较浅显的部分，更深入的细节研究将在后续进行。</p>\n<p>HTTP 协议主要是用来在服务器与浏览器直接传递信息，也就是常用的 B/S 模式，其实 B/S 模式本身就是一种 C/S 模式。每一次用户在点击一个超链接后浏览器作为客户端都会向服务器发出“请求”，而这个“请求”就是 HTTP 请求。HTTP 协议在协议栈中是在 TCP 层之上的，也就是说 HTTP 协议的传输是基于 TCP/IP 连接的，所以每一次发送 HTTP 请求之前都会在客户端与服务器之间进行 TCP 的三次握手连接。</p>\n<p>HTTP 协议的默认端口号是80端口。HTTP 协议是单向的、无状态的协议，即只能单一的从客户端向服务器发送请求，而当客户端没有发送请求时，服务器是无法向客户端返回信息的（HTTP 1.1）。而 HTTP 的无状态是指，同一个浏览器的两次 HTTP 请求之间是没有关系的，对于服务器来说每一次请求都是独立的，没有任何关系。</p>\n<p><img src=\"0.png\" alt=\"示例的 HTTP 请求头信息\"></p>\n<p>当服务器与客户端建立了 TCP 连接之后即可进行 HTTP 的请求与响应，首先浏览器客户端会向服务器发送一个 HTTP 请求，请求中包含一个 HTTP 请求头部，和可能携带的信息。如图，比如当我们访问“百度”网站的时候，浏览器向百度的服务器发的一个 HTTP 请求头部包含以下内容：</p>\n<ul>\n<li><strong> Accept：</strong> 表示浏览器支持的 MIME 类型；（HTML，图片等类型）</li>\n<li><strong> Accept-Encoding：</strong> 表示浏览器支持的压缩编码格式；（gzip, deflate, sdch）</li>\n<li><strong> Accept-Language：</strong> 表示浏览器支持的语言；（zh-CN 表示中文）</li>\n<li><strong> Cache-Control：</strong> 表示浏览器的缓冲控制时间；（max-age=0 即缓存时间为0）</li>\n<li><strong> Connection：</strong> 表示客户端与服务连接类型；（Keep-Alive 表示持久连接）</li>\n<li><strong> Cookie：</strong> 表示浏览器本地存储的 Cookie 内容；</li>\n<li><strong> Host：</strong> 表示请求的服务器域名；（<a href=\"https://www.baidu.com/）\" target=\"_blank\" rel=\"noopener\">https://www.baidu.com/）</a></li>\n<li><strong> User-Agent：</strong> 表示本地浏览器客户端的信息；(包括浏览器版本、类型、CPU 信息等）</li>\n</ul>\n<p><img src=\"1.png\" alt=\"请求响应的状态码\"></p>\n<p>当服务器成功受理了 HTTP 请求时，将会返回一个状态码，如果状态码为200则表示此次交易成功。服务器将返回响应信息。响应信息中也包括一系列字段如下图，一部分与 HTTP 请求头部的内容一致。当然，除了响应头部该有的信息外还有服务器自己传来的特殊字段，一般用于其他作用。</p>\n<p><img src=\"2.png\" alt=\"HTTP 请求的响应头\"></p>\n<p>上述响应头的部分字段意义如下：</p>\n<ul>\n<li><strong> Bdpagetype / Bdqid / Cxy_all：</strong> 百度服务器传来的特殊字段；</li>\n<li><strong> Server：</strong> 表示服务器的类型；（BWS：Baidu Web Server）</li>\n<li><strong> Set-Cookie：</strong> 服务器想要设置的本地 Cookie 内容；</li>\n</ul>\n<p>至此，一次简单的 HTTP 请求与响应就完成了。</p>\n","site":{"data":{}},"id":"5d7a5ead4d2dd6ca11190e87df4e8614","excerpt":"","more":"<p>昨天写了一篇在移动安卓端如何向服务器发送 HTTP 请求的文章，代码很少，操作起来也很简单。但是在安卓开发中，具体的 HTTP 连接和响应的细节都被封装在底层的函数中，我们并不能看到 HTTP 协议的真正面貌。所以今天我就来简单的讲讲我对 HTTP 协议的理解，当然今天只是说说 HTTP 协议比较浅显的部分，更深入的细节研究将在后续进行。</p>\n<p>HTTP 协议主要是用来在服务器与浏览器直接传递信息，也就是常用的 B/S 模式，其实 B/S 模式本身就是一种 C/S 模式。每一次用户在点击一个超链接后浏览器作为客户端都会向服务器发出“请求”，而这个“请求”就是 HTTP 请求。HTTP 协议在协议栈中是在 TCP 层之上的，也就是说 HTTP 协议的传输是基于 TCP/IP 连接的，所以每一次发送 HTTP 请求之前都会在客户端与服务器之间进行 TCP 的三次握手连接。</p>\n<p>HTTP 协议的默认端口号是80端口。HTTP 协议是单向的、无状态的协议，即只能单一的从客户端向服务器发送请求，而当客户端没有发送请求时，服务器是无法向客户端返回信息的（HTTP 1.1）。而 HTTP 的无状态是指，同一个浏览器的两次 HTTP 请求之间是没有关系的，对于服务器来说每一次请求都是独立的，没有任何关系。</p>\n<p><img src=\"0.png\" alt=\"示例的 HTTP 请求头信息\"></p>\n<p>当服务器与客户端建立了 TCP 连接之后即可进行 HTTP 的请求与响应，首先浏览器客户端会向服务器发送一个 HTTP 请求，请求中包含一个 HTTP 请求头部，和可能携带的信息。如图，比如当我们访问“百度”网站的时候，浏览器向百度的服务器发的一个 HTTP 请求头部包含以下内容：</p>\n<ul>\n<li><strong> Accept：</strong> 表示浏览器支持的 MIME 类型；（HTML，图片等类型）</li>\n<li><strong> Accept-Encoding：</strong> 表示浏览器支持的压缩编码格式；（gzip, deflate, sdch）</li>\n<li><strong> Accept-Language：</strong> 表示浏览器支持的语言；（zh-CN 表示中文）</li>\n<li><strong> Cache-Control：</strong> 表示浏览器的缓冲控制时间；（max-age=0 即缓存时间为0）</li>\n<li><strong> Connection：</strong> 表示客户端与服务连接类型；（Keep-Alive 表示持久连接）</li>\n<li><strong> Cookie：</strong> 表示浏览器本地存储的 Cookie 内容；</li>\n<li><strong> Host：</strong> 表示请求的服务器域名；（<a href=\"https://www.baidu.com/）\" target=\"_blank\" rel=\"noopener\">https://www.baidu.com/）</a></li>\n<li><strong> User-Agent：</strong> 表示本地浏览器客户端的信息；(包括浏览器版本、类型、CPU 信息等）</li>\n</ul>\n<p><img src=\"1.png\" alt=\"请求响应的状态码\"></p>\n<p>当服务器成功受理了 HTTP 请求时，将会返回一个状态码，如果状态码为200则表示此次交易成功。服务器将返回响应信息。响应信息中也包括一系列字段如下图，一部分与 HTTP 请求头部的内容一致。当然，除了响应头部该有的信息外还有服务器自己传来的特殊字段，一般用于其他作用。</p>\n<p><img src=\"2.png\" alt=\"HTTP 请求的响应头\"></p>\n<p>上述响应头的部分字段意义如下：</p>\n<ul>\n<li><strong> Bdpagetype / Bdqid / Cxy_all：</strong> 百度服务器传来的特殊字段；</li>\n<li><strong> Server：</strong> 表示服务器的类型；（BWS：Baidu Web Server）</li>\n<li><strong> Set-Cookie：</strong> 服务器想要设置的本地 Cookie 内容；</li>\n</ul>\n<p>至此，一次简单的 HTTP 请求与响应就完成了。</p>\n"},{"title":"算法基础 - 常用排序算法（上）","intro":"本文分为上下两篇，主要介绍算法中常用的七种“排序”算法。这七种算法主要是：冒泡排序、快速排序、归并排序、选择排序、堆排序、插入排序和希尔排序。算法问题大部分主要集中在“排序”和“查找”两部分，只有在对基础的排序算法有了深刻了解的基础上，我们才能为进一步学习诸如“动态规划”等高级算法思路打下基础。","comments":1,"date":"2016-09-18T06:30:00.000Z","_content":"\n本文分为上下两篇，主要介绍算法中常用的七种“排序”算法。这七种算法主要是：冒泡排序、快速排序、归并排序、选择排序、堆排序、插入排序和希尔排序。算法问题大部分主要集中在“排序”和“查找”两部分，只有在对基础的排序算法有了深刻了解的基础上，我们才能为进一步学习诸如“动态规划”等高级算法思路打下基础。\n\n#### 一、冒泡排序：\n\n冒泡排序主要思路是依次比较相邻的两个元素，并将这两个元素按照所需要的升序或者降序进行交换排列（例如 {1, 2}，按照升序则不用交换，否则按照降序交换两个元素的值，即变为 {2, 1}），每一次完整的循环都会排列好整个数组中的一个元素，若数组含有 N 个元素，则一共需要循环 N-1 次；第一次循环比较 N-1 次，第二次循环比较 N-2 次，依次类推。时间复杂度为 “O(n2)”，总共比较次数 “1 + 2 + ... + (n - 1) = (1 + n - 1)(n - 1) / 2 = **n(n - 1) / 2**”次。Java 实现代码如下所示：\n\n\n```java\npublic static int[] bubbleSort(int [] arr, String type) {\n    if (arr == null || arr.length == 0) {\n        return null; \n    }\n\t\t\n    int len = arr.length;\n    int temp = 0;\n\t\t\n    for (int j = 0; j < len - 1; j++) {\n        // 正序，由小到大；每次循环开头位置后移一位，结束位置不变；\n        if (type == \"ASC\") {\n            for (int i = j; i < len - 1; i++) {\t\t\n                if (arr[i] > arr[i + 1]) {\n                    temp = arr[i];\n                    arr[i] = arr[i + 1];\n                    arr[i + 1] = temp;\n                }\n            }\n        }\n        // 逆序，由大到小；每次循环结束位置前移一位，开头位置不变；\n        if (type == \"DESC\") {\n            for (int i = 0; i < len - j - 1; i++) {\t\t\n                if (arr[i] < arr[i + 1]) {\n                    temp = arr[i];\n                    arr[i] = arr[i + 1];\n                    arr[i + 1] = temp;\n                }\n            }\n        }\n    }\t\n    return arr;\n}\n```\n\n#### 二、快速排序：\n\n快速排序是一种高级的排序方法，其思想主要是根据“基准数”将大于或小于“基准数”的数字分别放置到该“基准数”的两侧，然后以同样的方式在上一个“基准数”两侧的子序列中选取下一个“基准数”以同样的方式处理子序列，依次递归处理子序列产生的子序列，直到全部处理完毕。该算法的平均时间复杂度为 “O(NlogN)”，最坏情况下仍可能是相邻的两个数进行了交换，此时的时间复杂度同“冒泡排序”，为 “O(N2)”。Java 实现代码如下所示：\n\n\n```java\npublic static void quickSort(int[] arr, int low, int high) {\n    if (arr == null || arr.length == 0)\n        return;\n    if (low >= high)\n        return;\n\n    // 选择基准数；\n    int middle = low + (high - low) / 2;\n    int pivot = arr[middle];\n\n    int i = low;\n    int j = high;\n    // 开始循环；\n    while (i <= j) {\n        while (arr[i] < pivot) {\n            i++;\n        }\n        while (arr[j] > pivot) {\n            j--;\n        }\n        if (i <= j) {\n            int temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i++;\n            j--;\n        }\n    }\n\n    // 递归处理子序列；\n    if (low < j)\n        quickSort(arr, low, j);\n    if (high > i)\n        quickSort(arr, i, high);\n}\n```\n","source":"_posts/算法基础-常用排序算法（上）.md","raw":"---\ntitle: 算法基础 - 常用排序算法（上）\nintro: 本文分为上下两篇，主要介绍算法中常用的七种“排序”算法。这七种算法主要是：冒泡排序、快速排序、归并排序、选择排序、堆排序、插入排序和希尔排序。算法问题大部分主要集中在“排序”和“查找”两部分，只有在对基础的排序算法有了深刻了解的基础上，我们才能为进一步学习诸如“动态规划”等高级算法思路打下基础。\ncomments: true\ndate: 2016-09-18 14:30:00\ntags:\n- 算法\n---\n\n本文分为上下两篇，主要介绍算法中常用的七种“排序”算法。这七种算法主要是：冒泡排序、快速排序、归并排序、选择排序、堆排序、插入排序和希尔排序。算法问题大部分主要集中在“排序”和“查找”两部分，只有在对基础的排序算法有了深刻了解的基础上，我们才能为进一步学习诸如“动态规划”等高级算法思路打下基础。\n\n#### 一、冒泡排序：\n\n冒泡排序主要思路是依次比较相邻的两个元素，并将这两个元素按照所需要的升序或者降序进行交换排列（例如 {1, 2}，按照升序则不用交换，否则按照降序交换两个元素的值，即变为 {2, 1}），每一次完整的循环都会排列好整个数组中的一个元素，若数组含有 N 个元素，则一共需要循环 N-1 次；第一次循环比较 N-1 次，第二次循环比较 N-2 次，依次类推。时间复杂度为 “O(n2)”，总共比较次数 “1 + 2 + ... + (n - 1) = (1 + n - 1)(n - 1) / 2 = **n(n - 1) / 2**”次。Java 实现代码如下所示：\n\n\n```java\npublic static int[] bubbleSort(int [] arr, String type) {\n    if (arr == null || arr.length == 0) {\n        return null; \n    }\n\t\t\n    int len = arr.length;\n    int temp = 0;\n\t\t\n    for (int j = 0; j < len - 1; j++) {\n        // 正序，由小到大；每次循环开头位置后移一位，结束位置不变；\n        if (type == \"ASC\") {\n            for (int i = j; i < len - 1; i++) {\t\t\n                if (arr[i] > arr[i + 1]) {\n                    temp = arr[i];\n                    arr[i] = arr[i + 1];\n                    arr[i + 1] = temp;\n                }\n            }\n        }\n        // 逆序，由大到小；每次循环结束位置前移一位，开头位置不变；\n        if (type == \"DESC\") {\n            for (int i = 0; i < len - j - 1; i++) {\t\t\n                if (arr[i] < arr[i + 1]) {\n                    temp = arr[i];\n                    arr[i] = arr[i + 1];\n                    arr[i + 1] = temp;\n                }\n            }\n        }\n    }\t\n    return arr;\n}\n```\n\n#### 二、快速排序：\n\n快速排序是一种高级的排序方法，其思想主要是根据“基准数”将大于或小于“基准数”的数字分别放置到该“基准数”的两侧，然后以同样的方式在上一个“基准数”两侧的子序列中选取下一个“基准数”以同样的方式处理子序列，依次递归处理子序列产生的子序列，直到全部处理完毕。该算法的平均时间复杂度为 “O(NlogN)”，最坏情况下仍可能是相邻的两个数进行了交换，此时的时间复杂度同“冒泡排序”，为 “O(N2)”。Java 实现代码如下所示：\n\n\n```java\npublic static void quickSort(int[] arr, int low, int high) {\n    if (arr == null || arr.length == 0)\n        return;\n    if (low >= high)\n        return;\n\n    // 选择基准数；\n    int middle = low + (high - low) / 2;\n    int pivot = arr[middle];\n\n    int i = low;\n    int j = high;\n    // 开始循环；\n    while (i <= j) {\n        while (arr[i] < pivot) {\n            i++;\n        }\n        while (arr[j] > pivot) {\n            j--;\n        }\n        if (i <= j) {\n            int temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i++;\n            j--;\n        }\n    }\n\n    // 递归处理子序列；\n    if (low < j)\n        quickSort(arr, low, j);\n    if (high > i)\n        quickSort(arr, i, high);\n}\n```\n","slug":"算法基础-常用排序算法（上）","published":1,"updated":"2019-02-10T03:02:02.087Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtbi007rknp2dwiui46d","content":"<p>本文分为上下两篇，主要介绍算法中常用的七种“排序”算法。这七种算法主要是：冒泡排序、快速排序、归并排序、选择排序、堆排序、插入排序和希尔排序。算法问题大部分主要集中在“排序”和“查找”两部分，只有在对基础的排序算法有了深刻了解的基础上，我们才能为进一步学习诸如“动态规划”等高级算法思路打下基础。</p>\n<h4 id=\"一、冒泡排序：\"><a href=\"#一、冒泡排序：\" class=\"headerlink\" title=\"一、冒泡排序：\"></a>一、冒泡排序：</h4><p>冒泡排序主要思路是依次比较相邻的两个元素，并将这两个元素按照所需要的升序或者降序进行交换排列（例如 {1, 2}，按照升序则不用交换，否则按照降序交换两个元素的值，即变为 {2, 1}），每一次完整的循环都会排列好整个数组中的一个元素，若数组含有 N 个元素，则一共需要循环 N-1 次；第一次循环比较 N-1 次，第二次循环比较 N-2 次，依次类推。时间复杂度为 “O(n2)”，总共比较次数 “1 + 2 + … + (n - 1) = (1 + n - 1)(n - 1) / 2 = <strong>n(n - 1) / 2</strong>”次。Java 实现代码如下所示：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">bubbleSort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arr<span class=\"token punctuation\">,</span> String type<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>arr <span class=\"token operator\">==</span> null <span class=\"token operator\">||</span> arr<span class=\"token punctuation\">.</span>length <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> null<span class=\"token punctuation\">;</span> \n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">int</span> len <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> temp <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> len <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 正序，由小到大；每次循环开头位置后移一位，结束位置不变；</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>type <span class=\"token operator\">==</span> <span class=\"token string\">\"ASC\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> j<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> len <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>        \n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> arr<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    temp <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                    arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                    arr<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 逆序，由大到小；每次循环结束位置前移一位，开头位置不变；</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>type <span class=\"token operator\">==</span> <span class=\"token string\">\"DESC\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> len <span class=\"token operator\">-</span> j <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>        \n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> arr<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    temp <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                    arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                    arr<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>    \n    <span class=\"token keyword\">return</span> arr<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"二、快速排序：\"><a href=\"#二、快速排序：\" class=\"headerlink\" title=\"二、快速排序：\"></a>二、快速排序：</h4><p>快速排序是一种高级的排序方法，其思想主要是根据“基准数”将大于或小于“基准数”的数字分别放置到该“基准数”的两侧，然后以同样的方式在上一个“基准数”两侧的子序列中选取下一个“基准数”以同样的方式处理子序列，依次递归处理子序列产生的子序列，直到全部处理完毕。该算法的平均时间复杂度为 “O(NlogN)”，最坏情况下仍可能是相邻的两个数进行了交换，此时的时间复杂度同“冒泡排序”，为 “O(N2)”。Java 实现代码如下所示：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">quickSort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arr<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> low<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> high<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>arr <span class=\"token operator\">==</span> null <span class=\"token operator\">||</span> arr<span class=\"token punctuation\">.</span>length <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>low <span class=\"token operator\">>=</span> high<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 选择基准数；</span>\n    <span class=\"token keyword\">int</span> middle <span class=\"token operator\">=</span> low <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>high <span class=\"token operator\">-</span> low<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> pivot <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>middle<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> low<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> high<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 开始循环；</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;=</span> j<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> pivot<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            i<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> pivot<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            j<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;=</span> j<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> temp <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span>\n            i<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n            j<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 递归处理子序列；</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>low <span class=\"token operator\">&lt;</span> j<span class=\"token punctuation\">)</span>\n        <span class=\"token function\">quickSort</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> low<span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>high <span class=\"token operator\">></span> i<span class=\"token punctuation\">)</span>\n        <span class=\"token function\">quickSort</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">,</span> high<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"id":"af62dc680ec65cc6a30d2e0ec4b9d213","excerpt":"","more":"<p>本文分为上下两篇，主要介绍算法中常用的七种“排序”算法。这七种算法主要是：冒泡排序、快速排序、归并排序、选择排序、堆排序、插入排序和希尔排序。算法问题大部分主要集中在“排序”和“查找”两部分，只有在对基础的排序算法有了深刻了解的基础上，我们才能为进一步学习诸如“动态规划”等高级算法思路打下基础。</p>\n<h4 id=\"一、冒泡排序：\"><a href=\"#一、冒泡排序：\" class=\"headerlink\" title=\"一、冒泡排序：\"></a>一、冒泡排序：</h4><p>冒泡排序主要思路是依次比较相邻的两个元素，并将这两个元素按照所需要的升序或者降序进行交换排列（例如 {1, 2}，按照升序则不用交换，否则按照降序交换两个元素的值，即变为 {2, 1}），每一次完整的循环都会排列好整个数组中的一个元素，若数组含有 N 个元素，则一共需要循环 N-1 次；第一次循环比较 N-1 次，第二次循环比较 N-2 次，依次类推。时间复杂度为 “O(n2)”，总共比较次数 “1 + 2 + … + (n - 1) = (1 + n - 1)(n - 1) / 2 = <strong>n(n - 1) / 2</strong>”次。Java 实现代码如下所示：</p>\n<pre><code class=\"java\">public static int[] bubbleSort(int [] arr, String type) {\n    if (arr == null || arr.length == 0) {\n        return null; \n    }\n\n    int len = arr.length;\n    int temp = 0;\n\n    for (int j = 0; j &lt; len - 1; j++) {\n        // 正序，由小到大；每次循环开头位置后移一位，结束位置不变；\n        if (type == &quot;ASC&quot;) {\n            for (int i = j; i &lt; len - 1; i++) {        \n                if (arr[i] &gt; arr[i + 1]) {\n                    temp = arr[i];\n                    arr[i] = arr[i + 1];\n                    arr[i + 1] = temp;\n                }\n            }\n        }\n        // 逆序，由大到小；每次循环结束位置前移一位，开头位置不变；\n        if (type == &quot;DESC&quot;) {\n            for (int i = 0; i &lt; len - j - 1; i++) {        \n                if (arr[i] &lt; arr[i + 1]) {\n                    temp = arr[i];\n                    arr[i] = arr[i + 1];\n                    arr[i + 1] = temp;\n                }\n            }\n        }\n    }    \n    return arr;\n}\n</code></pre>\n<h4 id=\"二、快速排序：\"><a href=\"#二、快速排序：\" class=\"headerlink\" title=\"二、快速排序：\"></a>二、快速排序：</h4><p>快速排序是一种高级的排序方法，其思想主要是根据“基准数”将大于或小于“基准数”的数字分别放置到该“基准数”的两侧，然后以同样的方式在上一个“基准数”两侧的子序列中选取下一个“基准数”以同样的方式处理子序列，依次递归处理子序列产生的子序列，直到全部处理完毕。该算法的平均时间复杂度为 “O(NlogN)”，最坏情况下仍可能是相邻的两个数进行了交换，此时的时间复杂度同“冒泡排序”，为 “O(N2)”。Java 实现代码如下所示：</p>\n<pre><code class=\"java\">public static void quickSort(int[] arr, int low, int high) {\n    if (arr == null || arr.length == 0)\n        return;\n    if (low &gt;= high)\n        return;\n\n    // 选择基准数；\n    int middle = low + (high - low) / 2;\n    int pivot = arr[middle];\n\n    int i = low;\n    int j = high;\n    // 开始循环；\n    while (i &lt;= j) {\n        while (arr[i] &lt; pivot) {\n            i++;\n        }\n        while (arr[j] &gt; pivot) {\n            j--;\n        }\n        if (i &lt;= j) {\n            int temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i++;\n            j--;\n        }\n    }\n\n    // 递归处理子序列；\n    if (low &lt; j)\n        quickSort(arr, low, j);\n    if (high &gt; i)\n        quickSort(arr, i, high);\n}\n</code></pre>\n"},{"title":"编码与“锟斤拷”的故事","intro":"最近一段时间因为在做网站的多浏览器优化工作，所以在各大浏览器之间进行测试和调试，便发现了许多有趣的事情。不知道是因为浏览器的版本原因还是我自身电脑系统的原因，每一次在“百度浏览器”右上方的搜索栏进行搜索的时候，都会出现“锟斤拷”的问题。","comments":1,"date":"2015-01-26T02:54:21.000Z","_content":"\n\n最近一段时间因为在做网站的多浏览器优化工作，所以在各大浏览器之间进行测试和调试，便发现了许多有趣的事情。不知道是因为浏览器的版本原因还是我自身电脑系统的原因，每一次在“百度浏览器”右上方的搜索栏进行搜索的时候，都会出现“锟斤拷”的问题。\n\n那么什么是“锟斤拷”呢？“锟斤拷”是一串经常在搜索引擎和其他网站上看到的乱码字符，而其根本原因是：**由于 GBK 字符集和 Unicode 字符集间的直接转换导致的**。\n\nUnicode 对于老的编码系统 GBK 中无法表示的字符将会使用占位符“U+FFFD”来表示，而 U+FFFD 使用 UTF-8 编码出来的结构恰好是“xefxbfxbd”。如果这个“xefxbfxbd”字符串重复多次，例如“xefxbfxbdxefxbfxbd”，然后再将其放到 GBK / CP936 / GB2312/ GB18030 等固定编码的环境中进行显示的话，一个汉字占用2个字节，最终的显示结果就变成了：锟斤拷：锟(0xEFBF)、斤（0xBDEF）、拷（0xBFBD）。\n\n而且，据悉百度搜索引擎从2011年起也多次出现了这种编码转换的问题，值得引起官方的注意。\n\n![百度搜索的“锟斤拷”问题](1.jpg)\n","source":"_posts/编码与“锟斤拷”的故事.md","raw":"---\ntitle: 编码与“锟斤拷”的故事\nintro: 最近一段时间因为在做网站的多浏览器优化工作，所以在各大浏览器之间进行测试和调试，便发现了许多有趣的事情。不知道是因为浏览器的版本原因还是我自身电脑系统的原因，每一次在“百度浏览器”右上方的搜索栏进行搜索的时候，都会出现“锟斤拷”的问题。\ncomments: true\ndate: 2015-01-26 10:54:21\ntags:\n- Web\n---\n\n\n最近一段时间因为在做网站的多浏览器优化工作，所以在各大浏览器之间进行测试和调试，便发现了许多有趣的事情。不知道是因为浏览器的版本原因还是我自身电脑系统的原因，每一次在“百度浏览器”右上方的搜索栏进行搜索的时候，都会出现“锟斤拷”的问题。\n\n那么什么是“锟斤拷”呢？“锟斤拷”是一串经常在搜索引擎和其他网站上看到的乱码字符，而其根本原因是：**由于 GBK 字符集和 Unicode 字符集间的直接转换导致的**。\n\nUnicode 对于老的编码系统 GBK 中无法表示的字符将会使用占位符“U+FFFD”来表示，而 U+FFFD 使用 UTF-8 编码出来的结构恰好是“xefxbfxbd”。如果这个“xefxbfxbd”字符串重复多次，例如“xefxbfxbdxefxbfxbd”，然后再将其放到 GBK / CP936 / GB2312/ GB18030 等固定编码的环境中进行显示的话，一个汉字占用2个字节，最终的显示结果就变成了：锟斤拷：锟(0xEFBF)、斤（0xBDEF）、拷（0xBFBD）。\n\n而且，据悉百度搜索引擎从2011年起也多次出现了这种编码转换的问题，值得引起官方的注意。\n\n![百度搜索的“锟斤拷”问题](1.jpg)\n","slug":"编码与“锟斤拷”的故事","published":1,"updated":"2019-02-04T08:47:33.768Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtbj007tknp242thj9hm","content":"<p>最近一段时间因为在做网站的多浏览器优化工作，所以在各大浏览器之间进行测试和调试，便发现了许多有趣的事情。不知道是因为浏览器的版本原因还是我自身电脑系统的原因，每一次在“百度浏览器”右上方的搜索栏进行搜索的时候，都会出现“锟斤拷”的问题。</p>\n<p>那么什么是“锟斤拷”呢？“锟斤拷”是一串经常在搜索引擎和其他网站上看到的乱码字符，而其根本原因是：<strong>由于 GBK 字符集和 Unicode 字符集间的直接转换导致的</strong>。</p>\n<p>Unicode 对于老的编码系统 GBK 中无法表示的字符将会使用占位符“U+FFFD”来表示，而 U+FFFD 使用 UTF-8 编码出来的结构恰好是“xefxbfxbd”。如果这个“xefxbfxbd”字符串重复多次，例如“xefxbfxbdxefxbfxbd”，然后再将其放到 GBK / CP936 / GB2312/ GB18030 等固定编码的环境中进行显示的话，一个汉字占用2个字节，最终的显示结果就变成了：锟斤拷：锟(0xEFBF)、斤（0xBDEF）、拷（0xBFBD）。</p>\n<p>而且，据悉百度搜索引擎从2011年起也多次出现了这种编码转换的问题，值得引起官方的注意。</p>\n<p><img src=\"1.jpg\" alt=\"百度搜索的“锟斤拷”问题\"></p>\n","site":{"data":{}},"id":"fc13ef086f6e97637b8ae6b12a51412d","excerpt":"","more":"<p>最近一段时间因为在做网站的多浏览器优化工作，所以在各大浏览器之间进行测试和调试，便发现了许多有趣的事情。不知道是因为浏览器的版本原因还是我自身电脑系统的原因，每一次在“百度浏览器”右上方的搜索栏进行搜索的时候，都会出现“锟斤拷”的问题。</p>\n<p>那么什么是“锟斤拷”呢？“锟斤拷”是一串经常在搜索引擎和其他网站上看到的乱码字符，而其根本原因是：<strong>由于 GBK 字符集和 Unicode 字符集间的直接转换导致的</strong>。</p>\n<p>Unicode 对于老的编码系统 GBK 中无法表示的字符将会使用占位符“U+FFFD”来表示，而 U+FFFD 使用 UTF-8 编码出来的结构恰好是“xefxbfxbd”。如果这个“xefxbfxbd”字符串重复多次，例如“xefxbfxbdxefxbfxbd”，然后再将其放到 GBK / CP936 / GB2312/ GB18030 等固定编码的环境中进行显示的话，一个汉字占用2个字节，最终的显示结果就变成了：锟斤拷：锟(0xEFBF)、斤（0xBDEF）、拷（0xBFBD）。</p>\n<p>而且，据悉百度搜索引擎从2011年起也多次出现了这种编码转换的问题，值得引起官方的注意。</p>\n<p><img src=\"1.jpg\" alt=\"百度搜索的“锟斤拷”问题\"></p>\n"},{"title":"设计模式速谈：一、序论","intro":"大家在平时的日常工作开发中，可能经常会听到“设计模式”这个词，那么到底什么是设计模式呢？如果要是按照课本上的方式来讲解，估计十篇博客也无法将它讲解透彻。“设计模式”的理论知识固然重要，但理论也是为了实践所做的基础，不要仅被理论就搞昏了头脑。","comments":1,"date":"2016-07-16T15:04:35.000Z","_content":"\n\n大家在平时的日常工作开发中，可能经常会听到“设计模式”这个词，那么到底什么是设计模式呢？如果要是按照课本上的方式来讲解，估计十篇博客也无法将它讲解透彻。“设计模式”的理论知识固然重要，但理论也是为了实践所做的基础，不要仅被理论就搞昏了头脑。\n\n“设计模式”顾名思义，就是设计软件体系时所使用的一系列模式，而这些模式是不会变化的或者说只会在很小的程度上变化，但每种模式的整体结构是基本不变的。所以可以说，每一种设计模式都对应着一种问题的解决方法。而如果需要在项目中使用这些方法，就要看哪一种设计模式更加适合自己的项目结构了。抽象的讲，设计模式是可以解决一类软件问题并能够重复使用的软件设计方法。\n\n“设计模式”是可复用的，也就是说很多结构或功能十分相似的工程项目均可以使用同一种“设计模式”来处理。在选择使用的“设计模式”时要关注程序整体的思路而不是过分的细节。因为“设计模式”是将项目的解决方案整体抽象出来，在类和对象的层次进行描述的。\n\n“设计模式”的**核心思想**是“**通过增加抽象层，把变化的部分从那些不变的部分中分离出来**”。在接下来的所有“设计模式速谈”系列文章中，针对每一种“设计模式”，我们会结合相应的简单例子来帮助大家理解“设计模式”在实际工程中的应用，而不是单纯的理论概念。\n\n首先需要知道的是，所有的设计模式都是建立在以下**五种原则**之上的：\n\n**1. “开.闭”原则（Open Closed Principle，OCP）：**\n\n软件设计应该对扩展是开放的，对修改是封闭的。OCP 原则可以理解为我们可以对软件系统进行功能上的扩展，但在进行扩展时不应该修改原有的系统代码。即在扩展时应该逐步迭代式开发，比如通过 `jQuery.extend()`。\n\n**2. 单一职责原则（Single Responsibility Principle, SRP）：**\n\n就一个类而言，应该有且只有一个引起其变化的原因，即只有一个职责。比如 Modem 类有两个方法，一个负责管理连接，一个负责通讯，则这个类便**违背**了 SRP 原则。Modem 类应该只用来负责通讯。所谓的“职责”可以理解为一个类所包含的功能范畴，这些功能应该全部属于同一个范畴之内。比如 Modem 类负责通讯，可以有**调整通讯协议**，**调整通讯方式**等方法，而管理连接则不应该属于通讯的范畴，即不应该属于 Modem 类所具有的功能。\n\n**3. 里氏替换原则（Liskov Substitution Principle, LSP)：**\n\n“继承”必须确保超类（父类）所拥有的性质在子类中仍然成立。LSP 原则是继承的“基石”，类之间的父子关系只有满足 LSP 原则时，才能称谓是继承关系。而确保 LSP 原则的方法是：只有当子类能够“替换”掉其父类，并且系统功能不受影响时，父类才能够被复用，子类也能够在父类的基础上增加新的功能。例如：父类-鸟，子类-企鹅，则这个关系便违背了 LSP 原则，因为父类的鸟有“飞”这个方法，但是企鹅并不会飞。\n\n**4. 依赖倒置原则（Dependence Inversion Principle, DIP）：**\n\n高层模块不应该依赖低层模块，二者都应该依赖于抽象。即父类应该是绝对抽象的，而不能是具体的，这样其子类才可以处理所有的情况。例如：父类-人，有一个“吃水果”的方法，而这个方法的参数是“苹果”，这个关系便违背了 DIP 原则，事实上这个“吃水果”的方法应该以更加抽象的“水果”为参数。\n\n**5. 接口隔离原则（Interface Segregation Principle, ISP）：**\n\n多个和客户相关的接口要好于一个通用的接口。这个原则很好理解，永远不要尝试去开发一个“通用”的接口，根据**不同的使用者**将功能独立出来是更好的选择。即一个类应该只对应一个使用者，按照功能或者属性尽量的去划分。\n\n这里再多说一句，设计模式根据应用的角度被分为“**创建型**”、“**结构型**”以及“**行为型**”三种类型。“**创建型**” 可以理解为用来创建对象的模式，这些模式抽象了类实例化的过程。“**结构型**”讨论的是类和对象间的结构，这些模式实现了不同的类继承关系。而“**行为型**”则着力解决的是类实体之间的通讯关系，即某一具体的控制流程。\n\n接下来，我们将会针对几种常用的设计模式进行逐一讲解。\n","source":"_posts/设计模式速谈：一、序论.md","raw":"---\ntitle: 设计模式速谈：一、序论\nintro: 大家在平时的日常工作开发中，可能经常会听到“设计模式”这个词，那么到底什么是设计模式呢？如果要是按照课本上的方式来讲解，估计十篇博客也无法将它讲解透彻。“设计模式”的理论知识固然重要，但理论也是为了实践所做的基础，不要仅被理论就搞昏了头脑。\ncomments: true\ndate: 2016-07-16 23:04:35\ntags:\n- 设计模式\n---\n\n\n大家在平时的日常工作开发中，可能经常会听到“设计模式”这个词，那么到底什么是设计模式呢？如果要是按照课本上的方式来讲解，估计十篇博客也无法将它讲解透彻。“设计模式”的理论知识固然重要，但理论也是为了实践所做的基础，不要仅被理论就搞昏了头脑。\n\n“设计模式”顾名思义，就是设计软件体系时所使用的一系列模式，而这些模式是不会变化的或者说只会在很小的程度上变化，但每种模式的整体结构是基本不变的。所以可以说，每一种设计模式都对应着一种问题的解决方法。而如果需要在项目中使用这些方法，就要看哪一种设计模式更加适合自己的项目结构了。抽象的讲，设计模式是可以解决一类软件问题并能够重复使用的软件设计方法。\n\n“设计模式”是可复用的，也就是说很多结构或功能十分相似的工程项目均可以使用同一种“设计模式”来处理。在选择使用的“设计模式”时要关注程序整体的思路而不是过分的细节。因为“设计模式”是将项目的解决方案整体抽象出来，在类和对象的层次进行描述的。\n\n“设计模式”的**核心思想**是“**通过增加抽象层，把变化的部分从那些不变的部分中分离出来**”。在接下来的所有“设计模式速谈”系列文章中，针对每一种“设计模式”，我们会结合相应的简单例子来帮助大家理解“设计模式”在实际工程中的应用，而不是单纯的理论概念。\n\n首先需要知道的是，所有的设计模式都是建立在以下**五种原则**之上的：\n\n**1. “开.闭”原则（Open Closed Principle，OCP）：**\n\n软件设计应该对扩展是开放的，对修改是封闭的。OCP 原则可以理解为我们可以对软件系统进行功能上的扩展，但在进行扩展时不应该修改原有的系统代码。即在扩展时应该逐步迭代式开发，比如通过 `jQuery.extend()`。\n\n**2. 单一职责原则（Single Responsibility Principle, SRP）：**\n\n就一个类而言，应该有且只有一个引起其变化的原因，即只有一个职责。比如 Modem 类有两个方法，一个负责管理连接，一个负责通讯，则这个类便**违背**了 SRP 原则。Modem 类应该只用来负责通讯。所谓的“职责”可以理解为一个类所包含的功能范畴，这些功能应该全部属于同一个范畴之内。比如 Modem 类负责通讯，可以有**调整通讯协议**，**调整通讯方式**等方法，而管理连接则不应该属于通讯的范畴，即不应该属于 Modem 类所具有的功能。\n\n**3. 里氏替换原则（Liskov Substitution Principle, LSP)：**\n\n“继承”必须确保超类（父类）所拥有的性质在子类中仍然成立。LSP 原则是继承的“基石”，类之间的父子关系只有满足 LSP 原则时，才能称谓是继承关系。而确保 LSP 原则的方法是：只有当子类能够“替换”掉其父类，并且系统功能不受影响时，父类才能够被复用，子类也能够在父类的基础上增加新的功能。例如：父类-鸟，子类-企鹅，则这个关系便违背了 LSP 原则，因为父类的鸟有“飞”这个方法，但是企鹅并不会飞。\n\n**4. 依赖倒置原则（Dependence Inversion Principle, DIP）：**\n\n高层模块不应该依赖低层模块，二者都应该依赖于抽象。即父类应该是绝对抽象的，而不能是具体的，这样其子类才可以处理所有的情况。例如：父类-人，有一个“吃水果”的方法，而这个方法的参数是“苹果”，这个关系便违背了 DIP 原则，事实上这个“吃水果”的方法应该以更加抽象的“水果”为参数。\n\n**5. 接口隔离原则（Interface Segregation Principle, ISP）：**\n\n多个和客户相关的接口要好于一个通用的接口。这个原则很好理解，永远不要尝试去开发一个“通用”的接口，根据**不同的使用者**将功能独立出来是更好的选择。即一个类应该只对应一个使用者，按照功能或者属性尽量的去划分。\n\n这里再多说一句，设计模式根据应用的角度被分为“**创建型**”、“**结构型**”以及“**行为型**”三种类型。“**创建型**” 可以理解为用来创建对象的模式，这些模式抽象了类实例化的过程。“**结构型**”讨论的是类和对象间的结构，这些模式实现了不同的类继承关系。而“**行为型**”则着力解决的是类实体之间的通讯关系，即某一具体的控制流程。\n\n接下来，我们将会针对几种常用的设计模式进行逐一讲解。\n","slug":"设计模式速谈：一、序论","published":1,"updated":"2019-02-07T15:38:58.505Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtbk007vknp2weiu6qwo","content":"<p>大家在平时的日常工作开发中，可能经常会听到“设计模式”这个词，那么到底什么是设计模式呢？如果要是按照课本上的方式来讲解，估计十篇博客也无法将它讲解透彻。“设计模式”的理论知识固然重要，但理论也是为了实践所做的基础，不要仅被理论就搞昏了头脑。</p>\n<p>“设计模式”顾名思义，就是设计软件体系时所使用的一系列模式，而这些模式是不会变化的或者说只会在很小的程度上变化，但每种模式的整体结构是基本不变的。所以可以说，每一种设计模式都对应着一种问题的解决方法。而如果需要在项目中使用这些方法，就要看哪一种设计模式更加适合自己的项目结构了。抽象的讲，设计模式是可以解决一类软件问题并能够重复使用的软件设计方法。</p>\n<p>“设计模式”是可复用的，也就是说很多结构或功能十分相似的工程项目均可以使用同一种“设计模式”来处理。在选择使用的“设计模式”时要关注程序整体的思路而不是过分的细节。因为“设计模式”是将项目的解决方案整体抽象出来，在类和对象的层次进行描述的。</p>\n<p>“设计模式”的<strong>核心思想</strong>是“<strong>通过增加抽象层，把变化的部分从那些不变的部分中分离出来</strong>”。在接下来的所有“设计模式速谈”系列文章中，针对每一种“设计模式”，我们会结合相应的简单例子来帮助大家理解“设计模式”在实际工程中的应用，而不是单纯的理论概念。</p>\n<p>首先需要知道的是，所有的设计模式都是建立在以下<strong>五种原则</strong>之上的：</p>\n<p><strong>1. “开.闭”原则（Open Closed Principle，OCP）：</strong></p>\n<p>软件设计应该对扩展是开放的，对修改是封闭的。OCP 原则可以理解为我们可以对软件系统进行功能上的扩展，但在进行扩展时不应该修改原有的系统代码。即在扩展时应该逐步迭代式开发，比如通过 <code>jQuery.extend()</code>。</p>\n<p><strong>2. 单一职责原则（Single Responsibility Principle, SRP）：</strong></p>\n<p>就一个类而言，应该有且只有一个引起其变化的原因，即只有一个职责。比如 Modem 类有两个方法，一个负责管理连接，一个负责通讯，则这个类便<strong>违背</strong>了 SRP 原则。Modem 类应该只用来负责通讯。所谓的“职责”可以理解为一个类所包含的功能范畴，这些功能应该全部属于同一个范畴之内。比如 Modem 类负责通讯，可以有<strong>调整通讯协议</strong>，<strong>调整通讯方式</strong>等方法，而管理连接则不应该属于通讯的范畴，即不应该属于 Modem 类所具有的功能。</p>\n<p><strong>3. 里氏替换原则（Liskov Substitution Principle, LSP)：</strong></p>\n<p>“继承”必须确保超类（父类）所拥有的性质在子类中仍然成立。LSP 原则是继承的“基石”，类之间的父子关系只有满足 LSP 原则时，才能称谓是继承关系。而确保 LSP 原则的方法是：只有当子类能够“替换”掉其父类，并且系统功能不受影响时，父类才能够被复用，子类也能够在父类的基础上增加新的功能。例如：父类-鸟，子类-企鹅，则这个关系便违背了 LSP 原则，因为父类的鸟有“飞”这个方法，但是企鹅并不会飞。</p>\n<p><strong>4. 依赖倒置原则（Dependence Inversion Principle, DIP）：</strong></p>\n<p>高层模块不应该依赖低层模块，二者都应该依赖于抽象。即父类应该是绝对抽象的，而不能是具体的，这样其子类才可以处理所有的情况。例如：父类-人，有一个“吃水果”的方法，而这个方法的参数是“苹果”，这个关系便违背了 DIP 原则，事实上这个“吃水果”的方法应该以更加抽象的“水果”为参数。</p>\n<p><strong>5. 接口隔离原则（Interface Segregation Principle, ISP）：</strong></p>\n<p>多个和客户相关的接口要好于一个通用的接口。这个原则很好理解，永远不要尝试去开发一个“通用”的接口，根据<strong>不同的使用者</strong>将功能独立出来是更好的选择。即一个类应该只对应一个使用者，按照功能或者属性尽量的去划分。</p>\n<p>这里再多说一句，设计模式根据应用的角度被分为“<strong>创建型</strong>”、“<strong>结构型</strong>”以及“<strong>行为型</strong>”三种类型。“<strong>创建型</strong>” 可以理解为用来创建对象的模式，这些模式抽象了类实例化的过程。“<strong>结构型</strong>”讨论的是类和对象间的结构，这些模式实现了不同的类继承关系。而“<strong>行为型</strong>”则着力解决的是类实体之间的通讯关系，即某一具体的控制流程。</p>\n<p>接下来，我们将会针对几种常用的设计模式进行逐一讲解。</p>\n","site":{"data":{}},"id":"ac7e5be84d03e4363ac1c371259b5e33","excerpt":"","more":"<p>大家在平时的日常工作开发中，可能经常会听到“设计模式”这个词，那么到底什么是设计模式呢？如果要是按照课本上的方式来讲解，估计十篇博客也无法将它讲解透彻。“设计模式”的理论知识固然重要，但理论也是为了实践所做的基础，不要仅被理论就搞昏了头脑。</p>\n<p>“设计模式”顾名思义，就是设计软件体系时所使用的一系列模式，而这些模式是不会变化的或者说只会在很小的程度上变化，但每种模式的整体结构是基本不变的。所以可以说，每一种设计模式都对应着一种问题的解决方法。而如果需要在项目中使用这些方法，就要看哪一种设计模式更加适合自己的项目结构了。抽象的讲，设计模式是可以解决一类软件问题并能够重复使用的软件设计方法。</p>\n<p>“设计模式”是可复用的，也就是说很多结构或功能十分相似的工程项目均可以使用同一种“设计模式”来处理。在选择使用的“设计模式”时要关注程序整体的思路而不是过分的细节。因为“设计模式”是将项目的解决方案整体抽象出来，在类和对象的层次进行描述的。</p>\n<p>“设计模式”的<strong>核心思想</strong>是“<strong>通过增加抽象层，把变化的部分从那些不变的部分中分离出来</strong>”。在接下来的所有“设计模式速谈”系列文章中，针对每一种“设计模式”，我们会结合相应的简单例子来帮助大家理解“设计模式”在实际工程中的应用，而不是单纯的理论概念。</p>\n<p>首先需要知道的是，所有的设计模式都是建立在以下<strong>五种原则</strong>之上的：</p>\n<p><strong>1. “开.闭”原则（Open Closed Principle，OCP）：</strong></p>\n<p>软件设计应该对扩展是开放的，对修改是封闭的。OCP 原则可以理解为我们可以对软件系统进行功能上的扩展，但在进行扩展时不应该修改原有的系统代码。即在扩展时应该逐步迭代式开发，比如通过 <code>jQuery.extend()</code>。</p>\n<p><strong>2. 单一职责原则（Single Responsibility Principle, SRP）：</strong></p>\n<p>就一个类而言，应该有且只有一个引起其变化的原因，即只有一个职责。比如 Modem 类有两个方法，一个负责管理连接，一个负责通讯，则这个类便<strong>违背</strong>了 SRP 原则。Modem 类应该只用来负责通讯。所谓的“职责”可以理解为一个类所包含的功能范畴，这些功能应该全部属于同一个范畴之内。比如 Modem 类负责通讯，可以有<strong>调整通讯协议</strong>，<strong>调整通讯方式</strong>等方法，而管理连接则不应该属于通讯的范畴，即不应该属于 Modem 类所具有的功能。</p>\n<p><strong>3. 里氏替换原则（Liskov Substitution Principle, LSP)：</strong></p>\n<p>“继承”必须确保超类（父类）所拥有的性质在子类中仍然成立。LSP 原则是继承的“基石”，类之间的父子关系只有满足 LSP 原则时，才能称谓是继承关系。而确保 LSP 原则的方法是：只有当子类能够“替换”掉其父类，并且系统功能不受影响时，父类才能够被复用，子类也能够在父类的基础上增加新的功能。例如：父类-鸟，子类-企鹅，则这个关系便违背了 LSP 原则，因为父类的鸟有“飞”这个方法，但是企鹅并不会飞。</p>\n<p><strong>4. 依赖倒置原则（Dependence Inversion Principle, DIP）：</strong></p>\n<p>高层模块不应该依赖低层模块，二者都应该依赖于抽象。即父类应该是绝对抽象的，而不能是具体的，这样其子类才可以处理所有的情况。例如：父类-人，有一个“吃水果”的方法，而这个方法的参数是“苹果”，这个关系便违背了 DIP 原则，事实上这个“吃水果”的方法应该以更加抽象的“水果”为参数。</p>\n<p><strong>5. 接口隔离原则（Interface Segregation Principle, ISP）：</strong></p>\n<p>多个和客户相关的接口要好于一个通用的接口。这个原则很好理解，永远不要尝试去开发一个“通用”的接口，根据<strong>不同的使用者</strong>将功能独立出来是更好的选择。即一个类应该只对应一个使用者，按照功能或者属性尽量的去划分。</p>\n<p>这里再多说一句，设计模式根据应用的角度被分为“<strong>创建型</strong>”、“<strong>结构型</strong>”以及“<strong>行为型</strong>”三种类型。“<strong>创建型</strong>” 可以理解为用来创建对象的模式，这些模式抽象了类实例化的过程。“<strong>结构型</strong>”讨论的是类和对象间的结构，这些模式实现了不同的类继承关系。而“<strong>行为型</strong>”则着力解决的是类实体之间的通讯关系，即某一具体的控制流程。</p>\n<p>接下来，我们将会针对几种常用的设计模式进行逐一讲解。</p>\n"},{"title":"设计模式速谈：三、工厂模式","intro":"在上一篇文章中，我们首先介绍了“创建型”设计模式中的其中一种 — “简单工厂模式”，而“简单工厂模式”又具体分为两类，一类是只带有“一个产品对象”的最简模式，另一类是带有“一个抽象产品对象”的模式。而今天我们要介绍的是一种更加抽象的“创建型”设计模式 — “工厂模式”。","comments":1,"date":"2016-07-19T00:54:39.000Z","_content":"\n在上一篇文章中，我们首先介绍了“**创建型**”设计模式中的其中一种 — “简单工厂模式”，而“简单工厂模式”又具体分为两类，一类是只带有“**一个产品对象**”的最简模式，另一类是带有“**一个抽象产品对象**”的模式。而今天我们要介绍的是一种更加抽象的“创建型”设计模式 — “**工厂模式**”。\n\n可以说，“工厂模式”是基于“简单工厂模式”抽象出来的一种更加抽象化的设计模式，它把所有“**类实例化**”（包括“工厂”和“产品”）的过程全部放到了**子类**当中去实现，而父类则负责定义创建对象的公共接口。“工厂模式”的一部分结构仍与“简单工厂模式”类似，只是相对于“简单工厂模式”而言，“工厂模式”没有了**固定**的核心工厂类，所有的“工厂”也需要由客户实现并实例化之后才能使用。\n\n“工厂类”作为核心类在“工厂模式”中变成了一个抽象的“工厂”角色，这样处于父类的“核心工厂类”便仅仅负责实现具体工厂子类必须实现的接口，而这样进一步进行抽象的好处便是该模式可以在不修改具体工厂角色的情况下“引进”新的“产品”。下面给出了工厂模式的 UML 类图。\n\n![](1.png)\n\n可以看得出来，相较于之前的“简单工厂模式”，在“工厂模式”中我们又增加一个抽象的“工厂类”，在该类中负责定义一些子类“工厂”所必须实现的通用接口。可以结合下面给出的示例代码来加以理解。\n\n**父类抽象角色**：\n\n```text\nAbstractFactory.java\nAbstractProduct.java\n```\n\n\n```java\n// AbstractFactory.java；\npublic abstract class AbstractFactory {\n    // 通用的抽象工厂父类，负责定义一些子类工厂需要的接口；\n    public abstract AbstractProduct createProduct(Class<!--? extends AbstractProduct--> product);\n}\n```\n\n\n```java\n// AbstractProduct.java；\npublic interface AbstractProduct {\n    // 抽象产品类，封装了产品本身的属性以及方法；\n    public double getPrice();\n    public void setPrice(double price);\n}\n```\n\n**子类抽象角色**：\n\n```text\nConcreteFactoryA.java\nConcreteFactoryB.java\nConcreteProductA.java\nConcreteProductB.java\n```\n\n\n```java\n// ConcreteFactoryA.java；\npublic class ConcreteFactoryA extends AbstractFactory {\n    // 工厂子类，继承自父类工厂；\n    @Override\n    public AbstractProduct createProduct(Class<!--? extends AbstractProduct--> product) {\n        AbstractProduct p = null;\n        try {\n            p = (AbstractProduct) Class.forName(product.getName()).newInstance();\t\t\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return p;\n    }\n}\n```\n\n\n```java\n// ConcreteFactoryB.java；\npublic class ConcreteFactoryB extends AbstractFactory {\n    // 工厂子类，继承自父类工厂；\n    @Override\n    public AbstractProduct createProduct(Class<!--? extends AbstractProduct--> product) {\n        AbstractProduct p = null;\n        try {\n            p = (AbstractProduct) Class.forName(product.getName()).newInstance();\n            // 加价；\n            p.setPrice(p.getPrice() * 1.5);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return p;\n    }\n}\n```\n\n\n```java\n// ConcreteProductA.java；\npublic class ConcreteProductA implements AbstractProduct {\n    // 子类产品，继承自父类产品；\n    private double price = 10.1;\n\t\n    public double getPrice() {\n        return this.price;\n    }\n\t\n    public void setPrice(double price) {\n        this.price = price;\n    }\n}\n\n```\n\n\n```java\n// ConcreteProductB.java；\npublic class ConcreteProductB implements AbstractProduct {\n    // 子类产品，继承自父类产品；\n    private double price = 9.9;\n\t\n    public double getPrice() {\n        return this.price;\n    }\n\t\n    public void setPrice(double price) {\n        this.price = price;\n    }\n}\n```\n\n**客户角色**（实体化工厂并生产产品）：\n\n```text\nClient.java\n```\n\n\n```java\n// Client.java；\npublic class Client {\n    // 客户角色；\n    public static void main(String[] args) {\n        AbstractFactory factoryA = new ConcreteFactoryA();\n        AbstractFactory factoryB = new ConcreteFactoryB();\n\t\t\n        AbstractProduct productAFormFactoryA = factoryA.createProduct(ConcreteProductA.class);\n        AbstractProduct productAFormFactoryB = factoryB.createProduct(ConcreteProductA.class);\n\t\t\n        AbstractProduct productBFormFactoryB = factoryB.createProduct(ConcreteProductB.class);\n\t\t\n        System.out.println(productAFormFactoryA.getPrice());\n        System.out.println(productAFormFactoryB.getPrice());\n        System.out.println(productBFormFactoryB.getPrice());\n    }\n}\n```\n","source":"_posts/设计模式速谈：三、工厂模式.md","raw":"---\ntitle: 设计模式速谈：三、工厂模式\nintro: 在上一篇文章中，我们首先介绍了“创建型”设计模式中的其中一种 — “简单工厂模式”，而“简单工厂模式”又具体分为两类，一类是只带有“一个产品对象”的最简模式，另一类是带有“一个抽象产品对象”的模式。而今天我们要介绍的是一种更加抽象的“创建型”设计模式 — “工厂模式”。\ncomments: true\ndate: 2016-07-19 08:54:39\ntags:\n- 设计模式\n---\n\n在上一篇文章中，我们首先介绍了“**创建型**”设计模式中的其中一种 — “简单工厂模式”，而“简单工厂模式”又具体分为两类，一类是只带有“**一个产品对象**”的最简模式，另一类是带有“**一个抽象产品对象**”的模式。而今天我们要介绍的是一种更加抽象的“创建型”设计模式 — “**工厂模式**”。\n\n可以说，“工厂模式”是基于“简单工厂模式”抽象出来的一种更加抽象化的设计模式，它把所有“**类实例化**”（包括“工厂”和“产品”）的过程全部放到了**子类**当中去实现，而父类则负责定义创建对象的公共接口。“工厂模式”的一部分结构仍与“简单工厂模式”类似，只是相对于“简单工厂模式”而言，“工厂模式”没有了**固定**的核心工厂类，所有的“工厂”也需要由客户实现并实例化之后才能使用。\n\n“工厂类”作为核心类在“工厂模式”中变成了一个抽象的“工厂”角色，这样处于父类的“核心工厂类”便仅仅负责实现具体工厂子类必须实现的接口，而这样进一步进行抽象的好处便是该模式可以在不修改具体工厂角色的情况下“引进”新的“产品”。下面给出了工厂模式的 UML 类图。\n\n![](1.png)\n\n可以看得出来，相较于之前的“简单工厂模式”，在“工厂模式”中我们又增加一个抽象的“工厂类”，在该类中负责定义一些子类“工厂”所必须实现的通用接口。可以结合下面给出的示例代码来加以理解。\n\n**父类抽象角色**：\n\n```text\nAbstractFactory.java\nAbstractProduct.java\n```\n\n\n```java\n// AbstractFactory.java；\npublic abstract class AbstractFactory {\n    // 通用的抽象工厂父类，负责定义一些子类工厂需要的接口；\n    public abstract AbstractProduct createProduct(Class<!--? extends AbstractProduct--> product);\n}\n```\n\n\n```java\n// AbstractProduct.java；\npublic interface AbstractProduct {\n    // 抽象产品类，封装了产品本身的属性以及方法；\n    public double getPrice();\n    public void setPrice(double price);\n}\n```\n\n**子类抽象角色**：\n\n```text\nConcreteFactoryA.java\nConcreteFactoryB.java\nConcreteProductA.java\nConcreteProductB.java\n```\n\n\n```java\n// ConcreteFactoryA.java；\npublic class ConcreteFactoryA extends AbstractFactory {\n    // 工厂子类，继承自父类工厂；\n    @Override\n    public AbstractProduct createProduct(Class<!--? extends AbstractProduct--> product) {\n        AbstractProduct p = null;\n        try {\n            p = (AbstractProduct) Class.forName(product.getName()).newInstance();\t\t\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return p;\n    }\n}\n```\n\n\n```java\n// ConcreteFactoryB.java；\npublic class ConcreteFactoryB extends AbstractFactory {\n    // 工厂子类，继承自父类工厂；\n    @Override\n    public AbstractProduct createProduct(Class<!--? extends AbstractProduct--> product) {\n        AbstractProduct p = null;\n        try {\n            p = (AbstractProduct) Class.forName(product.getName()).newInstance();\n            // 加价；\n            p.setPrice(p.getPrice() * 1.5);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return p;\n    }\n}\n```\n\n\n```java\n// ConcreteProductA.java；\npublic class ConcreteProductA implements AbstractProduct {\n    // 子类产品，继承自父类产品；\n    private double price = 10.1;\n\t\n    public double getPrice() {\n        return this.price;\n    }\n\t\n    public void setPrice(double price) {\n        this.price = price;\n    }\n}\n\n```\n\n\n```java\n// ConcreteProductB.java；\npublic class ConcreteProductB implements AbstractProduct {\n    // 子类产品，继承自父类产品；\n    private double price = 9.9;\n\t\n    public double getPrice() {\n        return this.price;\n    }\n\t\n    public void setPrice(double price) {\n        this.price = price;\n    }\n}\n```\n\n**客户角色**（实体化工厂并生产产品）：\n\n```text\nClient.java\n```\n\n\n```java\n// Client.java；\npublic class Client {\n    // 客户角色；\n    public static void main(String[] args) {\n        AbstractFactory factoryA = new ConcreteFactoryA();\n        AbstractFactory factoryB = new ConcreteFactoryB();\n\t\t\n        AbstractProduct productAFormFactoryA = factoryA.createProduct(ConcreteProductA.class);\n        AbstractProduct productAFormFactoryB = factoryB.createProduct(ConcreteProductA.class);\n\t\t\n        AbstractProduct productBFormFactoryB = factoryB.createProduct(ConcreteProductB.class);\n\t\t\n        System.out.println(productAFormFactoryA.getPrice());\n        System.out.println(productAFormFactoryB.getPrice());\n        System.out.println(productBFormFactoryB.getPrice());\n    }\n}\n```\n","slug":"设计模式速谈：三、工厂模式","published":1,"updated":"2019-02-09T15:08:35.448Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtbl007yknp2sz038q38","content":"<p>在上一篇文章中，我们首先介绍了“<strong>创建型</strong>”设计模式中的其中一种 — “简单工厂模式”，而“简单工厂模式”又具体分为两类，一类是只带有“<strong>一个产品对象</strong>”的最简模式，另一类是带有“<strong>一个抽象产品对象</strong>”的模式。而今天我们要介绍的是一种更加抽象的“创建型”设计模式 — “<strong>工厂模式</strong>”。</p>\n<p>可以说，“工厂模式”是基于“简单工厂模式”抽象出来的一种更加抽象化的设计模式，它把所有“<strong>类实例化</strong>”（包括“工厂”和“产品”）的过程全部放到了<strong>子类</strong>当中去实现，而父类则负责定义创建对象的公共接口。“工厂模式”的一部分结构仍与“简单工厂模式”类似，只是相对于“简单工厂模式”而言，“工厂模式”没有了<strong>固定</strong>的核心工厂类，所有的“工厂”也需要由客户实现并实例化之后才能使用。</p>\n<p>“工厂类”作为核心类在“工厂模式”中变成了一个抽象的“工厂”角色，这样处于父类的“核心工厂类”便仅仅负责实现具体工厂子类必须实现的接口，而这样进一步进行抽象的好处便是该模式可以在不修改具体工厂角色的情况下“引进”新的“产品”。下面给出了工厂模式的 UML 类图。</p>\n<p><img src=\"1.png\" alt></p>\n<p>可以看得出来，相较于之前的“简单工厂模式”，在“工厂模式”中我们又增加一个抽象的“工厂类”，在该类中负责定义一些子类“工厂”所必须实现的通用接口。可以结合下面给出的示例代码来加以理解。</p>\n<p><strong>父类抽象角色</strong>：</p>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">AbstractFactory.java\nAbstractProduct.java\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// AbstractFactory.java；</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">AbstractFactory</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 通用的抽象工厂父类，负责定义一些子类工厂需要的接口；</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> AbstractProduct <span class=\"token function\">createProduct</span><span class=\"token punctuation\">(</span>Class<span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span><span class=\"token operator\">?</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">AbstractProduct</span><span class=\"token operator\">--</span><span class=\"token operator\">></span> product<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// AbstractProduct.java；</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">AbstractProduct</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 抽象产品类，封装了产品本身的属性以及方法；</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">double</span> <span class=\"token function\">getPrice</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setPrice</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">double</span> price<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>子类抽象角色</strong>：</p>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">ConcreteFactoryA.java\nConcreteFactoryB.java\nConcreteProductA.java\nConcreteProductB.java\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// ConcreteFactoryA.java；</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ConcreteFactoryA</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">AbstractFactory</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 工厂子类，继承自父类工厂；</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> AbstractProduct <span class=\"token function\">createProduct</span><span class=\"token punctuation\">(</span>Class<span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span><span class=\"token operator\">?</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">AbstractProduct</span><span class=\"token operator\">--</span><span class=\"token operator\">></span> product<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        AbstractProduct p <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            p <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>AbstractProduct<span class=\"token punctuation\">)</span> Class<span class=\"token punctuation\">.</span><span class=\"token function\">forName</span><span class=\"token punctuation\">(</span>product<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">newInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>        \n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> p<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// ConcreteFactoryB.java；</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ConcreteFactoryB</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">AbstractFactory</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 工厂子类，继承自父类工厂；</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> AbstractProduct <span class=\"token function\">createProduct</span><span class=\"token punctuation\">(</span>Class<span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span><span class=\"token operator\">?</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">AbstractProduct</span><span class=\"token operator\">--</span><span class=\"token operator\">></span> product<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        AbstractProduct p <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            p <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>AbstractProduct<span class=\"token punctuation\">)</span> Class<span class=\"token punctuation\">.</span><span class=\"token function\">forName</span><span class=\"token punctuation\">(</span>product<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">newInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 加价；</span>\n            p<span class=\"token punctuation\">.</span><span class=\"token function\">setPrice</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">.</span><span class=\"token function\">getPrice</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token number\">1.5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> p<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// ConcreteProductA.java；</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ConcreteProductA</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">AbstractProduct</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 子类产品，继承自父类产品；</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">double</span> price <span class=\"token operator\">=</span> <span class=\"token number\">10.1</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">double</span> <span class=\"token function\">getPrice</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>price<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setPrice</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">double</span> price<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>price <span class=\"token operator\">=</span> price<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// ConcreteProductB.java；</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ConcreteProductB</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">AbstractProduct</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 子类产品，继承自父类产品；</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">double</span> price <span class=\"token operator\">=</span> <span class=\"token number\">9.9</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">double</span> <span class=\"token function\">getPrice</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>price<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setPrice</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">double</span> price<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>price <span class=\"token operator\">=</span> price<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>客户角色</strong>（实体化工厂并生产产品）：</p>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">Client.java\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// Client.java；</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Client</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 客户角色；</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        AbstractFactory factoryA <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ConcreteFactoryA</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        AbstractFactory factoryB <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ConcreteFactoryB</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        AbstractProduct productAFormFactoryA <span class=\"token operator\">=</span> factoryA<span class=\"token punctuation\">.</span><span class=\"token function\">createProduct</span><span class=\"token punctuation\">(</span>ConcreteProductA<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        AbstractProduct productAFormFactoryB <span class=\"token operator\">=</span> factoryB<span class=\"token punctuation\">.</span><span class=\"token function\">createProduct</span><span class=\"token punctuation\">(</span>ConcreteProductA<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        AbstractProduct productBFormFactoryB <span class=\"token operator\">=</span> factoryB<span class=\"token punctuation\">.</span><span class=\"token function\">createProduct</span><span class=\"token punctuation\">(</span>ConcreteProductB<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>productAFormFactoryA<span class=\"token punctuation\">.</span><span class=\"token function\">getPrice</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>productAFormFactoryB<span class=\"token punctuation\">.</span><span class=\"token function\">getPrice</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>productBFormFactoryB<span class=\"token punctuation\">.</span><span class=\"token function\">getPrice</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"id":"855ddb6eed0991f4ceb0a0d81f3adb2e","excerpt":"","more":"<p>在上一篇文章中，我们首先介绍了“<strong>创建型</strong>”设计模式中的其中一种 — “简单工厂模式”，而“简单工厂模式”又具体分为两类，一类是只带有“<strong>一个产品对象</strong>”的最简模式，另一类是带有“<strong>一个抽象产品对象</strong>”的模式。而今天我们要介绍的是一种更加抽象的“创建型”设计模式 — “<strong>工厂模式</strong>”。</p>\n<p>可以说，“工厂模式”是基于“简单工厂模式”抽象出来的一种更加抽象化的设计模式，它把所有“<strong>类实例化</strong>”（包括“工厂”和“产品”）的过程全部放到了<strong>子类</strong>当中去实现，而父类则负责定义创建对象的公共接口。“工厂模式”的一部分结构仍与“简单工厂模式”类似，只是相对于“简单工厂模式”而言，“工厂模式”没有了<strong>固定</strong>的核心工厂类，所有的“工厂”也需要由客户实现并实例化之后才能使用。</p>\n<p>“工厂类”作为核心类在“工厂模式”中变成了一个抽象的“工厂”角色，这样处于父类的“核心工厂类”便仅仅负责实现具体工厂子类必须实现的接口，而这样进一步进行抽象的好处便是该模式可以在不修改具体工厂角色的情况下“引进”新的“产品”。下面给出了工厂模式的 UML 类图。</p>\n<p><img src=\"1.png\" alt></p>\n<p>可以看得出来，相较于之前的“简单工厂模式”，在“工厂模式”中我们又增加一个抽象的“工厂类”，在该类中负责定义一些子类“工厂”所必须实现的通用接口。可以结合下面给出的示例代码来加以理解。</p>\n<p><strong>父类抽象角色</strong>：</p>\n<pre><code class=\"text\">AbstractFactory.java\nAbstractProduct.java\n</code></pre>\n<pre><code class=\"java\">// AbstractFactory.java；\npublic abstract class AbstractFactory {\n    // 通用的抽象工厂父类，负责定义一些子类工厂需要的接口；\n    public abstract AbstractProduct createProduct(Class&lt;!--? extends AbstractProduct--&gt; product);\n}\n</code></pre>\n<pre><code class=\"java\">// AbstractProduct.java；\npublic interface AbstractProduct {\n    // 抽象产品类，封装了产品本身的属性以及方法；\n    public double getPrice();\n    public void setPrice(double price);\n}\n</code></pre>\n<p><strong>子类抽象角色</strong>：</p>\n<pre><code class=\"text\">ConcreteFactoryA.java\nConcreteFactoryB.java\nConcreteProductA.java\nConcreteProductB.java\n</code></pre>\n<pre><code class=\"java\">// ConcreteFactoryA.java；\npublic class ConcreteFactoryA extends AbstractFactory {\n    // 工厂子类，继承自父类工厂；\n    @Override\n    public AbstractProduct createProduct(Class&lt;!--? extends AbstractProduct--&gt; product) {\n        AbstractProduct p = null;\n        try {\n            p = (AbstractProduct) Class.forName(product.getName()).newInstance();        \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return p;\n    }\n}\n</code></pre>\n<pre><code class=\"java\">// ConcreteFactoryB.java；\npublic class ConcreteFactoryB extends AbstractFactory {\n    // 工厂子类，继承自父类工厂；\n    @Override\n    public AbstractProduct createProduct(Class&lt;!--? extends AbstractProduct--&gt; product) {\n        AbstractProduct p = null;\n        try {\n            p = (AbstractProduct) Class.forName(product.getName()).newInstance();\n            // 加价；\n            p.setPrice(p.getPrice() * 1.5);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return p;\n    }\n}\n</code></pre>\n<pre><code class=\"java\">// ConcreteProductA.java；\npublic class ConcreteProductA implements AbstractProduct {\n    // 子类产品，继承自父类产品；\n    private double price = 10.1;\n\n    public double getPrice() {\n        return this.price;\n    }\n\n    public void setPrice(double price) {\n        this.price = price;\n    }\n}\n\n</code></pre>\n<pre><code class=\"java\">// ConcreteProductB.java；\npublic class ConcreteProductB implements AbstractProduct {\n    // 子类产品，继承自父类产品；\n    private double price = 9.9;\n\n    public double getPrice() {\n        return this.price;\n    }\n\n    public void setPrice(double price) {\n        this.price = price;\n    }\n}\n</code></pre>\n<p><strong>客户角色</strong>（实体化工厂并生产产品）：</p>\n<pre><code class=\"text\">Client.java\n</code></pre>\n<pre><code class=\"java\">// Client.java；\npublic class Client {\n    // 客户角色；\n    public static void main(String[] args) {\n        AbstractFactory factoryA = new ConcreteFactoryA();\n        AbstractFactory factoryB = new ConcreteFactoryB();\n\n        AbstractProduct productAFormFactoryA = factoryA.createProduct(ConcreteProductA.class);\n        AbstractProduct productAFormFactoryB = factoryB.createProduct(ConcreteProductA.class);\n\n        AbstractProduct productBFormFactoryB = factoryB.createProduct(ConcreteProductB.class);\n\n        System.out.println(productAFormFactoryA.getPrice());\n        System.out.println(productAFormFactoryB.getPrice());\n        System.out.println(productBFormFactoryB.getPrice());\n    }\n}\n</code></pre>\n"},{"title":"设计模式速谈：二、简单工厂模式","intro":"今天要介绍的是属于“创建型”设计模式之一的“简单工厂模式”。顾名思义，这个模式的整体思路十分的简单，但作为设计模式它并不属于 GOF23（一本设计模式的经典著作，一共有23种设计模式） 中的一种。但作为学习设计模式的开篇，“简单工厂模式”再合适不过。","comments":1,"date":"2016-07-17T09:08:13.000Z","_content":"\n\n今天要介绍的是属于“**创建型**”设计模式之一的“**简单工厂模式**”。顾名思义，这个模式的整体思路十分的简单，但作为设计模式它并不属于 GOF23（一本设计模式的经典著作，一共有23种设计模式） 中的一种。但作为学习设计模式的开篇，“简单工厂模式”再合适不过。\n\n“简单工厂模式”又叫做“**静态工厂方法**”，它是由一个工厂对象决定创建出哪一种产品类的实例。若要进行详细区分的话，可以分为两种：\n\n* -只有一个产品对象的简单工厂模式；\n* -带有一个抽象产品的简单工厂模式：\n\n下面给出了这两种具体简单工厂模式的 UML 类图。\n\n**1、只有一个产品对象的简单工厂模式：**\n\n![](1.png)\n\n如下所示的类图中“**虚线**”的部分表示两个类之间的的“**依赖关系**”，其中用户（Client）使用工厂（Factory）来“生产”产品（Product），这里的产品（Product）是固定不变的，即：用该工厂只能“生产”出**特定一种类型**的产品。示例代码如下所示：\n\n```java\n// Factory.java；\npublic class Factory {\n    // “工厂”类直接返回一个“产品”的实例；\n    public static Product createProduct() {\n        return new Product();\n    }\n}\n```\n\n```java\n// Client.java；\npublic class Client {\n    // “客户”类使用“工厂”类来生产“产品”；\n    public static void main(String[] args) {\n        Factory factory = new Factory();\n        // 调用“工厂”的生产方法；\n        Product product = factory.createProduct();\n\t\t\n        System.out.println(product.getPrice());\n    }\n}\n```\n\n```java\n// Product.java；\npublic class Product {\n    // “产品”类，负责包装产品的所有信息；\n    public Product() {}\n\t\n    private double price = 9.9;\n    public double getPrice() {\n        return this.price;\n    }\n}\n\n```\n\n**2、带有一个抽象产品的简单工厂模式：**\n\n![](2.png)\n\n基于前一种模式，只要我们稍加改进便会形成另一种类型的“简单工厂模式”，这里我们将具体的“产品”变为抽象的“产品”，即所有的具体产品均继承自抽象产品类型。这样在“工厂”内部，我们便可以根据“客户”的不同需求来创建不同的“产品”。示例代码如下所示：\n\n```java\n// Factory.java；\npublic class Factory {\n    public static AbstractProduct createProduct(String key) {\n        // 根据客户的选择，生产不同的“产品”；\n        if (key == \"ConcreteProductA\") {\n            return new ConcreteProductA();\n        } else {\n            return new ConcreteProductB();\n        }\n    }\n}\n```\n\n```java\n// Client.java；\npublic class Client {\n    public static void main(String[] args) {\n        Factory factory = new Factory();\n\t    // 客户选择需要“生产”的产品；\n        ConcreteProductA productA = (ConcreteProductA) factory.createProduct(\"ConcreteProductA\");\n        AbstractProduct productB = factory.createProduct(\"ConcreteProductB\");\n\t\t\n        System.out.println(productA.getPrice());\n        System.out.println(productB.getPrice());\n    }\n}\n```\n\n```java\n// AbstractProduct.java；\npublic interface AbstractProduct {\n    // 抽象出的产品接口；\n    double getPrice();\n}\n```\n\n```java\n// ConcreteProductA.java；\npublic class ConcreteProductA implements AbstractProduct {\n    // 具体产品类 A；\n    public ConcreteProductA() {}\n\t\n    private double price = 9.9;\n    public double getPrice() {\n        return this.price;\n    }\n}\n```\n\n```java\n// ConcreteProductB.java；\npublic class ConcreteProductB implements AbstractProduct {\n    // 具体产品类 B；\n    public ConcreteProductB() {}\n\t\n    private double price = 10.1;\n    public double getPrice() {\n        return this.price;\n    }\n}\n```\n\n\n至于对该设计模式的优缺点进行分析，我认为是完全没有必要的。每一种模式都有着其自己所擅长的场景。“具体项目具体分析”才是选择“设计模式”最好的方式。\n\n","source":"_posts/设计模式速谈：二、简单工厂模式.md","raw":"---\ntitle: 设计模式速谈：二、简单工厂模式\nintro: 今天要介绍的是属于“创建型”设计模式之一的“简单工厂模式”。顾名思义，这个模式的整体思路十分的简单，但作为设计模式它并不属于 GOF23（一本设计模式的经典著作，一共有23种设计模式） 中的一种。但作为学习设计模式的开篇，“简单工厂模式”再合适不过。\ncomments: true\ndate: 2016-07-17 17:08:13\ntags:\n- 设计模式\n---\n\n\n今天要介绍的是属于“**创建型**”设计模式之一的“**简单工厂模式**”。顾名思义，这个模式的整体思路十分的简单，但作为设计模式它并不属于 GOF23（一本设计模式的经典著作，一共有23种设计模式） 中的一种。但作为学习设计模式的开篇，“简单工厂模式”再合适不过。\n\n“简单工厂模式”又叫做“**静态工厂方法**”，它是由一个工厂对象决定创建出哪一种产品类的实例。若要进行详细区分的话，可以分为两种：\n\n* -只有一个产品对象的简单工厂模式；\n* -带有一个抽象产品的简单工厂模式：\n\n下面给出了这两种具体简单工厂模式的 UML 类图。\n\n**1、只有一个产品对象的简单工厂模式：**\n\n![](1.png)\n\n如下所示的类图中“**虚线**”的部分表示两个类之间的的“**依赖关系**”，其中用户（Client）使用工厂（Factory）来“生产”产品（Product），这里的产品（Product）是固定不变的，即：用该工厂只能“生产”出**特定一种类型**的产品。示例代码如下所示：\n\n```java\n// Factory.java；\npublic class Factory {\n    // “工厂”类直接返回一个“产品”的实例；\n    public static Product createProduct() {\n        return new Product();\n    }\n}\n```\n\n```java\n// Client.java；\npublic class Client {\n    // “客户”类使用“工厂”类来生产“产品”；\n    public static void main(String[] args) {\n        Factory factory = new Factory();\n        // 调用“工厂”的生产方法；\n        Product product = factory.createProduct();\n\t\t\n        System.out.println(product.getPrice());\n    }\n}\n```\n\n```java\n// Product.java；\npublic class Product {\n    // “产品”类，负责包装产品的所有信息；\n    public Product() {}\n\t\n    private double price = 9.9;\n    public double getPrice() {\n        return this.price;\n    }\n}\n\n```\n\n**2、带有一个抽象产品的简单工厂模式：**\n\n![](2.png)\n\n基于前一种模式，只要我们稍加改进便会形成另一种类型的“简单工厂模式”，这里我们将具体的“产品”变为抽象的“产品”，即所有的具体产品均继承自抽象产品类型。这样在“工厂”内部，我们便可以根据“客户”的不同需求来创建不同的“产品”。示例代码如下所示：\n\n```java\n// Factory.java；\npublic class Factory {\n    public static AbstractProduct createProduct(String key) {\n        // 根据客户的选择，生产不同的“产品”；\n        if (key == \"ConcreteProductA\") {\n            return new ConcreteProductA();\n        } else {\n            return new ConcreteProductB();\n        }\n    }\n}\n```\n\n```java\n// Client.java；\npublic class Client {\n    public static void main(String[] args) {\n        Factory factory = new Factory();\n\t    // 客户选择需要“生产”的产品；\n        ConcreteProductA productA = (ConcreteProductA) factory.createProduct(\"ConcreteProductA\");\n        AbstractProduct productB = factory.createProduct(\"ConcreteProductB\");\n\t\t\n        System.out.println(productA.getPrice());\n        System.out.println(productB.getPrice());\n    }\n}\n```\n\n```java\n// AbstractProduct.java；\npublic interface AbstractProduct {\n    // 抽象出的产品接口；\n    double getPrice();\n}\n```\n\n```java\n// ConcreteProductA.java；\npublic class ConcreteProductA implements AbstractProduct {\n    // 具体产品类 A；\n    public ConcreteProductA() {}\n\t\n    private double price = 9.9;\n    public double getPrice() {\n        return this.price;\n    }\n}\n```\n\n```java\n// ConcreteProductB.java；\npublic class ConcreteProductB implements AbstractProduct {\n    // 具体产品类 B；\n    public ConcreteProductB() {}\n\t\n    private double price = 10.1;\n    public double getPrice() {\n        return this.price;\n    }\n}\n```\n\n\n至于对该设计模式的优缺点进行分析，我认为是完全没有必要的。每一种模式都有着其自己所擅长的场景。“具体项目具体分析”才是选择“设计模式”最好的方式。\n\n","slug":"设计模式速谈：二、简单工厂模式","published":1,"updated":"2019-02-09T14:57:02.261Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtbl0080knp2adqe1ko7","content":"<p>今天要介绍的是属于“<strong>创建型</strong>”设计模式之一的“<strong>简单工厂模式</strong>”。顾名思义，这个模式的整体思路十分的简单，但作为设计模式它并不属于 GOF23（一本设计模式的经典著作，一共有23种设计模式） 中的一种。但作为学习设计模式的开篇，“简单工厂模式”再合适不过。</p>\n<p>“简单工厂模式”又叫做“<strong>静态工厂方法</strong>”，它是由一个工厂对象决定创建出哪一种产品类的实例。若要进行详细区分的话，可以分为两种：</p>\n<ul>\n<li>-只有一个产品对象的简单工厂模式；</li>\n<li>-带有一个抽象产品的简单工厂模式：</li>\n</ul>\n<p>下面给出了这两种具体简单工厂模式的 UML 类图。</p>\n<p><strong>1、只有一个产品对象的简单工厂模式：</strong></p>\n<p><img src=\"1.png\" alt></p>\n<p>如下所示的类图中“<strong>虚线</strong>”的部分表示两个类之间的的“<strong>依赖关系</strong>”，其中用户（Client）使用工厂（Factory）来“生产”产品（Product），这里的产品（Product）是固定不变的，即：用该工厂只能“生产”出<strong>特定一种类型</strong>的产品。示例代码如下所示：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// Factory.java；</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Factory</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// “工厂”类直接返回一个“产品”的实例；</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> Product <span class=\"token function\">createProduct</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Product</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// Client.java；</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Client</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// “客户”类使用“工厂”类来生产“产品”；</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Factory factory <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Factory</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 调用“工厂”的生产方法；</span>\n        Product product <span class=\"token operator\">=</span> factory<span class=\"token punctuation\">.</span><span class=\"token function\">createProduct</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>product<span class=\"token punctuation\">.</span><span class=\"token function\">getPrice</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// Product.java；</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Product</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// “产品”类，负责包装产品的所有信息；</span>\n    <span class=\"token keyword\">public</span> <span class=\"token function\">Product</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">double</span> price <span class=\"token operator\">=</span> <span class=\"token number\">9.9</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">double</span> <span class=\"token function\">getPrice</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>price<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>2、带有一个抽象产品的简单工厂模式：</strong></p>\n<p><img src=\"2.png\" alt></p>\n<p>基于前一种模式，只要我们稍加改进便会形成另一种类型的“简单工厂模式”，这里我们将具体的“产品”变为抽象的“产品”，即所有的具体产品均继承自抽象产品类型。这样在“工厂”内部，我们便可以根据“客户”的不同需求来创建不同的“产品”。示例代码如下所示：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// Factory.java；</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Factory</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> AbstractProduct <span class=\"token function\">createProduct</span><span class=\"token punctuation\">(</span>String key<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 根据客户的选择，生产不同的“产品”；</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>key <span class=\"token operator\">==</span> <span class=\"token string\">\"ConcreteProductA\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ConcreteProductA</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ConcreteProductB</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// Client.java；</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Client</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Factory factory <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Factory</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 客户选择需要“生产”的产品；</span>\n        ConcreteProductA productA <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>ConcreteProductA<span class=\"token punctuation\">)</span> factory<span class=\"token punctuation\">.</span><span class=\"token function\">createProduct</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"ConcreteProductA\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        AbstractProduct productB <span class=\"token operator\">=</span> factory<span class=\"token punctuation\">.</span><span class=\"token function\">createProduct</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"ConcreteProductB\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>productA<span class=\"token punctuation\">.</span><span class=\"token function\">getPrice</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>productB<span class=\"token punctuation\">.</span><span class=\"token function\">getPrice</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// AbstractProduct.java；</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">AbstractProduct</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 抽象出的产品接口；</span>\n    <span class=\"token keyword\">double</span> <span class=\"token function\">getPrice</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// ConcreteProductA.java；</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ConcreteProductA</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">AbstractProduct</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 具体产品类 A；</span>\n    <span class=\"token keyword\">public</span> <span class=\"token function\">ConcreteProductA</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">double</span> price <span class=\"token operator\">=</span> <span class=\"token number\">9.9</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">double</span> <span class=\"token function\">getPrice</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>price<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// ConcreteProductB.java；</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ConcreteProductB</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">AbstractProduct</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 具体产品类 B；</span>\n    <span class=\"token keyword\">public</span> <span class=\"token function\">ConcreteProductB</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">double</span> price <span class=\"token operator\">=</span> <span class=\"token number\">10.1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">double</span> <span class=\"token function\">getPrice</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>price<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>至于对该设计模式的优缺点进行分析，我认为是完全没有必要的。每一种模式都有着其自己所擅长的场景。“具体项目具体分析”才是选择“设计模式”最好的方式。</p>\n","site":{"data":{}},"id":"3cf306ab951dd2f3bcaf2d00c0c6e0cf","excerpt":"","more":"<p>今天要介绍的是属于“<strong>创建型</strong>”设计模式之一的“<strong>简单工厂模式</strong>”。顾名思义，这个模式的整体思路十分的简单，但作为设计模式它并不属于 GOF23（一本设计模式的经典著作，一共有23种设计模式） 中的一种。但作为学习设计模式的开篇，“简单工厂模式”再合适不过。</p>\n<p>“简单工厂模式”又叫做“<strong>静态工厂方法</strong>”，它是由一个工厂对象决定创建出哪一种产品类的实例。若要进行详细区分的话，可以分为两种：</p>\n<ul>\n<li>-只有一个产品对象的简单工厂模式；</li>\n<li>-带有一个抽象产品的简单工厂模式：</li>\n</ul>\n<p>下面给出了这两种具体简单工厂模式的 UML 类图。</p>\n<p><strong>1、只有一个产品对象的简单工厂模式：</strong></p>\n<p><img src=\"1.png\" alt></p>\n<p>如下所示的类图中“<strong>虚线</strong>”的部分表示两个类之间的的“<strong>依赖关系</strong>”，其中用户（Client）使用工厂（Factory）来“生产”产品（Product），这里的产品（Product）是固定不变的，即：用该工厂只能“生产”出<strong>特定一种类型</strong>的产品。示例代码如下所示：</p>\n<pre><code class=\"java\">// Factory.java；\npublic class Factory {\n    // “工厂”类直接返回一个“产品”的实例；\n    public static Product createProduct() {\n        return new Product();\n    }\n}\n</code></pre>\n<pre><code class=\"java\">// Client.java；\npublic class Client {\n    // “客户”类使用“工厂”类来生产“产品”；\n    public static void main(String[] args) {\n        Factory factory = new Factory();\n        // 调用“工厂”的生产方法；\n        Product product = factory.createProduct();\n\n        System.out.println(product.getPrice());\n    }\n}\n</code></pre>\n<pre><code class=\"java\">// Product.java；\npublic class Product {\n    // “产品”类，负责包装产品的所有信息；\n    public Product() {}\n\n    private double price = 9.9;\n    public double getPrice() {\n        return this.price;\n    }\n}\n\n</code></pre>\n<p><strong>2、带有一个抽象产品的简单工厂模式：</strong></p>\n<p><img src=\"2.png\" alt></p>\n<p>基于前一种模式，只要我们稍加改进便会形成另一种类型的“简单工厂模式”，这里我们将具体的“产品”变为抽象的“产品”，即所有的具体产品均继承自抽象产品类型。这样在“工厂”内部，我们便可以根据“客户”的不同需求来创建不同的“产品”。示例代码如下所示：</p>\n<pre><code class=\"java\">// Factory.java；\npublic class Factory {\n    public static AbstractProduct createProduct(String key) {\n        // 根据客户的选择，生产不同的“产品”；\n        if (key == &quot;ConcreteProductA&quot;) {\n            return new ConcreteProductA();\n        } else {\n            return new ConcreteProductB();\n        }\n    }\n}\n</code></pre>\n<pre><code class=\"java\">// Client.java；\npublic class Client {\n    public static void main(String[] args) {\n        Factory factory = new Factory();\n        // 客户选择需要“生产”的产品；\n        ConcreteProductA productA = (ConcreteProductA) factory.createProduct(&quot;ConcreteProductA&quot;);\n        AbstractProduct productB = factory.createProduct(&quot;ConcreteProductB&quot;);\n\n        System.out.println(productA.getPrice());\n        System.out.println(productB.getPrice());\n    }\n}\n</code></pre>\n<pre><code class=\"java\">// AbstractProduct.java；\npublic interface AbstractProduct {\n    // 抽象出的产品接口；\n    double getPrice();\n}\n</code></pre>\n<pre><code class=\"java\">// ConcreteProductA.java；\npublic class ConcreteProductA implements AbstractProduct {\n    // 具体产品类 A；\n    public ConcreteProductA() {}\n\n    private double price = 9.9;\n    public double getPrice() {\n        return this.price;\n    }\n}\n</code></pre>\n<pre><code class=\"java\">// ConcreteProductB.java；\npublic class ConcreteProductB implements AbstractProduct {\n    // 具体产品类 B；\n    public ConcreteProductB() {}\n\n    private double price = 10.1;\n    public double getPrice() {\n        return this.price;\n    }\n}\n</code></pre>\n<p>至于对该设计模式的优缺点进行分析，我认为是完全没有必要的。每一种模式都有着其自己所擅长的场景。“具体项目具体分析”才是选择“设计模式”最好的方式。</p>\n"},{"title":"设计模式速谈：六、单例模式","intro":"在上一篇文章中文我们谈到了“创建型”设计模式中的“建造者模式”，如果用一句话来概括“建造者模式”的精髓，那就是“工头制定计划带着工人的灵感跟客户一起做工程”，这样是不是变得很好理解了呢？今天我们要谈到的仍然是“创建型”中的一种 — “单例模式”。","comments":1,"date":"2016-07-25T00:27:50.000Z","_content":"\n在上一篇文章中文我们谈到了“创建型”设计模式中的“建造者模式”，如果用一句话来概括“建造者模式”的精髓，那就是“工头制定计划带着工人的灵感跟客户一起做工程”，这样是不是变得很好理解了呢？今天我们要谈到的仍然是“创建型”中的一种 — “**单例模式**”。\n\n“单例模式”从字面上来理解，就是只有一个实例的意思，那么在什么情况下一个类只需要一个实例就够了呢？比如：系统中只能有一个窗口管理器、系统中只能有一个文件系统、一个数字滤波器只能有一个 A/D 转换器、一个会计系统只能专用于一个公司等等。其实在日常开发中，“单例模式”是用到的比较多的一种模式，使用场景也是比较普遍的。\n\n那么，使用“单例模式”我们要确保哪些问题呢？答：我们要确保一个类**只有一个实例**并提供一个对它的全局**访问指针**。如果用正常语言来描述，就是对于一个使用“单例模式”的类，我们要保证该类只能提供**一个实例**，同时提供一个可以在**全局范围**内访问这个实例的**接口**。下面给出“单例模式”的UML类图：\n\n![](1.png)\n\n上图中的 Singleton 类即为一个使用了“单例模式”的类，在它的内部有一个静态变量（uniqueInstance）在初始化时便指向了自身的一个实例，同时还要确保用户**不可以**通过该类的构造函数来自行创建新的类实例（设置为私有）。所有对该类的访问只能通过该类提供的**接口（暴露出的变量或方法）**进行访问。\n\n值得一提的是，在 Java 的“单例模式”中常用的一共有五种形式：“**懒汉**”，“**饿汉**”，“**双重校验锁**”，“**枚举**”和“**静态内部类**”。他们都以其各自不同的方式解决了“单例模式”在多线程的情况下线程安全的问题。\n\n**1、懒汉：**\n\n符合 “Lazy Loading” 延迟加载的特性，即用户使用时才会生成相应的对象。\n\n\n```java\npublic class Singleton {  \n    private static Singleton instance = null;  \n    private Singleton (){}  \n    // 保持线程同步；\n    public static synchronized Singleton getInstance() {  \n        if (instance == null) {  \n            instance = new Singleton();  \n        }  \n        return instance;  \n    }  \n}  \n```\n\n**2、饿汉：**\n\n该方式初始时便生成对象。\n\n\n```java\npublic class Singleton {  \n    private static Singleton instance = new Singleton();  \n    private Singleton (){}  \n    public static Singleton getInstance() {  \n        return instance;  \n    }  \n}   \n```\n\n**3、静态内部类：**\n\n该方式利用了一个静态内部类来完成对“单例”的延迟加载，只有当用户“显式”的调用 “getInstance” 方法时系统才会自动生成一个静态内部类并初始化类实例。\n\n\n```java\npublic class Singleton {  \n    private static class SingletonHolder {  \n        private static final Singleton INSTANCE = new Singleton();  \n    }  \n    private Singleton () {}  \n    public static final Singleton getInstance() {  \n        return SingletonHolder.INSTANCE;  \n    }  \n}   \n```\n\n**4、枚举：**\n\n这种方式是《Effective Java》作者 “Josh Bloch” 所倡导的方式，它不仅能避免多线程同步问题，而且还能防止反序列化导致重新创建新的对象。在 Java1.5 之后推荐使用。我们在这里利用一个枚举类型的来作为“单例”的装载器。\n\n\n```java\npublic enum SingletonHelper {  \n    INSTANCE;  \n    private SingletonHelper() {}  \n    public Singleton getInstacne() {\n        Singleton s = new Singleton();\n        return s;\n    }\n}    \n```\n\n**5、双重校验锁：**\n\n该方式是上述“懒汉”的升级版。\n\n\n```java\npublic class Singleton {  \n    private volatile static Singleton singleton;  \n    private Singleton() {}  \n    public static Singleton getSingleton() {  \n        if (singleton == null) {  \n            synchronized (Singleton.class) {  \n                if (singleton == null) {  \n                    singleton = new Singleton();  \n                }  \n            }  \n        }  \n        return singleton;  \n    }  \n}    \n```\n","source":"_posts/设计模式速谈：六、单例模式.md","raw":"---\ntitle: 设计模式速谈：六、单例模式\nintro: 在上一篇文章中文我们谈到了“创建型”设计模式中的“建造者模式”，如果用一句话来概括“建造者模式”的精髓，那就是“工头制定计划带着工人的灵感跟客户一起做工程”，这样是不是变得很好理解了呢？今天我们要谈到的仍然是“创建型”中的一种 — “单例模式”。\ncomments: true\ndate: 2016-07-25 08:27:50\ntags:\n- 设计模式 \n---\n\n在上一篇文章中文我们谈到了“创建型”设计模式中的“建造者模式”，如果用一句话来概括“建造者模式”的精髓，那就是“工头制定计划带着工人的灵感跟客户一起做工程”，这样是不是变得很好理解了呢？今天我们要谈到的仍然是“创建型”中的一种 — “**单例模式**”。\n\n“单例模式”从字面上来理解，就是只有一个实例的意思，那么在什么情况下一个类只需要一个实例就够了呢？比如：系统中只能有一个窗口管理器、系统中只能有一个文件系统、一个数字滤波器只能有一个 A/D 转换器、一个会计系统只能专用于一个公司等等。其实在日常开发中，“单例模式”是用到的比较多的一种模式，使用场景也是比较普遍的。\n\n那么，使用“单例模式”我们要确保哪些问题呢？答：我们要确保一个类**只有一个实例**并提供一个对它的全局**访问指针**。如果用正常语言来描述，就是对于一个使用“单例模式”的类，我们要保证该类只能提供**一个实例**，同时提供一个可以在**全局范围**内访问这个实例的**接口**。下面给出“单例模式”的UML类图：\n\n![](1.png)\n\n上图中的 Singleton 类即为一个使用了“单例模式”的类，在它的内部有一个静态变量（uniqueInstance）在初始化时便指向了自身的一个实例，同时还要确保用户**不可以**通过该类的构造函数来自行创建新的类实例（设置为私有）。所有对该类的访问只能通过该类提供的**接口（暴露出的变量或方法）**进行访问。\n\n值得一提的是，在 Java 的“单例模式”中常用的一共有五种形式：“**懒汉**”，“**饿汉**”，“**双重校验锁**”，“**枚举**”和“**静态内部类**”。他们都以其各自不同的方式解决了“单例模式”在多线程的情况下线程安全的问题。\n\n**1、懒汉：**\n\n符合 “Lazy Loading” 延迟加载的特性，即用户使用时才会生成相应的对象。\n\n\n```java\npublic class Singleton {  \n    private static Singleton instance = null;  \n    private Singleton (){}  \n    // 保持线程同步；\n    public static synchronized Singleton getInstance() {  \n        if (instance == null) {  \n            instance = new Singleton();  \n        }  \n        return instance;  \n    }  \n}  \n```\n\n**2、饿汉：**\n\n该方式初始时便生成对象。\n\n\n```java\npublic class Singleton {  \n    private static Singleton instance = new Singleton();  \n    private Singleton (){}  \n    public static Singleton getInstance() {  \n        return instance;  \n    }  \n}   \n```\n\n**3、静态内部类：**\n\n该方式利用了一个静态内部类来完成对“单例”的延迟加载，只有当用户“显式”的调用 “getInstance” 方法时系统才会自动生成一个静态内部类并初始化类实例。\n\n\n```java\npublic class Singleton {  \n    private static class SingletonHolder {  \n        private static final Singleton INSTANCE = new Singleton();  \n    }  \n    private Singleton () {}  \n    public static final Singleton getInstance() {  \n        return SingletonHolder.INSTANCE;  \n    }  \n}   \n```\n\n**4、枚举：**\n\n这种方式是《Effective Java》作者 “Josh Bloch” 所倡导的方式，它不仅能避免多线程同步问题，而且还能防止反序列化导致重新创建新的对象。在 Java1.5 之后推荐使用。我们在这里利用一个枚举类型的来作为“单例”的装载器。\n\n\n```java\npublic enum SingletonHelper {  \n    INSTANCE;  \n    private SingletonHelper() {}  \n    public Singleton getInstacne() {\n        Singleton s = new Singleton();\n        return s;\n    }\n}    \n```\n\n**5、双重校验锁：**\n\n该方式是上述“懒汉”的升级版。\n\n\n```java\npublic class Singleton {  \n    private volatile static Singleton singleton;  \n    private Singleton() {}  \n    public static Singleton getSingleton() {  \n        if (singleton == null) {  \n            synchronized (Singleton.class) {  \n                if (singleton == null) {  \n                    singleton = new Singleton();  \n                }  \n            }  \n        }  \n        return singleton;  \n    }  \n}    \n```\n","slug":"设计模式速谈：六、单例模式","published":1,"updated":"2019-02-09T15:20:36.070Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtcu00c0knp2d9rc7iib","content":"<p>在上一篇文章中文我们谈到了“创建型”设计模式中的“建造者模式”，如果用一句话来概括“建造者模式”的精髓，那就是“工头制定计划带着工人的灵感跟客户一起做工程”，这样是不是变得很好理解了呢？今天我们要谈到的仍然是“创建型”中的一种 — “<strong>单例模式</strong>”。</p>\n<p>“单例模式”从字面上来理解，就是只有一个实例的意思，那么在什么情况下一个类只需要一个实例就够了呢？比如：系统中只能有一个窗口管理器、系统中只能有一个文件系统、一个数字滤波器只能有一个 A/D 转换器、一个会计系统只能专用于一个公司等等。其实在日常开发中，“单例模式”是用到的比较多的一种模式，使用场景也是比较普遍的。</p>\n<p>那么，使用“单例模式”我们要确保哪些问题呢？答：我们要确保一个类<strong>只有一个实例</strong>并提供一个对它的全局<strong>访问指针</strong>。如果用正常语言来描述，就是对于一个使用“单例模式”的类，我们要保证该类只能提供<strong>一个实例</strong>，同时提供一个可以在<strong>全局范围</strong>内访问这个实例的<strong>接口</strong>。下面给出“单例模式”的UML类图：</p>\n<p><img src=\"1.png\" alt></p>\n<p>上图中的 Singleton 类即为一个使用了“单例模式”的类，在它的内部有一个静态变量（uniqueInstance）在初始化时便指向了自身的一个实例，同时还要确保用户<strong>不可以</strong>通过该类的构造函数来自行创建新的类实例（设置为私有）。所有对该类的访问只能通过该类提供的<strong>接口（暴露出的变量或方法）</strong>进行访问。</p>\n<p>值得一提的是，在 Java 的“单例模式”中常用的一共有五种形式：“<strong>懒汉</strong>”，“<strong>饿汉</strong>”，“<strong>双重校验锁</strong>”，“<strong>枚举</strong>”和“<strong>静态内部类</strong>”。他们都以其各自不同的方式解决了“单例模式”在多线程的情况下线程安全的问题。</p>\n<p><strong>1、懒汉：</strong></p>\n<p>符合 “Lazy Loading” 延迟加载的特性，即用户使用时才会生成相应的对象。</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Singleton</span> <span class=\"token punctuation\">{</span>  \n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> Singleton instance <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>  \n    <span class=\"token keyword\">private</span> <span class=\"token function\">Singleton</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>  \n    <span class=\"token comment\" spellcheck=\"true\">// 保持线程同步；</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">synchronized</span> Singleton <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>instance <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n            instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n        <span class=\"token punctuation\">}</span>  \n        <span class=\"token keyword\">return</span> instance<span class=\"token punctuation\">;</span>  \n    <span class=\"token punctuation\">}</span>  \n<span class=\"token punctuation\">}</span>  \n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>2、饿汉：</strong></p>\n<p>该方式初始时便生成对象。</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Singleton</span> <span class=\"token punctuation\">{</span>  \n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> Singleton instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n    <span class=\"token keyword\">private</span> <span class=\"token function\">Singleton</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>  \n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> Singleton <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n        <span class=\"token keyword\">return</span> instance<span class=\"token punctuation\">;</span>  \n    <span class=\"token punctuation\">}</span>  \n<span class=\"token punctuation\">}</span>   \n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>3、静态内部类：</strong></p>\n<p>该方式利用了一个静态内部类来完成对“单例”的延迟加载，只有当用户“显式”的调用 “getInstance” 方法时系统才会自动生成一个静态内部类并初始化类实例。</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Singleton</span> <span class=\"token punctuation\">{</span>  \n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SingletonHolder</span> <span class=\"token punctuation\">{</span>  \n        <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> Singleton INSTANCE <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n    <span class=\"token punctuation\">}</span>  \n    <span class=\"token keyword\">private</span> <span class=\"token function\">Singleton</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>  \n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> Singleton <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n        <span class=\"token keyword\">return</span> SingletonHolder<span class=\"token punctuation\">.</span>INSTANCE<span class=\"token punctuation\">;</span>  \n    <span class=\"token punctuation\">}</span>  \n<span class=\"token punctuation\">}</span>   \n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>4、枚举：</strong></p>\n<p>这种方式是《Effective Java》作者 “Josh Bloch” 所倡导的方式，它不仅能避免多线程同步问题，而且还能防止反序列化导致重新创建新的对象。在 Java1.5 之后推荐使用。我们在这里利用一个枚举类型的来作为“单例”的装载器。</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">enum</span> SingletonHelper <span class=\"token punctuation\">{</span>  \n    INSTANCE<span class=\"token punctuation\">;</span>  \n    <span class=\"token keyword\">private</span> <span class=\"token function\">SingletonHelper</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>  \n    <span class=\"token keyword\">public</span> Singleton <span class=\"token function\">getInstacne</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Singleton s <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> s<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>    \n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>5、双重校验锁：</strong></p>\n<p>该方式是上述“懒汉”的升级版。</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Singleton</span> <span class=\"token punctuation\">{</span>  \n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">volatile</span> <span class=\"token keyword\">static</span> Singleton singleton<span class=\"token punctuation\">;</span>  \n    <span class=\"token keyword\">private</span> <span class=\"token function\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>  \n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> Singleton <span class=\"token function\">getSingleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>singleton <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n            <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>Singleton<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>singleton <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n                    singleton <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n                <span class=\"token punctuation\">}</span>  \n            <span class=\"token punctuation\">}</span>  \n        <span class=\"token punctuation\">}</span>  \n        <span class=\"token keyword\">return</span> singleton<span class=\"token punctuation\">;</span>  \n    <span class=\"token punctuation\">}</span>  \n<span class=\"token punctuation\">}</span>    \n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"id":"0001d5bfcdb2738e47428eac18cf3b73","excerpt":"","more":"<p>在上一篇文章中文我们谈到了“创建型”设计模式中的“建造者模式”，如果用一句话来概括“建造者模式”的精髓，那就是“工头制定计划带着工人的灵感跟客户一起做工程”，这样是不是变得很好理解了呢？今天我们要谈到的仍然是“创建型”中的一种 — “<strong>单例模式</strong>”。</p>\n<p>“单例模式”从字面上来理解，就是只有一个实例的意思，那么在什么情况下一个类只需要一个实例就够了呢？比如：系统中只能有一个窗口管理器、系统中只能有一个文件系统、一个数字滤波器只能有一个 A/D 转换器、一个会计系统只能专用于一个公司等等。其实在日常开发中，“单例模式”是用到的比较多的一种模式，使用场景也是比较普遍的。</p>\n<p>那么，使用“单例模式”我们要确保哪些问题呢？答：我们要确保一个类<strong>只有一个实例</strong>并提供一个对它的全局<strong>访问指针</strong>。如果用正常语言来描述，就是对于一个使用“单例模式”的类，我们要保证该类只能提供<strong>一个实例</strong>，同时提供一个可以在<strong>全局范围</strong>内访问这个实例的<strong>接口</strong>。下面给出“单例模式”的UML类图：</p>\n<p><img src=\"1.png\" alt></p>\n<p>上图中的 Singleton 类即为一个使用了“单例模式”的类，在它的内部有一个静态变量（uniqueInstance）在初始化时便指向了自身的一个实例，同时还要确保用户<strong>不可以</strong>通过该类的构造函数来自行创建新的类实例（设置为私有）。所有对该类的访问只能通过该类提供的<strong>接口（暴露出的变量或方法）</strong>进行访问。</p>\n<p>值得一提的是，在 Java 的“单例模式”中常用的一共有五种形式：“<strong>懒汉</strong>”，“<strong>饿汉</strong>”，“<strong>双重校验锁</strong>”，“<strong>枚举</strong>”和“<strong>静态内部类</strong>”。他们都以其各自不同的方式解决了“单例模式”在多线程的情况下线程安全的问题。</p>\n<p><strong>1、懒汉：</strong></p>\n<p>符合 “Lazy Loading” 延迟加载的特性，即用户使用时才会生成相应的对象。</p>\n<pre><code class=\"java\">public class Singleton {  \n    private static Singleton instance = null;  \n    private Singleton (){}  \n    // 保持线程同步；\n    public static synchronized Singleton getInstance() {  \n        if (instance == null) {  \n            instance = new Singleton();  \n        }  \n        return instance;  \n    }  \n}  \n</code></pre>\n<p><strong>2、饿汉：</strong></p>\n<p>该方式初始时便生成对象。</p>\n<pre><code class=\"java\">public class Singleton {  \n    private static Singleton instance = new Singleton();  \n    private Singleton (){}  \n    public static Singleton getInstance() {  \n        return instance;  \n    }  \n}   \n</code></pre>\n<p><strong>3、静态内部类：</strong></p>\n<p>该方式利用了一个静态内部类来完成对“单例”的延迟加载，只有当用户“显式”的调用 “getInstance” 方法时系统才会自动生成一个静态内部类并初始化类实例。</p>\n<pre><code class=\"java\">public class Singleton {  \n    private static class SingletonHolder {  \n        private static final Singleton INSTANCE = new Singleton();  \n    }  \n    private Singleton () {}  \n    public static final Singleton getInstance() {  \n        return SingletonHolder.INSTANCE;  \n    }  \n}   \n</code></pre>\n<p><strong>4、枚举：</strong></p>\n<p>这种方式是《Effective Java》作者 “Josh Bloch” 所倡导的方式，它不仅能避免多线程同步问题，而且还能防止反序列化导致重新创建新的对象。在 Java1.5 之后推荐使用。我们在这里利用一个枚举类型的来作为“单例”的装载器。</p>\n<pre><code class=\"java\">public enum SingletonHelper {  \n    INSTANCE;  \n    private SingletonHelper() {}  \n    public Singleton getInstacne() {\n        Singleton s = new Singleton();\n        return s;\n    }\n}    \n</code></pre>\n<p><strong>5、双重校验锁：</strong></p>\n<p>该方式是上述“懒汉”的升级版。</p>\n<pre><code class=\"java\">public class Singleton {  \n    private volatile static Singleton singleton;  \n    private Singleton() {}  \n    public static Singleton getSingleton() {  \n        if (singleton == null) {  \n            synchronized (Singleton.class) {  \n                if (singleton == null) {  \n                    singleton = new Singleton();  \n                }  \n            }  \n        }  \n        return singleton;  \n    }  \n}    \n</code></pre>\n"},{"title":"设计模式速谈：五、建造者模式","intro":"今天我们继续来聊设计模式。在上一篇中我们讲解了“工厂模式”的另一种更加抽象的形式 — “抽象工厂模式”，这种模式适用于属于不同产品族但属于相同产品等级产品的构建。今天要介绍的仍然是“创建型”设计模式中的一种 — “建造者模式”。","comments":1,"date":"2016-07-23T14:10:35.000Z","_content":"\n今天我们继续来聊设计模式。在上一篇中我们讲解了“工厂模式”的另一种更加抽象的形式 — “抽象工厂模式”，这种模式适用于属于不同产品族但属于相同产品等级产品的构建。今天要介绍的仍然是“创建型”设计模式中的一种 — “**建造者模式**”。\n\n试想这样一个场景：我们来设计一个游戏场景中的“房屋”。对于一个“房屋”这个结构来说，它主要包括“地板，墙壁，窗户，门，天花板”这五个基本的部分，并且对于任意一个房屋来说，都是含有这五个基本的组成部分的。同时，我们在构建房子的过程中也是按照一定的顺序来进行的，比如先建造地板和墙壁，最后建造天花板。在这整个构建房屋的过程中，其构建的步骤和顺序是基本相同且**不变**的（比如先建造地板后建造天花板这个顺序）。而相对房屋中某个具体的组件而言（比如门），选用哪种样式，哪种规格的门便需要进行一番商议了，对于一个房屋构建过程中的这部分具体组件的构建我们称其是**易变**的。\n\n在上述的场景中我们可以发现，一个房屋的基本组成结构和构建的顺序是基本不变的，但是对于每一个独立的“组件”而言，又有着不同的组成形式。对于这样的场景，我们便可以使用“建造者模式”来进行构建。\n\n在软件系统中，有时面临着“一个复杂对象”的创建工作，该复杂对象通常由各个部分的子对象用一定的算法构成。这个复杂对象的各个部分经常面临着剧烈变化。，但是将它们组合在一起的算法却相对稳定。而“建造者模式”就是为了解决该类问题而存在的，它将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。\n\n![](1.png)\n\n从上面给出的 UML 类图中可以看到，“建造者模式”将一个复杂任务中相对稳定不变的部分放到了 “Director” 中，而 “Builder” 则规定了每一个具体组件需要遵循的标准，再这个标准之上可以对各个“组件”进行任意的改造。多个 “Builder” 类聚合成了 “Director” 类。\n\n\n```java\n// House.java；\npublic class House {\n    // 房屋类的属性和方法；\n    public int doorStyleNum = 1;\n    public int floorStyleNum = 1;\n    public int wallStyleNum = 1;\n\t\n    public void setDoor(int val) {\n        this.doorStyleNum = val;\n    }\n    public void setFloor(int val) {\n        this.floorStyleNum = val;\n    }\n    public void setWall(int val) {\n        this.wallStyleNum = val;\n    }\n}\n```\n\n\n```java\n// Builder.java；\npublic abstract class Builder {\n    // 抽象的构建器类，记得包含返回实例的方法；\n    public abstract void buildFloor(int val);\n    public abstract void buildDoor(int val);\n    public abstract void buildWall(int val);\n\t\n    public abstract House getHouse();\n}\n```\n\n\n```java\n// ConcreteBuilder.java；\npublic class ConcreteBuilder extends Builder {\n    // 具体的构建器类，记得包含返回实例的方法；\n    House house = null;\n\t\n    public ConcreteBuilder() {\n        this.house = new House();\n    }\n    @Override\n    public void buildFloor() {\n        this.house.setFloor(1);\n    }\n    @Override\n    public void buildDoor() {\n        this.house.setDoor(2);\n    }\n    @Override\n    public void buildWall() {\n        this.house.setWall(3);\n    }\n    @Override\n    public House getHouse() {\n        return this.house;\n    }\n}\n```\n\n\n```java\n// Director.java；\npublic abstract class Director {\n    public static House createHouse(Builder builder) {\n        // 工头类，负责制定工程整体的施工顺序，初期制定好后期基本没事干，全部交由工人去具体实施；\n        builder.buildFloor();\n        builder.buildDoor();\n        builder.buildWall();\n\t\t\n        return builder.getHouse();\n    }\n}\n```\n\n```java\n// Client.java；\npublic class Client {\n    public static void main(String[] args) {\n        // 客户类，让工人们按照工头的旨意去造房子，但工人们都各具自己的特色；\n        House house = Director.createHouse(new ConcreteBuilder());\n        System.out.println(house.doorStyleNum);\n        System.out.println(house.floorStyleNum);\n        System.out.println(house.wallStyleNum);\n    }\n}\n```\n\n对于“建造者模式”的**快速总结**：\n\n* 工头：“我这里制订了整个工程的具体步骤，但具体每个步骤找谁去做，由客户们选择”。\n* 客户1：“第一个步骤我想让小强工人去做，第二个 ...”。\n* 客户2：“第一个步骤我想让小明工人去做，第二个 ...”。\n\n\n\n","source":"_posts/设计模式速谈：五、建造者模式.md","raw":"---\ntitle: 设计模式速谈：五、建造者模式\nintro: 今天我们继续来聊设计模式。在上一篇中我们讲解了“工厂模式”的另一种更加抽象的形式 — “抽象工厂模式”，这种模式适用于属于不同产品族但属于相同产品等级产品的构建。今天要介绍的仍然是“创建型”设计模式中的一种 — “建造者模式”。\ncomments: true\ndate: 2016-07-23 22:10:35\ntags:\n- 设计模式\n---\n\n今天我们继续来聊设计模式。在上一篇中我们讲解了“工厂模式”的另一种更加抽象的形式 — “抽象工厂模式”，这种模式适用于属于不同产品族但属于相同产品等级产品的构建。今天要介绍的仍然是“创建型”设计模式中的一种 — “**建造者模式**”。\n\n试想这样一个场景：我们来设计一个游戏场景中的“房屋”。对于一个“房屋”这个结构来说，它主要包括“地板，墙壁，窗户，门，天花板”这五个基本的部分，并且对于任意一个房屋来说，都是含有这五个基本的组成部分的。同时，我们在构建房子的过程中也是按照一定的顺序来进行的，比如先建造地板和墙壁，最后建造天花板。在这整个构建房屋的过程中，其构建的步骤和顺序是基本相同且**不变**的（比如先建造地板后建造天花板这个顺序）。而相对房屋中某个具体的组件而言（比如门），选用哪种样式，哪种规格的门便需要进行一番商议了，对于一个房屋构建过程中的这部分具体组件的构建我们称其是**易变**的。\n\n在上述的场景中我们可以发现，一个房屋的基本组成结构和构建的顺序是基本不变的，但是对于每一个独立的“组件”而言，又有着不同的组成形式。对于这样的场景，我们便可以使用“建造者模式”来进行构建。\n\n在软件系统中，有时面临着“一个复杂对象”的创建工作，该复杂对象通常由各个部分的子对象用一定的算法构成。这个复杂对象的各个部分经常面临着剧烈变化。，但是将它们组合在一起的算法却相对稳定。而“建造者模式”就是为了解决该类问题而存在的，它将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。\n\n![](1.png)\n\n从上面给出的 UML 类图中可以看到，“建造者模式”将一个复杂任务中相对稳定不变的部分放到了 “Director” 中，而 “Builder” 则规定了每一个具体组件需要遵循的标准，再这个标准之上可以对各个“组件”进行任意的改造。多个 “Builder” 类聚合成了 “Director” 类。\n\n\n```java\n// House.java；\npublic class House {\n    // 房屋类的属性和方法；\n    public int doorStyleNum = 1;\n    public int floorStyleNum = 1;\n    public int wallStyleNum = 1;\n\t\n    public void setDoor(int val) {\n        this.doorStyleNum = val;\n    }\n    public void setFloor(int val) {\n        this.floorStyleNum = val;\n    }\n    public void setWall(int val) {\n        this.wallStyleNum = val;\n    }\n}\n```\n\n\n```java\n// Builder.java；\npublic abstract class Builder {\n    // 抽象的构建器类，记得包含返回实例的方法；\n    public abstract void buildFloor(int val);\n    public abstract void buildDoor(int val);\n    public abstract void buildWall(int val);\n\t\n    public abstract House getHouse();\n}\n```\n\n\n```java\n// ConcreteBuilder.java；\npublic class ConcreteBuilder extends Builder {\n    // 具体的构建器类，记得包含返回实例的方法；\n    House house = null;\n\t\n    public ConcreteBuilder() {\n        this.house = new House();\n    }\n    @Override\n    public void buildFloor() {\n        this.house.setFloor(1);\n    }\n    @Override\n    public void buildDoor() {\n        this.house.setDoor(2);\n    }\n    @Override\n    public void buildWall() {\n        this.house.setWall(3);\n    }\n    @Override\n    public House getHouse() {\n        return this.house;\n    }\n}\n```\n\n\n```java\n// Director.java；\npublic abstract class Director {\n    public static House createHouse(Builder builder) {\n        // 工头类，负责制定工程整体的施工顺序，初期制定好后期基本没事干，全部交由工人去具体实施；\n        builder.buildFloor();\n        builder.buildDoor();\n        builder.buildWall();\n\t\t\n        return builder.getHouse();\n    }\n}\n```\n\n```java\n// Client.java；\npublic class Client {\n    public static void main(String[] args) {\n        // 客户类，让工人们按照工头的旨意去造房子，但工人们都各具自己的特色；\n        House house = Director.createHouse(new ConcreteBuilder());\n        System.out.println(house.doorStyleNum);\n        System.out.println(house.floorStyleNum);\n        System.out.println(house.wallStyleNum);\n    }\n}\n```\n\n对于“建造者模式”的**快速总结**：\n\n* 工头：“我这里制订了整个工程的具体步骤，但具体每个步骤找谁去做，由客户们选择”。\n* 客户1：“第一个步骤我想让小强工人去做，第二个 ...”。\n* 客户2：“第一个步骤我想让小明工人去做，第二个 ...”。\n\n\n\n","slug":"设计模式速谈：五、建造者模式","published":1,"updated":"2019-02-09T15:14:13.860Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtcw00c1knp2ci0jm1p1","content":"<p>今天我们继续来聊设计模式。在上一篇中我们讲解了“工厂模式”的另一种更加抽象的形式 — “抽象工厂模式”，这种模式适用于属于不同产品族但属于相同产品等级产品的构建。今天要介绍的仍然是“创建型”设计模式中的一种 — “<strong>建造者模式</strong>”。</p>\n<p>试想这样一个场景：我们来设计一个游戏场景中的“房屋”。对于一个“房屋”这个结构来说，它主要包括“地板，墙壁，窗户，门，天花板”这五个基本的部分，并且对于任意一个房屋来说，都是含有这五个基本的组成部分的。同时，我们在构建房子的过程中也是按照一定的顺序来进行的，比如先建造地板和墙壁，最后建造天花板。在这整个构建房屋的过程中，其构建的步骤和顺序是基本相同且<strong>不变</strong>的（比如先建造地板后建造天花板这个顺序）。而相对房屋中某个具体的组件而言（比如门），选用哪种样式，哪种规格的门便需要进行一番商议了，对于一个房屋构建过程中的这部分具体组件的构建我们称其是<strong>易变</strong>的。</p>\n<p>在上述的场景中我们可以发现，一个房屋的基本组成结构和构建的顺序是基本不变的，但是对于每一个独立的“组件”而言，又有着不同的组成形式。对于这样的场景，我们便可以使用“建造者模式”来进行构建。</p>\n<p>在软件系统中，有时面临着“一个复杂对象”的创建工作，该复杂对象通常由各个部分的子对象用一定的算法构成。这个复杂对象的各个部分经常面临着剧烈变化。，但是将它们组合在一起的算法却相对稳定。而“建造者模式”就是为了解决该类问题而存在的，它将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p>\n<p><img src=\"1.png\" alt></p>\n<p>从上面给出的 UML 类图中可以看到，“建造者模式”将一个复杂任务中相对稳定不变的部分放到了 “Director” 中，而 “Builder” 则规定了每一个具体组件需要遵循的标准，再这个标准之上可以对各个“组件”进行任意的改造。多个 “Builder” 类聚合成了 “Director” 类。</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// House.java；</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">House</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 房屋类的属性和方法；</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> doorStyleNum <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> floorStyleNum <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> wallStyleNum <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setDoor</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> val<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>doorStyleNum <span class=\"token operator\">=</span> val<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setFloor</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> val<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>floorStyleNum <span class=\"token operator\">=</span> val<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setWall</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> val<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>wallStyleNum <span class=\"token operator\">=</span> val<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// Builder.java；</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Builder</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 抽象的构建器类，记得包含返回实例的方法；</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">void</span> <span class=\"token function\">buildFloor</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">void</span> <span class=\"token function\">buildDoor</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">void</span> <span class=\"token function\">buildWall</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> House <span class=\"token function\">getHouse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// ConcreteBuilder.java；</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ConcreteBuilder</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Builder</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 具体的构建器类，记得包含返回实例的方法；</span>\n    House house <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">ConcreteBuilder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>house <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">House</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">buildFloor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>house<span class=\"token punctuation\">.</span><span class=\"token function\">setFloor</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">buildDoor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>house<span class=\"token punctuation\">.</span><span class=\"token function\">setDoor</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">buildWall</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>house<span class=\"token punctuation\">.</span><span class=\"token function\">setWall</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> House <span class=\"token function\">getHouse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>house<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// Director.java；</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Director</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> House <span class=\"token function\">createHouse</span><span class=\"token punctuation\">(</span>Builder builder<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 工头类，负责制定工程整体的施工顺序，初期制定好后期基本没事干，全部交由工人去具体实施；</span>\n        builder<span class=\"token punctuation\">.</span><span class=\"token function\">buildFloor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        builder<span class=\"token punctuation\">.</span><span class=\"token function\">buildDoor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        builder<span class=\"token punctuation\">.</span><span class=\"token function\">buildWall</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">return</span> builder<span class=\"token punctuation\">.</span><span class=\"token function\">getHouse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// Client.java；</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Client</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 客户类，让工人们按照工头的旨意去造房子，但工人们都各具自己的特色；</span>\n        House house <span class=\"token operator\">=</span> Director<span class=\"token punctuation\">.</span><span class=\"token function\">createHouse</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">ConcreteBuilder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>house<span class=\"token punctuation\">.</span>doorStyleNum<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>house<span class=\"token punctuation\">.</span>floorStyleNum<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>house<span class=\"token punctuation\">.</span>wallStyleNum<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>对于“建造者模式”的<strong>快速总结</strong>：</p>\n<ul>\n<li>工头：“我这里制订了整个工程的具体步骤，但具体每个步骤找谁去做，由客户们选择”。</li>\n<li>客户1：“第一个步骤我想让小强工人去做，第二个 …”。</li>\n<li>客户2：“第一个步骤我想让小明工人去做，第二个 …”。</li>\n</ul>\n","site":{"data":{}},"id":"0a425a20677d775846daecc51efd0567","excerpt":"","more":"<p>今天我们继续来聊设计模式。在上一篇中我们讲解了“工厂模式”的另一种更加抽象的形式 — “抽象工厂模式”，这种模式适用于属于不同产品族但属于相同产品等级产品的构建。今天要介绍的仍然是“创建型”设计模式中的一种 — “<strong>建造者模式</strong>”。</p>\n<p>试想这样一个场景：我们来设计一个游戏场景中的“房屋”。对于一个“房屋”这个结构来说，它主要包括“地板，墙壁，窗户，门，天花板”这五个基本的部分，并且对于任意一个房屋来说，都是含有这五个基本的组成部分的。同时，我们在构建房子的过程中也是按照一定的顺序来进行的，比如先建造地板和墙壁，最后建造天花板。在这整个构建房屋的过程中，其构建的步骤和顺序是基本相同且<strong>不变</strong>的（比如先建造地板后建造天花板这个顺序）。而相对房屋中某个具体的组件而言（比如门），选用哪种样式，哪种规格的门便需要进行一番商议了，对于一个房屋构建过程中的这部分具体组件的构建我们称其是<strong>易变</strong>的。</p>\n<p>在上述的场景中我们可以发现，一个房屋的基本组成结构和构建的顺序是基本不变的，但是对于每一个独立的“组件”而言，又有着不同的组成形式。对于这样的场景，我们便可以使用“建造者模式”来进行构建。</p>\n<p>在软件系统中，有时面临着“一个复杂对象”的创建工作，该复杂对象通常由各个部分的子对象用一定的算法构成。这个复杂对象的各个部分经常面临着剧烈变化。，但是将它们组合在一起的算法却相对稳定。而“建造者模式”就是为了解决该类问题而存在的，它将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p>\n<p><img src=\"1.png\" alt></p>\n<p>从上面给出的 UML 类图中可以看到，“建造者模式”将一个复杂任务中相对稳定不变的部分放到了 “Director” 中，而 “Builder” 则规定了每一个具体组件需要遵循的标准，再这个标准之上可以对各个“组件”进行任意的改造。多个 “Builder” 类聚合成了 “Director” 类。</p>\n<pre><code class=\"java\">// House.java；\npublic class House {\n    // 房屋类的属性和方法；\n    public int doorStyleNum = 1;\n    public int floorStyleNum = 1;\n    public int wallStyleNum = 1;\n\n    public void setDoor(int val) {\n        this.doorStyleNum = val;\n    }\n    public void setFloor(int val) {\n        this.floorStyleNum = val;\n    }\n    public void setWall(int val) {\n        this.wallStyleNum = val;\n    }\n}\n</code></pre>\n<pre><code class=\"java\">// Builder.java；\npublic abstract class Builder {\n    // 抽象的构建器类，记得包含返回实例的方法；\n    public abstract void buildFloor(int val);\n    public abstract void buildDoor(int val);\n    public abstract void buildWall(int val);\n\n    public abstract House getHouse();\n}\n</code></pre>\n<pre><code class=\"java\">// ConcreteBuilder.java；\npublic class ConcreteBuilder extends Builder {\n    // 具体的构建器类，记得包含返回实例的方法；\n    House house = null;\n\n    public ConcreteBuilder() {\n        this.house = new House();\n    }\n    @Override\n    public void buildFloor() {\n        this.house.setFloor(1);\n    }\n    @Override\n    public void buildDoor() {\n        this.house.setDoor(2);\n    }\n    @Override\n    public void buildWall() {\n        this.house.setWall(3);\n    }\n    @Override\n    public House getHouse() {\n        return this.house;\n    }\n}\n</code></pre>\n<pre><code class=\"java\">// Director.java；\npublic abstract class Director {\n    public static House createHouse(Builder builder) {\n        // 工头类，负责制定工程整体的施工顺序，初期制定好后期基本没事干，全部交由工人去具体实施；\n        builder.buildFloor();\n        builder.buildDoor();\n        builder.buildWall();\n\n        return builder.getHouse();\n    }\n}\n</code></pre>\n<pre><code class=\"java\">// Client.java；\npublic class Client {\n    public static void main(String[] args) {\n        // 客户类，让工人们按照工头的旨意去造房子，但工人们都各具自己的特色；\n        House house = Director.createHouse(new ConcreteBuilder());\n        System.out.println(house.doorStyleNum);\n        System.out.println(house.floorStyleNum);\n        System.out.println(house.wallStyleNum);\n    }\n}\n</code></pre>\n<p>对于“建造者模式”的<strong>快速总结</strong>：</p>\n<ul>\n<li>工头：“我这里制订了整个工程的具体步骤，但具体每个步骤找谁去做，由客户们选择”。</li>\n<li>客户1：“第一个步骤我想让小强工人去做，第二个 …”。</li>\n<li>客户2：“第一个步骤我想让小明工人去做，第二个 …”。</li>\n</ul>\n"},{"title":"设计模式速谈：四、抽象工厂模式","intro":"上一篇文章中我们讲到了“工厂模式”，它的特征是把所有“类实例化”（包括“工厂”和“产品”）的过程全部放到了“子类”当中去实现。今天我们来说说“工厂系列”的最后一种模式 — “抽象工厂模式”。其实它的本质是“工厂模式”进一步抽象的结果。","comments":1,"date":"2016-07-20T16:18:38.000Z","_content":"\n上一篇文章中我们讲到了“**工厂模式**”，它的特征是把所有“**类实例化**”（包括“工厂”和“产品”）的过程全部放到了**子类**当中去实现。今天我们来说说“工厂系列”的最后一种模式 — “**抽象工厂模式**”。其实它的本质是“工厂模式”进一步抽象的结果。\n\n在“工厂模式”中，我们的“**父类**”是作为某一种“**具体类**”的抽象而存在的，比如一个具体类叫“白种人”，那么它的抽象类为“人类”；一个具体类“白种人工厂”的抽象类即为“人类工厂”，“白种人工厂”只能生产白种人，“黄种人工厂”只能生产黄种人，以此类推。因此，在“工厂模式”中，**每一个继承自“父类”工厂的具体工厂类所生产的东西是不同的**。再举一个例子，比如一个抽象父类“食物工厂类”，每一种继承自它的“子类”都只能生成出自己所属的那种食物，比如饼干，面包等等。\n\n那么，如果我想要两个继承自同一个“父类”的具体子类都可以制造生产同样的东西呢？比如两个工厂一个是“热带工厂”，另一个是“亚热带工厂”，但这两个工厂都可以生产蔬菜和水果，只是这些蔬菜和水果来自不同的“**产品族**”（可以理解为不同工厂）而已。我们可以理解为不同的工厂都生成同一种类型的东西，即称这些东西来自不同的“**产品族**”，而来自同一个工厂的不同东西之间是属于不同“**产品等级**”的关系。“抽象工厂模式”便是为了解决这个问题而来的，该模式的 UML 类图如下所示：\n\n![](1.png)\n\n从上述类图中可以很明确的看出各个类与接口之间的继承关系，在父类的工厂接口中定义了属于**不同产品族**的两个工厂的共有方法和属性。对应上述类图我们在下面给出了该模式对应的示例代码：\n\n**父类抽象接口角色**：\n\n```text\nFruitInterface.java\nVegetableInterface.java\nFactoryInterface.java\n```\n\n\n```java\n// FruitInterface.java；\npublic interface Fruit {\n    public double getPrice();\n}\n```\n\n\n```java\n// VegetableInterface.java；\npublic interface Vegetable {\n    public double getPrice();\n}\n```\n\n\n```java\n// FactoryInterface.java；\npublic interface Factory {\n    // 当传入了错误的参数（比如向热带工厂提出生成亚热带产品的要求）时会抛出异常；\n    public Fruit produceFruit(Class<? extends Fruit> product) throws Exception;\n    public Vegetable produceVegetable(Class<? extends Vegetable> product) throws Exception;\n}\n```\n\n**子类抽象工厂**：\n\n```text\nTropicalFactory.java\nSubtropicalFactory.java\n```\n\n\n```java\n// TropicalFactory.java；\npublic class TropicalFactory implements Factory {\n    @Override\n    public Fruit produceFruit(Class<? extends Fruit> product) throws Exception {\n        // 判断是否符合生成规范；\n        if (product == TropicalFruit.class) {\n            return (Fruit) Class.forName(product.getName()).newInstance();\n        } else {\n            // 不规范则抛出异常；\n            throw new Exception(&quot;We can not produce it!&quot;);\n        }\n    }\n    @Override\n    public Vegetable produceVegetable(Class<? extends Vegetable> product) throws Exception {\n        if (product == TropicalVegetable.class) {\n            return (Vegetable) Class.forName(product.getName()).newInstance();\n        } else {\n            throw new Exception(&quot;We can not produce it!&quot;);\n        }\n    }\n}\n```\n\n\n```java\n// SubtropicalFactory.java；\npublic class SubtropicalFactory implements Factory {\n    @Override\n    public Fruit produceFruit(Class<? extends Fruit> product) throws Exception {\n        if (product == SubtropicalFruit.class) {\n            return (Fruit) Class.forName(product.getName()).newInstance();\n        } else {\n            throw new Exception(&quot;We can not produce it!&quot;);\n        }\n    }\n    @Override\n    public Vegetable produceVegetable(Class<? extends Vegetable> product) throws Exception {\n        if (product == SubtropicalVegetable.class) {\n\t        return (Vegetable) Class.forName(product.getName()).newInstance();\n        } else {\n            throw new Exception(&quot;We can not produce it!&quot;);\n        }\n    }\n}\n```\n\n**子类抽象水果产品**：\n\n```text\nTropicalFruit.java\nSubtropicalFruit.java\n```\n\n\n```java\n// TropicalFruit.java；\npublic class TropicalFruit implements Fruit {\n    private double price = 1.82;\n    @Override\n    public double getPrice() {\n        return this.price;\n    }\n}\n```\n\n\n```java\n// SubtropicalFruit.java；\npublic class SubtropicalFruit implements Fruit {\n    private double price = 1.54;\n    @Override\n    public double getPrice() {\n        return this.price;\n    }\n}\n```\n\n**子类抽象蔬菜产品**：\n\n```text\nTropicalVegetable.java\nSubtropicalVegetable.java\n```\n\n\n```java\n// TropicalVegetable.java；\npublic class TropicalVegetable implements Vegetable {\n    private double price = 1.21;\n    @Override\n    public double getPrice() {\n        return this.price;\n    }\n}\n```\n\n\n```java\n// SubtropicalVegetable.java；\npublic class SubtropicalVegetable implements Vegetable {\n    private double price = 1.11;\n    @Override\n    public double getPrice() {\n        return this.price;\n    }\n}\n```\n\n**客户角色**：\n\n```text\nclient.java\n```\n\n\n```java\n// Client.java；\npublic class Client {\n    public static void main(String[] args) {\n        TropicalFactory tropicalFactory = new TropicalFactory();\n\t\t\n        try {\n            // 以正确的生成方式生产产品；\n            Fruit tropicalFruit = tropicalFactory.produceFruit(TropicalFruit.class);\n            System.out.println(tropicalFruit.getPrice());\n\t\t\t\n            // 以不正确的生成方式生产产品；\n            Fruit subTropicalFruit = tropicalFactory.produceFruit(SubtropicalFruit.class);\n            System.out.println(subTropicalFruit.getPrice());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n","source":"_posts/设计模式速谈：四、抽象工厂模式.md","raw":"---\ntitle: 设计模式速谈：四、抽象工厂模式\nintro: 上一篇文章中我们讲到了“工厂模式”，它的特征是把所有“类实例化”（包括“工厂”和“产品”）的过程全部放到了“子类”当中去实现。今天我们来说说“工厂系列”的最后一种模式 — “抽象工厂模式”。其实它的本质是“工厂模式”进一步抽象的结果。\ncomments: true\ndate: 2016-07-21 00:18:38\ntags:\n- 设计模式\n---\n\n上一篇文章中我们讲到了“**工厂模式**”，它的特征是把所有“**类实例化**”（包括“工厂”和“产品”）的过程全部放到了**子类**当中去实现。今天我们来说说“工厂系列”的最后一种模式 — “**抽象工厂模式**”。其实它的本质是“工厂模式”进一步抽象的结果。\n\n在“工厂模式”中，我们的“**父类**”是作为某一种“**具体类**”的抽象而存在的，比如一个具体类叫“白种人”，那么它的抽象类为“人类”；一个具体类“白种人工厂”的抽象类即为“人类工厂”，“白种人工厂”只能生产白种人，“黄种人工厂”只能生产黄种人，以此类推。因此，在“工厂模式”中，**每一个继承自“父类”工厂的具体工厂类所生产的东西是不同的**。再举一个例子，比如一个抽象父类“食物工厂类”，每一种继承自它的“子类”都只能生成出自己所属的那种食物，比如饼干，面包等等。\n\n那么，如果我想要两个继承自同一个“父类”的具体子类都可以制造生产同样的东西呢？比如两个工厂一个是“热带工厂”，另一个是“亚热带工厂”，但这两个工厂都可以生产蔬菜和水果，只是这些蔬菜和水果来自不同的“**产品族**”（可以理解为不同工厂）而已。我们可以理解为不同的工厂都生成同一种类型的东西，即称这些东西来自不同的“**产品族**”，而来自同一个工厂的不同东西之间是属于不同“**产品等级**”的关系。“抽象工厂模式”便是为了解决这个问题而来的，该模式的 UML 类图如下所示：\n\n![](1.png)\n\n从上述类图中可以很明确的看出各个类与接口之间的继承关系，在父类的工厂接口中定义了属于**不同产品族**的两个工厂的共有方法和属性。对应上述类图我们在下面给出了该模式对应的示例代码：\n\n**父类抽象接口角色**：\n\n```text\nFruitInterface.java\nVegetableInterface.java\nFactoryInterface.java\n```\n\n\n```java\n// FruitInterface.java；\npublic interface Fruit {\n    public double getPrice();\n}\n```\n\n\n```java\n// VegetableInterface.java；\npublic interface Vegetable {\n    public double getPrice();\n}\n```\n\n\n```java\n// FactoryInterface.java；\npublic interface Factory {\n    // 当传入了错误的参数（比如向热带工厂提出生成亚热带产品的要求）时会抛出异常；\n    public Fruit produceFruit(Class<? extends Fruit> product) throws Exception;\n    public Vegetable produceVegetable(Class<? extends Vegetable> product) throws Exception;\n}\n```\n\n**子类抽象工厂**：\n\n```text\nTropicalFactory.java\nSubtropicalFactory.java\n```\n\n\n```java\n// TropicalFactory.java；\npublic class TropicalFactory implements Factory {\n    @Override\n    public Fruit produceFruit(Class<? extends Fruit> product) throws Exception {\n        // 判断是否符合生成规范；\n        if (product == TropicalFruit.class) {\n            return (Fruit) Class.forName(product.getName()).newInstance();\n        } else {\n            // 不规范则抛出异常；\n            throw new Exception(&quot;We can not produce it!&quot;);\n        }\n    }\n    @Override\n    public Vegetable produceVegetable(Class<? extends Vegetable> product) throws Exception {\n        if (product == TropicalVegetable.class) {\n            return (Vegetable) Class.forName(product.getName()).newInstance();\n        } else {\n            throw new Exception(&quot;We can not produce it!&quot;);\n        }\n    }\n}\n```\n\n\n```java\n// SubtropicalFactory.java；\npublic class SubtropicalFactory implements Factory {\n    @Override\n    public Fruit produceFruit(Class<? extends Fruit> product) throws Exception {\n        if (product == SubtropicalFruit.class) {\n            return (Fruit) Class.forName(product.getName()).newInstance();\n        } else {\n            throw new Exception(&quot;We can not produce it!&quot;);\n        }\n    }\n    @Override\n    public Vegetable produceVegetable(Class<? extends Vegetable> product) throws Exception {\n        if (product == SubtropicalVegetable.class) {\n\t        return (Vegetable) Class.forName(product.getName()).newInstance();\n        } else {\n            throw new Exception(&quot;We can not produce it!&quot;);\n        }\n    }\n}\n```\n\n**子类抽象水果产品**：\n\n```text\nTropicalFruit.java\nSubtropicalFruit.java\n```\n\n\n```java\n// TropicalFruit.java；\npublic class TropicalFruit implements Fruit {\n    private double price = 1.82;\n    @Override\n    public double getPrice() {\n        return this.price;\n    }\n}\n```\n\n\n```java\n// SubtropicalFruit.java；\npublic class SubtropicalFruit implements Fruit {\n    private double price = 1.54;\n    @Override\n    public double getPrice() {\n        return this.price;\n    }\n}\n```\n\n**子类抽象蔬菜产品**：\n\n```text\nTropicalVegetable.java\nSubtropicalVegetable.java\n```\n\n\n```java\n// TropicalVegetable.java；\npublic class TropicalVegetable implements Vegetable {\n    private double price = 1.21;\n    @Override\n    public double getPrice() {\n        return this.price;\n    }\n}\n```\n\n\n```java\n// SubtropicalVegetable.java；\npublic class SubtropicalVegetable implements Vegetable {\n    private double price = 1.11;\n    @Override\n    public double getPrice() {\n        return this.price;\n    }\n}\n```\n\n**客户角色**：\n\n```text\nclient.java\n```\n\n\n```java\n// Client.java；\npublic class Client {\n    public static void main(String[] args) {\n        TropicalFactory tropicalFactory = new TropicalFactory();\n\t\t\n        try {\n            // 以正确的生成方式生产产品；\n            Fruit tropicalFruit = tropicalFactory.produceFruit(TropicalFruit.class);\n            System.out.println(tropicalFruit.getPrice());\n\t\t\t\n            // 以不正确的生成方式生产产品；\n            Fruit subTropicalFruit = tropicalFactory.produceFruit(SubtropicalFruit.class);\n            System.out.println(subTropicalFruit.getPrice());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n","slug":"设计模式速谈：四、抽象工厂模式","published":1,"updated":"2019-02-09T15:10:53.905Z","layout":"post","photos":[],"link":"","_id":"cjsqwhtcw00c3knp2yfnx6ev9","content":"<p>上一篇文章中我们讲到了“<strong>工厂模式</strong>”，它的特征是把所有“<strong>类实例化</strong>”（包括“工厂”和“产品”）的过程全部放到了<strong>子类</strong>当中去实现。今天我们来说说“工厂系列”的最后一种模式 — “<strong>抽象工厂模式</strong>”。其实它的本质是“工厂模式”进一步抽象的结果。</p>\n<p>在“工厂模式”中，我们的“<strong>父类</strong>”是作为某一种“<strong>具体类</strong>”的抽象而存在的，比如一个具体类叫“白种人”，那么它的抽象类为“人类”；一个具体类“白种人工厂”的抽象类即为“人类工厂”，“白种人工厂”只能生产白种人，“黄种人工厂”只能生产黄种人，以此类推。因此，在“工厂模式”中，<strong>每一个继承自“父类”工厂的具体工厂类所生产的东西是不同的</strong>。再举一个例子，比如一个抽象父类“食物工厂类”，每一种继承自它的“子类”都只能生成出自己所属的那种食物，比如饼干，面包等等。</p>\n<p>那么，如果我想要两个继承自同一个“父类”的具体子类都可以制造生产同样的东西呢？比如两个工厂一个是“热带工厂”，另一个是“亚热带工厂”，但这两个工厂都可以生产蔬菜和水果，只是这些蔬菜和水果来自不同的“<strong>产品族</strong>”（可以理解为不同工厂）而已。我们可以理解为不同的工厂都生成同一种类型的东西，即称这些东西来自不同的“<strong>产品族</strong>”，而来自同一个工厂的不同东西之间是属于不同“<strong>产品等级</strong>”的关系。“抽象工厂模式”便是为了解决这个问题而来的，该模式的 UML 类图如下所示：</p>\n<p><img src=\"1.png\" alt></p>\n<p>从上述类图中可以很明确的看出各个类与接口之间的继承关系，在父类的工厂接口中定义了属于<strong>不同产品族</strong>的两个工厂的共有方法和属性。对应上述类图我们在下面给出了该模式对应的示例代码：</p>\n<p><strong>父类抽象接口角色</strong>：</p>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">FruitInterface.java\nVegetableInterface.java\nFactoryInterface.java\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// FruitInterface.java；</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Fruit</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">double</span> <span class=\"token function\">getPrice</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// VegetableInterface.java；</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Vegetable</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">double</span> <span class=\"token function\">getPrice</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// FactoryInterface.java；</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Factory</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 当传入了错误的参数（比如向热带工厂提出生成亚热带产品的要求）时会抛出异常；</span>\n    <span class=\"token keyword\">public</span> Fruit <span class=\"token function\">produceFruit</span><span class=\"token punctuation\">(</span>Class<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Fruit</span><span class=\"token operator\">></span> product<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> Exception<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> Vegetable <span class=\"token function\">produceVegetable</span><span class=\"token punctuation\">(</span>Class<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Vegetable</span><span class=\"token operator\">></span> product<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> Exception<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>子类抽象工厂</strong>：</p>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">TropicalFactory.java\nSubtropicalFactory.java\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// TropicalFactory.java；</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TropicalFactory</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Factory</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> Fruit <span class=\"token function\">produceFruit</span><span class=\"token punctuation\">(</span>Class<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Fruit</span><span class=\"token operator\">></span> product<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> Exception <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 判断是否符合生成规范；</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>product <span class=\"token operator\">==</span> TropicalFruit<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>Fruit<span class=\"token punctuation\">)</span> Class<span class=\"token punctuation\">.</span><span class=\"token function\">forName</span><span class=\"token punctuation\">(</span>product<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">newInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 不规范则抛出异常；</span>\n            <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Exception</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>We can not produce it<span class=\"token operator\">!</span><span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> Vegetable <span class=\"token function\">produceVegetable</span><span class=\"token punctuation\">(</span>Class<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Vegetable</span><span class=\"token operator\">></span> product<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> Exception <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>product <span class=\"token operator\">==</span> TropicalVegetable<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>Vegetable<span class=\"token punctuation\">)</span> Class<span class=\"token punctuation\">.</span><span class=\"token function\">forName</span><span class=\"token punctuation\">(</span>product<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">newInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Exception</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>We can not produce it<span class=\"token operator\">!</span><span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// SubtropicalFactory.java；</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SubtropicalFactory</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Factory</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> Fruit <span class=\"token function\">produceFruit</span><span class=\"token punctuation\">(</span>Class<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Fruit</span><span class=\"token operator\">></span> product<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> Exception <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>product <span class=\"token operator\">==</span> SubtropicalFruit<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>Fruit<span class=\"token punctuation\">)</span> Class<span class=\"token punctuation\">.</span><span class=\"token function\">forName</span><span class=\"token punctuation\">(</span>product<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">newInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Exception</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>We can not produce it<span class=\"token operator\">!</span><span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> Vegetable <span class=\"token function\">produceVegetable</span><span class=\"token punctuation\">(</span>Class<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Vegetable</span><span class=\"token operator\">></span> product<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> Exception <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>product <span class=\"token operator\">==</span> SubtropicalVegetable<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>Vegetable<span class=\"token punctuation\">)</span> Class<span class=\"token punctuation\">.</span><span class=\"token function\">forName</span><span class=\"token punctuation\">(</span>product<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">newInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Exception</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span>We can not produce it<span class=\"token operator\">!</span><span class=\"token operator\">&amp;</span>quot<span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>子类抽象水果产品</strong>：</p>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">TropicalFruit.java\nSubtropicalFruit.java\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// TropicalFruit.java；</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TropicalFruit</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Fruit</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">double</span> price <span class=\"token operator\">=</span> <span class=\"token number\">1.82</span><span class=\"token punctuation\">;</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">double</span> <span class=\"token function\">getPrice</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>price<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// SubtropicalFruit.java；</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SubtropicalFruit</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Fruit</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">double</span> price <span class=\"token operator\">=</span> <span class=\"token number\">1.54</span><span class=\"token punctuation\">;</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">double</span> <span class=\"token function\">getPrice</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>price<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>子类抽象蔬菜产品</strong>：</p>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">TropicalVegetable.java\nSubtropicalVegetable.java\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// TropicalVegetable.java；</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TropicalVegetable</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Vegetable</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">double</span> price <span class=\"token operator\">=</span> <span class=\"token number\">1.21</span><span class=\"token punctuation\">;</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">double</span> <span class=\"token function\">getPrice</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>price<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// SubtropicalVegetable.java；</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SubtropicalVegetable</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Vegetable</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">double</span> price <span class=\"token operator\">=</span> <span class=\"token number\">1.11</span><span class=\"token punctuation\">;</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">double</span> <span class=\"token function\">getPrice</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>price<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>客户角色</strong>：</p>\n<pre class=\"line-numbers language-text\"><code class=\"language-text\">client.java\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// Client.java；</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Client</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        TropicalFactory tropicalFactory <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TropicalFactory</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 以正确的生成方式生产产品；</span>\n            Fruit tropicalFruit <span class=\"token operator\">=</span> tropicalFactory<span class=\"token punctuation\">.</span><span class=\"token function\">produceFruit</span><span class=\"token punctuation\">(</span>TropicalFruit<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>tropicalFruit<span class=\"token punctuation\">.</span><span class=\"token function\">getPrice</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">// 以不正确的生成方式生产产品；</span>\n            Fruit subTropicalFruit <span class=\"token operator\">=</span> tropicalFactory<span class=\"token punctuation\">.</span><span class=\"token function\">produceFruit</span><span class=\"token punctuation\">(</span>SubtropicalFruit<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>subTropicalFruit<span class=\"token punctuation\">.</span><span class=\"token function\">getPrice</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"id":"c3051da88d2c0206278700711c43ee49","excerpt":"","more":"<p>上一篇文章中我们讲到了“<strong>工厂模式</strong>”，它的特征是把所有“<strong>类实例化</strong>”（包括“工厂”和“产品”）的过程全部放到了<strong>子类</strong>当中去实现。今天我们来说说“工厂系列”的最后一种模式 — “<strong>抽象工厂模式</strong>”。其实它的本质是“工厂模式”进一步抽象的结果。</p>\n<p>在“工厂模式”中，我们的“<strong>父类</strong>”是作为某一种“<strong>具体类</strong>”的抽象而存在的，比如一个具体类叫“白种人”，那么它的抽象类为“人类”；一个具体类“白种人工厂”的抽象类即为“人类工厂”，“白种人工厂”只能生产白种人，“黄种人工厂”只能生产黄种人，以此类推。因此，在“工厂模式”中，<strong>每一个继承自“父类”工厂的具体工厂类所生产的东西是不同的</strong>。再举一个例子，比如一个抽象父类“食物工厂类”，每一种继承自它的“子类”都只能生成出自己所属的那种食物，比如饼干，面包等等。</p>\n<p>那么，如果我想要两个继承自同一个“父类”的具体子类都可以制造生产同样的东西呢？比如两个工厂一个是“热带工厂”，另一个是“亚热带工厂”，但这两个工厂都可以生产蔬菜和水果，只是这些蔬菜和水果来自不同的“<strong>产品族</strong>”（可以理解为不同工厂）而已。我们可以理解为不同的工厂都生成同一种类型的东西，即称这些东西来自不同的“<strong>产品族</strong>”，而来自同一个工厂的不同东西之间是属于不同“<strong>产品等级</strong>”的关系。“抽象工厂模式”便是为了解决这个问题而来的，该模式的 UML 类图如下所示：</p>\n<p><img src=\"1.png\" alt></p>\n<p>从上述类图中可以很明确的看出各个类与接口之间的继承关系，在父类的工厂接口中定义了属于<strong>不同产品族</strong>的两个工厂的共有方法和属性。对应上述类图我们在下面给出了该模式对应的示例代码：</p>\n<p><strong>父类抽象接口角色</strong>：</p>\n<pre><code class=\"text\">FruitInterface.java\nVegetableInterface.java\nFactoryInterface.java\n</code></pre>\n<pre><code class=\"java\">// FruitInterface.java；\npublic interface Fruit {\n    public double getPrice();\n}\n</code></pre>\n<pre><code class=\"java\">// VegetableInterface.java；\npublic interface Vegetable {\n    public double getPrice();\n}\n</code></pre>\n<pre><code class=\"java\">// FactoryInterface.java；\npublic interface Factory {\n    // 当传入了错误的参数（比如向热带工厂提出生成亚热带产品的要求）时会抛出异常；\n    public Fruit produceFruit(Class&lt;? extends Fruit&gt; product) throws Exception;\n    public Vegetable produceVegetable(Class&lt;? extends Vegetable&gt; product) throws Exception;\n}\n</code></pre>\n<p><strong>子类抽象工厂</strong>：</p>\n<pre><code class=\"text\">TropicalFactory.java\nSubtropicalFactory.java\n</code></pre>\n<pre><code class=\"java\">// TropicalFactory.java；\npublic class TropicalFactory implements Factory {\n    @Override\n    public Fruit produceFruit(Class&lt;? extends Fruit&gt; product) throws Exception {\n        // 判断是否符合生成规范；\n        if (product == TropicalFruit.class) {\n            return (Fruit) Class.forName(product.getName()).newInstance();\n        } else {\n            // 不规范则抛出异常；\n            throw new Exception(&amp;quot;We can not produce it!&amp;quot;);\n        }\n    }\n    @Override\n    public Vegetable produceVegetable(Class&lt;? extends Vegetable&gt; product) throws Exception {\n        if (product == TropicalVegetable.class) {\n            return (Vegetable) Class.forName(product.getName()).newInstance();\n        } else {\n            throw new Exception(&amp;quot;We can not produce it!&amp;quot;);\n        }\n    }\n}\n</code></pre>\n<pre><code class=\"java\">// SubtropicalFactory.java；\npublic class SubtropicalFactory implements Factory {\n    @Override\n    public Fruit produceFruit(Class&lt;? extends Fruit&gt; product) throws Exception {\n        if (product == SubtropicalFruit.class) {\n            return (Fruit) Class.forName(product.getName()).newInstance();\n        } else {\n            throw new Exception(&amp;quot;We can not produce it!&amp;quot;);\n        }\n    }\n    @Override\n    public Vegetable produceVegetable(Class&lt;? extends Vegetable&gt; product) throws Exception {\n        if (product == SubtropicalVegetable.class) {\n            return (Vegetable) Class.forName(product.getName()).newInstance();\n        } else {\n            throw new Exception(&amp;quot;We can not produce it!&amp;quot;);\n        }\n    }\n}\n</code></pre>\n<p><strong>子类抽象水果产品</strong>：</p>\n<pre><code class=\"text\">TropicalFruit.java\nSubtropicalFruit.java\n</code></pre>\n<pre><code class=\"java\">// TropicalFruit.java；\npublic class TropicalFruit implements Fruit {\n    private double price = 1.82;\n    @Override\n    public double getPrice() {\n        return this.price;\n    }\n}\n</code></pre>\n<pre><code class=\"java\">// SubtropicalFruit.java；\npublic class SubtropicalFruit implements Fruit {\n    private double price = 1.54;\n    @Override\n    public double getPrice() {\n        return this.price;\n    }\n}\n</code></pre>\n<p><strong>子类抽象蔬菜产品</strong>：</p>\n<pre><code class=\"text\">TropicalVegetable.java\nSubtropicalVegetable.java\n</code></pre>\n<pre><code class=\"java\">// TropicalVegetable.java；\npublic class TropicalVegetable implements Vegetable {\n    private double price = 1.21;\n    @Override\n    public double getPrice() {\n        return this.price;\n    }\n}\n</code></pre>\n<pre><code class=\"java\">// SubtropicalVegetable.java；\npublic class SubtropicalVegetable implements Vegetable {\n    private double price = 1.11;\n    @Override\n    public double getPrice() {\n        return this.price;\n    }\n}\n</code></pre>\n<p><strong>客户角色</strong>：</p>\n<pre><code class=\"text\">client.java\n</code></pre>\n<pre><code class=\"java\">// Client.java；\npublic class Client {\n    public static void main(String[] args) {\n        TropicalFactory tropicalFactory = new TropicalFactory();\n\n        try {\n            // 以正确的生成方式生产产品；\n            Fruit tropicalFruit = tropicalFactory.produceFruit(TropicalFruit.class);\n            System.out.println(tropicalFruit.getPrice());\n\n            // 以不正确的生成方式生产产品；\n            Fruit subTropicalFruit = tropicalFactory.produceFruit(SubtropicalFruit.class);\n            System.out.println(subTropicalFruit.getPrice());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre>\n"}],"PostAsset":[{"_id":"source/_posts/Docker-最佳实践（一）/1.png","slug":"1.png","post":"cjsqwht7e000eknp29l3h34mx","modified":1,"renderable":0},{"_id":"source/_posts/Docker-最佳实践（三）/1.png","slug":"1.png","post":"cjsqwht7f000gknp21kqmiy04","modified":1,"renderable":0},{"_id":"source/_posts/V8-内存优化之-Ignition-解释器/4.png","slug":"4.png","post":"cjsqwhta0003yknp2i4pgxrlt","modified":1,"renderable":0},{"_id":"source/_posts/Web-新时代与挑战/1.png","slug":"1.png","post":"cjsqwhta10040knp255rftjdu","modified":1,"renderable":0},{"_id":"source/_posts/前端那些事儿-表单域的-MIME-编码/2.jpg","slug":"2.jpg","post":"cjsqwhtay006bknp258xt8yid","modified":1,"renderable":0},{"_id":"source/_posts/日本樱花季游攻略/11.jpg","slug":"11.jpg","post":"cjsqwhtbb007aknp24xkhpxkv","modified":1,"renderable":0},{"_id":"source/_posts/日本樱花季游攻略/18.jpg","slug":"18.jpg","post":"cjsqwhtbb007aknp24xkhpxkv","modified":1,"renderable":0},{"_id":"source/_posts/日本樱花季游攻略/22.jpg","slug":"22.jpg","post":"cjsqwhtbb007aknp24xkhpxkv","modified":1,"renderable":0},{"_id":"source/_posts/日本樱花季游攻略/26.jpg","slug":"26.jpg","post":"cjsqwhtbb007aknp24xkhpxkv","modified":1,"renderable":0},{"_id":"source/_posts/日本樱花季游攻略/3.jpg","slug":"3.jpg","post":"cjsqwhtbb007aknp24xkhpxkv","modified":1,"renderable":0},{"_id":"source/_posts/日本樱花季游攻略/8.jpg","slug":"8.jpg","post":"cjsqwhtbb007aknp24xkhpxkv","modified":1,"renderable":0},{"_id":"source/_posts/Flush-Reload-Attack-与-Meltdown/1.png","slug":"1.png","post":"cjsqwht7k000pknp201gp1a9h","modified":1,"renderable":0},{"_id":"source/_posts/Flush-Reload-Attack-与-Meltdown/2.png","slug":"2.png","post":"cjsqwht7k000pknp201gp1a9h","modified":1,"renderable":0},{"_id":"source/_posts/Flush-Reload-Attack-与-Meltdown/3.png","slug":"3.png","post":"cjsqwht7k000pknp201gp1a9h","modified":1,"renderable":0},{"_id":"source/_posts/PureRenderMixin-immutable-js-提高-VDOM-渲染效率/1.gif","slug":"1.gif","post":"cjsqwht9q0035knp2a0bczrk2","modified":1,"renderable":0},{"_id":"source/_posts/使用-Noteflight-来快速作曲和-MusicXML-导出/1.png","slug":"1.png","post":"cjsqwhtao005nknp2iust0fpy","modified":1,"renderable":0},{"_id":"source/_posts/使用-Noteflight-来快速作曲和-MusicXML-导出/2.png","slug":"2.png","post":"cjsqwhtao005nknp2iust0fpy","modified":1,"renderable":0},{"_id":"source/_posts/日本樱花季游攻略/2.jpg","slug":"2.jpg","post":"cjsqwhtbb007aknp24xkhpxkv","modified":1,"renderable":0},{"_id":"source/_posts/日本樱花季游攻略/21.jpg","slug":"21.jpg","post":"cjsqwhtbb007aknp24xkhpxkv","modified":1,"renderable":0},{"_id":"source/_posts/日本樱花季游攻略/9.gif","slug":"9.gif","post":"cjsqwhtbb007aknp24xkhpxkv","modified":1,"renderable":0},{"_id":"source/_posts/ES-6-ES-2015-常用知识点归纳/1.png","post":"cjsqwht7j000nknp23p896zxj","slug":"1.png","modified":1,"renderable":1},{"_id":"source/_posts/STC-与-PTC/1.jpg","post":"cjsqwht9t003fknp2sz7lazp4","slug":"1.jpg","modified":1,"renderable":1},{"_id":"source/_posts/SVG-技术之-路径/1.png","post":"cjsqwht9w003kknp24mdf28up","slug":"1.png","modified":1,"renderable":1},{"_id":"source/_posts/WebAssembly-尝试研究报告-API-之初始化、内存和表的分配/1.png","post":"cjsqwhta20043knp2grd6jmak","slug":"1.png","modified":1,"renderable":1},{"_id":"source/_posts/“大型网站技术架构”总结：一，概述/1.jpg","slug":"1.jpg","post":"cjsqwhtai0056knp2efaw9ib0","modified":1,"renderable":0},{"_id":"source/_posts/“大型网站技术架构”总结：三，网站的高可用架构/1.jpg","post":"cjsqwhtak005dknp2dh10qo6e","slug":"1.jpg","modified":1,"renderable":1},{"_id":"source/_posts/五分钟算法-二分法查找（Binary-Search）/1.jpg","post":"cjsqwhtam005iknp2zvp6il7j","slug":"1.jpg","modified":1,"renderable":1},{"_id":"source/_posts/前端项目规划与团队管理/1.jpg","post":"cjsqwhtb0006gknp2sarpkzee","slug":"1.jpg","modified":1,"renderable":1},{"_id":"source/_posts/编码与“锟斤拷”的故事/1.jpg","post":"cjsqwhtbj007tknp242thj9hm","slug":"1.jpg","modified":1,"renderable":1},{"_id":"source/_posts/设计模式速谈：三、工厂模式/1.png","post":"cjsqwhtbl007yknp2sz038q38","slug":"1.png","modified":1,"renderable":1},{"_id":"source/_posts/Redis-源码之内存管理-zmalloc-zfree/1.jpg","post":"cjsqwht9v003hknp22029tq07","slug":"1.jpg","modified":1,"renderable":1},{"_id":"source/_posts/Redis-源码之内存管理-zmalloc-zfree/2.jpg","post":"cjsqwht9v003hknp22029tq07","slug":"2.jpg","modified":1,"renderable":1},{"_id":"source/_posts/Web-新时代与挑战/2.png","slug":"2.png","post":"cjsqwhta10040knp255rftjdu","modified":1,"renderable":0},{"_id":"source/_posts/WebAssembly-尝试研究报告（一）/1.png","post":"cjsqwhta60049knp2s4jwt3gn","slug":"1.png","modified":1,"renderable":1},{"_id":"source/_posts/WebAssembly-尝试研究报告（一）/2.png","post":"cjsqwhta60049knp2s4jwt3gn","slug":"2.png","modified":1,"renderable":1},{"_id":"source/_posts/利用-ab-命令进行简单压测/1.png","post":"cjsqwhtar005pknp2qt7keuqm","slug":"1.png","modified":1,"renderable":1},{"_id":"source/_posts/利用-ab-命令进行简单压测/2.png","post":"cjsqwhtar005pknp2qt7keuqm","slug":"2.png","modified":1,"renderable":1},{"_id":"source/_posts/前端那些事儿-表单域的-MIME-编码/1.jpg","post":"cjsqwhtay006bknp258xt8yid","slug":"1.jpg","modified":1,"renderable":1},{"_id":"source/_posts/设计模式速谈：二、简单工厂模式/1.png","post":"cjsqwhtbl0080knp2adqe1ko7","slug":"1.png","modified":1,"renderable":1},{"_id":"source/_posts/设计模式速谈：二、简单工厂模式/2.png","post":"cjsqwhtbl0080knp2adqe1ko7","slug":"2.png","modified":1,"renderable":1},{"_id":"source/_posts/BigPipe-原理实现与使用场景分析/1.png","post":"cjsqwht780006knp25wkvl88e","slug":"1.png","modified":1,"renderable":1},{"_id":"source/_posts/BigPipe-原理实现与使用场景分析/2.png","post":"cjsqwht780006knp25wkvl88e","slug":"2.png","modified":1,"renderable":1},{"_id":"source/_posts/BigPipe-原理实现与使用场景分析/3.jpg","post":"cjsqwht780006knp25wkvl88e","slug":"3.jpg","modified":1,"renderable":1},{"_id":"source/_posts/Docker-最佳实践（一）/2.png","post":"cjsqwht7e000eknp29l3h34mx","slug":"2.png","modified":1,"renderable":1},{"_id":"source/_posts/Docker-最佳实践（一）/3.png","post":"cjsqwht7e000eknp29l3h34mx","slug":"3.png","modified":1,"renderable":1},{"_id":"source/_posts/JavaScript-浏览器自动化/1.jpg","post":"cjsqwht8r001nknp275qrcpki","slug":"1.jpg","modified":1,"renderable":1},{"_id":"source/_posts/JavaScript-浏览器自动化/2.jpg","post":"cjsqwht8r001nknp275qrcpki","slug":"2.jpg","modified":1,"renderable":1},{"_id":"source/_posts/JavaScript-浏览器自动化/3.jpg","post":"cjsqwht8r001nknp275qrcpki","slug":"3.jpg","modified":1,"renderable":1},{"_id":"source/_posts/WebAssembly-尝试研究报告-DIP-实践/1.png","slug":"1.png","post":"cjsqwht9z003tknp2v5zz2mg9","modified":1,"renderable":0},{"_id":"source/_posts/WebAssembly-尝试研究报告-DIP-实践/2.png","slug":"2.png","post":"cjsqwht9z003tknp2v5zz2mg9","modified":1,"renderable":0},{"_id":"source/_posts/WebAssembly-尝试研究报告-DIP-实践/3.png","post":"cjsqwht9z003tknp2v5zz2mg9","slug":"3.png","modified":1,"renderable":1},{"_id":"source/_posts/WebAssembly-尝试研究报告（三）/1.png","slug":"1.png","post":"cjsqwhta30045knp2vmo9vocz","modified":1,"renderable":0},{"_id":"source/_posts/WebAssembly-尝试研究报告（三）/2.png","slug":"2.png","post":"cjsqwhta30045knp2vmo9vocz","modified":1,"renderable":0},{"_id":"source/_posts/WebAssembly-尝试研究报告（三）/3.png","slug":"3.png","post":"cjsqwhta30045knp2vmo9vocz","modified":1,"renderable":0},{"_id":"source/_posts/一种新的共享计算力模式/1.png","post":"cjsqwhtah0054knp2f1cumq23","slug":"1.png","modified":1,"renderable":1},{"_id":"source/_posts/一种新的共享计算力模式/2.png","post":"cjsqwhtah0054knp2f1cumq23","slug":"2.png","modified":1,"renderable":1},{"_id":"source/_posts/一种新的共享计算力模式/3.png","post":"cjsqwhtah0054knp2f1cumq23","slug":"3.png","modified":1,"renderable":1},{"_id":"source/_posts/前端-DCE-策略之-—-Tree-Shaking/1.jpg","post":"cjsqwhtas005sknp26egbxmch","slug":"1.jpg","modified":1,"renderable":1},{"_id":"source/_posts/前端-DCE-策略之-—-Tree-Shaking/2.jpg","post":"cjsqwhtas005sknp26egbxmch","slug":"2.jpg","modified":1,"renderable":1},{"_id":"source/_posts/前端-DCE-策略之-—-Tree-Shaking/3.jpg","post":"cjsqwhtas005sknp26egbxmch","slug":"3.jpg","modified":1,"renderable":1},{"_id":"source/_posts/前端常见技术点-CSS-DOM-布局/1.jpg","post":"cjsqwhtat005wknp2hdv7ikv5","slug":"1.jpg","modified":1,"renderable":1},{"_id":"source/_posts/前端常见技术点-CSS-DOM-布局/2.png","post":"cjsqwhtat005wknp2hdv7ikv5","slug":"2.png","modified":1,"renderable":1},{"_id":"source/_posts/前端常见技术点-CSS-DOM-布局/3.jpg","post":"cjsqwhtat005wknp2hdv7ikv5","slug":"3.jpg","modified":1,"renderable":1},{"_id":"source/_posts/基于-AWS-探索-Shadowsocks/1.png","slug":"1.png","post":"cjsqwhtb3006lknp2v0ms2kkl","modified":1,"renderable":0},{"_id":"source/_posts/基于-AWS-探索-Shadowsocks/2.png","post":"cjsqwhtb3006lknp2v0ms2kkl","slug":"2.png","modified":1,"renderable":1},{"_id":"source/_posts/基于-AWS-探索-Shadowsocks/3.png","post":"cjsqwhtb3006lknp2v0ms2kkl","slug":"3.png","modified":1,"renderable":1},{"_id":"source/_posts/简单理解-HTTP-协议/0.png","post":"cjsqwhtbi007pknp2s29xohpd","slug":"0.png","modified":1,"renderable":1},{"_id":"source/_posts/简单理解-HTTP-协议/1.png","post":"cjsqwhtbi007pknp2s29xohpd","slug":"1.png","modified":1,"renderable":1},{"_id":"source/_posts/简单理解-HTTP-协议/2.png","post":"cjsqwhtbi007pknp2s29xohpd","slug":"2.png","modified":1,"renderable":1},{"_id":"source/_posts/Docker-最佳实践（二）/1.png","post":"cjsqwht7g000iknp23mxywy9r","slug":"1.png","modified":1,"renderable":1},{"_id":"source/_posts/Docker-最佳实践（二）/2.png","post":"cjsqwht7g000iknp23mxywy9r","slug":"2.png","modified":1,"renderable":1},{"_id":"source/_posts/Docker-最佳实践（二）/3.png","post":"cjsqwht7g000iknp23mxywy9r","slug":"3.png","modified":1,"renderable":1},{"_id":"source/_posts/Docker-最佳实践（二）/4.png","post":"cjsqwht7g000iknp23mxywy9r","slug":"4.png","modified":1,"renderable":1},{"_id":"source/_posts/V8-内存优化之-Ignition-解释器/1.png","slug":"1.png","post":"cjsqwhta0003yknp2i4pgxrlt","modified":1,"renderable":0},{"_id":"source/_posts/V8-内存优化之-Ignition-解释器/2.png","slug":"2.png","post":"cjsqwhta0003yknp2i4pgxrlt","modified":1,"renderable":0},{"_id":"source/_posts/V8-内存优化之-Ignition-解释器/3.png","slug":"3.png","post":"cjsqwhta0003yknp2i4pgxrlt","modified":1,"renderable":0},{"_id":"source/_posts/前端那些事儿-Console-对象/1.png","post":"cjsqwhtaw0063knp223lj5qyw","slug":"1.png","modified":1,"renderable":1},{"_id":"source/_posts/前端那些事儿-Console-对象/2.png","post":"cjsqwhtaw0063knp223lj5qyw","slug":"2.png","modified":1,"renderable":1},{"_id":"source/_posts/前端那些事儿-Console-对象/3.png","post":"cjsqwhtaw0063knp223lj5qyw","slug":"3.png","modified":1,"renderable":1},{"_id":"source/_posts/前端那些事儿-Console-对象/4.png","post":"cjsqwhtaw0063knp223lj5qyw","slug":"4.png","modified":1,"renderable":1},{"_id":"source/_posts/前端那些事儿-Console-对象/5.png","post":"cjsqwhtaw0063knp223lj5qyw","slug":"5.png","modified":1,"renderable":1},{"_id":"source/_posts/前端常见技术点-JavaScript/1.jpg","post":"cjsqwhtav0061knp25nqnf2ud","slug":"1.jpg","modified":1,"renderable":1},{"_id":"source/_posts/前端常见技术点-JavaScript/2.jpg","post":"cjsqwhtav0061knp25nqnf2ud","slug":"2.jpg","modified":1,"renderable":1},{"_id":"source/_posts/前端常见技术点-JavaScript/3.jpg","post":"cjsqwhtav0061knp25nqnf2ud","slug":"3.jpg","modified":1,"renderable":1},{"_id":"source/_posts/前端常见技术点-JavaScript/4.jpg","post":"cjsqwhtav0061knp25nqnf2ud","slug":"4.jpg","modified":1,"renderable":1},{"_id":"source/_posts/前端常见技术点-JavaScript/5.jpg","post":"cjsqwhtav0061knp25nqnf2ud","slug":"5.jpg","modified":1,"renderable":1},{"_id":"source/_posts/WebAssembly-深入研究报告-二进制编码/1.png","post":"cjsqwhta8004fknp2csi25llj","slug":"1.png","modified":1,"renderable":1},{"_id":"source/_posts/WebAssembly-深入研究报告-二进制编码/2.png","post":"cjsqwhta8004fknp2csi25llj","slug":"2.png","modified":1,"renderable":1},{"_id":"source/_posts/WebAssembly-深入研究报告-二进制编码/3.png","post":"cjsqwhta8004fknp2csi25llj","slug":"3.png","modified":1,"renderable":1},{"_id":"source/_posts/WebAssembly-深入研究报告-二进制编码/4.png","post":"cjsqwhta8004fknp2csi25llj","slug":"4.png","modified":1,"renderable":1},{"_id":"source/_posts/WebAssembly-深入研究报告-二进制编码/5.png","post":"cjsqwhta8004fknp2csi25llj","slug":"5.png","modified":1,"renderable":1},{"_id":"source/_posts/WebAssembly-深入研究报告-二进制编码/6.png","post":"cjsqwhta8004fknp2csi25llj","slug":"6.png","modified":1,"renderable":1},{"_id":"source/_posts/CSS-常用布局解决方案/1.jpg","post":"cjsqwht7a0008knp27plwk7p5","slug":"1.jpg","modified":1,"renderable":1},{"_id":"source/_posts/CSS-常用布局解决方案/10.jpg","post":"cjsqwht7a0008knp27plwk7p5","slug":"10.jpg","modified":1,"renderable":1},{"_id":"source/_posts/CSS-常用布局解决方案/11.jpg","post":"cjsqwht7a0008knp27plwk7p5","slug":"11.jpg","modified":1,"renderable":1},{"_id":"source/_posts/CSS-常用布局解决方案/12.jpg","post":"cjsqwht7a0008knp27plwk7p5","slug":"12.jpg","modified":1,"renderable":1},{"_id":"source/_posts/CSS-常用布局解决方案/13.jpg","post":"cjsqwht7a0008knp27plwk7p5","slug":"13.jpg","modified":1,"renderable":1},{"_id":"source/_posts/CSS-常用布局解决方案/14.jpg","post":"cjsqwht7a0008knp27plwk7p5","slug":"14.jpg","modified":1,"renderable":1},{"_id":"source/_posts/CSS-常用布局解决方案/15.jpg","post":"cjsqwht7a0008knp27plwk7p5","slug":"15.jpg","modified":1,"renderable":1},{"_id":"source/_posts/CSS-常用布局解决方案/2.jpg","post":"cjsqwht7a0008knp27plwk7p5","slug":"2.jpg","modified":1,"renderable":1},{"_id":"source/_posts/CSS-常用布局解决方案/3.jpg","post":"cjsqwht7a0008knp27plwk7p5","slug":"3.jpg","modified":1,"renderable":1},{"_id":"source/_posts/CSS-常用布局解决方案/4.jpg","post":"cjsqwht7a0008knp27plwk7p5","slug":"4.jpg","modified":1,"renderable":1},{"_id":"source/_posts/CSS-常用布局解决方案/5.jpg","post":"cjsqwht7a0008knp27plwk7p5","slug":"5.jpg","modified":1,"renderable":1},{"_id":"source/_posts/CSS-常用布局解决方案/6.jpg","post":"cjsqwht7a0008knp27plwk7p5","slug":"6.jpg","modified":1,"renderable":1},{"_id":"source/_posts/CSS-常用布局解决方案/7.jpg","post":"cjsqwht7a0008knp27plwk7p5","slug":"7.jpg","modified":1,"renderable":1},{"_id":"source/_posts/CSS-常用布局解决方案/8.jpg","post":"cjsqwht7a0008knp27plwk7p5","slug":"8.jpg","modified":1,"renderable":1},{"_id":"source/_posts/CSS-常用布局解决方案/9.jpg","post":"cjsqwht7a0008knp27plwk7p5","slug":"9.jpg","modified":1,"renderable":1},{"_id":"source/_posts/日本樱花季游攻略/1.jpg","post":"cjsqwhtbb007aknp24xkhpxkv","slug":"1.jpg","modified":1,"renderable":1},{"_id":"source/_posts/日本樱花季游攻略/6.jpg","post":"cjsqwhtbb007aknp24xkhpxkv","slug":"6.jpg","modified":1,"renderable":1},{"_id":"source/_posts/日本樱花季游攻略/10.jpg","post":"cjsqwhtbb007aknp24xkhpxkv","slug":"10.jpg","modified":1,"renderable":1},{"_id":"source/_posts/日本樱花季游攻略/12.jpg","post":"cjsqwhtbb007aknp24xkhpxkv","slug":"12.jpg","modified":1,"renderable":1},{"_id":"source/_posts/日本樱花季游攻略/13.jpg","post":"cjsqwhtbb007aknp24xkhpxkv","slug":"13.jpg","modified":1,"renderable":1},{"_id":"source/_posts/日本樱花季游攻略/15.jpg","post":"cjsqwhtbb007aknp24xkhpxkv","slug":"15.jpg","modified":1,"renderable":1},{"_id":"source/_posts/日本樱花季游攻略/16.jpg","slug":"16.jpg","post":"cjsqwhtbb007aknp24xkhpxkv","modified":1,"renderable":0},{"_id":"source/_posts/日本樱花季游攻略/17.jpg","post":"cjsqwhtbb007aknp24xkhpxkv","slug":"17.jpg","modified":1,"renderable":1},{"_id":"source/_posts/日本樱花季游攻略/19.jpg","post":"cjsqwhtbb007aknp24xkhpxkv","slug":"19.jpg","modified":1,"renderable":1},{"_id":"source/_posts/日本樱花季游攻略/20.jpg","slug":"20.jpg","post":"cjsqwhtbb007aknp24xkhpxkv","modified":1,"renderable":0},{"_id":"source/_posts/日本樱花季游攻略/23.jpg","post":"cjsqwhtbb007aknp24xkhpxkv","slug":"23.jpg","modified":1,"renderable":1},{"_id":"source/_posts/日本樱花季游攻略/24.jpg","slug":"24.jpg","post":"cjsqwhtbb007aknp24xkhpxkv","modified":1,"renderable":0},{"_id":"source/_posts/日本樱花季游攻略/25.jpg","post":"cjsqwhtbb007aknp24xkhpxkv","slug":"25.jpg","modified":1,"renderable":1},{"_id":"source/_posts/日本樱花季游攻略/27.png","slug":"27.png","post":"cjsqwhtbb007aknp24xkhpxkv","modified":1,"renderable":0},{"_id":"source/_posts/日本樱花季游攻略/28.jpg","post":"cjsqwhtbb007aknp24xkhpxkv","slug":"28.jpg","modified":1,"renderable":1},{"_id":"source/_posts/日本樱花季游攻略/29.png","slug":"29.png","post":"cjsqwhtbb007aknp24xkhpxkv","modified":1,"renderable":0},{"_id":"source/_posts/日本樱花季游攻略/30.png","slug":"30.png","post":"cjsqwhtbb007aknp24xkhpxkv","modified":1,"renderable":0},{"_id":"source/_posts/日本樱花季游攻略/31.png","slug":"31.png","post":"cjsqwhtbb007aknp24xkhpxkv","modified":1,"renderable":0},{"_id":"source/_posts/日本樱花季游攻略/4.jpg","post":"cjsqwhtbb007aknp24xkhpxkv","slug":"4.jpg","modified":1,"renderable":1},{"_id":"source/_posts/日本樱花季游攻略/5.jpg","post":"cjsqwhtbb007aknp24xkhpxkv","slug":"5.jpg","modified":1,"renderable":1},{"_id":"source/_posts/日本樱花季游攻略/7.jpg","post":"cjsqwhtbb007aknp24xkhpxkv","slug":"7.jpg","modified":1,"renderable":1},{"_id":"source/_posts/设计模式速谈：五、建造者模式/1.png","post":"cjsqwhtcw00c1knp2ci0jm1p1","slug":"1.png","modified":1,"renderable":1},{"_id":"source/_posts/设计模式速谈：四、抽象工厂模式/1.png","post":"cjsqwhtcw00c3knp2yfnx6ev9","slug":"1.png","modified":1,"renderable":1},{"_id":"source/_posts/设计模式速谈：六、单例模式/1.png","post":"cjsqwhtcu00c0knp2d9rc7iib","slug":"1.png","modified":1,"renderable":1}],"PostCategory":[],"PostTag":[{"post_id":"cjsqwht710001knp2a28wu9d8","tag_id":"cjsqwht760004knp2yo8myu34","_id":"cjsqwht7c000aknp2uri2dwsk"},{"post_id":"cjsqwht750003knp2eone6n5q","tag_id":"cjsqwht7b0009knp2fi856l5n","_id":"cjsqwht7f000fknp2tn8hde81"},{"post_id":"cjsqwht780006knp25wkvl88e","tag_id":"cjsqwht7e000dknp2sevolh27","_id":"cjsqwht7i000mknp2pe3rhv5f"},{"post_id":"cjsqwht780006knp25wkvl88e","tag_id":"cjsqwht7g000hknp20837q03t","_id":"cjsqwht7j000oknp2satamf5r"},{"post_id":"cjsqwht7h000jknp2mj2l37ir","tag_id":"cjsqwht7e000dknp2sevolh27","_id":"cjsqwht7k000rknp20q3vu9fi"},{"post_id":"cjsqwht7i000lknp2vnezwrx4","tag_id":"cjsqwht7e000dknp2sevolh27","_id":"cjsqwht7m000tknp2wi5fryh8"},{"post_id":"cjsqwht790007knp2dczokgpj","tag_id":"cjsqwht7i000kknp2oqi3dthc","_id":"cjsqwht7n000wknp2mlwsirwu"},{"post_id":"cjsqwht7l000sknp2l8t4mcpc","tag_id":"cjsqwht760004knp2yo8myu34","_id":"cjsqwht7n000yknp28qtcvejj"},{"post_id":"cjsqwht7a0008knp27plwk7p5","tag_id":"cjsqwht7k000qknp2aunwp69p","_id":"cjsqwht7o0011knp2ayxaay75"},{"post_id":"cjsqwht7m000uknp22od2x9m7","tag_id":"cjsqwht760004knp2yo8myu34","_id":"cjsqwht7p0013knp2ah7p7njw"},{"post_id":"cjsqwht7n000xknp2xndncldb","tag_id":"cjsqwht760004knp2yo8myu34","_id":"cjsqwht7q0015knp2nha7kj2g"},{"post_id":"cjsqwht7c000bknp2ennwi2rk","tag_id":"cjsqwht7m000vknp24uiy92qb","_id":"cjsqwht7v0018knp2vqdwe4gz"},{"post_id":"cjsqwht7c000bknp2ennwi2rk","tag_id":"cjsqwht7o0010knp2talw2e9s","_id":"cjsqwht7z001aknp2tf1alnpd"},{"post_id":"cjsqwht7d000cknp2jp70qdn6","tag_id":"cjsqwht7q0016knp2v9vgsgah","_id":"cjsqwht83001dknp253yb7185"},{"post_id":"cjsqwht83001eknp2b9t6ydag","tag_id":"cjsqwht7e000dknp2sevolh27","_id":"cjsqwht8e001hknp2lcv8nnvs"},{"post_id":"cjsqwht7e000eknp29l3h34mx","tag_id":"cjsqwht80001cknp2bi3lmvqz","_id":"cjsqwht8i001jknp21kcus3ym"},{"post_id":"cjsqwht88001fknp2lydoyl7l","tag_id":"cjsqwht7e000dknp2sevolh27","_id":"cjsqwht8r001mknp2d32udq1g"},{"post_id":"cjsqwht8e001iknp2qi8qef23","tag_id":"cjsqwht7e000dknp2sevolh27","_id":"cjsqwht8v001oknp2ww2jmzvr"},{"post_id":"cjsqwht7f000gknp21kqmiy04","tag_id":"cjsqwht80001cknp2bi3lmvqz","_id":"cjsqwht91001rknp2l8ey0mm7"},{"post_id":"cjsqwht8r001nknp275qrcpki","tag_id":"cjsqwht7e000dknp2sevolh27","_id":"cjsqwht95001tknp20vq4sgid"},{"post_id":"cjsqwht7g000iknp23mxywy9r","tag_id":"cjsqwht80001cknp2bi3lmvqz","_id":"cjsqwht99001wknp25ds8bggv"},{"post_id":"cjsqwht7j000nknp23p896zxj","tag_id":"cjsqwht7e000dknp2sevolh27","_id":"cjsqwht9a001yknp2ioxx8i7t"},{"post_id":"cjsqwht7j000nknp23p896zxj","tag_id":"cjsqwht8w001qknp2prtnrosz","_id":"cjsqwht9b0020knp25aixugn5"},{"post_id":"cjsqwht7k000pknp201gp1a9h","tag_id":"cjsqwht99001vknp2b8tlyukq","_id":"cjsqwht9c0023knp23i46uq4f"},{"post_id":"cjsqwht7o000zknp209lpfveh","tag_id":"cjsqwht9b0021knp26a4w986i","_id":"cjsqwht9e0027knp2t9slhyme"},{"post_id":"cjsqwht7p0012knp2s06v37kj","tag_id":"cjsqwht9b0021knp26a4w986i","_id":"cjsqwht9f002bknp2luy3uqh6"},{"post_id":"cjsqwht7p0014knp2txjwl8w4","tag_id":"cjsqwht9f002aknp2z34icdkw","_id":"cjsqwht9h002gknp2kx8qvbky"},{"post_id":"cjsqwht7q0017knp2fwfpm201","tag_id":"cjsqwht9h002eknp2il8renz1","_id":"cjsqwht9j002kknp2kyg8ofsc"},{"post_id":"cjsqwht7w0019knp2oy1ykfo0","tag_id":"cjsqwht9i002iknp2ob4be0x7","_id":"cjsqwht9k002oknp2y8tnmv46"},{"post_id":"cjsqwht80001bknp2ld4dv10c","tag_id":"cjsqwht9j002mknp2kmku0z00","_id":"cjsqwht9l002sknp2xschirde"},{"post_id":"cjsqwht8i001kknp2g2gr673g","tag_id":"cjsqwht9l002rknp2jul146fm","_id":"cjsqwht9o002xknp2p5f04qc1"},{"post_id":"cjsqwht9o002yknp2sw26hady","tag_id":"cjsqwht7q0016knp2v9vgsgah","_id":"cjsqwht9p0031knp2cy1qc779"},{"post_id":"cjsqwht9o0030knp2tp16rwfc","tag_id":"cjsqwht7m000vknp24uiy92qb","_id":"cjsqwht9q0033knp2dhtvq45f"},{"post_id":"cjsqwht8w001pknp2efblsozr","tag_id":"cjsqwht9n002vknp204igyldr","_id":"cjsqwht9r0036knp2a1fyujl6"},{"post_id":"cjsqwht8w001pknp2efblsozr","tag_id":"cjsqwht9o002zknp200sh4d89","_id":"cjsqwht9r0038knp2kjhc5cfo"},{"post_id":"cjsqwht9p0032knp2uf37ds8z","tag_id":"cjsqwht7e000dknp2sevolh27","_id":"cjsqwht9s003bknp24hnmyx28"},{"post_id":"cjsqwht9r0037knp2senpefiq","tag_id":"cjsqwht7e000dknp2sevolh27","_id":"cjsqwht9t003dknp2tdjz8obq"},{"post_id":"cjsqwht91001sknp2ngxsorzt","tag_id":"cjsqwht9n002vknp204igyldr","_id":"cjsqwht9v003gknp21wpfvhp1"},{"post_id":"cjsqwht91001sknp2ngxsorzt","tag_id":"cjsqwht9o002zknp200sh4d89","_id":"cjsqwht9w003iknp2e60mv0vx"},{"post_id":"cjsqwht9w003kknp24mdf28up","tag_id":"cjsqwht7k000qknp2aunwp69p","_id":"cjsqwht9x003mknp23xs38kf1"},{"post_id":"cjsqwht95001uknp2h8n6bpq7","tag_id":"cjsqwht9n002vknp204igyldr","_id":"cjsqwht9y003pknp2ldcqf6t7"},{"post_id":"cjsqwht95001uknp2h8n6bpq7","tag_id":"cjsqwht9o002zknp200sh4d89","_id":"cjsqwht9y003rknp23qlta0x3"},{"post_id":"cjsqwht9y003qknp2tyas98kq","tag_id":"cjsqwht7e000dknp2sevolh27","_id":"cjsqwht9z003uknp2rkud493c"},{"post_id":"cjsqwht9y003qknp2tyas98kq","tag_id":"cjsqwht9l002rknp2jul146fm","_id":"cjsqwhta0003wknp2dxc51yyf"},{"post_id":"cjsqwht9a001xknp2kqb7wkjg","tag_id":"cjsqwht9n002vknp204igyldr","_id":"cjsqwhta1003zknp2x2tdfmv7"},{"post_id":"cjsqwht9a001xknp2kqb7wkjg","tag_id":"cjsqwht9o002zknp200sh4d89","_id":"cjsqwhta10041knp2xfs3guin"},{"post_id":"cjsqwhta10040knp255rftjdu","tag_id":"cjsqwht760004knp2yo8myu34","_id":"cjsqwhta30044knp2c7tj6nam"},{"post_id":"cjsqwht9a001zknp2namufh7z","tag_id":"cjsqwht9n002vknp204igyldr","_id":"cjsqwhta50048knp2d94e5obm"},{"post_id":"cjsqwht9a001zknp2namufh7z","tag_id":"cjsqwht9o002zknp200sh4d89","_id":"cjsqwhta6004aknp2wqz81879"},{"post_id":"cjsqwht9b0022knp2ukt5asbf","tag_id":"cjsqwht9n002vknp204igyldr","_id":"cjsqwhta8004gknp2gv0haymq"},{"post_id":"cjsqwht9b0022knp2ukt5asbf","tag_id":"cjsqwht9o002zknp200sh4d89","_id":"cjsqwhta9004iknp26s8qimf9"},{"post_id":"cjsqwht9c0024knp2gdmqoojl","tag_id":"cjsqwht9n002vknp204igyldr","_id":"cjsqwhtac004oknp2muzur20o"},{"post_id":"cjsqwht9c0024knp2gdmqoojl","tag_id":"cjsqwht9o002zknp200sh4d89","_id":"cjsqwhtac004qknp2jedazgqz"},{"post_id":"cjsqwhtaa004lknp2r95kzexx","tag_id":"cjsqwht7e000dknp2sevolh27","_id":"cjsqwhtad004tknp2074wxhs7"},{"post_id":"cjsqwht9c0025knp2ozgfuo7k","tag_id":"cjsqwht9n002vknp204igyldr","_id":"cjsqwhtaf004xknp2v9n44swf"},{"post_id":"cjsqwht9c0025knp2ozgfuo7k","tag_id":"cjsqwht9o002zknp200sh4d89","_id":"cjsqwhtag004zknp2xbcndwc3"},{"post_id":"cjsqwht9e0028knp2zqsv50wo","tag_id":"cjsqwht9n002vknp204igyldr","_id":"cjsqwhtai0055knp2jake2wil"},{"post_id":"cjsqwht9e0028knp2zqsv50wo","tag_id":"cjsqwht9o002zknp200sh4d89","_id":"cjsqwhtaj0057knp2pdokfdyf"},{"post_id":"cjsqwhtaj0059knp24k9nv07v","tag_id":"cjsqwht7e000dknp2sevolh27","_id":"cjsqwhtak005bknp2huuf30c4"},{"post_id":"cjsqwht9f0029knp2stpufl19","tag_id":"cjsqwht9n002vknp204igyldr","_id":"cjsqwhtal005eknp2dryh0tee"},{"post_id":"cjsqwht9f0029knp2stpufl19","tag_id":"cjsqwht9o002zknp200sh4d89","_id":"cjsqwhtam005gknp2sai3dfz3"},{"post_id":"cjsqwhtak005aknp2du596dos","tag_id":"cjsqwht9j002mknp2kmku0z00","_id":"cjsqwhtan005jknp296vz8rnp"},{"post_id":"cjsqwhtal005fknp2atx236c1","tag_id":"cjsqwht7e000dknp2sevolh27","_id":"cjsqwhtao005lknp2f6qqtbcp"},{"post_id":"cjsqwhtam005iknp2zvp6il7j","tag_id":"cjsqwht9n002vknp204igyldr","_id":"cjsqwhtar005oknp23n8m75rl"},{"post_id":"cjsqwht9f002cknp20p09yqym","tag_id":"cjsqwht9n002vknp204igyldr","_id":"cjsqwhtas005qknp2yd795v8x"},{"post_id":"cjsqwht9f002cknp20p09yqym","tag_id":"cjsqwht9o002zknp200sh4d89","_id":"cjsqwhtat005tknp2b34dmc4i"},{"post_id":"cjsqwht9g002dknp2nn2us3wy","tag_id":"cjsqwht9n002vknp204igyldr","_id":"cjsqwhtau005xknp2gm6jnacz"},{"post_id":"cjsqwht9g002dknp2nn2us3wy","tag_id":"cjsqwht9o002zknp200sh4d89","_id":"cjsqwhtav005zknp2qxrt1hub"},{"post_id":"cjsqwhtat005uknp2txzoy9t6","tag_id":"cjsqwht7e000dknp2sevolh27","_id":"cjsqwhtaw0062knp2o867n2q6"},{"post_id":"cjsqwhtat005uknp2txzoy9t6","tag_id":"cjsqwht7k000qknp2aunwp69p","_id":"cjsqwhtaw0064knp2n05s0tsv"},{"post_id":"cjsqwhtau005yknp2fwiagcbk","tag_id":"cjsqwht9f002aknp2z34icdkw","_id":"cjsqwhtax0067knp2luwxpg94"},{"post_id":"cjsqwhtav0061knp25nqnf2ud","tag_id":"cjsqwht7e000dknp2sevolh27","_id":"cjsqwhtay0069knp2ne3vawa0"},{"post_id":"cjsqwht9h002fknp240f3lp7v","tag_id":"cjsqwht9n002vknp204igyldr","_id":"cjsqwhtaz006cknp2g76xg2fa"},{"post_id":"cjsqwht9h002fknp240f3lp7v","tag_id":"cjsqwht9o002zknp200sh4d89","_id":"cjsqwhtb0006eknp2im8yrccq"},{"post_id":"cjsqwhtaw0063knp223lj5qyw","tag_id":"cjsqwht7e000dknp2sevolh27","_id":"cjsqwhtb2006hknp29s53ork8"},{"post_id":"cjsqwhtax0066knp28vo77yr8","tag_id":"cjsqwht7e000dknp2sevolh27","_id":"cjsqwhtb2006jknp2hhuuc8ya"},{"post_id":"cjsqwhtax0068knp26vn2sg4l","tag_id":"cjsqwht7e000dknp2sevolh27","_id":"cjsqwhtb3006mknp2dn9ja6qq"},{"post_id":"cjsqwht9i002hknp26w0jyksm","tag_id":"cjsqwht9n002vknp204igyldr","_id":"cjsqwhtb4006oknp207rl8j4l"},{"post_id":"cjsqwht9i002hknp26w0jyksm","tag_id":"cjsqwht9o002zknp200sh4d89","_id":"cjsqwhtb5006rknp23swro8kq"},{"post_id":"cjsqwht9i002jknp2f7t3qtvi","tag_id":"cjsqwht9n002vknp204igyldr","_id":"cjsqwhtb6006tknp24mw3o8h3"},{"post_id":"cjsqwht9i002jknp2f7t3qtvi","tag_id":"cjsqwht9o002zknp200sh4d89","_id":"cjsqwhtb7006wknp2u2la648d"},{"post_id":"cjsqwhtb3006nknp253hksycu","tag_id":"cjsqwht9j002mknp2kmku0z00","_id":"cjsqwhtb7006yknp2nf0st5mk"},{"post_id":"cjsqwhtb5006sknp2q6ibs2i9","tag_id":"cjsqwht9l002rknp2jul146fm","_id":"cjsqwhtb90071knp2k8kabi61"},{"post_id":"cjsqwht9j002lknp2cmtr1pxd","tag_id":"cjsqwht9n002vknp204igyldr","_id":"cjsqwhtba0073knp2zh0euisx"},{"post_id":"cjsqwht9j002lknp2cmtr1pxd","tag_id":"cjsqwht9o002zknp200sh4d89","_id":"cjsqwhtbb0076knp2mjf65q45"},{"post_id":"cjsqwhtb90072knp2x62m5uda","tag_id":"cjsqwht760004knp2yo8myu34","_id":"cjsqwhtbb0078knp2klgmeyyq"},{"post_id":"cjsqwhtba0075knp2l7mojp66","tag_id":"cjsqwht9n002vknp204igyldr","_id":"cjsqwhtbc007bknp2dzatbist"},{"post_id":"cjsqwht9k002nknp2m0bwj2o8","tag_id":"cjsqwht9n002vknp204igyldr","_id":"cjsqwhtbd007dknp2zijtgbmt"},{"post_id":"cjsqwht9k002nknp2m0bwj2o8","tag_id":"cjsqwht9o002zknp200sh4d89","_id":"cjsqwhtbe007gknp2gie5ek4i"},{"post_id":"cjsqwhtbd007fknp2qkhg5u1y","tag_id":"cjsqwht9h002eknp2il8renz1","_id":"cjsqwhtbf007iknp23tyz6yf0"},{"post_id":"cjsqwht9k002pknp2sr2skd8g","tag_id":"cjsqwht9n002vknp204igyldr","_id":"cjsqwhtbh007lknp2m88i5s5f"},{"post_id":"cjsqwht9k002pknp2sr2skd8g","tag_id":"cjsqwht9o002zknp200sh4d89","_id":"cjsqwhtbh007nknp2cfki9tgq"},{"post_id":"cjsqwhtbh007mknp2kytfl7ws","tag_id":"cjsqwht7e000dknp2sevolh27","_id":"cjsqwhtbi007qknp2s9hna5jl"},{"post_id":"cjsqwht9l002qknp2pucyrqr1","tag_id":"cjsqwht9n002vknp204igyldr","_id":"cjsqwhtbk007uknp2bk5i8ucb"},{"post_id":"cjsqwht9l002qknp2pucyrqr1","tag_id":"cjsqwht9o002zknp200sh4d89","_id":"cjsqwhtbk007wknp2zalqx2ko"},{"post_id":"cjsqwhtbi007rknp2dwiui46d","tag_id":"cjsqwht9n002vknp204igyldr","_id":"cjsqwhtbl007zknp2qcayuv3o"},{"post_id":"cjsqwht9m002tknp2r8w6ichf","tag_id":"cjsqwht9n002vknp204igyldr","_id":"cjsqwhtbm0082knp2v11vg25b"},{"post_id":"cjsqwht9m002tknp2r8w6ichf","tag_id":"cjsqwht9o002zknp200sh4d89","_id":"cjsqwhtbn0083knp2vp4qnu82"},{"post_id":"cjsqwht9m002uknp2i5dav7wo","tag_id":"cjsqwhtbm0081knp2iap94kgp","_id":"cjsqwhtbn0085knp2f7ot2ggb"},{"post_id":"cjsqwht9n002wknp2hinnkz7t","tag_id":"cjsqwht9n002vknp204igyldr","_id":"cjsqwhtbn0087knp2e62l08ag"},{"post_id":"cjsqwht9n002wknp2hinnkz7t","tag_id":"cjsqwht9o002zknp200sh4d89","_id":"cjsqwhtbn0088knp29ml1ixc6"},{"post_id":"cjsqwht9q0035knp2a0bczrk2","tag_id":"cjsqwhtbn0086knp2tlshzwax","_id":"cjsqwhtbo008aknp2i5msregp"},{"post_id":"cjsqwht9s003aknp2xsq3tgf6","tag_id":"cjsqwhtbn0089knp2dx7xhshy","_id":"cjsqwhtbo008cknp2ypukh1ic"},{"post_id":"cjsqwht9s003cknp2jvlbjjeg","tag_id":"cjsqwhtbo008bknp2di6bulwz","_id":"cjsqwhtbp008eknp2peke30t5"},{"post_id":"cjsqwht9t003fknp2sz7lazp4","tag_id":"cjsqwhtbp008dknp2qvpfcoti","_id":"cjsqwhtbp008gknp2qwfm5utf"},{"post_id":"cjsqwht9v003hknp22029tq07","tag_id":"cjsqwhtbp008fknp2i6ru0lwq","_id":"cjsqwhtbq008iknp2ho1m3u6w"},{"post_id":"cjsqwht9w003lknp2fi3ngx9k","tag_id":"cjsqwhtbp008hknp20ap378s9","_id":"cjsqwhtbq008kknp2oavw5n8a"},{"post_id":"cjsqwht9x003oknp2rs211u08","tag_id":"cjsqwhtbq008jknp2e4ywyect","_id":"cjsqwhtbq008mknp25x3eblxm"},{"post_id":"cjsqwht9z003tknp2v5zz2mg9","tag_id":"cjsqwhtbq008lknp29z4kgcxp","_id":"cjsqwhtbr008oknp277h0m5zm"},{"post_id":"cjsqwhta0003vknp2qtcm6nzb","tag_id":"cjsqwhtbq008lknp29z4kgcxp","_id":"cjsqwhtbr008qknp23x01skny"},{"post_id":"cjsqwhta0003yknp2i4pgxrlt","tag_id":"cjsqwhtbr008pknp2n0awroai","_id":"cjsqwhtbs008sknp22m0vjpq9"},{"post_id":"cjsqwhta20043knp2grd6jmak","tag_id":"cjsqwhtbq008lknp29z4kgcxp","_id":"cjsqwhtbs008uknp2v2q17zdb"},{"post_id":"cjsqwhta30045knp2vmo9vocz","tag_id":"cjsqwhtbq008lknp29z4kgcxp","_id":"cjsqwhtbs008wknp2s9sa43vy"},{"post_id":"cjsqwhta50047knp2jy4j8mvo","tag_id":"cjsqwhtbq008lknp29z4kgcxp","_id":"cjsqwhtbt008yknp27yi6lihi"},{"post_id":"cjsqwhta60049knp2s4jwt3gn","tag_id":"cjsqwhtbq008lknp29z4kgcxp","_id":"cjsqwhtbt0090knp2ed5nvp2o"},{"post_id":"cjsqwhta6004cknp2x2grqtxk","tag_id":"cjsqwhtbq008lknp29z4kgcxp","_id":"cjsqwhtbt0092knp2phfh3n53"},{"post_id":"cjsqwhta7004dknp2lzbpfho8","tag_id":"cjsqwhtbq008lknp29z4kgcxp","_id":"cjsqwhtbu0094knp2cu6mh4yq"},{"post_id":"cjsqwhta8004fknp2csi25llj","tag_id":"cjsqwhtbq008lknp29z4kgcxp","_id":"cjsqwhtbu0096knp23ozynkh1"},{"post_id":"cjsqwhta8004hknp2jiv7htcn","tag_id":"cjsqwhtbq008lknp29z4kgcxp","_id":"cjsqwhtbv0098knp2kcxhewvy"},{"post_id":"cjsqwhta9004kknp2x6w6bxwi","tag_id":"cjsqwht7e000dknp2sevolh27","_id":"cjsqwhtbv009aknp2qame88n0"},{"post_id":"cjsqwhta9004kknp2x6w6bxwi","tag_id":"cjsqwhtbu0097knp2duebi2ak","_id":"cjsqwhtbv009bknp2twysthyo"},{"post_id":"cjsqwhtab004nknp27m7ao82q","tag_id":"cjsqwhtbm0081knp2iap94kgp","_id":"cjsqwhtbv009dknp22hghlh63"},{"post_id":"cjsqwhtac004pknp2glrz1lzk","tag_id":"cjsqwhtbv009cknp21y3dy4ea","_id":"cjsqwhtbw009fknp2w0ucrcg4"},{"post_id":"cjsqwhtac004pknp2glrz1lzk","tag_id":"cjsqwht7e000dknp2sevolh27","_id":"cjsqwhtbw009gknp2n9yhevme"},{"post_id":"cjsqwhtad004sknp2dwiqeau8","tag_id":"cjsqwhtbv009eknp2xz6yzn4l","_id":"cjsqwhtbx009jknp2b0twze3p"},{"post_id":"cjsqwhtad004sknp2dwiqeau8","tag_id":"cjsqwhtbw009hknp2v6zs8xvr","_id":"cjsqwhtbx009kknp20yn09zgz"},{"post_id":"cjsqwhtae004uknp233ytkuxn","tag_id":"cjsqwhtbw009iknp25zkeittq","_id":"cjsqwhtbx009nknp2t1sgdb8b"},{"post_id":"cjsqwhtae004uknp233ytkuxn","tag_id":"cjsqwhtbx009lknp2rjg8kwf3","_id":"cjsqwhtbx009oknp2dhfgid8p"},{"post_id":"cjsqwhtae004wknp2ir4fl57h","tag_id":"cjsqwhtbv009eknp2xz6yzn4l","_id":"cjsqwhtby009rknp275s318pg"},{"post_id":"cjsqwhtae004wknp2ir4fl57h","tag_id":"cjsqwhtbw009hknp2v6zs8xvr","_id":"cjsqwhtby009sknp289at66c0"},{"post_id":"cjsqwhtaf004yknp2i442959q","tag_id":"cjsqwhtbv009eknp2xz6yzn4l","_id":"cjsqwhtbz009vknp2qasf4h1k"},{"post_id":"cjsqwhtaf004yknp2i442959q","tag_id":"cjsqwhtby009tknp25tmwdgff","_id":"cjsqwhtbz009wknp2m86tavhl"},{"post_id":"cjsqwhtag0051knp20ywc41kx","tag_id":"cjsqwht7e000dknp2sevolh27","_id":"cjsqwhtbz009yknp23jhiyu0m"},{"post_id":"cjsqwhtag0051knp20ywc41kx","tag_id":"cjsqwhtby009uknp2jqgdqkk8","_id":"cjsqwhtbz009zknp25699kufs"},{"post_id":"cjsqwhtah0052knp2q91r2nf2","tag_id":"cjsqwhtbv009eknp2xz6yzn4l","_id":"cjsqwhtc000a2knp240f8hdx1"},{"post_id":"cjsqwhtah0052knp2q91r2nf2","tag_id":"cjsqwhtbw009hknp2v6zs8xvr","_id":"cjsqwhtc000a3knp26sijoit3"},{"post_id":"cjsqwhtah0054knp2f1cumq23","tag_id":"cjsqwhtbx009lknp2rjg8kwf3","_id":"cjsqwhtc000a5knp2vpb04gt2"},{"post_id":"cjsqwhtai0056knp2efaw9ib0","tag_id":"cjsqwhtbw009iknp25zkeittq","_id":"cjsqwhtc100a8knp2pt5mpwk8"},{"post_id":"cjsqwhtai0056knp2efaw9ib0","tag_id":"cjsqwhtbx009lknp2rjg8kwf3","_id":"cjsqwhtc100a9knp2qpfac28s"},{"post_id":"cjsqwhtak005dknp2dh10qo6e","tag_id":"cjsqwhtbw009iknp25zkeittq","_id":"cjsqwhtc200acknp22yx0ujh0"},{"post_id":"cjsqwhtak005dknp2dh10qo6e","tag_id":"cjsqwhtbx009lknp2rjg8kwf3","_id":"cjsqwhtc200adknp2okukfg6i"},{"post_id":"cjsqwhtan005kknp2ukpuhjab","tag_id":"cjsqwhtc100abknp2txuzek6p","_id":"cjsqwhtc200afknp2zl144776"},{"post_id":"cjsqwhtao005nknp2iust0fpy","tag_id":"cjsqwhtc200aeknp2m2gb225y","_id":"cjsqwhtc200ahknp219t9noyo"},{"post_id":"cjsqwhtar005pknp2qt7keuqm","tag_id":"cjsqwhtc200agknp2gre3m97l","_id":"cjsqwhtc300ajknp2463jjsvk"},{"post_id":"cjsqwhtas005sknp26egbxmch","tag_id":"cjsqwhtc200aiknp2baniq0qr","_id":"cjsqwhtc300amknp2e3lfrjn4"},{"post_id":"cjsqwhtas005sknp26egbxmch","tag_id":"cjsqwhtc300akknp2c1ce2tc2","_id":"cjsqwhtc300anknp2v5i7evoj"},{"post_id":"cjsqwhtat005wknp2hdv7ikv5","tag_id":"cjsqwht7k000qknp2aunwp69p","_id":"cjsqwhtc400apknp2f2eu51fy"},{"post_id":"cjsqwhtat005wknp2hdv7ikv5","tag_id":"cjsqwhtc300alknp2wdqrr0cj","_id":"cjsqwhtc400aqknp2wycweoqn"},{"post_id":"cjsqwhtay006bknp258xt8yid","tag_id":"cjsqwhtbm0081knp2iap94kgp","_id":"cjsqwhtc500asknp219kjg5qj"},{"post_id":"cjsqwhtaz006dknp2uowtrlv3","tag_id":"cjsqwhtbm0081knp2iap94kgp","_id":"cjsqwhtc500auknp29f5qx1eh"},{"post_id":"cjsqwhtb0006gknp2sarpkzee","tag_id":"cjsqwhtc500atknp29b0o3qrs","_id":"cjsqwhtc600awknp2e7tn81yh"},{"post_id":"cjsqwhtb2006iknp2o4ibl5os","tag_id":"cjsqwhtc500avknp2ddy45ifj","_id":"cjsqwhtc600ayknp2a5488gtp"},{"post_id":"cjsqwhtb3006lknp2v0ms2kkl","tag_id":"cjsqwhtc600axknp20if7gvzy","_id":"cjsqwhtc700b1knp22pu6ruln"},{"post_id":"cjsqwhtb3006lknp2v0ms2kkl","tag_id":"cjsqwhtc600azknp24yedwsuu","_id":"cjsqwhtc700b2knp29uosh0io"},{"post_id":"cjsqwhtb4006qknp2msquzl4w","tag_id":"cjsqwhtc700b0knp2108pnohc","_id":"cjsqwhtc700b5knp2o647lmgq"},{"post_id":"cjsqwhtb4006qknp2msquzl4w","tag_id":"cjsqwhtc700b3knp2re9czu7d","_id":"cjsqwhtc700b6knp2ngwp2dgg"},{"post_id":"cjsqwhtb6006vknp2m4hd0pko","tag_id":"cjsqwhtc700b4knp2h35mou6o","_id":"cjsqwhtc800b9knp2f6mvj7tq"},{"post_id":"cjsqwhtb6006vknp2m4hd0pko","tag_id":"cjsqwhtbx009lknp2rjg8kwf3","_id":"cjsqwhtc800baknp2cpcigixo"},{"post_id":"cjsqwhtb7006xknp25fub8sbs","tag_id":"cjsqwhtc800b8knp2agowxd1e","_id":"cjsqwhtc800bcknp2ayxn2yn6"},{"post_id":"cjsqwhtb80070knp24vir3mxn","tag_id":"cjsqwhtc800bbknp2m0zms4uv","_id":"cjsqwhtc900beknp23kf7ct1x"},{"post_id":"cjsqwhtbb0077knp2r1sca5x3","tag_id":"cjsqwhtc900bdknp26kifl1op","_id":"cjsqwhtc900bgknp2rgzk9ora"},{"post_id":"cjsqwhtbb007aknp24xkhpxkv","tag_id":"cjsqwht760004knp2yo8myu34","_id":"cjsqwhtca00biknp2p51d2op3"},{"post_id":"cjsqwhtbb007aknp24xkhpxkv","tag_id":"cjsqwhtc900bfknp2i8evteex","_id":"cjsqwhtca00bjknp28ahwhbnm"},{"post_id":"cjsqwhtbc007cknp2r0vflne0","tag_id":"cjsqwhtbm0081knp2iap94kgp","_id":"cjsqwhtcb00blknp2yosfbo4r"},{"post_id":"cjsqwhtbe007hknp25xwvom0b","tag_id":"cjsqwht7e000dknp2sevolh27","_id":"cjsqwhtcb00bnknp25z6e0qw9"},{"post_id":"cjsqwhtbe007hknp25xwvom0b","tag_id":"cjsqwhtca00bkknp2sp4yehi3","_id":"cjsqwhtcb00boknp2clhxhul0"},{"post_id":"cjsqwhtbf007kknp244qz1bb5","tag_id":"cjsqwhtcb00bmknp2pike84ar","_id":"cjsqwhtcc00bqknp2wigejtuv"},{"post_id":"cjsqwhtbi007pknp2s29xohpd","tag_id":"cjsqwhtbm0081knp2iap94kgp","_id":"cjsqwhtcf00bsknp218n2bjll"},{"post_id":"cjsqwhtbj007tknp242thj9hm","tag_id":"cjsqwhtbm0081knp2iap94kgp","_id":"cjsqwhtcf00buknp2bden6bfh"},{"post_id":"cjsqwhtbk007vknp2weiu6qwo","tag_id":"cjsqwhtcf00btknp2x71af27j","_id":"cjsqwhtcg00bwknp2ehcl6e9s"},{"post_id":"cjsqwhtbl007yknp2sz038q38","tag_id":"cjsqwhtcf00btknp2x71af27j","_id":"cjsqwhtcg00byknp2bkwppbxm"},{"post_id":"cjsqwhtbl0080knp2adqe1ko7","tag_id":"cjsqwhtcf00btknp2x71af27j","_id":"cjsqwhtcg00bzknp28jeacejv"},{"post_id":"cjsqwhtcu00c0knp2d9rc7iib","tag_id":"cjsqwhtcf00btknp2x71af27j","_id":"cjsqwhtcw00c2knp2pza7kwbv"},{"post_id":"cjsqwhtcw00c1knp2ci0jm1p1","tag_id":"cjsqwhtcf00btknp2x71af27j","_id":"cjsqwhtcy00c4knp2svciifzi"},{"post_id":"cjsqwhtcw00c3knp2yfnx6ev9","tag_id":"cjsqwhtcf00btknp2x71af27j","_id":"cjsqwhtcy00c5knp2212hnkay"}],"Tag":[{"name":"日记","_id":"cjsqwht760004knp2yo8myu34"},{"name":"Android","_id":"cjsqwht7b0009knp2fi856l5n"},{"name":"JavaScript","_id":"cjsqwht7e000dknp2sevolh27"},{"name":"BigPipe","_id":"cjsqwht7g000hknp20837q03t"},{"name":"C++","_id":"cjsqwht7i000kknp2oqi3dthc"},{"name":"CSS","_id":"cjsqwht7k000qknp2aunwp69p"},{"name":"Linux","_id":"cjsqwht7m000vknp24uiy92qb"},{"name":"MySQL","_id":"cjsqwht7o0010knp2talw2e9s"},{"name":"Lisp","_id":"cjsqwht7q0016knp2v9vgsgah"},{"name":"Docker","_id":"cjsqwht80001cknp2bi3lmvqz"},{"name":"ECMAScript","_id":"cjsqwht8w001qknp2prtnrosz"},{"name":"漏洞","_id":"cjsqwht99001vknp2b8tlyukq"},{"name":"Git","_id":"cjsqwht9b0021knp26a4w986i"},{"name":"HTML","_id":"cjsqwht9f002aknp2z34icdkw"},{"name":"HTTP","_id":"cjsqwht9h002eknp2il8renz1"},{"name":"互联网思考","_id":"cjsqwht9i002iknp2ob4be0x7"},{"name":"Java","_id":"cjsqwht9j002mknp2kmku0z00"},{"name":"PHP","_id":"cjsqwht9l002rknp2jul146fm"},{"name":"算法","_id":"cjsqwht9n002vknp204igyldr"},{"name":"LeetCode","_id":"cjsqwht9o002zknp200sh4d89"},{"name":"Web","_id":"cjsqwhtbm0081knp2iap94kgp"},{"name":"React","_id":"cjsqwhtbn0086knp2tlshzwax"},{"name":"Python","_id":"cjsqwhtbn0089knp2dx7xhshy"},{"name":"python","_id":"cjsqwhtbo008bknp2di6bulwz"},{"name":"尾递归","_id":"cjsqwhtbp008dknp2qvpfcoti"},{"name":"Redis","_id":"cjsqwhtbp008fknp2i6ru0lwq"},{"name":"编码","_id":"cjsqwhtbp008hknp20ap378s9"},{"name":"Twelve-Factor","_id":"cjsqwhtbq008jknp2e4ywyect"},{"name":"WebAssembly","_id":"cjsqwhtbq008lknp29z4kgcxp"},{"name":"V8","_id":"cjsqwhtbr008pknp2n0awroai"},{"name":"Library","_id":"cjsqwhtbu0097knp2duebi2ak"},{"name":"柯里化","_id":"cjsqwhtbv009cknp21y3dy4ea"},{"name":"读书","_id":"cjsqwhtbv009eknp2xz6yzn4l"},{"name":"创业","_id":"cjsqwhtbw009hknp2v6zs8xvr"},{"name":"后端","_id":"cjsqwhtbw009iknp25zkeittq"},{"name":"架构","_id":"cjsqwhtbx009lknp2rjg8kwf3"},{"name":"经营","_id":"cjsqwhtby009tknp25tmwdgff"},{"name":"jQuery","_id":"cjsqwhtby009uknp2jqgdqkk8"},{"name":"商业评论","_id":"cjsqwhtc100abknp2txuzek6p"},{"name":"钢琴","_id":"cjsqwhtc200aeknp2m2gb225y"},{"name":"Apache","_id":"cjsqwhtc200agknp2gre3m97l"},{"name":"ES6","_id":"cjsqwhtc200aiknp2baniq0qr"},{"name":"DCE","_id":"cjsqwhtc300akknp2c1ce2tc2"},{"name":"DOM","_id":"cjsqwhtc300alknp2wdqrr0cj"},{"name":"团队管理","_id":"cjsqwhtc500atknp29b0o3qrs"},{"name":"网站事务","_id":"cjsqwhtc500avknp2ddy45ifj"},{"name":"AWS","_id":"cjsqwhtc600axknp20if7gvzy"},{"name":"Shadowsocks","_id":"cjsqwhtc600azknp24yedwsuu"},{"name":"KNN","_id":"cjsqwhtc700b0knp2108pnohc"},{"name":"TensorFlow","_id":"cjsqwhtc700b3knp2re9czu7d"},{"name":"大数据","_id":"cjsqwhtc700b4knp2h35mou6o"},{"name":"Shell","_id":"cjsqwhtc800b8knp2agowxd1e"},{"name":"出版","_id":"cjsqwhtc800bbknp2m0zms4uv"},{"name":"机器学习","_id":"cjsqwhtc900bdknp26kifl1op"},{"name":"旅游","_id":"cjsqwhtc900bfknp2i8evteex"},{"name":"BigRender","_id":"cjsqwhtca00bkknp2sp4yehi3"},{"name":"互联网","_id":"cjsqwhtcb00bmknp2pike84ar"},{"name":"设计模式","_id":"cjsqwhtcf00btknp2x71af27j"}]}}