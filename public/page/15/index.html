<!DOCTYPE html><html lang="en-us"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>曜彤.手记</title><meta name="description"><meta name="generator" content="曜彤.手记"><meta name="author" content="于航(曜彤)"><meta name="keywords" content="博客, C++, C, VB, Web, Java, IT, 编程, 开发, Android, Python, MySQL, 科技, 黑客, 技术, Javascript, 云, 大数据, 计算, 机器学习, AI, 人工智能, 创业, 产品, 公司, WebAssembly, Wasm"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=0"><link rel="stylesheet" type="text/css" href="/styles/screen.css"><link rel="apple-touch-icon" sizes="57x57" href="/images/apple-touch-icon-57x57.jpg"><link rel="apple-touch-icon" sizes="60x60" href="/images/apple-touch-icon-60x60.jpg"><link rel="apple-touch-icon" sizes="72x72" href="/images/apple-touch-icon-72x72.jpg"><link rel="apple-touch-icon" sizes="76x76" href="/images/apple-touch-icon-76x76.jpg"><link rel="apple-touch-icon" sizes="114x114" href="/images/apple-touch-icon-114x114.jpg"><link rel="apple-touch-icon" sizes="120x120" href="/images/apple-touch-icon-120x120.jpg"><link rel="apple-touch-icon" sizes="144x144" href="/images/apple-touch-icon-144x144.jpg"><link rel="apple-touch-icon" sizes="152x152" href="/images/apple-touch-icon-152x152.jpg"><link rel="apple-touch-icon" sizes="196x196" href="/images/apple-touch-icon-196x196.jpg"><link rel="apple-touch-icon" sizes="310x310" href="/images/apple-touch-icon-310x310.jpg"><link href="/images/splash/iphone5_splash.png" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/iphone6_splash.png" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/iphoneplus_splash.png" media="(device-width: 621px) and (device-height: 1104px) and (-webkit-device-pixel-ratio: 3)" rel="apple-touch-startup-image"><link href="/images/splash/iphonex_splash.png" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3)" rel="apple-touch-startup-image"><link href="/images/splash/iphonexr_splash.png" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/iphonexsmax_splash.png" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3)" rel="apple-touch-startup-image"><link href="/images/splash/ipad_splash.png" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/ipadpro1_splash.png" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/ipadpro3_splash.png" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/ipadpro2_splash.png" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/images/favicon-96x96.png"><link rel="icon" type="image/png" sizes="128x128" href="/images/favicon-128.png"><link rel="icon" type="image/png" sizes="196x196" href="/images/favicon-196x196.png"><meta name="msapplication-TileColor" content="#FFFFFF"><meta name="msapplication-TileImage" content="mstile-144x144.png"><meta name="msapplication-square70x70logo" content="mstile-70x70.png"><meta name="msapplication-square150x150logo" content="mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="mstile-310x150.png"><meta name="msapplication-square310x310logo" content="mstile-310x310.png"><meta name="msapplication-square310x310logo" content="mstile-310x310.png"><link rel="manifest" href="/manifest.webmanifest"><link rel="stylesheet" href="/css/prism-okaidia.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body itemscope itemtype="https://schema.org/WebPage"><div class="canvas-containter"><span>X</span></div><header itemscope itemtype="https://schema.org/WPHeader"><div class="logo"></div><h1><a href="/" alt="曜彤.手记" title="曜彤.手记" itemprop="headline">曜彤.手记</a></h1><p itemprop="description">随手写写，关于互联网技术、产品与创业</p><nav itemscope itemtype="https://schema.org/SiteNavigationElement"><ul><li itemprop="name" class="menu-item"><a href="/ " alt="首页" title="首页" itemprop="url">首页</a></li><li itemprop="name" class="menu-item"><a href="/articles" alt="文章" title="文章" itemprop="url">文章</a></li><li itemprop="name" class="menu-item"><a href="/works" alt="作品" title="作品" itemprop="url">作品</a></li><li itemprop="name" class="menu-item"><a href="/tags" alt="标签" title="标签" itemprop="url">标签</a></li><li itemprop="name" class="menu-item"><a href="/author" alt="关于" title="关于" itemprop="url">关于</a></li></ul></nav><div class="space"></div></header><main itemscope itemtype="https://schema.org/Blog"><h4 class="page-title">Recent Articles</h4><a href="/2019/11/22/C-编码准则之-“The-Rule-of-Three”/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">C++ 编码准则之 “The Rule of Three”</h2><span class="post-meta">Published on<time itemprop="datePublished" datetime="2019-11-22T13:39:14.000Z"> 2019 / 11 / 22, 21:39:14</time></span><p itemprop="text" class="post-excerpt">不同于 C 语言，在 C++ 中，我们通常会使用“类”结构，来定义和管理资源。类，可以让我们将程序逻辑和数据按照不同的角色，进行封装，进而提高代码的重用性、灵活性和扩展性。但随之而来的类对象的“隐式”拷贝，却也在不经意间充斥在整个应用程序运行的各个生命周期中。好的类结构定义，可以让应用程序通过“资源移动”等方式，使数据资源的流动和使用变得更高效。相反，不当的类结构定义反而会使应用程序，在运行过程中发生未知的资源使用问题，比如常见的内存泄漏、内存溢出、悬挂指针，以及非法的内存释放，等等。那么，为了尽可能避免出现这些问题，”The Rule of Three“ 这一套编码准则，在经过不断地实践后，便被人们总结出来了。</p></article></a><a href="/2019/11/22/C-中的移动构造与-noexcept/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">C++ 中的移动构造与 noexcept</h2><span class="post-meta">Published on<time itemprop="datePublished" datetime="2019-11-22T13:23:18.000Z"> 2019 / 11 / 22, 21:23:18</time></span><p itemprop="text" class="post-excerpt">相信对 C++ 语言熟悉的同学应该都知道，C++ 在它的第11个版本中加入了新的名为“移动构造函数”的构造函数类型。通过使用移动构造函数，我们可以在对象进行“复制”时，来直接“窃取”拷贝对象所保有的一些资源。比如，已经在原对象中分配的堆内存、文件描述符，以及 IO 流等。但是在大多数情况下，当我们在代码中声明类的移动构造函数时，都通常会使用 “noexcept” 关键字来修饰对应的移动构造函数，那么这样做是为什么呢？或者说这样做有什么样的好处呢？今天我们就来探讨一下这个问题。</p></article></a><a href="/2019/10/14/浅谈企业股权设计/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">浅谈企业股权设计</h2><span class="post-meta">Published on<time itemprop="datePublished" datetime="2019-10-14T00:43:29.000Z"> 2019 / 10 / 14, 08:43:29</time></span><p itemprop="text" class="post-excerpt">最近花点时间读了一些“创业股权设计”相关的书籍，本文用来总结一些与之相关的要点。初创企业在企业进行备案注册与创始人（合伙人）职能分配时，总会涉及到公司股权划分的问题。合理的股权分配原则能够产生“1 + 1 &gt; 2”的效果。反之，不合理的股权划分则一般都或多或少预示着企业内部可能潜在的利益分配冲突。随着公司估值的增加，冲突也被逐渐放大，以致最后可能会发生诸如“兄弟式入伙，仇人式散伙”等影响企业生存的问题。因此，合理的股权划分便显得十分重要。</p></article></a><a href="/2019/10/11/SICP-计算机程序的构造和解释（一）/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">SICP-计算机程序的构造和解释（一）</h2><span class="post-meta">Published on<time itemprop="datePublished" datetime="2019-10-11T12:54:34.000Z"> 2019 / 10 / 11, 20:54:34</time></span><p itemprop="text" class="post-excerpt">SICP 第一章内容回顾。Lisp 语言的一种最重要的特点就是：计算过程的 Lisp 描述（称为过程）本身又可以作为 Lisp 的数据来表示和操作。</p></article></a><a href="/2019/09/16/English-key-Points-Conclusion-1/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">English key Points Conclusion .1</h2><span class="post-meta">Published on<time itemprop="datePublished" datetime="2019-09-16T02:02:52.000Z"> 2019 / 09 / 16, 10:02:52</time></span><p itemprop="text" class="post-excerpt">English knowledge series, key points conclusion .1</p></article></a><a href="/2019/09/13/Privacy-Policy-for-TOVD/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">Privacy Policy for TOVD</h2><span class="post-meta">Published on<time itemprop="datePublished" datetime="2019-09-13T14:05:42.000Z"> 2019 / 09 / 13, 22:05:42</time></span><p itemprop="text" class="post-excerpt">This page informs you of our policies regarding the collection, use, and disclosure of personal data when you use our Service and the choices you have associated with that data. Our Privacy Policy for TOVD is created with the help of the Free Privacy Policy Generator.</p></article></a><a href="/2019/09/09/JavaScript-杂记：全等、indexOf-语义与-Membrane/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">JavaScript 杂记：全等、indexOf 语义与 Membrane</h2><span class="post-meta">Published on<time itemprop="datePublished" datetime="2019-09-09T12:06:50.000Z"> 2019 / 09 / 09, 20:06:50</time></span><p itemprop="text" class="post-excerpt">专门写篇文章来记录最近一段时间遇到的几个小问题。本文主要介绍 JavaScript 中全等（“===”）运算符和 “Array.prototype.indexOf” 方法在 ECMA262 标准中的语义以及 JavaScript Membrane 的定义。其中 “JavaScript Membrane” 是 TC39 官方给出的对 ES6 中新增的 Proxy 特性正确使用场景的代码描述。</p></article></a><a href="/2019/09/01/C-编译器优化之-RVO-与-NRVO/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">C++ 编译器优化之 RVO 与 NRVO</h2><span class="post-meta">Published on<time itemprop="datePublished" datetime="2019-09-01T09:32:04.000Z"> 2019 / 09 / 01, 17:32:04</time></span><p itemprop="text" class="post-excerpt">RVO 即 “Return Value Optimization”，是一种编译器优化技术，通过该技术编译器可以减少函数返回时生成临时值值（对象）的个数，从某种程度上可以提高程序的运行效率，对需要分配大量内存的类对象其值复制过程十分友好。NRVO 全称为 “Named Return Value Optimization”，该优化的大致流程与 RVO 类似。</p></article></a><a href="/2019/08/31/C-11-好用的新语法特性/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">C++11 好用的新语法特性</h2><span class="post-meta">Published on<time itemprop="datePublished" datetime="2019-08-31T08:17:08.000Z"> 2019 / 08 / 31, 16:17:08</time></span><p itemprop="text" class="post-excerpt">C++ 语言自1983年发展至今已经过去了36年之久。从 C++98 标准到2017年的第五个标准也就是 C++17，C++ 语言的发展逐渐“脱离”了人们能够熟练驾驭它的速度。不仅如此，由于 C++ 语言在它设计之初，就秉承着这样一个设计理念：即要成为一种“能够直接和广泛地支持多种程序设计风格的语言，比如函数式编程、OOP 范式等”，并且在此之上还需要同时尽可能地与 C 语言的语法特性进行兼容。由于这些种种约束，导致 C++ 语言体系变得较为复杂和混乱，当然上述提到的只是造成这种问题的一部分原因。虽然 C++ 标准中有很多不是那么容易理解且学习路线陡峭的语法特性，但相对的，也有很多十分好用且易学的语法特性。今天，我们就来介绍几个在 C++11 标准中新增的，简单易用的语法特性。</p></article></a><a href="/2019/08/31/C-左值、右值与右值引用/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">C++ 左值、右值与右值引用</h2><span class="post-meta">Published on<time itemprop="datePublished" datetime="2019-08-31T08:16:32.000Z"> 2019 / 08 / 31, 16:16:32</time></span><p itemprop="text" class="post-excerpt">在我们日常的 C/C++ 语言学习过程中，我们肯定会经常听到诸如“左值”和“右值”这样的名词。不仅如此，在我们编译 C/C++ 应用程序时，编译器偶尔也会在其错误信息中包含与左值、右值相关的错误信息。那么究竟什么是左值和右值呢？是不是同它们的名字一样，可以通过一些“位置”因素来进行判断呢？比如位于某个语法结构中左侧的值就是左值，而位于右边的就是右值？而在本文中，我们将以 C++ 语言为例来介绍在其语言体系中，左值、右值和右值引用的概念和应用。</p></article></a><h4 class="page-title">See more? Please go to "Articles" page : )</h4></main><script src="/scripts/index.js" type="text/javascript"></script></body></html>