<!DOCTYPE html><html lang="en-us"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>“Low-Level Programming” 读书笔记（一） | 曜彤.手记</title><meta name="description" content="无意间找到的一本好书，主要介绍 X86_64 体系下的 C 和汇编。其中第二章关于 “C Programming Language” 的内容就简单略过了。"><meta name="generator" content="曜彤.手记"><meta name="author" content="于航(曜彤)"><meta name="keywords" content="博客, C++, C, VB, Web, Java, IT, 编程, 开发, Android, Python, MySQL, 科技, 黑客, 技术, Javascript, 云, 大数据, 计算, 机器学习, AI, 人工智能, 创业, 产品, 公司, WebAssembly, Wasm"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=0"><link rel="stylesheet" type="text/css" href="/styles/screen.css"><link rel="apple-touch-icon" sizes="57x57" href="/images/apple-touch-icon-57x57.jpg"><link rel="apple-touch-icon" sizes="60x60" href="/images/apple-touch-icon-60x60.jpg"><link rel="apple-touch-icon" sizes="72x72" href="/images/apple-touch-icon-72x72.jpg"><link rel="apple-touch-icon" sizes="76x76" href="/images/apple-touch-icon-76x76.jpg"><link rel="apple-touch-icon" sizes="114x114" href="/images/apple-touch-icon-114x114.jpg"><link rel="apple-touch-icon" sizes="120x120" href="/images/apple-touch-icon-120x120.jpg"><link rel="apple-touch-icon" sizes="144x144" href="/images/apple-touch-icon-144x144.jpg"><link rel="apple-touch-icon" sizes="152x152" href="/images/apple-touch-icon-152x152.jpg"><link rel="apple-touch-icon" sizes="196x196" href="/images/apple-touch-icon-196x196.jpg"><link rel="apple-touch-icon" sizes="310x310" href="/images/apple-touch-icon-310x310.jpg"><link href="/images/splash/iphone5_splash.png" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/iphone6_splash.png" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/iphoneplus_splash.png" media="(device-width: 621px) and (device-height: 1104px) and (-webkit-device-pixel-ratio: 3)" rel="apple-touch-startup-image"><link href="/images/splash/iphonex_splash.png" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3)" rel="apple-touch-startup-image"><link href="/images/splash/iphonexr_splash.png" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/iphonexsmax_splash.png" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3)" rel="apple-touch-startup-image"><link href="/images/splash/ipad_splash.png" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/ipadpro1_splash.png" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/ipadpro3_splash.png" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/ipadpro2_splash.png" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/images/favicon-96x96.png"><link rel="icon" type="image/png" sizes="128x128" href="/images/favicon-128.png"><link rel="icon" type="image/png" sizes="196x196" href="/images/favicon-196x196.png"><meta name="msapplication-TileColor" content="#FFFFFF"><meta name="msapplication-TileImage" content="mstile-144x144.png"><meta name="msapplication-square70x70logo" content="mstile-70x70.png"><meta name="msapplication-square150x150logo" content="mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="mstile-310x150.png"><meta name="msapplication-square310x310logo" content="mstile-310x310.png"><meta name="msapplication-square310x310logo" content="mstile-310x310.png"><link rel="manifest" href="/manifest.webmanifest"><link rel="alternate" type="application/atom+xml" title="Atom 0.3" href="/atom.xml"><link rel="stylesheet" href="/css/prism-okaidia.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body itemscope itemtype="https://schema.org/WebPage"><div class="canvas-containter"><span>X</span></div><header itemscope itemtype="https://schema.org/WPHeader"><div class="logo"></div><h1><a href="/" alt="曜彤.手记" title="曜彤.手记" itemprop="headline">曜彤.手记</a><a title="Atom 0.3" target="__blank" href="/atom.xml" class="rss"><img src="/images/rss.png"></a></h1><p itemprop="description">随记，关于互联网技术、产品与创业</p><nav itemscope itemtype="https://schema.org/SiteNavigationElement"><ul><li itemprop="name" class="menu-item"><a href="/ " alt="首页" title="首页" itemprop="url">首页</a></li><li itemprop="name" class="menu-item"><a href="/articles" alt="文章" title="文章" itemprop="url">文章</a></li><li itemprop="name" class="menu-item"><a href="/works" alt="作品" title="作品" itemprop="url">作品</a></li><li itemprop="name" class="menu-item"><a href="/readings" alt="阅读" title="阅读" itemprop="url">阅读</a></li><li itemprop="name" class="menu-item"><a href="/tags" alt="标签" title="标签" itemprop="url">标签</a></li><li itemprop="name" class="menu-item"><a href="/author" alt="关于" title="关于" itemprop="url">关于</a></li></ul></nav><p class="meta-icp"><a target="_blank" href="http://www.miit.gov.cn/"><span>吉 ICP 备10004938号</span></a></p><div class="space"></div></header><main itemscope itemtype="https://schema.org/Blog"><script src="https://shadow.elemecdn.com/npm/zoomage.js@latest/dist/zoomage.min.js" type="text/javascript"></script><script src="https://shadow.elemecdn.com/npm/axios@0.18.0/dist/axios.min.js" type="text/javascript"></script><script src="/scripts/post.js" type="text/javascript"></script><div class="touch-top"><span></span></div><article post-id="f2958ed42ac6f084c8ed9c8e52cb2e69" class="full"><h1 itemprop="headline" class="post-heading">“Low-Level Programming” 读书笔记（一）</h1><div class="article-meta"><span class="post-meta"><br>Created on<time itemprop="dateCreated" datetime="2020-06-25T08:15:36.000Z"> 2020 / 06 / 25, 16:15:36</time></span><span class="page-tag-anchor"><a href="/tags/汇编" itemprop="url">#汇编</a>&nbsp;&nbsp;</span></div><br><p>无意间找到的一本好书，主要介绍 X86_64 体系下的 C 和汇编。其中第二章关于 “C Programming Language” 的内容就简单略过了。</p>
<h3 id="Chapter-1：计算机基础架构"><a href="#Chapter-1：计算机基础架构" class="headerlink" title="Chapter 1：计算机基础架构"></a>Chapter 1：计算机基础架构</h3><ol>
<li>（Page：4）<strong>冯诺依曼体系</strong>：强健且易于编程。拥有一个 CPU 处理单元和内存单元，被连接到公用的总线上。CPU 内部分为控制单元（Control Unit）与算数逻辑单元（ALU）以进行逻辑控制和算数计算，而内存单元则用于存储数据。被编码的指令和数据均存放于内存中，内存按字节被分为一个个单元。指令以顺序的形式被依次执行除非特殊的 jump 指令被执行。</li>
<li>（Page：5）内存状态和寄存器的值从程序员的视角描述了某一时刻的 CPU 状态。每一条机器指令都对应着不同的内存和寄存器状态。</li>
<li>（Page：6）<strong>长模式</strong>：在 X86_64 处理器架构中，当处于长模式（Long Mode）时，<strong>64 位应用程序（或者是操作系统）可以使用 64 位指令和寄存器</strong>，而 32 位程序将以一种兼容子模式运行。不在长模式下运行时，处理器支持<strong>真实模式</strong>和<strong>保护模式</strong>两个子模式，在这两个模式下的 X86_64 处理器与 X86_32 处理器运行方式完全相同。</li>
<li>（Page：6）Intel 64 基于冯诺依曼的扩展：</li>
</ol>
<ul>
<li><strong>寄存器</strong>：直接存在于 CPU 上的存储单元；由于不需要经由总线调度，因此存取速度很快，通常只需要几个 CPU 周期；</li>
<li><strong>栈</strong>：即进程虚拟地址空间中的栈结构，rsp 寄存器指向栈顶位置。用于保存当前栈帧中使用的局部变量、参数等；</li>
<li><strong>中断</strong>：可用于改变程序的执行顺序。常见的中断场景：外部设备的响应、运行时异常（除零）、无效指令、尝试以非特权模式执行特权指令等；</li>
<li><strong>保护环（分级保护域）</strong>：一般只使用 ring0 和 ring3。ring0 可以执行所有的 CPU 指令。ring3 一般是用户应用程序所在的层级，只能使用最安全的 CPU 指令；另外的 ring1 \ ring2 一般不使用；</li>
<li><strong>虚拟内存</strong>：一般指进程独立的虚拟地址空间（VAS）。可以隔离进程运行环境，并且借由分段、分页技术，可以很好地管理进程的内存使用；</li>
</ul>
<p><img src="1.png" alt=""></p>
<ol start="5">
<li>（Page：8）程序访问的局部性：<strong>一个程序 80% 的执行时间花费在仅 20% 的代码中</strong>。分为时间局部性 —— 近期被访问的信息，可能在短时间内被访问，和空间局部性 —— 与被访问地址相邻的地址上信息可能会在短期内被再次访问。基本思想：<strong>对大概率事件赋予它优先的处理权和资源使用权，以获得全局的最优结果</strong>。</li>
<li>（Page：9）X86_64 下的通用寄存器（<strong>16 个 64 位的整型寄存器</strong>）：</li>
</ol>
<ul>
<li><strong>r0 (rax)</strong>：算术指令中使用的一种“累加器”。通常也作为系统调用的序号，以及返回值的容器；Accumulator；</li>
<li><strong>r1 (rcx)</strong>：用于循环控制；Cycle；</li>
<li><strong>r2 (rdx)</strong>：在输入/输出操作期间存储数据。通常也作为系统调用中参数传递寄存器（第三个参数）；Data；</li>
<li><strong>r3 (rbx)</strong>：基址寄存器，用于存放早期处理器模型中的基址；Base；</li>
<li><strong>r4 (rsp)</strong>：类似 i386 下的 esp，指向进程栈的栈顶；Stack；</li>
<li><strong>r5 (rbp)</strong>：类似 i386 下的 ebp，栈帧寄存器，默认指向旧的 rbp 的值；Stack Base；</li>
<li><strong>r6 (rsi)</strong>：字符串操作命令中的源索引；通常也作为系统调用中参数传递寄存器（第二个参数）；Source Index；</li>
<li><strong>r7 (rdi)</strong>：字符串操作命令中的目标索引；通常也作为系统调用中参数传递寄存器（第一个参数）；Destination Index；</li>
<li><strong>r8 - r15</strong>：通常用于存储临时变量；</li>
</ul>
<ol start="7">
<li>（Page：10）当使用通用寄存器名时，可以为其添加后缀，以寻址其一部分区域：</li>
</ol>
<ul>
<li><strong>d</strong>：即 double，寻址其低 32 位（如：r0d）；</li>
<li><strong>w</strong>：即 word，寻址其低 16 位（如：r3w）；</li>
<li><strong>b</strong>：即 byte，寻址其低 8 位（如：r7b）；</li>
</ul>
<p>对于 r0-r7 我们一般使用其别名来表示；而 r8-r15 则直接使用数字索引的形式来表示。我们也可以通过别名来访问 r0-r7 的一部分区域，对于 rax / rbx / rcx / rdx 来说，有着统一规则的表达方式：</p>
<p><img src="2.png" alt=""></p>
<p>对于 rsi / rdi / rsp / rbp 来说，有着另外的表达方式（规则相同）：</p>
<p><img src="3.png" alt=""></p>
<ol start="8">
<li>（Page：12）<strong>rip 寄存器</strong>：程序员可以访问 rip 寄存器。它是一个 64 位寄存器，始终存储要执行的下一条指令的地址。分支指令会对其进行修改。因此，每次执行任何指令时，rip 都会存储下一条将要执行的指令地址。另一个可访问的寄存器称为 <strong>rflags</strong>：它存储着反映当前程序运行状态的标志。例如，最后一条算术指令的结果是是否是负数？是否发生了溢出？等。它的部分寻址为：<strong>eflags（低 32 位）</strong>和 <strong>flags（低 16 位）</strong>。其内部的标志位如下所示：</li>
</ol>
<p><img src="4.png" alt=""></p>
<ol start="9">
<li>（Page：12）<strong>xmm0 - xmm15 寄存器</strong>：用于进行 SIMD 以及浮点数运算。</li>
<li>（Page：13）系统寄存器（被 OS 特殊使用）：</li>
</ol>
<ul>
<li><strong>cr0 / cr4</strong>：存储与不同处理器模式和虚拟内存有关的标志；</li>
<li><strong>cr2 / cr3</strong>：用于支持虚拟内存；</li>
<li><strong>cr8（tpr）</strong>：用于优化中断机制；</li>
<li><strong>efer</strong>：标志寄存器，用于控制 CPU 模式和扩展；</li>
<li><strong>idtr</strong>：存储中断描述表的地址；</li>
<li><strong>gdtr / ldtr</strong>：存储描述符表的地址；</li>
<li><strong>cs / ds / ss / es / gs / fs</strong>：段寄存器，主要用于实现分段机制，其中一部分仍用于实现特权模式；</li>
</ul>
<p>在长模式下，当前保护环等级存储在寄存器 cs 的最低两位中，并且仅在处理中断或系统调用（需要进入内核模式）时才能更改。</p>
<ol start="11">
<li>（Page：15）关于栈的说明：</li>
</ol>
<ul>
<li><strong>没有“空栈”的概念</strong>。无论如何都可以从栈上 pop 一个值，但获得的值可能没有意义；</li>
<li>栈向<strong>低地址</strong>方向增长；</li>
<li>几乎所有类型的操作数都被视为<strong>带符号整数</strong>，因此会发生符号位扩展（有符号数扩展符号位，即 1；无符号数扩展 0）；</li>
<li>大多数支持栈的体系结构都使用相同的原理，即栈顶位置由某些寄存器定义，但不同之处在于各个地址的含义。在某些体系结构上，<strong>寄存器的值是下一个被推入元素的地址</strong>；在其他情况下，寄存器的值是<strong>已经被压入堆栈的最后一个元素的地址</strong>；</li>
</ul>
<ol start="12">
<li>（Page：16）PUSH 指令：</li>
</ol>
<p><img src="5.png" alt=""></p>
<ul>
<li><strong><em>push r/m16</em></strong>：将一个 16 位的寄存器的值或者从内存中取得的 16 位数字推入当前的栈中；</li>
<li><strong><em>push CS</em></strong>：将段寄存器 cs 的值推入栈中；</li>
<li><strong><em>push imm16</em></strong>：将 16 位的立即数推入栈中；</li>
</ul>
<h3 id="Chapter-2：汇编语言"><a href="#Chapter-2：汇编语言" class="headerlink" title="Chapter 2：汇编语言"></a>Chapter 2：汇编语言</h3><ol start="13">
<li>（Page：18）Unix 将一切资源均视为“文件”。从广义上讲，<strong>文件就是看起来像字节流的任何东西</strong>。</li>
<li>（Page：19）通常来讲，汇编语言不区分大小写，但是<strong>标签名称</strong>（global _start）和<strong>段名称</strong>（section .data）区分大小写。</li>
<li>（Page：19）伪指令（非真实的 X86_64 指令集指令）<strong>DB</strong>（Declaring Initialized Data）家族，用于<strong>定义以字节形式表示的初始化数据</strong>：</li>
</ol>
<ul>
<li><strong>db</strong>：bytes；</li>
<li><strong>dw</strong>：2bytes；</li>
<li><strong>dd</strong>：4bytes；</li>
<li><strong>dq</strong>：8bytes；</li>
</ul>
<pre class="line-numbers language-asm"><code class="language-asm">db    0x55                ; just the byte 0x55 
db    0x55,0x56,0x57      ; three bytes in succession 
db    'a',0x55            ; character constants are OK 
db    'hello',13,10,'$'   ; so are string constants 
dw    0x1234              ; 0x34 0x12 
dw    'a'                 ; 0x61 0x00 (it's just a number) 
dw    'ab'                ; 0x61 0x62 (character constant) 
dw    'abc'               ; 0x61 0x62 0x63 0x00 (string) 
dd    0x12345678          ; 0x78 0x56 0x34 0x12 
dd    1.234567e20         ; floating-point constant 
dq    0x123456789abcdef0  ; eight byte constant 
dq    1.234567e20         ; double-precision float <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="16">
<li>（Page：20）伪指令 <strong>TIMES，用于重复多次执行某指令</strong>：</li>
</ol>
<pre class="line-numbers language-asm"><code class="language-asm">    global _start
    section .text
_start:   
    mov rax, 1
    mov rdi, 1  ; stdout；
    mov rsi, message  ; buffer；
    mov rdx, 64  ; length；
    syscall
    mov rax, 60
    xor rdi, rdi  ; clean rdi and pass 0 to exit() system call；
    syscall 

    section .rodata
message:  
    times 10 db 'ABC'  ; message 符号的内容会成为一个整体；
    times 64-$+message db '$'  ; times 伪指令可以接受表达式作为第一个参数；$ 为特殊符号表示当前语句开头的汇编位置；$$ 表示当前段开头处的汇编位置；
    db 10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="17">
<li>（Page：20）X86_64 下系统调用的传参寄存器：rdi / rsi / rdx / r10 / r8 / r9；最多传递 6 个参数。</li>
<li>（Page：22）一个通过“<strong>位移 sar</strong>”和“<strong>逻辑与 and</strong>”来输出数字值的例子：</li>
</ol>
<pre class="line-numbers language-asm"><code class="language-asm">section .data
codes: 
    db '0123456789ABCDEF'  ; char symbols；

global _start
section .text
_start:
    mov rax, 0x1122334455667788  ; 64bits；
    mov rdi, 1  ; "stdout"；
    mov rdx, 1  ; length of chars to print；
    mov rcx, 64   ; counter for 16 times iteration;
.loop:
    push rax  ; rax -> stack;
    sub rcx, 4  ; rcx <- rcx - 4；
    sar rax, cl  ; (Shirt Arithmetic Right) rax >> (cl times)；
    and rax, 0xf  ; for iteration turns > 0

    lea rsi, [codes + rax]  ; (Load Effective Address) map to char*;
    mov rax, 1  ; set system call to write()；

    push rcx  ; save rcx;
    syscall
    pop rcx

    pop rax
    test rcx, rcx  ; test if zero, will change SF, ZF, PF accordingly；
    jnz .loop  ; loop if not zero；

    mov rax, 60  ; exit；
    xor rdi, rdi
    syscall<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>sar 为算数右移，会进行<strong>符号位扩展</strong>；shr 为逻辑右移，扩展为填充 0；</li>
<li>.loop 为本地标签，隶属于某个全局标签之下（比如这里的 _start），因此其全名为 <strong>_start.loop</strong>，我们可以在整个程序中用这个名称进行索引；</li>
<li><code>lea rsi, [codes + rax]</code> 使用了间接寻址；</li>
</ul>
<ol start="19">
<li>（Page：24）lea 与 mov 的区别（大部分情况下 <strong>mov 操作的是值</strong>，<strong>lea 操作的是地址</strong>）：</li>
</ol>
<ul>
<li>mov rsi, codes：codes 的地址存放到 rsi；</li>
<li>mov rsi, [codes]：codes 地址开始的 8 字节内存内容存放到 ris；</li>
<li>les rsi, [codes]：codes 的地址存放到 rsi；</li>
<li>mov rsi, [codes + rax]：codes + rax 地址开始的 8 字节内存内容存放到 ris；</li>
<li>lea rsi, [codes + rax]：codes 的地址加 rax 值存放到 rsi</li>
</ul>
<ol start="20">
<li>（Page：24）常用的跳转指令：</li>
</ol>
<ul>
<li><strong>无条件跳转</strong>：jmp；</li>
<li><strong>有条件跳转</strong>：jz / jnz / ja / jb / jg / jl / jae / jle（其中 ja / jb 用于 unsigned 数字，jg / jl 用于 signed 数字）；</li>
</ul>
<p>其中条件跳转指令依赖于 rflags 寄存器的值，这些值会被诸如 <strong>test</strong> / <strong>cmp</strong> 等指令改变。</p>
<pre class="line-numbers language-asm"><code class="language-asm">global _start
section .rodata
message:
    db 'YHSPY', 10
section .text
_start:
    mov rax, 1
    cmp rax, 2
    jl yes  ; jump if rax less than 2；
    mov rbx, 0
    jmp ex
yes:
    mov rax, 1
    mov rdi, 1 
    mov rsi, message
    mov rdx, 6
    syscall
    mov rax, 60
    xor rdi, rdi
    syscall
ex:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<br><div class="article-bottom-meta"><span class="post-meta">Last built on<time itemprop="dateModified" datetime="2020-06-25T08:15:36.000Z"> 2020 / 06 / 26, 15:16:22</time></span></div></article><br><a name="comments"></a><div class="article-end-saparator"><span class="line"></span><span class="text">这是文章底线，下面是评论</span><span class="line"></span></div><div class="comments-display-container"><div class="placeholder"><i class="fa fa-battery-empty">&nbsp;&nbsp;暂无评论，欢迎勾搭 ：）</i></div></div><div class="dot-decoration"></div><div class="comments-input"><textarea name="comment" placeholder="请输入评论内容 ..."></textarea><div><input type="text" placeholder="请输入昵称 ..."><button class="submit-comment">发布</button></div></div><span class="next-post"><a href="/2020/06/25/NASM-小记录/" itemprop="url">Older Post ⇒</a></span><br><br><br><br><br></main><script src="/scripts/index.js" type="text/javascript"></script></body></html>