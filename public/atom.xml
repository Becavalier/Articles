<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>曜彤.手记</title>
  <icon>https://www.yhspy.com/images/rss.png</icon>
  <subtitle>YHSPY</subtitle>
  <link href="//atom.xml" rel="self"/>
  
  <link href="https://www.yhspy.com/"/>
  <updated>2020-06-25T06:36:33.811Z</updated>
  <id>https://www.yhspy.com/</id>
  
  <author>
    <name>于航(曜彤)</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>NASM 小记录</title>
    <link href="https://www.yhspy.com/2020/06/25/NASM-%E5%B0%8F%E8%AE%B0%E5%BD%95/"/>
    <id>https://www.yhspy.com/2020/06/25/NASM-%E5%B0%8F%E8%AE%B0%E5%BD%95/</id>
    <published>2020-06-25T05:42:46.000Z</published>
    <updated>2020-06-25T06:36:33.811Z</updated>
    
    <summary type="html">
    
      本文记录一些在使用 NASM 时的一些常用信息，供快速查阅之用。
    
    </summary>
    
    
    
      <category term="NASM" scheme="https://www.yhspy.com/tags/NASM/"/>
    
  </entry>
  
  <entry>
    <title>Linux 共享库应用 --version-script</title>
    <link href="https://www.yhspy.com/2020/06/23/Linux-%E5%85%B1%E4%BA%AB%E5%BA%93%E5%BA%94%E7%94%A8-version-script/"/>
    <id>https://www.yhspy.com/2020/06/23/Linux-%E5%85%B1%E4%BA%AB%E5%BA%93%E5%BA%94%E7%94%A8-version-script/</id>
    <published>2020-06-23T10:18:37.000Z</published>
    <updated>2020-06-23T11:25:51.863Z</updated>
    
    <summary type="html">
    
      我们知道，传统 Linux 共享库的 SO-NAME 机制无法解决当依赖共享库的次版本号不同时所可能带来的符号不兼容问题。为此，我们可以为共享库添加 Version Script 以标记其中各符号所对应的次版本号，当所依赖版本符号不存在时便可以给出相对友好的提示信息。不仅如此，借助 Version Script 我们还可以向应用程序屏蔽共享库的一些内部工具符号。
    
    </summary>
    
    
    
      <category term="计算机" scheme="https://www.yhspy.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>链接、装载与库相关记录（二）</title>
    <link href="https://www.yhspy.com/2020/06/21/%E9%93%BE%E6%8E%A5%E3%80%81%E8%A3%85%E8%BD%BD%E4%B8%8E%E5%BA%93%E7%9B%B8%E5%85%B3%E8%AE%B0%E5%BD%95%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://www.yhspy.com/2020/06/21/%E9%93%BE%E6%8E%A5%E3%80%81%E8%A3%85%E8%BD%BD%E4%B8%8E%E5%BA%93%E7%9B%B8%E5%85%B3%E8%AE%B0%E5%BD%95%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2020-06-21T14:00:50.000Z</published>
    <updated>2020-06-25T05:27:07.584Z</updated>
    
    <summary type="html">
    
      本文承接上文“链接、装载与库相关记录（一）”。
    
    </summary>
    
    
    
      <category term="计算机" scheme="https://www.yhspy.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>ld 链接控制脚本与默认脚本</title>
    <link href="https://www.yhspy.com/2020/06/19/ld-%E9%93%BE%E6%8E%A5%E6%8E%A7%E5%88%B6%E8%84%9A%E6%9C%AC%E4%B8%8E%E9%BB%98%E8%AE%A4%E8%84%9A%E6%9C%AC/"/>
    <id>https://www.yhspy.com/2020/06/19/ld-%E9%93%BE%E6%8E%A5%E6%8E%A7%E5%88%B6%E8%84%9A%E6%9C%AC%E4%B8%8E%E9%BB%98%E8%AE%A4%E8%84%9A%E6%9C%AC/</id>
    <published>2020-06-19T10:02:50.000Z</published>
    <updated>2020-06-19T10:17:04.344Z</updated>
    
    <summary type="html">
    
      我们可以通过 `ld -verbose` 命令来查看 GNU 链接器 ld 默认使用的内部链接控制脚本。这里直接列出该控制脚本的内容。
    
    </summary>
    
    
    
      <category term="计算机" scheme="https://www.yhspy.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>尝试构建体积最小的 ELF 可执行程序</title>
    <link href="https://www.yhspy.com/2020/06/19/%E5%B0%9D%E8%AF%95%E6%9E%84%E5%BB%BA%E4%BD%93%E7%A7%AF%E6%9C%80%E5%B0%8F%E7%9A%84-ELF-%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F/"/>
    <id>https://www.yhspy.com/2020/06/19/%E5%B0%9D%E8%AF%95%E6%9E%84%E5%BB%BA%E4%BD%93%E7%A7%AF%E6%9C%80%E5%B0%8F%E7%9A%84-ELF-%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F/</id>
    <published>2020-06-19T07:44:56.000Z</published>
    <updated>2020-06-25T05:20:22.832Z</updated>
    
    <summary type="html">
    
      本文将尝试构建一个代码量最少、体积最小的 ELF 可执行程序，程序运行时会向 stdout 输出字符串 “Hello, YHSPY!”。
    
    </summary>
    
    
    
      <category term="计算机" scheme="https://www.yhspy.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>GCC 下的 COMMON 块控制</title>
    <link href="https://www.yhspy.com/2020/06/19/GCC-%E4%B8%8B%E7%9A%84-COMMON-%E5%9D%97%E6%8E%A7%E5%88%B6/"/>
    <id>https://www.yhspy.com/2020/06/19/GCC-%E4%B8%8B%E7%9A%84-COMMON-%E5%9D%97%E6%8E%A7%E5%88%B6/</id>
    <published>2020-06-19T03:18:27.000Z</published>
    <updated>2020-06-19T05:56:29.129Z</updated>
    
    <summary type="html">
    
      在 GCC 下，我们可以通过 `__attribute__((common))` 扩展参数来控制编译器对 C 源码中的未初始化全局变量的处理方式。默认情况下，GCC 将采用 COMMON 块来存放未初始化全局变量，这里注意是 C 源代码。
    
    </summary>
    
    
    
      <category term="计算机" scheme="https://www.yhspy.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>ELF 静态 / 动态链接流程解析</title>
    <link href="https://www.yhspy.com/2020/06/18/ELF-%E9%9D%99%E6%80%81-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/"/>
    <id>https://www.yhspy.com/2020/06/18/ELF-%E9%9D%99%E6%80%81-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/</id>
    <published>2020-06-18T11:24:18.000Z</published>
    <updated>2020-06-24T22:13:06.841Z</updated>
    
    <summary type="html">
    
      本文将以两个具体的例子来剖析 ELF 目标文件（.o）和动态库文件（.so）在分别进行静态链接和动态链接时的具体流程。
    
    </summary>
    
    
    
      <category term="计算机" scheme="https://www.yhspy.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Clang 下的 weak 与 weakref</title>
    <link href="https://www.yhspy.com/2020/06/18/Clang-%E4%B8%8B%E7%9A%84-weak-%E4%B8%8E-weakref/"/>
    <id>https://www.yhspy.com/2020/06/18/Clang-%E4%B8%8B%E7%9A%84-weak-%E4%B8%8E-weakref/</id>
    <published>2020-06-18T05:24:56.000Z</published>
    <updated>2020-06-18T09:23:18.079Z</updated>
    
    <summary type="html">
    
      符号表结构中 st_info 字段的高 28 位决定了 ST_BIND 的值，而它的一种枚举值 STB_WEAK 表示了一种特殊类型的符号，即“弱符号”。而对应的一种抽象关系便称为“弱引用”。同时相对的，也有着“强符号”和“强引用”的定义。
    
    </summary>
    
    
    
      <category term="计算机" scheme="https://www.yhspy.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>使用 objcopy 为 ELF 加入自定义 Section</title>
    <link href="https://www.yhspy.com/2020/06/17/%E4%BD%BF%E7%94%A8-objcopy-%E4%B8%BA-ELF-%E5%8A%A0%E5%85%A5%E8%87%AA%E5%AE%9A%E4%B9%89-Section/"/>
    <id>https://www.yhspy.com/2020/06/17/%E4%BD%BF%E7%94%A8-objcopy-%E4%B8%BA-ELF-%E5%8A%A0%E5%85%A5%E8%87%AA%E5%AE%9A%E4%B9%89-Section/</id>
    <published>2020-06-17T07:42:53.000Z</published>
    <updated>2020-06-18T05:21:49.787Z</updated>
    
    <summary type="html">
    
      我们可以使用 objcopy 工具为一个 ELF 文件加入自定义的 Section 信息，并在主程序中访问该目标文件中这些自定义的 Section 内的数据。
    
    </summary>
    
    
    
      <category term="计算机" scheme="https://www.yhspy.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Linux 下的 ELF 完整结构分析</title>
    <link href="https://www.yhspy.com/2020/06/17/Linux%20%E4%B8%8B%E7%9A%84%20ELF%20%E5%AE%8C%E6%95%B4%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/"/>
    <id>https://www.yhspy.com/2020/06/17/Linux%20%E4%B8%8B%E7%9A%84%20ELF%20%E5%AE%8C%E6%95%B4%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/</id>
    <published>2020-06-17T06:23:58.000Z</published>
    <updated>2020-06-23T05:57:33.381Z</updated>
    
    <summary type="html">
    
      本文我们将以如下这段代码为例，来分析其对应 ELF Object / Executable 文件在 Linux 下的完整数据结构，以及各结构在操作系统源码中的实际类型定义。
    
    </summary>
    
    
    
      <category term="计算机" scheme="https://www.yhspy.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>链接、装载与库相关记录（一）</title>
    <link href="https://www.yhspy.com/2020/06/16/%E9%93%BE%E6%8E%A5%E3%80%81%E8%A3%85%E8%BD%BD%E4%B8%8E%E5%BA%93%E7%9B%B8%E5%85%B3%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://www.yhspy.com/2020/06/16/%E9%93%BE%E6%8E%A5%E3%80%81%E8%A3%85%E8%BD%BD%E4%B8%8E%E5%BA%93%E7%9B%B8%E5%85%B3%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2020-06-16T11:15:02.000Z</published>
    <updated>2020-06-25T05:24:57.687Z</updated>
    
    <summary type="html">
    
      本文内容主要摘自《程序员的自我修养 — 链接、装载与库》一书。
    
    </summary>
    
    
    
      <category term="计算机" scheme="https://www.yhspy.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>“领域规则类”设计模式（C++）</title>
    <link href="https://www.yhspy.com/2020/06/08/%E2%80%9C%E9%A2%86%E5%9F%9F%E8%A7%84%E5%88%99%E7%B1%BB%E2%80%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88C-%EF%BC%89/"/>
    <id>https://www.yhspy.com/2020/06/08/%E2%80%9C%E9%A2%86%E5%9F%9F%E8%A7%84%E5%88%99%E7%B1%BB%E2%80%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88C-%EF%BC%89/</id>
    <published>2020-06-08T06:57:27.000Z</published>
    <updated>2020-06-08T09:47:16.834Z</updated>
    
    <summary type="html">
    
      在特定领域中，某些变化虽然频繁，但可以抽象为某种规则。这时候，结合特定领域，将问题抽象为语法规则，从而给出在该领域下的一般性解决方案。
    
    </summary>
    
    
    
      <category term="C++" scheme="https://www.yhspy.com/tags/C/"/>
    
      <category term="设计模式" scheme="https://www.yhspy.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>“行为变化类”设计模式（C++）</title>
    <link href="https://www.yhspy.com/2020/06/08/%E2%80%9C%E8%A1%8C%E4%B8%BA%E5%8F%98%E5%8C%96%E7%B1%BB%E2%80%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88C-%EF%BC%89/"/>
    <id>https://www.yhspy.com/2020/06/08/%E2%80%9C%E8%A1%8C%E4%B8%BA%E5%8F%98%E5%8C%96%E7%B1%BB%E2%80%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88C-%EF%BC%89/</id>
    <published>2020-06-08T04:17:52.000Z</published>
    <updated>2020-06-08T06:52:46.911Z</updated>
    
    <summary type="html">
    
      在组件的构建过程中，组件行为的变化经常导致组件本身剧烈的变化。“行为变化”模式将组件的行为和组件本身进行解耦，从而支持组件行为的变化，实现两者之间的松耦合。
    
    </summary>
    
    
    
      <category term="C++" scheme="https://www.yhspy.com/tags/C/"/>
    
      <category term="设计模式" scheme="https://www.yhspy.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>“数据结构类”设计模式（C++）</title>
    <link href="https://www.yhspy.com/2020/06/07/%E2%80%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B1%BB%E2%80%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88C-%EF%BC%89/"/>
    <id>https://www.yhspy.com/2020/06/07/%E2%80%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B1%BB%E2%80%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88C-%EF%BC%89/</id>
    <published>2020-06-07T15:53:32.000Z</published>
    <updated>2020-06-08T04:52:27.882Z</updated>
    
    <summary type="html">
    
      常常有一些组件在内部具有特定的数据结构，如果让客户程序依赖这些特定的数据结构，将极大地破坏组件的复用。这时候，将这些特定数据结构封装在内部，在外部提供统一的接口，来实现与特定数据结构无关的访问，是一种行之有效的解决方案。
    
    </summary>
    
    
    
      <category term="C++" scheme="https://www.yhspy.com/tags/C/"/>
    
      <category term="设计模式" scheme="https://www.yhspy.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>“状态变化类”设计模式（C++）</title>
    <link href="https://www.yhspy.com/2020/06/04/%E2%80%9C%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96%E7%B1%BB%E2%80%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88C-%EF%BC%89/"/>
    <id>https://www.yhspy.com/2020/06/04/%E2%80%9C%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96%E7%B1%BB%E2%80%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88C-%EF%BC%89/</id>
    <published>2020-06-04T00:43:45.000Z</published>
    <updated>2020-06-04T07:37:49.596Z</updated>
    
    <summary type="html">
    
      在组件构建过程中，某些对象的状态经常面临变化，如何对这些变化进行有效的管理？同时又维持高层模块的稳定？“状态变化”模式为这一问题提供了一种解决方案。
    
    </summary>
    
    
    
      <category term="C++" scheme="https://www.yhspy.com/tags/C/"/>
    
      <category term="设计模式" scheme="https://www.yhspy.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>“接口隔离类”设计模式（C++）</title>
    <link href="https://www.yhspy.com/2020/06/03/%E2%80%9C%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E7%B1%BB%E2%80%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88C-%EF%BC%89/"/>
    <id>https://www.yhspy.com/2020/06/03/%E2%80%9C%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E7%B1%BB%E2%80%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88C-%EF%BC%89/</id>
    <published>2020-06-03T02:33:31.000Z</published>
    <updated>2020-06-07T16:00:11.898Z</updated>
    
    <summary type="html">
    
      在组件构建过程中，某些接口之间直接的依赖常常会带来很多问题、甚至根本无法实现。采用添加一层间接（稳定）接口，来隔离本来相互紧密关联的接口是一种常见的解决方案。
    
    </summary>
    
    
    
      <category term="C++" scheme="https://www.yhspy.com/tags/C/"/>
    
      <category term="设计模式" scheme="https://www.yhspy.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>“对象性能类”设计模式（C++）</title>
    <link href="https://www.yhspy.com/2020/06/02/%E2%80%9C%E5%AF%B9%E8%B1%A1%E6%80%A7%E8%83%BD%E7%B1%BB%E2%80%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88C-%EF%BC%89/"/>
    <id>https://www.yhspy.com/2020/06/02/%E2%80%9C%E5%AF%B9%E8%B1%A1%E6%80%A7%E8%83%BD%E7%B1%BB%E2%80%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88C-%EF%BC%89/</id>
    <published>2020-06-02T02:28:53.000Z</published>
    <updated>2020-06-02T13:26:32.803Z</updated>
    
    <summary type="html">
    
      OOP 很好地解决了“抽象”的问题，但是必不可免地要付出一定的代价。对于通常情况来讲，面向对象的成本大都可以忽略不计。但是对于某些情况，其所带来的成本必须被谨慎处理。
    
    </summary>
    
    
    
      <category term="C++" scheme="https://www.yhspy.com/tags/C/"/>
    
      <category term="设计模式" scheme="https://www.yhspy.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>“对象创建类”设计模式（C++）</title>
    <link href="https://www.yhspy.com/2020/06/01/%E2%80%9C%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%B1%BB%E2%80%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88C-%EF%BC%89/"/>
    <id>https://www.yhspy.com/2020/06/01/%E2%80%9C%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%B1%BB%E2%80%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88C-%EF%BC%89/</id>
    <published>2020-06-01T09:17:37.000Z</published>
    <updated>2020-06-08T09:16:09.837Z</updated>
    
    <summary type="html">
    
      通过“对象创建”模式绕开 new，来避免对象创建（new）过程中所导致的紧耦合（依赖具体类），从而支持对象创建的稳定。它是接口抽象之后的第一步工作。
    
    </summary>
    
    
    
      <category term="C++" scheme="https://www.yhspy.com/tags/C/"/>
    
      <category term="设计模式" scheme="https://www.yhspy.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>“单一职责类”设计模式（C++）</title>
    <link href="https://www.yhspy.com/2020/05/29/%E2%80%9C%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E7%B1%BB%E2%80%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88C-%EF%BC%89/"/>
    <id>https://www.yhspy.com/2020/05/29/%E2%80%9C%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E7%B1%BB%E2%80%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88C-%EF%BC%89/</id>
    <published>2020-05-29T07:37:37.000Z</published>
    <updated>2020-06-02T06:12:58.157Z</updated>
    
    <summary type="html">
    
      在软件组件的设计中，如果责任划分的不清晰，使用继承得到的结果往往是：随着需求的变化，子类急剧膨胀，同时充斥着重复代码的。而这时候的关键则是划清责任。
    
    </summary>
    
    
    
      <category term="C++" scheme="https://www.yhspy.com/tags/C/"/>
    
      <category term="设计模式" scheme="https://www.yhspy.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>“组件协作类”设计模式（C++）</title>
    <link href="https://www.yhspy.com/2020/05/28/%E2%80%9C%E7%BB%84%E4%BB%B6%E5%8D%8F%E4%BD%9C%E7%B1%BB%E2%80%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88C-%EF%BC%89/"/>
    <id>https://www.yhspy.com/2020/05/28/%E2%80%9C%E7%BB%84%E4%BB%B6%E5%8D%8F%E4%BD%9C%E7%B1%BB%E2%80%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88C-%EF%BC%89/</id>
    <published>2020-05-28T03:40:48.000Z</published>
    <updated>2020-06-08T08:05:20.977Z</updated>
    
    <summary type="html">
    
      该类设计模式主要用于解决组件之间的协作问题。
    
    </summary>
    
    
    
      <category term="C++" scheme="https://www.yhspy.com/tags/C/"/>
    
      <category term="设计模式" scheme="https://www.yhspy.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>C++17 部分新特性一览</title>
    <link href="https://www.yhspy.com/2020/05/25/C-17-%E9%83%A8%E5%88%86%E6%96%B0%E7%89%B9%E6%80%A7%E4%B8%80%E8%A7%88/"/>
    <id>https://www.yhspy.com/2020/05/25/C-17-%E9%83%A8%E5%88%86%E6%96%B0%E7%89%B9%E6%80%A7%E4%B8%80%E8%A7%88/</id>
    <published>2020-05-25T06:36:45.000Z</published>
    <updated>2020-05-25T11:10:53.294Z</updated>
    
    <summary type="html">
    
      C++17 又称 C++1z，是 C++ 的现行标准的非正式名称，正式名称为 “International Standard ISO/IEC Programming Language C++”。C++17 旨在作为大型扩展，最终的投票期于2017年结束。
    
    </summary>
    
    
    
      <category term="C++" scheme="https://www.yhspy.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 字符串拷贝优化策略：Eager-Copy、SSO 与 COW</title>
    <link href="https://www.yhspy.com/2020/05/24/C-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%B7%E8%B4%9D%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5%EF%BC%9AEager-Copy%E3%80%81SSO-%E4%B8%8E-COW/"/>
    <id>https://www.yhspy.com/2020/05/24/C-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%B7%E8%B4%9D%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5%EF%BC%9AEager-Copy%E3%80%81SSO-%E4%B8%8E-COW/</id>
    <published>2020-05-24T01:31:12.000Z</published>
    <updated>2020-05-26T04:40:53.452Z</updated>
    
    <summary type="html">
    
      在 C++ 中，对于一个类型为 std::string 的字符串对象来说，可以有多种方式来拷贝它所对应的资源。而在这些方法中，最常见的三种为：Eager-Copy、SSO 以及 COW。其中最为广泛使用的是 “SSO”，而其他方式则已大都不再被编译器所使用。
    
    </summary>
    
    
    
      <category term="C++" scheme="https://www.yhspy.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>“Effective Modern C++” 读书笔记（二）</title>
    <link href="https://www.yhspy.com/2020/05/23/Effective-Modern-C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://www.yhspy.com/2020/05/23/Effective-Modern-C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2020-05-23T09:19:08.000Z</published>
    <updated>2020-06-11T06:26:16.948Z</updated>
    
    <summary type="html">
    
      文接上回，本文为上一文的第二篇。
    
    </summary>
    
    
    
      <category term="C++" scheme="https://www.yhspy.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>“Effective Modern C++” 读书笔记（一）</title>
    <link href="https://www.yhspy.com/2020/05/14/Effective-Modern-C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://www.yhspy.com/2020/05/14/Effective-Modern-C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2020-05-14T02:32:16.000Z</published>
    <updated>2020-05-23T09:27:38.707Z</updated>
    
    <summary type="html">
    
      《Effective Modern C++》这本书主要介绍了 C++11 与 C++14 中的一些新的语言特性及编码建议。由于这段时间忙于它事，看书的速度会放缓，因此关于这本书的内容就一边读一边整理记录了。同《Effective C++ 3th》一样，这本书的行文也是按照“建议条目”的方式通过几个大的主题分门别类进行介绍的，其中部分之前博客文章中已经提到过得内容将不再赘述。
    
    </summary>
    
    
    
      <category term="C++" scheme="https://www.yhspy.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>“深入理解 C++11：C++11 新特性解析与应用” 读书笔记（二）</title>
    <link href="https://www.yhspy.com/2020/05/12/%E2%80%9C%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-C-11%EF%BC%9AC-11-%E6%96%B0%E7%89%B9%E6%80%A7%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8%E2%80%9D-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://www.yhspy.com/2020/05/12/%E2%80%9C%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-C-11%EF%BC%9AC-11-%E6%96%B0%E7%89%B9%E6%80%A7%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8%E2%80%9D-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2020-05-12T08:21:23.000Z</published>
    <updated>2020-05-12T13:03:13.456Z</updated>
    
    <summary type="html">
    
      文接上回，由于接下来关于“变长模板”、“原子类型与原子操作”等的内容会比较多，为了保证阅读体验，因此这里将分为两篇博文来分别记录。
    
    </summary>
    
    
    
      <category term="C++" scheme="https://www.yhspy.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>“深入理解 C++11：C++11 新特性解析与应用” 读书笔记（一）</title>
    <link href="https://www.yhspy.com/2020/05/09/%E2%80%9C%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-C-11%EF%BC%9AC-11-%E6%96%B0%E7%89%B9%E6%80%A7%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8%E2%80%9D%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://www.yhspy.com/2020/05/09/%E2%80%9C%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-C-11%EF%BC%9AC-11-%E6%96%B0%E7%89%B9%E6%80%A7%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8%E2%80%9D%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2020-05-09T02:22:12.000Z</published>
    <updated>2020-05-12T08:22:50.758Z</updated>
    
    <summary type="html">
    
      作为一本之前已经读过两遍的书，终于决定在第三次“复习”的时候做下读书笔记了。鉴于之前已经完整读过《Primer C++ 5th》、《Effective C++ 3th》两本书，因此本文仅作为查缺补漏之用，对于前两本书中没有提到一些诸如“最小垃圾回收”、以及“原子类型与原子操作”等内容进行回顾与记录。整个 C++ 系列还有一本想完整仔细阅读的《Effective Modern C++ - 42 Specific Ways to Improve Your Use of C++11 and C++14》可能会稍微往后放了，由于 C++14 仅作为 C++11 的微小改进和补充，对于一些常用的特性其实已经在实际项目中开始使用了。而对于诸如 std::future 以及 std::promise 等特性，由于其涉及异步和并发相关场景，因此可以参考《C++ Concurrency in Action 2th》一书，暂时没有实际需求便先不打算进行了解。
    
    </summary>
    
    
    
      <category term="C++" scheme="https://www.yhspy.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 聚合类与 POD</title>
    <link href="https://www.yhspy.com/2020/05/06/C-%E8%81%9A%E5%90%88%E7%B1%BB%E4%B8%8E-POD/"/>
    <id>https://www.yhspy.com/2020/05/06/C-%E8%81%9A%E5%90%88%E7%B1%BB%E4%B8%8E-POD/</id>
    <published>2020-05-06T09:54:58.000Z</published>
    <updated>2020-05-23T08:41:24.948Z</updated>
    
    <summary type="html">
    
      POD 在 C++ 中一直是一个没有很直观代码体现的概念，但其存在却涉及到了 C++ 中诸如字节赋值、内存布局、静态初始化安全甚至是有关 EBO 优化等相关的内容，而本文我们将对 POD 的概念进行总结，并同时对比其与“聚合类”之间的关系。
    
    </summary>
    
    
    
      <category term="C++" scheme="https://www.yhspy.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 空基类优化（EBO）与私有继承</title>
    <link href="https://www.yhspy.com/2020/04/27/C-%E7%A9%BA%E5%9F%BA%E7%B1%BB%E4%BC%98%E5%8C%96%EF%BC%88EBO%EF%BC%89%E4%B8%8E%E7%A7%81%E6%9C%89%E7%BB%A7%E6%89%BF/"/>
    <id>https://www.yhspy.com/2020/04/27/C-%E7%A9%BA%E5%9F%BA%E7%B1%BB%E4%BC%98%E5%8C%96%EF%BC%88EBO%EF%BC%89%E4%B8%8E%E7%A7%81%E6%9C%89%E7%BB%A7%E6%89%BF/</id>
    <published>2020-04-27T12:27:20.000Z</published>
    <updated>2020-05-23T08:35:45.865Z</updated>
    
    <summary type="html">
    
      通常我们认为“私有继承”和“组合”都有着相同的应用层语义，即：派生类或包含类是通过继承的类或组合的类对象来实现的（is-implemented-in-terms-of）。但在 C++ 中，由于 EBO（Empty Base Optimization）机制的存在，某种情况下我们可能会更倾向于使用私有继承而非组合的方式。
    
    </summary>
    
    
    
      <category term="C++" scheme="https://www.yhspy.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>常用 C++ 高效开发范式（二）</title>
    <link href="https://www.yhspy.com/2020/04/26/%E5%B8%B8%E7%94%A8-C-%E9%AB%98%E6%95%88%E5%BC%80%E5%8F%91%E8%8C%83%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://www.yhspy.com/2020/04/26/%E5%B8%B8%E7%94%A8-C-%E9%AB%98%E6%95%88%E5%BC%80%E5%8F%91%E8%8C%83%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2020-04-26T13:28:21.000Z</published>
    <updated>2020-04-29T08:00:57.361Z</updated>
    
    <summary type="html">
    
      文接上回，本文将继续记录常见的 C++ 高效开发范式，这些范式均总结于《Effective C++ 3th》一书。由于该书出版年代较为久远，因此对于书中条款的不适用之处，作者将尽量予以纠正并给出自己的建议。
    
    </summary>
    
    
    
      <category term="C++" scheme="https://www.yhspy.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 未限定名称查找与 ADL</title>
    <link href="https://www.yhspy.com/2020/04/26/C-%E6%9C%AA%E9%99%90%E5%AE%9A%E5%90%8D%E5%AD%97%E6%9F%A5%E6%89%BE%E4%B8%8E-ADL/"/>
    <id>https://www.yhspy.com/2020/04/26/C-%E6%9C%AA%E9%99%90%E5%AE%9A%E5%90%8D%E5%AD%97%E6%9F%A5%E6%89%BE%E4%B8%8E-ADL/</id>
    <published>2020-04-26T13:10:29.000Z</published>
    <updated>2020-04-26T15:31:05.838Z</updated>
    
    <summary type="html">
    
      简单总结下 ADL（aka. Koenig Lookup）算法与 C++ 中对于“未限定名称”查找之间的关系。毕竟日常对于 using、命名空间内（或标准库全特化）的自定义 swap 函数等的用法都涉及到这部分内容，记录下免得踩坑。
    
    </summary>
    
    
    
      <category term="C++" scheme="https://www.yhspy.com/tags/C/"/>
    
  </entry>
  
</feed>
